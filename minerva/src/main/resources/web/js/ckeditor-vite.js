var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_ckeditor_vite = __commonJS({
  "ckeditor-vite.js"(exports, module) {
    function _mergeNamespaces(n, m) {
      for (var i = 0; i < m.length; i++) {
        const e = m[i];
        if (typeof e !== "string" && !Array.isArray(e)) {
          for (const k in e) {
            if (k !== "default" && !(k in n)) {
              const d = Object.getOwnPropertyDescriptor(e, k);
              if (d) {
                Object.defineProperty(n, k, d.get ? d : {
                  enumerable: true,
                  get: () => e[k]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link2 of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link2);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link2) {
        const fetchOpts = {};
        if (link2.integrity) fetchOpts.integrity = link2.integrity;
        if (link2.referrerPolicy) fetchOpts.referrerPolicy = link2.referrerPolicy;
        if (link2.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link2.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link2) {
        if (link2.ep)
          return;
        link2.ep = true;
        const fetchOpts = getFetchOpts(link2);
        fetch(link2.href, fetchOpts);
      }
    })();
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root$1 = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root$1.Symbol;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$f.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty$c.call(value, symToStringTag$1), tag = value[symToStringTag$1];
      try {
        value[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$e = Object.prototype;
    var nativeObjectToString = objectProto$e.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$3;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    var isArray = Array.isArray;
    var INFINITY$1 = 1 / 0;
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
    }
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject$1(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject$1(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    function identity(value) {
      return value;
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject$1(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root$1["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value) {
      if (!isObject$1(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var WeakMap$1 = getNative(root$1, "WeakMap");
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject$1(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function copyArray(source, array) {
      var index2 = -1, length = source.length;
      array || (array = Array(length));
      while (++index2 < length) {
        array[index2] = source[index2];
      }
      return array;
    }
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    var setToString = shortOut(baseSetToString);
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function baseAssignValue(object, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object[key] = value;
      }
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var objectProto$c = Object.prototype;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty$a.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform2) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
        while (++index2 < length) {
          array[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = transform2(array);
        return apply(func, this, otherArgs);
      };
    }
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength$1(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isArrayLike(value) {
      return value != null && isLength$1(value.length) && !isFunction(value);
    }
    function isIterateeCall(value, index2, object) {
      if (!isObject$1(object)) {
        return false;
      }
      var type = typeof index2;
      if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
        return eq(object[index2], value);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index2 < length) {
          var source = sources[index2];
          if (source) {
            assigner(object, source, index2, customizer);
          }
        }
        return object;
      });
    }
    var objectProto$b = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$b;
      return value === proto;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$3;
    }
    var objectProto$a = Object.prototype;
    var hasOwnProperty$9 = objectProto$a.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
    };
    function stubFalse() {
      return false;
    }
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
    var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$4 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$4] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var freeProcess = moduleExports$1 && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty$8.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$8 = Object.prototype;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$7.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject$1(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$6.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$5.call(data, key) ? data[key] : void 0;
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$4.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
      return this;
    }
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    var Map$1 = getNative(root$1, "Map");
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
        if (cache2.has(key)) {
          return cache2.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache2.set(key, result) || cache2;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache2.size === MAX_MEMOIZE_SIZE) {
          cache2.clear();
        }
        return key;
      });
      var cache2 = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote2, subString) {
        result.push(quote2 ? subString.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index2 = 0, length = path.length;
      while (object != null && index2 < length) {
        object = object[toKey(path[index2++])];
      }
      return index2 && index2 == length ? object : void 0;
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectTag$3 = "[object Object]";
    var funcProto = Function.prototype, objectProto$4 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag$3) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$3.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    function baseSlice(array, start, end) {
      var index2 = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array[index2 + start];
      }
      return result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f";
    var rsZWJ$2 = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function asciiToArray(string) {
      return string.split("");
    }
    var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d";
    var reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
    var rsCombo$1 = "[" + rsComboRange$1 + "]";
    var reComboMark = RegExp(rsCombo$1, "g");
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    var rsApos = "['’]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    var DataView = getNative(root$1, "DataView");
    var Promise$1 = getNative(root$1, "Promise");
    var Set$1 = getNative(root$1, "Set");
    var mapTag$4 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$3 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$4;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$4;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty$2.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    var Uint8Array2 = root$1.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$3 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$2:
          return cloneArrayBuffer(object);
        case boolTag$2:
        case dateTag$2:
          return new Ctor(+object);
        case dataViewTag$2:
          return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object, isDeep);
        case mapTag$3:
          return new Ctor();
        case numberTag$2:
        case stringTag$3:
          return new Ctor(object);
        case regexpTag$2:
          return cloneRegExp(object);
        case setTag$3:
          return new Ctor();
        case symbolTag$2:
          return cloneSymbol(object);
      }
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    var mapTag$2 = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag$2;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$2 = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag$2;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG$2 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$3 = 4;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$1 = "[object Number]", objectTag$1 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$2 = "[object String]", symbolTag$1 = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$3;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject$1(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    var CLONE_SYMBOLS_FLAG$2 = 4;
    function clone$1(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG$2);
    }
    var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag$1:
          return object == other + "";
        case mapTag:
          var convert2 = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert2 || (convert2 = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object, other);
          var result = equalArrays(convert2(object), convert2(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index2 = matchData.length, length = index2;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index2--) {
        var data = matchData[index2];
        if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index2 < length) {
        data = matchData[index2];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          var result;
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value) {
      return value === value && !isObject$1(value);
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index2 = -1, length = path.length, result = false;
      while (++index2 < length) {
        var key = toKey(path[index2]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength$1(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    var now = function() {
      return root$1.Date.now();
    };
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject$1(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel2() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel2;
      debounced.flush = flush;
      return debounced;
    }
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject$1(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject$1(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }
    function isElement$1(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == "function" ? customizer : void 0;
      var result = customizer ? customizer(value, other) : void 0;
      return result === void 0 ? baseIsEqual(value, other, void 0, customizer) : !!result;
    }
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee);
      baseForOwn(object, function(value, key, object2) {
        baseAssignValue(result, key, iteratee(value, key, object2));
      });
      return result;
    }
    var merge$1 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }
    function baseSet(object, path, value, customizer) {
      if (!isObject$1(object)) {
        return object;
      }
      path = castPath(path, object);
      var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index2 < length) {
        var key = toKey(path[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index2 != lastIndex) {
          var objValue = nested[key];
          newValue = void 0;
          if (newValue === void 0) {
            newValue = isObject$1(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    var startCase = createCompounder(function(result, word, index2) {
      return result + (index2 ? " " : "") + upperFirst(word);
    });
    var FUNC_ERROR_TEXT = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject$1(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    let globalVar;
    try {
      globalVar = {
        window,
        document
      };
    } catch (e) {
      /* istanbul ignore next -- @preserve */
      globalVar = {
        window: {},
        document: {}
      };
    }
    var global$1 = globalVar;
    function getUserAgent() {
      try {
        return navigator.userAgent.toLowerCase();
      } catch (e) {
        return "";
      }
    }
    const userAgent = /* @__PURE__ */ getUserAgent();
    const env = {
      isMac: /* @__PURE__ */ isMac(userAgent),
      isWindows: /* @__PURE__ */ isWindows(userAgent),
      isGecko: /* @__PURE__ */ isGecko(userAgent),
      isSafari: /* @__PURE__ */ isSafari(userAgent),
      isiOS: /* @__PURE__ */ isiOS(userAgent),
      isAndroid: /* @__PURE__ */ isAndroid(userAgent),
      isBlink: /* @__PURE__ */ isBlink(userAgent),
      get isMediaForcedColors() {
        return isMediaForcedColors();
      },
      get isMotionReduced() {
        return isMotionReduced();
      },
      features: {
        isRegExpUnicodePropertySupported: /* @__PURE__ */ isRegExpUnicodePropertySupported()
      }
    };
    function isMac(userAgent2) {
      return userAgent2.indexOf("macintosh") > -1;
    }
    function isWindows(userAgent2) {
      return userAgent2.indexOf("windows") > -1;
    }
    function isGecko(userAgent2) {
      return !!userAgent2.match(/gecko\/\d+/);
    }
    function isSafari(userAgent2) {
      return userAgent2.indexOf(" applewebkit/") > -1 && userAgent2.indexOf("chrome") === -1;
    }
    function isiOS(userAgent2) {
      return !!userAgent2.match(/iphone|ipad/i) || isMac(userAgent2) && navigator.maxTouchPoints > 0;
    }
    function isAndroid(userAgent2) {
      return userAgent2.indexOf("android") > -1;
    }
    function isBlink(userAgent2) {
      return userAgent2.indexOf("chrome/") > -1 && userAgent2.indexOf("edge/") < 0;
    }
    function isRegExpUnicodePropertySupported() {
      let isSupported = false;
      try {
        isSupported = "ć".search(new RegExp("[\\p{L}]", "u")) === 0;
      } catch (error) {
      }
      return isSupported;
    }
    function isMediaForcedColors() {
      return global$1.window.matchMedia ? global$1.window.matchMedia("(forced-colors: active)").matches : false;
    }
    function isMotionReduced() {
      return global$1.window.matchMedia ? global$1.window.matchMedia("(prefers-reduced-motion)").matches : false;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function fastDiff(a, b, cmp, atomicChanges) {
      cmp = cmp || function(a2, b2) {
        return a2 === b2;
      };
      const arrayA = Array.isArray(a) ? a : Array.prototype.slice.call(a);
      const arrayB = Array.isArray(b) ? b : Array.prototype.slice.call(b);
      const changeIndexes = findChangeBoundaryIndexes(arrayA, arrayB, cmp);
      const result = atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, arrayB.length) : changeIndexesToChanges(arrayB, changeIndexes);
      return result;
    }
    function findChangeBoundaryIndexes(arr1, arr2, cmp) {
      const firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp);
      if (firstIndex === -1) {
        return {
          firstIndex: -1,
          lastIndexOld: -1,
          lastIndexNew: -1
        };
      }
      const oldArrayReversed = cutAndReverse(arr1, firstIndex);
      const newArrayReversed = cutAndReverse(arr2, firstIndex);
      const lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp);
      const lastIndexOld = arr1.length - lastIndex;
      const lastIndexNew = arr2.length - lastIndex;
      return {
        firstIndex,
        lastIndexOld,
        lastIndexNew
      };
    }
    function findFirstDifferenceIndex(arr1, arr2, cmp) {
      for (let i = 0; i < Math.max(arr1.length, arr2.length); i++) {
        if (arr1[i] === void 0 || arr2[i] === void 0 || !cmp(arr1[i], arr2[i])) {
          return i;
        }
      }
      return -1;
    }
    function cutAndReverse(arr, howMany) {
      return arr.slice(howMany).reverse();
    }
    function changeIndexesToChanges(newArray, changeIndexes) {
      const result = [];
      const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
      if (lastIndexNew - firstIndex > 0) {
        result.push({
          index: firstIndex,
          type: "insert",
          values: newArray.slice(firstIndex, lastIndexNew)
        });
      }
      if (lastIndexOld - firstIndex > 0) {
        result.push({
          index: firstIndex + (lastIndexNew - firstIndex),
          type: "delete",
          howMany: lastIndexOld - firstIndex
        });
      }
      return result;
    }
    function changeIndexesToAtomicChanges(changeIndexes, newLength) {
      const { firstIndex, lastIndexOld, lastIndexNew } = changeIndexes;
      if (firstIndex === -1) {
        return Array(newLength).fill("equal");
      }
      let result = [];
      if (firstIndex > 0) {
        result = result.concat(Array(firstIndex).fill("equal"));
      }
      if (lastIndexNew - firstIndex > 0) {
        result = result.concat(Array(lastIndexNew - firstIndex).fill("insert"));
      }
      if (lastIndexOld - firstIndex > 0) {
        result = result.concat(Array(lastIndexOld - firstIndex).fill("delete"));
      }
      if (lastIndexNew < newLength) {
        result = result.concat(Array(newLength - lastIndexNew).fill("equal"));
      }
      return result;
    }
    function diff(a, b, cmp) {
      cmp = cmp || function(a2, b2) {
        return a2 === b2;
      };
      const aLength = a.length;
      const bLength = b.length;
      if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
        return diff.fastDiff(a, b, cmp, true);
      }
      let _insert2, _delete;
      if (bLength < aLength) {
        const tmp = a;
        a = b;
        b = tmp;
        _insert2 = "delete";
        _delete = "insert";
      } else {
        _insert2 = "insert";
        _delete = "delete";
      }
      const m = a.length;
      const n = b.length;
      const delta = n - m;
      const es = {};
      const fp = {};
      function snake(k2) {
        const y1 = (fp[k2 - 1] !== void 0 ? fp[k2 - 1] : -1) + 1;
        const y2 = fp[k2 + 1] !== void 0 ? fp[k2 + 1] : -1;
        const dir = y1 > y2 ? -1 : 1;
        if (es[k2 + dir]) {
          es[k2] = es[k2 + dir].slice(0);
        }
        if (!es[k2]) {
          es[k2] = [];
        }
        es[k2].push(y1 > y2 ? _insert2 : _delete);
        let y = Math.max(y1, y2);
        let x = y - k2;
        while (x < m && y < n && cmp(a[x], b[y])) {
          x++;
          y++;
          es[k2].push("equal");
        }
        return y;
      }
      let p = 0;
      let k;
      do {
        for (k = -p; k < delta; k++) {
          fp[k] = snake(k);
        }
        for (k = delta + p; k > delta; k--) {
          fp[k] = snake(k);
        }
        fp[delta] = snake(delta);
        p++;
      } while (fp[delta] !== n);
      return es[delta].slice(1);
    }
    diff.fastDiff = fastDiff;
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function spy() {
      return function spy2() {
        spy2.called = true;
      };
    }
    class EventInfo {
      /**
      * @param source The emitter.
      * @param name The event name.
      */
      constructor(source, name) {
        /**
        * The object that fired the event.
        */
        __publicField(this, "source");
        /**
        * The event name.
        */
        __publicField(this, "name");
        /**
        * Path this event has followed. See {@link module:utils/emittermixin~Emitter#delegate}.
        */
        __publicField(this, "path");
        /**
        * Stops the event emitter to call further callbacks for this event interaction.
        */
        __publicField(this, "stop");
        /**
        * Removes the current callback from future interactions of this event.
        */
        __publicField(this, "off");
        /**
        * The value which will be returned by {@link module:utils/emittermixin~Emitter#fire}.
        *
        * It's `undefined` by default and can be changed by an event listener:
        *
        * ```ts
        * dataController.fire( 'getSelectedContent', ( evt ) => {
        * 	// This listener will make `dataController.fire( 'getSelectedContent' )`
        * 	// always return an empty DocumentFragment.
        * 	evt.return = new DocumentFragment();
        *
        * 	// Make sure no other listeners are executed.
        * 	evt.stop();
        * } );
        * ```
        */
        __publicField(this, "return");
        this.source = source;
        this.name = name;
        this.path = [];
        this.stop = spy();
        this.off = spy();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const HEX_NUMBERS = new Array(256).fill("").map((_, index2) => ("0" + index2.toString(16)).slice(-2));
    function uid() {
      const r1 = Math.random() * 4294967296 >>> 0;
      const r2 = Math.random() * 4294967296 >>> 0;
      const r3 = Math.random() * 4294967296 >>> 0;
      const r4 = Math.random() * 4294967296 >>> 0;
      return "e" + HEX_NUMBERS[r1 >> 0 & 255] + HEX_NUMBERS[r1 >> 8 & 255] + HEX_NUMBERS[r1 >> 16 & 255] + HEX_NUMBERS[r1 >> 24 & 255] + HEX_NUMBERS[r2 >> 0 & 255] + HEX_NUMBERS[r2 >> 8 & 255] + HEX_NUMBERS[r2 >> 16 & 255] + HEX_NUMBERS[r2 >> 24 & 255] + HEX_NUMBERS[r3 >> 0 & 255] + HEX_NUMBERS[r3 >> 8 & 255] + HEX_NUMBERS[r3 >> 16 & 255] + HEX_NUMBERS[r3 >> 24 & 255] + HEX_NUMBERS[r4 >> 0 & 255] + HEX_NUMBERS[r4 >> 8 & 255] + HEX_NUMBERS[r4 >> 16 & 255] + HEX_NUMBERS[r4 >> 24 & 255];
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const priorities = {
      get(priority = "normal") {
        if (typeof priority != "number") {
          return this[priority] || this.normal;
        } else {
          return priority;
        }
      },
      highest: 1e5,
      high: 1e3,
      normal: 0,
      low: -1e3,
      lowest: -1e5
    };
    function insertToPriorityArray(objects, objectToInsert) {
      const priority = priorities.get(objectToInsert.priority);
      for (let i = 0; i < objects.length; i++) {
        if (priorities.get(objects[i].priority) < priority) {
          objects.splice(i, 0, objectToInsert);
          return;
        }
      }
      objects.push(objectToInsert);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const DOCUMENTATION_URL = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
    class CKEditorError extends Error {
      /**
      * Creates an instance of the CKEditorError class.
      *
      * @param errorName The error id in an `error-name` format. A link to this error documentation page will be added
      * to the thrown error's `message`.
      * @param context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
      * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
      * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
      * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
      * to check if the object works as the context.
      * @param data Additional data describing the error. A stringified version of this object
      * will be appended to the error message, so the data are quickly visible in the console. The original
      * data object will also be later available under the {@link #data} property.
      */
      constructor(errorName, context, data) {
        super(getErrorMessage(errorName, data));
        /**
        * A context of the error by which the Watchdog is able to determine which editor crashed.
        */
        __publicField(this, "context");
        /**
        * The additional error data passed to the constructor. Undefined if none was passed.
        */
        __publicField(this, "data");
        this.name = "CKEditorError";
        this.context = context;
        this.data = data;
      }
      /**
      * Checks if the error is of the `CKEditorError` type.
      */
      is(type) {
        return type === "CKEditorError";
      }
      /**
      * A utility that ensures that the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
      * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
      * of a {@link module:utils/ckeditorerror~CKEditorError} error.
      *
      * @param err The error to rethrow.
      * @param context An object connected through properties with the editor instance. This context will be used
      * by the watchdog to verify which editor should be restarted.
      */
      static rethrowUnexpectedError(err, context) {
        if (err.is && err.is("CKEditorError")) {
          throw err;
        }
        const error = new CKEditorError(err.message, context);
        error.stack = err.stack;
        throw error;
      }
    }
    function logWarning(errorName, data) {
      console.warn(...formatConsoleArguments(errorName, data));
    }
    function getLinkToDocumentationMessage(errorName) {
      return `
Read more: ${DOCUMENTATION_URL}#error-${errorName}`;
    }
    function getErrorMessage(errorName, data) {
      const processedObjects = /* @__PURE__ */ new WeakSet();
      const circularReferencesReplacer = (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (processedObjects.has(value)) {
            return `[object ${value.constructor.name}]`;
          }
          processedObjects.add(value);
        }
        return value;
      };
      const stringifiedData = data ? ` ${JSON.stringify(data, circularReferencesReplacer)}` : "";
      const documentationLink = getLinkToDocumentationMessage(errorName);
      return errorName + stringifiedData + documentationLink;
    }
    function formatConsoleArguments(errorName, data) {
      const documentationMessage = getLinkToDocumentationMessage(errorName);
      return data ? [
        errorName,
        data,
        documentationMessage
      ] : [
        errorName,
        documentationMessage
      ];
    }
    const version = "42.0.0";
    const releaseDate = new Date(2024, 5, 26);
    /* istanbul ignore next -- @preserve */
    if (globalThis.CKEDITOR_VERSION) {
      throw new CKEditorError("ckeditor-duplicated-modules", null);
    } else {
      globalThis.CKEDITOR_VERSION = version;
    }
    const _listeningTo = Symbol("listeningTo");
    const _emitterId = Symbol("emitterId");
    const _delegations = Symbol("delegations");
    const defaultEmitterClass$1 = /* @__PURE__ */ EmitterMixin(Object);
    function EmitterMixin(base) {
      if (!base) {
        return defaultEmitterClass$1;
      }
      class Mixin extends base {
        on(event, callback, options) {
          this.listenTo(this, event, callback, options);
        }
        once(event, callback, options) {
          let wasFired = false;
          const onceCallback = (event2, ...args) => {
            if (!wasFired) {
              wasFired = true;
              event2.off();
              callback.call(this, event2, ...args);
            }
          };
          this.listenTo(this, event, onceCallback, options);
        }
        off(event, callback) {
          this.stopListening(this, event, callback);
        }
        listenTo(emitter, event, callback, options = {}) {
          let emitterInfo, eventCallbacks;
          if (!this[_listeningTo]) {
            this[_listeningTo] = {};
          }
          const emitters = this[_listeningTo];
          if (!_getEmitterId(emitter)) {
            _setEmitterId(emitter);
          }
          const emitterId = _getEmitterId(emitter);
          if (!(emitterInfo = emitters[emitterId])) {
            emitterInfo = emitters[emitterId] = {
              emitter,
              callbacks: {}
            };
          }
          if (!(eventCallbacks = emitterInfo.callbacks[event])) {
            eventCallbacks = emitterInfo.callbacks[event] = [];
          }
          eventCallbacks.push(callback);
          addEventListener(this, emitter, event, callback, options);
        }
        stopListening(emitter, event, callback) {
          const emitters = this[_listeningTo];
          let emitterId = emitter && _getEmitterId(emitter);
          const emitterInfo = emitters && emitterId ? emitters[emitterId] : void 0;
          const eventCallbacks = emitterInfo && event ? emitterInfo.callbacks[event] : void 0;
          if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
            return;
          }
          if (callback) {
            removeEventListener(this, emitter, event, callback);
            const index2 = eventCallbacks.indexOf(callback);
            if (index2 !== -1) {
              if (eventCallbacks.length === 1) {
                delete emitterInfo.callbacks[event];
              } else {
                removeEventListener(this, emitter, event, callback);
              }
            }
          } else if (eventCallbacks) {
            while (callback = eventCallbacks.pop()) {
              removeEventListener(this, emitter, event, callback);
            }
            delete emitterInfo.callbacks[event];
          } else if (emitterInfo) {
            for (event in emitterInfo.callbacks) {
              this.stopListening(emitter, event);
            }
            delete emitters[emitterId];
          } else {
            for (emitterId in emitters) {
              this.stopListening(emitters[emitterId].emitter);
            }
            delete this[_listeningTo];
          }
        }
        fire(eventOrInfo, ...args) {
          try {
            const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
            const event = eventInfo.name;
            let callbacks = getCallbacksForEvent(this, event);
            eventInfo.path.push(this);
            if (callbacks) {
              const callbackArgs = [
                eventInfo,
                ...args
              ];
              callbacks = Array.from(callbacks);
              for (let i = 0; i < callbacks.length; i++) {
                callbacks[i].callback.apply(this, callbackArgs);
                if (eventInfo.off.called) {
                  delete eventInfo.off.called;
                  this._removeEventListener(event, callbacks[i].callback);
                }
                if (eventInfo.stop.called) {
                  break;
                }
              }
            }
            const delegations = this[_delegations];
            if (delegations) {
              const destinations = delegations.get(event);
              const passAllDestinations = delegations.get("*");
              if (destinations) {
                fireDelegatedEvents(destinations, eventInfo, args);
              }
              if (passAllDestinations) {
                fireDelegatedEvents(passAllDestinations, eventInfo, args);
              }
            }
            return eventInfo.return;
          } catch (err) {
            /* istanbul ignore next -- @preserve */
            CKEditorError.rethrowUnexpectedError(err, this);
          }
        }
        delegate(...events) {
          return {
            to: (emitter, nameOrFunction) => {
              if (!this[_delegations]) {
                this[_delegations] = /* @__PURE__ */ new Map();
              }
              events.forEach((eventName) => {
                const destinations = this[_delegations].get(eventName);
                if (!destinations) {
                  this[_delegations].set(eventName, /* @__PURE__ */ new Map([
                    [
                      emitter,
                      nameOrFunction
                    ]
                  ]));
                } else {
                  destinations.set(emitter, nameOrFunction);
                }
              });
            }
          };
        }
        stopDelegating(event, emitter) {
          if (!this[_delegations]) {
            return;
          }
          if (!event) {
            this[_delegations].clear();
          } else if (!emitter) {
            this[_delegations].delete(event);
          } else {
            const destinations = this[_delegations].get(event);
            if (destinations) {
              destinations.delete(emitter);
            }
          }
        }
        _addEventListener(event, callback, options) {
          createEventNamespace(this, event);
          const lists = getCallbacksListsForNamespace(this, event);
          const priority = priorities.get(options.priority);
          const callbackDefinition = {
            callback,
            priority
          };
          for (const callbacks of lists) {
            insertToPriorityArray(callbacks, callbackDefinition);
          }
        }
        _removeEventListener(event, callback) {
          const lists = getCallbacksListsForNamespace(this, event);
          for (const callbacks of lists) {
            for (let i = 0; i < callbacks.length; i++) {
              if (callbacks[i].callback == callback) {
                callbacks.splice(i, 1);
                i--;
              }
            }
          }
        }
      }
      return Mixin;
    }
    [
      "on",
      "once",
      "off",
      "listenTo",
      "stopListening",
      "fire",
      "delegate",
      "stopDelegating",
      "_addEventListener",
      "_removeEventListener"
    ].forEach((key) => {
      EmitterMixin[key] = defaultEmitterClass$1.prototype[key];
    });
    function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
      const listeningTo = listeningEmitter[_listeningTo];
      if (listeningTo && listeningTo[listenedToEmitterId]) {
        return listeningTo[listenedToEmitterId].emitter;
      }
      return null;
    }
    function _setEmitterId(emitter, id) {
      if (!emitter[_emitterId]) {
        emitter[_emitterId] = id || uid();
      }
    }
    function _getEmitterId(emitter) {
      return emitter[_emitterId];
    }
    function getEvents(source) {
      if (!source._events) {
        Object.defineProperty(source, "_events", {
          value: {}
        });
      }
      return source._events;
    }
    function makeEventNode() {
      return {
        callbacks: [],
        childEvents: []
      };
    }
    function createEventNamespace(source, eventName) {
      const events = getEvents(source);
      if (events[eventName]) {
        return;
      }
      let name = eventName;
      let childEventName = null;
      const newEventNodes = [];
      while (name !== "") {
        if (events[name]) {
          break;
        }
        events[name] = makeEventNode();
        newEventNodes.push(events[name]);
        if (childEventName) {
          events[name].childEvents.push(childEventName);
        }
        childEventName = name;
        name = name.substr(0, name.lastIndexOf(":"));
      }
      if (name !== "") {
        for (const node of newEventNodes) {
          node.callbacks = events[name].callbacks.slice();
        }
        events[name].childEvents.push(childEventName);
      }
    }
    function getCallbacksListsForNamespace(source, eventName) {
      const eventNode = getEvents(source)[eventName];
      if (!eventNode) {
        return [];
      }
      let callbacksLists = [
        eventNode.callbacks
      ];
      for (let i = 0; i < eventNode.childEvents.length; i++) {
        const childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);
        callbacksLists = callbacksLists.concat(childCallbacksLists);
      }
      return callbacksLists;
    }
    function getCallbacksForEvent(source, eventName) {
      let event;
      if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
        if (eventName.indexOf(":") > -1) {
          return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(":")));
        } else {
          return null;
        }
      }
      return event.callbacks;
    }
    function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
      for (let [emitter, name] of destinations) {
        if (!name) {
          name = eventInfo.name;
        } else if (typeof name == "function") {
          name = name(eventInfo.name);
        }
        const delegatedInfo = new EventInfo(eventInfo.source, name);
        delegatedInfo.path = [
          ...eventInfo.path
        ];
        emitter.fire(delegatedInfo, ...fireArgs);
      }
    }
    function addEventListener(listener, emitter, event, callback, options) {
      if (emitter._addEventListener) {
        emitter._addEventListener(event, callback, options);
      } else {
        listener._addEventListener.call(emitter, event, callback, options);
      }
    }
    function removeEventListener(listener, emitter, event, callback) {
      if (emitter._removeEventListener) {
        emitter._removeEventListener(event, callback);
      } else {
        listener._removeEventListener.call(emitter, event, callback);
      }
    }
    const observablePropertiesSymbol = Symbol("observableProperties");
    const boundObservablesSymbol = Symbol("boundObservables");
    const boundPropertiesSymbol = Symbol("boundProperties");
    const decoratedMethods = Symbol("decoratedMethods");
    const decoratedOriginal = Symbol("decoratedOriginal");
    const defaultObservableClass = /* @__PURE__ */ ObservableMixin(/* @__PURE__ */ EmitterMixin());
    function ObservableMixin(base) {
      var _a, _b, _c, _d, _e;
      if (!base) {
        return defaultObservableClass;
      }
      class Mixin extends (_e = base, _d = observablePropertiesSymbol, _c = decoratedMethods, _b = boundPropertiesSymbol, _a = boundObservablesSymbol, _e) {
        constructor() {
          super(...arguments);
          __publicField(this, _d);
          __publicField(this, _c);
          __publicField(this, _b);
          __publicField(this, _a);
        }
        set(name, value) {
          if (isObject$1(name)) {
            Object.keys(name).forEach((property2) => {
              this.set(property2, name[property2]);
            }, this);
            return;
          }
          initObservable(this);
          const properties = this[observablePropertiesSymbol];
          if (name in this && !properties.has(name)) {
            throw new CKEditorError("observable-set-cannot-override", this);
          }
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            get() {
              return properties.get(name);
            },
            set(value2) {
              const oldValue = properties.get(name);
              let newValue = this.fire(`set:${name}`, name, value2, oldValue);
              if (newValue === void 0) {
                newValue = value2;
              }
              if (oldValue !== newValue || !properties.has(name)) {
                properties.set(name, newValue);
                this.fire(`change:${name}`, name, newValue, oldValue);
              }
            }
          });
          this[name] = value;
        }
        bind(...bindProperties) {
          if (!bindProperties.length || !isStringArray$1(bindProperties)) {
            throw new CKEditorError("observable-bind-wrong-properties", this);
          }
          if (new Set(bindProperties).size !== bindProperties.length) {
            throw new CKEditorError("observable-bind-duplicate-properties", this);
          }
          initObservable(this);
          const boundProperties = this[boundPropertiesSymbol];
          bindProperties.forEach((propertyName) => {
            if (boundProperties.has(propertyName)) {
              throw new CKEditorError("observable-bind-rebind", this);
            }
          });
          const bindings = /* @__PURE__ */ new Map();
          bindProperties.forEach((a) => {
            const binding = {
              property: a,
              to: []
            };
            boundProperties.set(a, binding);
            bindings.set(a, binding);
          });
          return {
            to: bindTo,
            toMany: bindToMany,
            _observable: this,
            _bindProperties: bindProperties,
            _to: [],
            _bindings: bindings
          };
        }
        unbind(...unbindProperties) {
          if (!this[observablePropertiesSymbol]) {
            return;
          }
          const boundProperties = this[boundPropertiesSymbol];
          const boundObservables = this[boundObservablesSymbol];
          if (unbindProperties.length) {
            if (!isStringArray$1(unbindProperties)) {
              throw new CKEditorError("observable-unbind-wrong-properties", this);
            }
            unbindProperties.forEach((propertyName) => {
              const binding = boundProperties.get(propertyName);
              if (!binding) {
                return;
              }
              binding.to.forEach(([toObservable, toProperty]) => {
                const toProperties = boundObservables.get(toObservable);
                const toPropertyBindings = toProperties[toProperty];
                toPropertyBindings.delete(binding);
                if (!toPropertyBindings.size) {
                  delete toProperties[toProperty];
                }
                if (!Object.keys(toProperties).length) {
                  boundObservables.delete(toObservable);
                  this.stopListening(toObservable, "change");
                }
              });
              boundProperties.delete(propertyName);
            });
          } else {
            boundObservables.forEach((bindings, boundObservable) => {
              this.stopListening(boundObservable, "change");
            });
            boundObservables.clear();
            boundProperties.clear();
          }
        }
        decorate(methodName) {
          initObservable(this);
          const originalMethod = this[methodName];
          if (!originalMethod) {
            throw new CKEditorError("observablemixin-cannot-decorate-undefined", this, {
              object: this,
              methodName
            });
          }
          this.on(methodName, (evt, args) => {
            evt.return = originalMethod.apply(this, args);
          });
          this[methodName] = function(...args) {
            return this.fire(methodName, args);
          };
          this[methodName][decoratedOriginal] = originalMethod;
          if (!this[decoratedMethods]) {
            this[decoratedMethods] = [];
          }
          this[decoratedMethods].push(methodName);
        }
        // Override the EmitterMixin stopListening method to be able to clean (and restore) decorated methods.
        // This is needed in case of:
        //  1. Have x.foo() decorated.
        //  2. Call x.stopListening()
        //  3. Call x.foo(). Problem: nothing happens (the original foo() method is not executed)
        stopListening(emitter, event, callback) {
          if (!emitter && this[decoratedMethods]) {
            for (const methodName of this[decoratedMethods]) {
              this[methodName] = this[methodName][decoratedOriginal];
            }
            delete this[decoratedMethods];
          }
          super.stopListening(emitter, event, callback);
        }
      }
      return Mixin;
    }
    [
      "set",
      "bind",
      "unbind",
      "decorate",
      "on",
      "once",
      "off",
      "listenTo",
      "stopListening",
      "fire",
      "delegate",
      "stopDelegating",
      "_addEventListener",
      "_removeEventListener"
    ].forEach((key) => {
      ObservableMixin[key] = defaultObservableClass.prototype[key];
    });
    function initObservable(observable) {
      if (observable[observablePropertiesSymbol]) {
        return;
      }
      Object.defineProperty(observable, observablePropertiesSymbol, {
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(observable, boundObservablesSymbol, {
        value: /* @__PURE__ */ new Map()
      });
      Object.defineProperty(observable, boundPropertiesSymbol, {
        value: /* @__PURE__ */ new Map()
      });
    }
    function bindTo(...args) {
      const parsedArgs = parseBindToArgs(...args);
      const bindingsKeys = Array.from(this._bindings.keys());
      const numberOfBindings = bindingsKeys.length;
      if (!parsedArgs.callback && parsedArgs.to.length > 1) {
        throw new CKEditorError("observable-bind-to-no-callback", this);
      }
      if (numberOfBindings > 1 && parsedArgs.callback) {
        throw new CKEditorError("observable-bind-to-extra-callback", this);
      }
      parsedArgs.to.forEach((to) => {
        if (to.properties.length && to.properties.length !== numberOfBindings) {
          throw new CKEditorError("observable-bind-to-properties-length", this);
        }
        if (!to.properties.length) {
          to.properties = this._bindProperties;
        }
      });
      this._to = parsedArgs.to;
      if (parsedArgs.callback) {
        this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
      }
      attachBindToListeners(this._observable, this._to);
      updateBindToBound(this);
      this._bindProperties.forEach((propertyName) => {
        updateBoundObservableProperty(this._observable, propertyName);
      });
    }
    function bindToMany(observables, attribute, callback) {
      if (this._bindings.size > 1) {
        throw new CKEditorError("observable-bind-to-many-not-one-binding", this);
      }
      this.to(
        ...getBindingTargets(observables, attribute),
        // ...using given callback to parse attribute values.
        callback
      );
    }
    function getBindingTargets(observables, attribute) {
      const observableAndAttributePairs = observables.map((observable) => [
        observable,
        attribute
      ]);
      return Array.prototype.concat.apply([], observableAndAttributePairs);
    }
    function isStringArray$1(arr) {
      return arr.every((a) => typeof a == "string");
    }
    function parseBindToArgs(...args) {
      if (!args.length) {
        throw new CKEditorError("observable-bind-to-parse-error", null);
      }
      const parsed = {
        to: []
      };
      let lastObservable;
      if (typeof args[args.length - 1] == "function") {
        parsed.callback = args.pop();
      }
      args.forEach((a) => {
        if (typeof a == "string") {
          lastObservable.properties.push(a);
        } else if (typeof a == "object") {
          lastObservable = {
            observable: a,
            properties: []
          };
          parsed.to.push(lastObservable);
        } else {
          throw new CKEditorError("observable-bind-to-parse-error", null);
        }
      });
      return parsed;
    }
    function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
      const boundObservables = observable[boundObservablesSymbol];
      const bindingsToObservable = boundObservables.get(toObservable);
      const bindings = bindingsToObservable || {};
      if (!bindings[toPropertyName]) {
        bindings[toPropertyName] = /* @__PURE__ */ new Set();
      }
      bindings[toPropertyName].add(binding);
      if (!bindingsToObservable) {
        boundObservables.set(toObservable, bindings);
      }
    }
    function updateBindToBound(chain) {
      let toProperty;
      chain._bindings.forEach((binding, propertyName) => {
        chain._to.forEach((to) => {
          toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];
          binding.to.push([
            to.observable,
            toProperty
          ]);
          updateBoundObservables(chain._observable, binding, to.observable, toProperty);
        });
      });
    }
    function updateBoundObservableProperty(observable, propertyName) {
      const boundProperties = observable[boundPropertiesSymbol];
      const binding = boundProperties.get(propertyName);
      let propertyValue;
      if (binding.callback) {
        propertyValue = binding.callback.apply(observable, binding.to.map((to) => to[0][to[1]]));
      } else {
        propertyValue = binding.to[0];
        propertyValue = propertyValue[0][propertyValue[1]];
      }
      if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
        observable[propertyName] = propertyValue;
      } else {
        observable.set(propertyName, propertyValue);
      }
    }
    function attachBindToListeners(observable, toBindings) {
      toBindings.forEach((to) => {
        const boundObservables = observable[boundObservablesSymbol];
        let bindings;
        if (!boundObservables.get(to.observable)) {
          observable.listenTo(to.observable, "change", (evt, propertyName) => {
            bindings = boundObservables.get(to.observable)[propertyName];
            if (bindings) {
              bindings.forEach((binding) => {
                updateBoundObservableProperty(observable, binding.property);
              });
            }
          });
        }
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function count(iterable) {
      let count2 = 0;
      for (const _ of iterable) {
        count2++;
      }
      return count2;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function compareArrays(a, b) {
      const minLen = Math.min(a.length, b.length);
      for (let i = 0; i < minLen; i++) {
        if (a[i] != b[i]) {
          return i;
        }
      }
      if (a.length == b.length) {
        return "same";
      } else if (a.length < b.length) {
        return "prefix";
      } else {
        return "extension";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isIterable(value) {
      return !!(value && value[Symbol.iterator]);
    }
    function createElement(doc, name, attributes = {}, children = []) {
      const namespace = attributes && attributes.xmlns;
      const element = namespace ? doc.createElementNS(namespace, name) : doc.createElement(name);
      for (const key in attributes) {
        element.setAttribute(key, attributes[key]);
      }
      if (isString(children) || !isIterable(children)) {
        children = [
          children
        ];
      }
      for (let child of children) {
        if (isString(child)) {
          child = doc.createTextNode(child);
        }
        element.appendChild(child);
      }
      return element;
    }
    class Config {
      /**
      * Creates an instance of the {@link ~Config} class.
      *
      * @param configurations The initial configurations to be set. Usually, provided by the user.
      * @param defaultConfigurations The default configurations. Usually, provided by the system.
      */
      constructor(configurations, defaultConfigurations) {
        /**
        * Store for the whole configuration.
        */
        __publicField(this, "_config");
        this._config = {};
        if (defaultConfigurations) {
          this.define(cloneConfig(defaultConfigurations));
        }
        if (configurations) {
          this._setObjectToTarget(this._config, configurations);
        }
      }
      set(name, value) {
        this._setToTarget(this._config, name, value);
      }
      define(name, value) {
        const isDefine = true;
        this._setToTarget(this._config, name, value, isDefine);
      }
      /**
      * Gets the value for a configuration entry.
      *
      * ```ts
      * config.get( 'name' );
      * ```
      *
      * Deep configurations can be retrieved by separating each part with a dot.
      *
      * ```ts
      * config.get( 'toolbar.collapsed' );
      * ```
      *
      * @param name The configuration name. Configuration names are case-sensitive.
      * @returns The configuration value or `undefined` if the configuration entry was not found.
      */
      get(name) {
        return this._getFromSource(this._config, name);
      }
      /**
      * Iterates over all top level configuration names.
      */
      *names() {
        for (const name of Object.keys(this._config)) {
          yield name;
        }
      }
      /**
      * Saves passed configuration to the specified target (nested object).
      *
      * @param target Nested config object.
      * @param name The configuration name or an object from which take properties as
      * configuration entries. Configuration names are case-sensitive.
      * @param value The configuration value. Used if a name is passed.
      * @param isDefine Define if passed configuration should overwrite existing one.
      */
      _setToTarget(target, name, value, isDefine = false) {
        if (isPlainObject(name)) {
          this._setObjectToTarget(target, name, isDefine);
          return;
        }
        const parts = name.split(".");
        name = parts.pop();
        for (const part of parts) {
          if (!isPlainObject(target[part])) {
            target[part] = {};
          }
          target = target[part];
        }
        if (isPlainObject(value)) {
          if (!isPlainObject(target[name])) {
            target[name] = {};
          }
          target = target[name];
          this._setObjectToTarget(target, value, isDefine);
          return;
        }
        if (isDefine && typeof target[name] != "undefined") {
          return;
        }
        target[name] = value;
      }
      /**
      * Get specified configuration from specified source (nested object).
      *
      * @param source level of nested object.
      * @param name The configuration name. Configuration names are case-sensitive.
      * @returns The configuration value or `undefined` if the configuration entry was not found.
      */
      _getFromSource(source, name) {
        const parts = name.split(".");
        name = parts.pop();
        for (const part of parts) {
          if (!isPlainObject(source[part])) {
            source = null;
            break;
          }
          source = source[part];
        }
        return source ? cloneConfig(source[name]) : void 0;
      }
      /**
      * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
      *
      * @param target Nested config object.
      * @param configuration Configuration data set
      * @param isDefine Defines if passed configuration is default configuration or not.
      */
      _setObjectToTarget(target, configuration, isDefine) {
        Object.keys(configuration).forEach((key) => {
          this._setToTarget(target, key, configuration[key], isDefine);
        });
      }
    }
    function cloneConfig(source) {
      return cloneDeepWith(source, leaveItemReferences);
    }
    function leaveItemReferences(value) {
      return isElement$1(value) || typeof value === "function" ? value : void 0;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isNode(obj) {
      if (obj) {
        if (obj.defaultView) {
          return obj instanceof obj.defaultView.Document;
        } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
          return obj instanceof obj.ownerDocument.defaultView.Node;
        }
      }
      return false;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isWindow(obj) {
      const stringifiedObject = Object.prototype.toString.apply(obj);
      if (stringifiedObject == "[object Window]") {
        return true;
      }
      if (stringifiedObject == "[object global]") {
        return true;
      }
      return false;
    }
    const defaultEmitterClass = /* @__PURE__ */ DomEmitterMixin(/* @__PURE__ */ EmitterMixin());
    function DomEmitterMixin(base) {
      if (!base) {
        return defaultEmitterClass;
      }
      class Mixin extends base {
        listenTo(emitter, event, callback, options = {}) {
          if (isNode(emitter) || isWindow(emitter)) {
            const proxyOptions = {
              capture: !!options.useCapture,
              passive: !!options.usePassive
            };
            const proxyEmitter = this._getProxyEmitter(emitter, proxyOptions) || new ProxyEmitter(emitter, proxyOptions);
            this.listenTo(proxyEmitter, event, callback, options);
          } else {
            super.listenTo(emitter, event, callback, options);
          }
        }
        stopListening(emitter, event, callback) {
          if (isNode(emitter) || isWindow(emitter)) {
            const proxyEmitters = this._getAllProxyEmitters(emitter);
            for (const proxy of proxyEmitters) {
              this.stopListening(proxy, event, callback);
            }
          } else {
            super.stopListening(emitter, event, callback);
          }
        }
        /**
        * Retrieves ProxyEmitter instance for given DOM Node residing in this Host and given options.
        *
        * @param node DOM Node of the ProxyEmitter.
        * @param options Additional options.
        * @param options.useCapture Indicates that events of this type will be dispatched to the registered
        * listener before being dispatched to any EventTarget beneath it in the DOM tree.
        * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
        * and prevents blocking browser's main thread by this event handler.
        * @returns ProxyEmitter instance bound to the DOM Node.
        */
        _getProxyEmitter(node, options) {
          return _getEmitterListenedTo(this, getProxyEmitterId(node, options));
        }
        /**
        * Retrieves all the ProxyEmitter instances for given DOM Node residing in this Host.
        *
        * @param node DOM Node of the ProxyEmitter.
        */
        _getAllProxyEmitters(node) {
          return [
            {
              capture: false,
              passive: false
            },
            {
              capture: false,
              passive: true
            },
            {
              capture: true,
              passive: false
            },
            {
              capture: true,
              passive: true
            }
          ].map((options) => this._getProxyEmitter(node, options)).filter((proxy) => !!proxy);
        }
      }
      return Mixin;
    }
    [
      "_getProxyEmitter",
      "_getAllProxyEmitters",
      "on",
      "once",
      "off",
      "listenTo",
      "stopListening",
      "fire",
      "delegate",
      "stopDelegating",
      "_addEventListener",
      "_removeEventListener"
    ].forEach((key) => {
      DomEmitterMixin[key] = defaultEmitterClass.prototype[key];
    });
    class ProxyEmitter extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * @param node DOM Node that fires events.
      * @param options Additional options.
      * @param options.useCapture Indicates that events of this type will be dispatched to the registered
      * listener before being dispatched to any EventTarget beneath it in the DOM tree.
      * @param options.usePassive Indicates that the function specified by listener will never call preventDefault()
      * and prevents blocking browser's main thread by this event handler.
      */
      constructor(node, options) {
        super();
        __publicField(this, "_domNode");
        __publicField(this, "_options");
        /**
        * Collection of native DOM listeners.
        */
        __publicField(this, "_domListeners");
        _setEmitterId(this, getProxyEmitterId(node, options));
        this._domNode = node;
        this._options = options;
      }
      /**
      * Registers a callback function to be executed when an event is fired.
      *
      * It attaches a native DOM listener to the DOM Node. When fired,
      * a corresponding Emitter event will also fire with DOM Event object as an argument.
      *
      * **Note**: This is automatically called by the
      * {@link module:utils/emittermixin~Emitter#listenTo `Emitter#listenTo()`}.
      *
      * @param event The name of the event.
      */
      attach(event) {
        if (this._domListeners && this._domListeners[event]) {
          return;
        }
        const domListener = this._createDomListener(event);
        this._domNode.addEventListener(event, domListener, this._options);
        if (!this._domListeners) {
          this._domListeners = {};
        }
        this._domListeners[event] = domListener;
      }
      /**
      * Stops executing the callback on the given event.
      *
      * **Note**: This is automatically called by the
      * {@link module:utils/emittermixin~Emitter#stopListening `Emitter#stopListening()`}.
      *
      * @param event The name of the event.
      */
      detach(event) {
        let events;
        if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
          this._domListeners[event].removeListener();
        }
      }
      /**
      * Adds callback to emitter for given event.
      *
      * @internal
      * @param event The name of the event.
      * @param callback The function to be called on event.
      * @param options Additional options.
      */
      _addEventListener(event, callback, options) {
        this.attach(event);
        EmitterMixin().prototype._addEventListener.call(this, event, callback, options);
      }
      /**
      * Removes callback from emitter for given event.
      *
      * @internal
      * @param event The name of the event.
      * @param callback The function to stop being called.
      */
      _removeEventListener(event, callback) {
        EmitterMixin().prototype._removeEventListener.call(this, event, callback);
        this.detach(event);
      }
      /**
      * Creates a native DOM listener callback. When the native DOM event
      * is fired it will fire corresponding event on this ProxyEmitter.
      * Note: A native DOM Event is passed as an argument.
      *
      * @param event The name of the event.
      * @returns The DOM listener callback.
      */
      _createDomListener(event) {
        const domListener = (domEvt) => {
          this.fire(event, domEvt);
        };
        domListener.removeListener = () => {
          this._domNode.removeEventListener(event, domListener, this._options);
          delete this._domListeners[event];
        };
        return domListener;
      }
    }
    function getNodeUID(node) {
      return node["data-ck-expando"] || (node["data-ck-expando"] = uid());
    }
    function getProxyEmitterId(node, options) {
      let id = getNodeUID(node);
      for (const option of Object.keys(options).sort()) {
        if (options[option]) {
          id += "-" + option;
        }
      }
      return id;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getAncestors(node) {
      const nodes = [];
      let currentNode = node;
      while (currentNode && currentNode.nodeType != Node.DOCUMENT_NODE) {
        nodes.unshift(currentNode);
        currentNode = currentNode.parentNode;
      }
      return nodes;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getDataFromElement(el) {
      if (el instanceof HTMLTextAreaElement) {
        return el.value;
      }
      return el.innerHTML;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getBorderWidths(element) {
      const style = element.ownerDocument.defaultView.getComputedStyle(element);
      return {
        top: parseInt(style.borderTopWidth, 10),
        right: parseInt(style.borderRightWidth, 10),
        bottom: parseInt(style.borderBottomWidth, 10),
        left: parseInt(style.borderLeftWidth, 10)
      };
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isText(obj) {
      return Object.prototype.toString.call(obj) == "[object Text]";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isRange(obj) {
      return Object.prototype.toString.apply(obj) == "[object Range]";
    }
    function getPositionedAncestor(element) {
      if (!element || !element.parentNode) {
        return null;
      }
      if (element.offsetParent === global$1.document.body) {
        return null;
      }
      return element.offsetParent;
    }
    const rectProperties = [
      "top",
      "right",
      "bottom",
      "left",
      "width",
      "height"
    ];
    class Rect {
      /**
      * Creates an instance of rect.
      *
      * ```ts
      * // Rect of an HTMLElement.
      * const rectA = new Rect( document.body );
      *
      * // Rect of a DOM Range.
      * const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
      *
      * // Rect of a window (web browser viewport).
      * const rectC = new Rect( window );
      *
      * // Rect out of an object.
      * const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
      *
      * // Rect out of another Rect instance.
      * const rectE = new Rect( rectD );
      *
      * // Rect out of a ClientRect.
      * const rectF = new Rect( document.body.getClientRects().item( 0 ) );
      * ```
      *
      * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
      * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
      * to get the inner part of the rect.
      *
      * @param source A source object to create the rect.
      */
      constructor(source) {
        /**
        * The "top" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "top");
        /**
        * The "right" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "right");
        /**
        * The "bottom" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "bottom");
        /**
        * The "left" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "left");
        /**
        * The "width" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "width");
        /**
        * The "height" value of the rect.
        *
        * @readonly
        */
        __publicField(this, "height");
        /**
        * The object this rect is for.
        *
        * @readonly
        */
        __publicField(this, "_source");
        const isSourceRange = isRange(source);
        Object.defineProperty(this, "_source", {
          // If the source is a Rect instance, copy it's #_source.
          value: source._source || source,
          writable: true,
          enumerable: false
        });
        if (isDomElement(source) || isSourceRange) {
          if (isSourceRange) {
            const rangeRects = Rect.getDomRangeRects(source);
            copyRectProperties(this, Rect.getBoundingRect(rangeRects));
          } else {
            copyRectProperties(this, source.getBoundingClientRect());
          }
        } else if (isWindow(source)) {
          const { innerWidth, innerHeight } = source;
          copyRectProperties(this, {
            top: 0,
            right: innerWidth,
            bottom: innerHeight,
            left: 0,
            width: innerWidth,
            height: innerHeight
          });
        } else {
          copyRectProperties(this, source);
        }
      }
      /**
      * Returns a clone of the rect.
      *
      * @returns A cloned rect.
      */
      clone() {
        return new Rect(this);
      }
      /**
      * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.
      *
      * @param x Desired horizontal location.
      * @param y Desired vertical location.
      * @returns A rect which has been moved.
      */
      moveTo(x, y) {
        this.top = y;
        this.right = x + this.width;
        this.bottom = y + this.height;
        this.left = x;
        return this;
      }
      /**
      * Moves the rect in–place by a dedicated offset.
      *
      * @param x A horizontal offset.
      * @param y A vertical offset
      * @returns A rect which has been moved.
      */
      moveBy(x, y) {
        this.top += y;
        this.right += x;
        this.left += x;
        this.bottom += y;
        return this;
      }
      /**
      * Returns a new rect a a result of intersection with another rect.
      */
      getIntersection(anotherRect) {
        const rect = {
          top: Math.max(this.top, anotherRect.top),
          right: Math.min(this.right, anotherRect.right),
          bottom: Math.min(this.bottom, anotherRect.bottom),
          left: Math.max(this.left, anotherRect.left),
          width: 0,
          height: 0
        };
        rect.width = rect.right - rect.left;
        rect.height = rect.bottom - rect.top;
        if (rect.width < 0 || rect.height < 0) {
          return null;
        } else {
          const newRect = new Rect(rect);
          newRect._source = this._source;
          return newRect;
        }
      }
      /**
      * Returns the area of intersection with another rect.
      *
      * @returns Area of intersection.
      */
      getIntersectionArea(anotherRect) {
        const rect = this.getIntersection(anotherRect);
        if (rect) {
          return rect.getArea();
        } else {
          return 0;
        }
      }
      /**
      * Returns the area of the rect.
      */
      getArea() {
        return this.width * this.height;
      }
      /**
      * Returns a new rect, a part of the original rect, which is actually visible to the user and is relative to the,`body`,
      * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
      * other than `"visible"`.
      *
      * If there's no such visible rect, which is when the rect is limited by one or many of
      * the ancestors, `null` is returned.
      *
      * **Note**: This method does not consider the boundaries of the viewport (window).
      * To get a rect cropped by all ancestors and the viewport, use an intersection such as:
      *
      * ```ts
      * const visibleInViewportRect = new Rect( window ).getIntersection( new Rect( source ).getVisible() );
      * ```
      *
      * @returns A visible rect instance or `null`, if there's none.
      */
      getVisible() {
        const source = this._source;
        let visibleRect = this.clone();
        if (isBody(source)) {
          return visibleRect;
        }
        let child = source;
        let parent2 = source.parentNode || source.commonAncestorContainer;
        let absolutelyPositionedChildElement;
        while (parent2 && !isBody(parent2)) {
          const isParentOverflowVisible = getElementOverflow(parent2) === "visible";
          if (child instanceof HTMLElement && getElementPosition(child) === "absolute") {
            absolutelyPositionedChildElement = child;
          }
          const parentElementPosition = getElementPosition(parent2);
          if (isParentOverflowVisible || absolutelyPositionedChildElement && (parentElementPosition === "relative" && isParentOverflowVisible || parentElementPosition !== "relative")) {
            child = parent2;
            parent2 = parent2.parentNode;
            continue;
          }
          const parentRect = new Rect(parent2);
          const intersectionRect = visibleRect.getIntersection(parentRect);
          if (intersectionRect) {
            if (intersectionRect.getArea() < visibleRect.getArea()) {
              visibleRect = intersectionRect;
            }
          } else {
            return null;
          }
          child = parent2;
          parent2 = parent2.parentNode;
        }
        return visibleRect;
      }
      /**
      * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
      * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
      * instances.
      *
      * @param anotherRect A rect instance to compare with.
      * @returns `true` when Rects are equal. `false` otherwise.
      */
      isEqual(anotherRect) {
        for (const prop of rectProperties) {
          if (this[prop] !== anotherRect[prop]) {
            return false;
          }
        }
        return true;
      }
      /**
      * Checks whether a rect fully contains another rect instance.
      *
      * @param anotherRect
      * @returns `true` if contains, `false` otherwise.
      */
      contains(anotherRect) {
        const intersectRect = this.getIntersection(anotherRect);
        return !!(intersectRect && intersectRect.isEqual(anotherRect));
      }
      /**
      * Recalculates screen coordinates to coordinates relative to the positioned ancestor offset.
      */
      toAbsoluteRect() {
        const { scrollX, scrollY } = global$1.window;
        const absoluteRect = this.clone().moveBy(scrollX, scrollY);
        if (isDomElement(absoluteRect._source)) {
          const positionedAncestor = getPositionedAncestor(absoluteRect._source);
          if (positionedAncestor) {
            shiftRectToCompensatePositionedAncestor(absoluteRect, positionedAncestor);
          }
        }
        return absoluteRect;
      }
      /**
      * Excludes scrollbars and CSS borders from the rect.
      *
      * * Borders are removed when {@link #_source} is an HTML element.
      * * Scrollbars are excluded from HTML elements and the `window`.
      *
      * @returns A rect which has been updated.
      */
      excludeScrollbarsAndBorders() {
        const source = this._source;
        let scrollBarWidth, scrollBarHeight, direction;
        if (isWindow(source)) {
          scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;
          scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;
          direction = source.getComputedStyle(source.document.documentElement).direction;
        } else {
          const borderWidths = getBorderWidths(source);
          scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;
          scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;
          direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;
          this.left += borderWidths.left;
          this.top += borderWidths.top;
          this.right -= borderWidths.right;
          this.bottom -= borderWidths.bottom;
          this.width = this.right - this.left;
          this.height = this.bottom - this.top;
        }
        this.width -= scrollBarWidth;
        if (direction === "ltr") {
          this.right -= scrollBarWidth;
        } else {
          this.left += scrollBarWidth;
        }
        this.height -= scrollBarHeight;
        this.bottom -= scrollBarHeight;
        return this;
      }
      /**
      * Returns an array of rects of the given native DOM Range.
      *
      * @param range A native DOM range.
      * @returns DOM Range rects.
      */
      static getDomRangeRects(range) {
        const rects = [];
        const clientRects = Array.from(range.getClientRects());
        if (clientRects.length) {
          for (const rect of clientRects) {
            rects.push(new Rect(rect));
          }
        } else {
          let startContainer = range.startContainer;
          if (isText(startContainer)) {
            startContainer = startContainer.parentNode;
          }
          const rect = new Rect(startContainer.getBoundingClientRect());
          rect.right = rect.left;
          rect.width = 0;
          rects.push(rect);
        }
        return rects;
      }
      /**
      * Returns a bounding rectangle that contains all the given `rects`.
      *
      * @param rects A list of rectangles that should be contained in the result rectangle.
      * @returns Bounding rectangle or `null` if no `rects` were given.
      */
      static getBoundingRect(rects) {
        const boundingRectData = {
          left: Number.POSITIVE_INFINITY,
          top: Number.POSITIVE_INFINITY,
          right: Number.NEGATIVE_INFINITY,
          bottom: Number.NEGATIVE_INFINITY,
          width: 0,
          height: 0
        };
        let rectangleCount = 0;
        for (const rect of rects) {
          rectangleCount++;
          boundingRectData.left = Math.min(boundingRectData.left, rect.left);
          boundingRectData.top = Math.min(boundingRectData.top, rect.top);
          boundingRectData.right = Math.max(boundingRectData.right, rect.right);
          boundingRectData.bottom = Math.max(boundingRectData.bottom, rect.bottom);
        }
        if (rectangleCount == 0) {
          return null;
        }
        boundingRectData.width = boundingRectData.right - boundingRectData.left;
        boundingRectData.height = boundingRectData.bottom - boundingRectData.top;
        return new Rect(boundingRectData);
      }
    }
    function copyRectProperties(rect, source) {
      for (const p of rectProperties) {
        rect[p] = source[p];
      }
    }
    function isBody(value) {
      if (!isDomElement(value)) {
        return false;
      }
      return value === value.ownerDocument.body;
    }
    function isDomElement(value) {
      return value !== null && typeof value === "object" && value.nodeType === 1 && typeof value.getBoundingClientRect === "function";
    }
    function getElementPosition(element) {
      return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).position : "static";
    }
    function getElementOverflow(element) {
      return element instanceof HTMLElement ? element.ownerDocument.defaultView.getComputedStyle(element).overflow : "visible";
    }
    function shiftRectToCompensatePositionedAncestor(rect, positionedElementAncestor) {
      const ancestorPosition = new Rect(positionedElementAncestor);
      const ancestorBorderWidths = getBorderWidths(positionedElementAncestor);
      let moveX = 0;
      let moveY = 0;
      moveX -= ancestorPosition.left;
      moveY -= ancestorPosition.top;
      moveX += positionedElementAncestor.scrollLeft;
      moveY += positionedElementAncestor.scrollTop;
      moveX -= ancestorBorderWidths.left;
      moveY -= ancestorBorderWidths.top;
      rect.moveBy(moveX, moveY);
    }
    const _ResizeObserver = class _ResizeObserver {
      /**
      * Creates an instance of the `ResizeObserver` class.
      *
      * @param element A DOM element that is to be observed for resizing. Note that
      * the element must be visible (i.e. not detached from DOM) for the observer to work.
      * @param callback A function called when the observed element was resized. It passes
      * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
      * object with information about the resize event.
      */
      constructor(element, callback) {
        /**
        * The element observed by this observer.
        */
        __publicField(this, "_element");
        /**
        * The callback executed each time {@link #_element} is resized.
        */
        __publicField(this, "_callback");
        if (!_ResizeObserver._observerInstance) {
          _ResizeObserver._createObserver();
        }
        this._element = element;
        this._callback = callback;
        _ResizeObserver._addElementCallback(element, callback);
        _ResizeObserver._observerInstance.observe(element);
      }
      /**
      * The element observed by this observer.
      */
      get element() {
        return this._element;
      }
      /**
      * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
      */
      destroy() {
        _ResizeObserver._deleteElementCallback(this._element, this._callback);
      }
      /**
      * Registers a new resize callback for the DOM element.
      */
      static _addElementCallback(element, callback) {
        if (!_ResizeObserver._elementCallbacks) {
          _ResizeObserver._elementCallbacks = /* @__PURE__ */ new Map();
        }
        let callbacks = _ResizeObserver._elementCallbacks.get(element);
        if (!callbacks) {
          callbacks = /* @__PURE__ */ new Set();
          _ResizeObserver._elementCallbacks.set(element, callbacks);
        }
        callbacks.add(callback);
      }
      /**
      * Removes a resize callback from the DOM element. If no callbacks are left
      * for the element, it removes the element from the native observer.
      */
      static _deleteElementCallback(element, callback) {
        const callbacks = _ResizeObserver._getElementCallbacks(element);
        if (callbacks) {
          callbacks.delete(callback);
          if (!callbacks.size) {
            _ResizeObserver._elementCallbacks.delete(element);
            _ResizeObserver._observerInstance.unobserve(element);
          }
        }
        if (_ResizeObserver._elementCallbacks && !_ResizeObserver._elementCallbacks.size) {
          _ResizeObserver._observerInstance = null;
          _ResizeObserver._elementCallbacks = null;
        }
      }
      /**
      * Returns are registered resize callbacks for the DOM element.
      */
      static _getElementCallbacks(element) {
        if (!_ResizeObserver._elementCallbacks) {
          return null;
        }
        return _ResizeObserver._elementCallbacks.get(element);
      }
      /**
      * Creates the single native observer shared across all `ResizeObserver` instances.
      */
      static _createObserver() {
        _ResizeObserver._observerInstance = new global$1.window.ResizeObserver((entries) => {
          for (const entry of entries) {
            const callbacks = _ResizeObserver._getElementCallbacks(entry.target);
            if (callbacks) {
              for (const callback of callbacks) {
                callback(entry);
              }
            }
          }
        });
      }
    };
    /**
    * The single native observer instance shared across all {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
    */
    __publicField(_ResizeObserver, "_observerInstance", null);
    /**
    * A mapping of native DOM elements and their callbacks shared across all
    * {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
    */
    __publicField(_ResizeObserver, "_elementCallbacks", null);
    let ResizeObserver = _ResizeObserver;
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function setDataInElement(el, data) {
      if (el instanceof HTMLTextAreaElement) {
        el.value = data;
      }
      el.innerHTML = data;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function toUnit(unit) {
      return (value) => value + unit;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function indexOf(node) {
      let index2 = 0;
      while (node.previousSibling) {
        node = node.previousSibling;
        index2++;
      }
      return index2;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function insertAt(parentElement, index2, nodeToInsert) {
      parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index2] || null);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isComment(obj) {
      return obj && obj.nodeType === Node.COMMENT_NODE;
    }
    function isValidAttributeName(name) {
      try {
        global$1.document.createAttribute(name);
      } catch (error) {
        return false;
      }
      return true;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isVisible(element) {
      return !!(element && element.getClientRects && element.getClientRects().length);
    }
    function getOptimalPosition({ element, target, positions, limiter, fitInViewport, viewportOffsetConfig }) {
      if (isFunction(target)) {
        target = target();
      }
      if (isFunction(limiter)) {
        limiter = limiter();
      }
      const positionedElementAncestor = getPositionedAncestor(element);
      const constrainedViewportRect = getConstrainedViewportRect$1(viewportOffsetConfig);
      const elementRect = new Rect(element);
      const visibleTargetRect = getVisibleViewportIntersectionRect(target, constrainedViewportRect);
      let bestPosition;
      if (!visibleTargetRect || !constrainedViewportRect.getIntersection(visibleTargetRect)) {
        return null;
      }
      const positionOptions = {
        targetRect: visibleTargetRect,
        elementRect,
        positionedElementAncestor,
        viewportRect: constrainedViewportRect
      };
      if (!limiter && !fitInViewport) {
        bestPosition = new PositionObject(positions[0], positionOptions);
      } else {
        if (limiter) {
          const visibleLimiterRect = getVisibleViewportIntersectionRect(limiter, constrainedViewportRect);
          if (visibleLimiterRect) {
            positionOptions.limiterRect = visibleLimiterRect;
          }
        }
        bestPosition = getBestPosition(positions, positionOptions);
      }
      return bestPosition;
    }
    function getVisibleViewportIntersectionRect(source, viewportRect) {
      const visibleSourceRect = new Rect(source).getVisible();
      if (!visibleSourceRect) {
        return null;
      }
      return visibleSourceRect.getIntersection(viewportRect);
    }
    function getConstrainedViewportRect$1(viewportOffsetConfig) {
      viewportOffsetConfig = Object.assign({
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }, viewportOffsetConfig);
      const viewportRect = new Rect(global$1.window);
      viewportRect.top += viewportOffsetConfig.top;
      viewportRect.height -= viewportOffsetConfig.top;
      viewportRect.bottom -= viewportOffsetConfig.bottom;
      viewportRect.height -= viewportOffsetConfig.bottom;
      return viewportRect;
    }
    function getBestPosition(positions, options) {
      const { elementRect } = options;
      const elementRectArea = elementRect.getArea();
      const positionInstances = positions.map((positioningFunction) => new PositionObject(positioningFunction, options)).filter((position) => !!position.name);
      let maxFitFactor = 0;
      let bestPosition = null;
      for (const position of positionInstances) {
        const { limiterIntersectionArea, viewportIntersectionArea } = position;
        if (limiterIntersectionArea === elementRectArea) {
          return position;
        }
        const fitFactor = viewportIntersectionArea ** 2 + limiterIntersectionArea ** 2;
        if (fitFactor > maxFitFactor) {
          maxFitFactor = fitFactor;
          bestPosition = position;
        }
      }
      return bestPosition;
    }
    class PositionObject {
      /**
      * Creates an instance of the {@link module:utils/dom/position~PositionObject} class.
      *
      * @param positioningFunction function The function that defines the expected
      * coordinates the positioned element should move to.
      * @param options options object.
      * @param options.elementRect The positioned element rect.
      * @param options.targetRect The target element rect.
      * @param options.viewportRect The viewport rect.
      * @param options.limiterRect The limiter rect.
      * @param options.positionedElementAncestor Nearest element ancestor element which CSS position is not "static".
      */
      constructor(positioningFunction, options) {
        __publicField(this, "name");
        __publicField(this, "config");
        __publicField(this, "_positioningFunctionCoordinates");
        __publicField(this, "_options");
        __publicField(this, "_cachedRect");
        __publicField(this, "_cachedAbsoluteRect");
        const positioningFunctionOutput = positioningFunction(options.targetRect, options.elementRect, options.viewportRect, options.limiterRect);
        if (!positioningFunctionOutput) {
          return;
        }
        const { left, top, name, config } = positioningFunctionOutput;
        this.name = name;
        this.config = config;
        this._positioningFunctionCoordinates = {
          left,
          top
        };
        this._options = options;
      }
      /**
      * The left value in pixels in the CSS `position: absolute` coordinate system.
      * Set it on the positioned element in DOM to move it to the position.
      */
      get left() {
        return this._absoluteRect.left;
      }
      /**
      * The top value in pixels in the CSS `position: absolute` coordinate system.
      * Set it on the positioned element in DOM to move it to the position.
      */
      get top() {
        return this._absoluteRect.top;
      }
      /**
      * An intersection area between positioned element and limiter within viewport constraints.
      */
      get limiterIntersectionArea() {
        const limiterRect = this._options.limiterRect;
        if (limiterRect) {
          return limiterRect.getIntersectionArea(this._rect);
        }
        return 0;
      }
      /**
      * An intersection area between positioned element and viewport.
      */
      get viewportIntersectionArea() {
        const viewportRect = this._options.viewportRect;
        return viewportRect.getIntersectionArea(this._rect);
      }
      /**
      * An already positioned element rect. A clone of the element rect passed to the constructor
      * but placed in the viewport according to the positioning function.
      */
      get _rect() {
        if (this._cachedRect) {
          return this._cachedRect;
        }
        this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top);
        return this._cachedRect;
      }
      /**
      * An already absolutely positioned element rect. See ({@link #_rect}).
      */
      get _absoluteRect() {
        if (this._cachedAbsoluteRect) {
          return this._cachedAbsoluteRect;
        }
        this._cachedAbsoluteRect = this._rect.toAbsoluteRect();
        return this._cachedAbsoluteRect;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function remove$1(node) {
      const parent2 = node.parentNode;
      if (parent2) {
        parent2.removeChild(node);
      }
    }
    function scrollViewportToShowTarget({ target, viewportOffset = 0, ancestorOffset = 0, alignToTop, forceScroll }) {
      const targetWindow = getWindow(target);
      let currentWindow = targetWindow;
      let currentFrame = null;
      viewportOffset = normalizeViewportOffset(viewportOffset);
      while (currentWindow) {
        let firstAncestorToScroll;
        if (currentWindow == targetWindow) {
          firstAncestorToScroll = getParentElement(target);
        } else {
          firstAncestorToScroll = getParentElement(currentFrame);
        }
        scrollAncestorsToShowRect({
          parent: firstAncestorToScroll,
          getRect: () => {
            return getRectRelativeToWindow(target, currentWindow);
          },
          alignToTop,
          ancestorOffset,
          forceScroll
        });
        const targetRect = getRectRelativeToWindow(target, currentWindow);
        scrollWindowToShowRect({
          window: currentWindow,
          rect: targetRect,
          viewportOffset,
          alignToTop,
          forceScroll
        });
        if (currentWindow.parent != currentWindow) {
          currentFrame = currentWindow.frameElement;
          currentWindow = currentWindow.parent;
          if (!currentFrame) {
            return;
          }
        } else {
          currentWindow = null;
        }
      }
    }
    function scrollWindowToShowRect({ window: window2, rect, alignToTop, forceScroll, viewportOffset }) {
      const targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset.bottom);
      const targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset.top);
      const viewportRect = new Rect(window2).excludeScrollbarsAndBorders();
      const rects = [
        targetShiftedUpRect,
        targetShiftedDownRect
      ];
      const forceScrollToTop = alignToTop && forceScroll;
      const allRectsFitInViewport = rects.every((rect2) => viewportRect.contains(rect2));
      let { scrollX, scrollY } = window2;
      const initialScrollX = scrollX;
      const initialScrollY = scrollY;
      if (forceScrollToTop) {
        scrollY -= viewportRect.top - rect.top + viewportOffset.top;
      } else if (!allRectsFitInViewport) {
        if (isAbove(targetShiftedUpRect, viewportRect)) {
          scrollY -= viewportRect.top - rect.top + viewportOffset.top;
        } else if (isBelow(targetShiftedDownRect, viewportRect)) {
          if (alignToTop) {
            scrollY += rect.top - viewportRect.top - viewportOffset.top;
          } else {
            scrollY += rect.bottom - viewportRect.bottom + viewportOffset.bottom;
          }
        }
      }
      if (!allRectsFitInViewport) {
        if (isLeftOf(rect, viewportRect)) {
          scrollX -= viewportRect.left - rect.left + viewportOffset.left;
        } else if (isRightOf(rect, viewportRect)) {
          scrollX += rect.right - viewportRect.right + viewportOffset.right;
        }
      }
      if (scrollX != initialScrollX || scrollY !== initialScrollY) {
        window2.scrollTo(scrollX, scrollY);
      }
    }
    function scrollAncestorsToShowRect({ parent: parent2, getRect, alignToTop, forceScroll, ancestorOffset = 0, limiterElement }) {
      const parentWindow = getWindow(parent2);
      const forceScrollToTop = alignToTop && forceScroll;
      let parentRect, targetRect, targetFitsInTarget;
      const limiter = limiterElement || parentWindow.document.body;
      while (parent2 != limiter) {
        targetRect = getRect();
        parentRect = new Rect(parent2).excludeScrollbarsAndBorders();
        targetFitsInTarget = parentRect.contains(targetRect);
        if (forceScrollToTop) {
          parent2.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
        } else if (!targetFitsInTarget) {
          if (isAbove(targetRect, parentRect)) {
            parent2.scrollTop -= parentRect.top - targetRect.top + ancestorOffset;
          } else if (isBelow(targetRect, parentRect)) {
            if (alignToTop) {
              parent2.scrollTop += targetRect.top - parentRect.top - ancestorOffset;
            } else {
              parent2.scrollTop += targetRect.bottom - parentRect.bottom + ancestorOffset;
            }
          }
        }
        if (!targetFitsInTarget) {
          if (isLeftOf(targetRect, parentRect)) {
            parent2.scrollLeft -= parentRect.left - targetRect.left + ancestorOffset;
          } else if (isRightOf(targetRect, parentRect)) {
            parent2.scrollLeft += targetRect.right - parentRect.right + ancestorOffset;
          }
        }
        parent2 = parent2.parentNode;
      }
    }
    function isBelow(firstRect, secondRect) {
      return firstRect.bottom > secondRect.bottom;
    }
    function isAbove(firstRect, secondRect) {
      return firstRect.top < secondRect.top;
    }
    function isLeftOf(firstRect, secondRect) {
      return firstRect.left < secondRect.left;
    }
    function isRightOf(firstRect, secondRect) {
      return firstRect.right > secondRect.right;
    }
    function getWindow(elementOrRange) {
      if (isRange(elementOrRange)) {
        return elementOrRange.startContainer.ownerDocument.defaultView;
      } else {
        return elementOrRange.ownerDocument.defaultView;
      }
    }
    function getParentElement(elementOrRange) {
      if (isRange(elementOrRange)) {
        let parent2 = elementOrRange.commonAncestorContainer;
        if (isText(parent2)) {
          parent2 = parent2.parentNode;
        }
        return parent2;
      } else {
        return elementOrRange.parentNode;
      }
    }
    function getRectRelativeToWindow(target, relativeWindow) {
      const targetWindow = getWindow(target);
      const rect = new Rect(target);
      if (targetWindow === relativeWindow) {
        return rect;
      } else {
        let currentWindow = targetWindow;
        while (currentWindow != relativeWindow) {
          const frame = currentWindow.frameElement;
          const frameRect = new Rect(frame).excludeScrollbarsAndBorders();
          rect.moveBy(frameRect.left, frameRect.top);
          currentWindow = currentWindow.parent;
        }
      }
      return rect;
    }
    function normalizeViewportOffset(viewportOffset) {
      if (typeof viewportOffset === "number") {
        return {
          top: viewportOffset,
          bottom: viewportOffset,
          left: viewportOffset,
          right: viewportOffset
        };
      }
      return viewportOffset;
    }
    const modifiersToGlyphsMac = {
      ctrl: "⌃",
      cmd: "⌘",
      alt: "⌥",
      shift: "⇧"
    };
    const modifiersToGlyphsNonMac = {
      ctrl: "Ctrl+",
      alt: "Alt+",
      shift: "Shift+"
    };
    const keyCodesToGlyphs = {
      37: "←",
      38: "↑",
      39: "→",
      40: "↓",
      9: "⇥",
      33: "Page Up",
      34: "Page Down"
    };
    const keyCodes = /* @__PURE__ */ generateKnownKeyCodes();
    const keyCodeNames = /* @__PURE__ */ Object.fromEntries(/* @__PURE__ */ Object.entries(keyCodes).map(([name, code]) => {
      let prettyKeyName;
      if (code in keyCodesToGlyphs) {
        prettyKeyName = keyCodesToGlyphs[code];
      } else {
        prettyKeyName = name.charAt(0).toUpperCase() + name.slice(1);
      }
      return [
        code,
        prettyKeyName
      ];
    }));
    function getCode(key) {
      let keyCode;
      if (typeof key == "string") {
        keyCode = keyCodes[key.toLowerCase()];
        if (!keyCode) {
          throw new CKEditorError("keyboard-unknown-key", null, {
            key
          });
        }
      } else {
        keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0) + (key.metaKey ? keyCodes.cmd : 0);
      }
      return keyCode;
    }
    function parseKeystroke(keystroke) {
      if (typeof keystroke == "string") {
        keystroke = splitKeystrokeText(keystroke);
      }
      return keystroke.map((key) => typeof key == "string" ? getEnvKeyCode(key) : key).reduce((key, sum) => sum + key, 0);
    }
    function getEnvKeystrokeText(keystroke) {
      let keystrokeCode = parseKeystroke(keystroke);
      const modifiersToGlyphs = Object.entries(env.isMac || env.isiOS ? modifiersToGlyphsMac : modifiersToGlyphsNonMac);
      const modifiers = modifiersToGlyphs.reduce((modifiers2, [name, glyph]) => {
        if ((keystrokeCode & keyCodes[name]) != 0) {
          keystrokeCode &= ~keyCodes[name];
          modifiers2 += glyph;
        }
        return modifiers2;
      }, "");
      return modifiers + (keystrokeCode ? keyCodeNames[keystrokeCode] : "");
    }
    function isArrowKeyCode(keyCode) {
      return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
    }
    function getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection) {
      const isLtrContent = contentLanguageDirection === "ltr";
      switch (keyCode) {
        case keyCodes.arrowleft:
          return isLtrContent ? "left" : "right";
        case keyCodes.arrowright:
          return isLtrContent ? "right" : "left";
        case keyCodes.arrowup:
          return "up";
        case keyCodes.arrowdown:
          return "down";
      }
    }
    function getEnvKeyCode(key) {
      if (key.endsWith("!")) {
        return getCode(key.slice(0, -1));
      }
      const code = getCode(key);
      return (env.isMac || env.isiOS) && code == keyCodes.ctrl ? keyCodes.cmd : code;
    }
    function isForwardArrowKeyCode(keyCode, contentLanguageDirection) {
      const localizedKeyCodeDirection = getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection);
      return localizedKeyCodeDirection === "down" || localizedKeyCodeDirection === "right";
    }
    function generateKnownKeyCodes() {
      const keyCodes2 = {
        pageup: 33,
        pagedown: 34,
        arrowleft: 37,
        arrowup: 38,
        arrowright: 39,
        arrowdown: 40,
        backspace: 8,
        delete: 46,
        enter: 13,
        space: 32,
        esc: 27,
        tab: 9,
        // The idea about these numbers is that they do not collide with any real key codes, so we can use them
        // like bit masks.
        ctrl: 1114112,
        shift: 2228224,
        alt: 4456448,
        cmd: 8912896
      };
      for (let code = 65; code <= 90; code++) {
        const letter = String.fromCharCode(code);
        keyCodes2[letter.toLowerCase()] = code;
      }
      for (let code = 48; code <= 57; code++) {
        keyCodes2[code - 48] = code;
      }
      for (let code = 112; code <= 123; code++) {
        keyCodes2["f" + (code - 111)] = code;
      }
      Object.assign(keyCodes2, {
        "'": 222,
        ",": 108,
        "-": 109,
        ".": 110,
        "/": 111,
        ";": 186,
        "=": 187,
        "[": 219,
        "\\": 220,
        "]": 221,
        "`": 223
      });
      return keyCodes2;
    }
    function splitKeystrokeText(keystroke) {
      return keystroke.split("+").map((key) => key.trim());
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const RTL_LANGUAGE_CODES = [
      "ar",
      "ara",
      "dv",
      "div",
      "fa",
      "per",
      "fas",
      "he",
      "heb",
      "ku",
      "kur",
      "ug",
      "uig"
      // Uighur, Uyghur
    ];
    function getLanguageDirection(languageCode) {
      return RTL_LANGUAGE_CODES.includes(languageCode) ? "rtl" : "ltr";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function toArray$1(data) {
      return Array.isArray(data) ? data : [
        data
      ];
    }
    /* istanbul ignore else -- @preserve */
    if (!global$1.window.CKEDITOR_TRANSLATIONS) {
      global$1.window.CKEDITOR_TRANSLATIONS = {};
    }
    function _translate(language, message, quantity = 1, translations) {
      if (typeof quantity !== "number") {
        throw new CKEditorError("translation-service-quantity-not-a-number", null, {
          quantity
        });
      }
      const normalizedTranslations = translations || global$1.window.CKEDITOR_TRANSLATIONS;
      const numberOfLanguages = getNumberOfLanguages(normalizedTranslations);
      if (numberOfLanguages === 1) {
        language = Object.keys(normalizedTranslations)[0];
      }
      const messageId = message.id || message.string;
      if (numberOfLanguages === 0 || !hasTranslation(language, messageId, normalizedTranslations)) {
        if (quantity !== 1) {
          return message.plural;
        }
        return message.string;
      }
      const dictionary = normalizedTranslations[language].dictionary;
      const getPluralForm = normalizedTranslations[language].getPluralForm || ((n) => n === 1 ? 0 : 1);
      const translation = dictionary[messageId];
      if (typeof translation === "string") {
        return translation;
      }
      const pluralFormIndex = Number(getPluralForm(quantity));
      return translation[pluralFormIndex];
    }
    function _unifyTranslations(translations) {
      return Array.isArray(translations) ? translations.reduce((acc, translation) => merge$1(acc, translation)) : translations;
    }
    function hasTranslation(language, messageId, translations) {
      return !!translations[language] && !!translations[language].dictionary[messageId];
    }
    function getNumberOfLanguages(translations) {
      return Object.keys(translations).length;
    }
    class Locale {
      /**
      * Creates a new instance of the locale class. Learn more about
      * {@glink getting-started/setup/ui-language configuring the language of the editor}.
      *
      * @param options Locale configuration.
      * @param options.uiLanguage The editor UI language code in the
      * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
      * @param options.contentLanguage The editor content language code in the
      * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
      * See {@link #contentLanguage}.
      * @param translations Translations passed as a editor config parameter.
      */
      constructor({ uiLanguage = "en", contentLanguage, translations } = {}) {
        /**
        * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
        *
        * If the {@link #contentLanguage content language} was not specified in the `Locale` constructor,
        * it also defines the language of the content.
        */
        __publicField(this, "uiLanguage");
        /**
        * Text direction of the {@link #uiLanguage editor UI language}. Either `'ltr'` or `'rtl'`.
        */
        __publicField(this, "uiLanguageDirection");
        /**
        * The editor content language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
        *
        * Usually the same as the {@link #uiLanguage editor language}, it can be customized by passing an optional
        * argument to the `Locale` constructor.
        */
        __publicField(this, "contentLanguage");
        /**
        * Text direction of the {@link #contentLanguage editor content language}.
        *
        * If the content language was passed directly to the `Locale` constructor, this property represents the
        * direction of that language.
        *
        * If the {@link #contentLanguage editor content language} was derived from the {@link #uiLanguage editor language},
        * the content language direction is the same as the {@link #uiLanguageDirection UI language direction}.
        *
        * The value is either `'ltr'` or `'rtl'`.
        */
        __publicField(this, "contentLanguageDirection");
        /**
        * Translates the given message to the {@link #uiLanguage}. This method is also available in
        * {@link module:core/editor/editor~Editor#t `Editor`} and {@link module:ui/view~View#t `View`}.
        *
        * This method's context is statically bound to the `Locale` instance and **should always be called as a function**:
        *
        * ```ts
        * const t = locale.t;
        * t( 'Label' );
        * ```
        *
        * The message can be either a string or an object implementing the {@link module:utils/translation-service~Message} interface.
        *
        * The message may contain placeholders (`%<index>`) for value(s) that are passed as a `values` parameter.
        * For an array of values, the `%<index>` will be changed to an element of that array at the given index.
        * For a single value passed as the second argument, only the `%0` placeholders will be changed to the provided value.
        *
        * ```ts
        * t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
        * t( 'Created file "%0", fileName );
        * ```
        *
        * The message supports plural forms. To specify the plural form, use the `plural` property. Singular or plural form
        * will be chosen depending on the first value from the passed `values`. The value of the `plural` property is used
        * as a default plural translation when the translation for the target language is missing.
        *
        * ```ts
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Add a space' for the English language.
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Add 5 spaces' for the English language.
        * t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Add 2 spaces' for the English language.
        *
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Dodaj spację' for the Polish language.
        * t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Dodaj 5 spacji' for the Polish language.
        * t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Dodaj 2 spacje' for the Polish language.
        * ```
        *
        *  * The message should provide an ID using the `id` property when the message strings are not unique and their
        * translations should be different.
        *
        * ```ts
        * translate( 'en', { string: 'image', id: 'ADD_IMAGE' } );
        * translate( 'en', { string: 'image', id: 'AN_IMAGE' } );
        * ```
        */
        __publicField(this, "t");
        /**
        * Object that contains translations.
        */
        __publicField(this, "translations");
        this.uiLanguage = uiLanguage;
        this.contentLanguage = contentLanguage || this.uiLanguage;
        this.uiLanguageDirection = getLanguageDirection(this.uiLanguage);
        this.contentLanguageDirection = getLanguageDirection(this.contentLanguage);
        this.translations = _unifyTranslations(translations);
        this.t = (message, values) => this._t(message, values);
      }
      /**
      * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
      *
      * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
      * properties instead.
      *
      * @deprecated
      */
      get language() {
        console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead.");
        return this.uiLanguage;
      }
      /**
      * An unbound version of the {@link #t} method.
      */
      _t(message, values = []) {
        values = toArray$1(values);
        if (typeof message === "string") {
          message = {
            string: message
          };
        }
        const hasPluralForm = !!message.plural;
        const quantity = hasPluralForm ? values[0] : 1;
        const translatedString = _translate(this.uiLanguage, message, quantity, this.translations);
        return interpolateString(translatedString, values);
      }
    }
    function interpolateString(string, values) {
      return string.replace(/%(\d+)/g, (match, index2) => {
        return index2 < values.length ? values[index2] : match;
      });
    }
    class Collection extends (/* @__PURE__ */ EmitterMixin()) {
      constructor(initialItemsOrOptions = {}, options = {}) {
        super();
        /**
        * The internal list of items in the collection.
        */
        __publicField(this, "_items");
        /**
        * The internal map of items in the collection.
        */
        __publicField(this, "_itemMap");
        /**
        * The name of the property which is considered to identify an item.
        */
        __publicField(this, "_idProperty");
        /**
        * A collection instance this collection is bound to as a result
        * of calling {@link #bindTo} method.
        */
        __publicField(this, "_bindToCollection");
        /**
        * A helper mapping external items of a bound collection ({@link #bindTo})
        * and actual items of this collection. It provides information
        * necessary to properly remove items bound to another collection.
        *
        * See {@link #_bindToInternalToExternalMap}.
        */
        __publicField(this, "_bindToExternalToInternalMap");
        /**
        * A helper mapping items of this collection to external items of a bound collection
        * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.
        * to avoid loops in two–way bindings.
        *
        * See {@link #_bindToExternalToInternalMap}.
        */
        __publicField(this, "_bindToInternalToExternalMap");
        /**
        * Stores indexes of skipped items from bound external collection.
        */
        __publicField(this, "_skippedIndexesFromExternal");
        const hasInitialItems = isIterable(initialItemsOrOptions);
        if (!hasInitialItems) {
          options = initialItemsOrOptions;
        }
        this._items = [];
        this._itemMap = /* @__PURE__ */ new Map();
        this._idProperty = options.idProperty || "id";
        this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap();
        this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap();
        this._skippedIndexesFromExternal = [];
        if (hasInitialItems) {
          for (const item of initialItemsOrOptions) {
            this._items.push(item);
            this._itemMap.set(this._getItemIdBeforeAdding(item), item);
          }
        }
      }
      /**
      * The number of items available in the collection.
      */
      get length() {
        return this._items.length;
      }
      /**
      * Returns the first item from the collection or null when collection is empty.
      */
      get first() {
        return this._items[0] || null;
      }
      /**
      * Returns the last item from the collection or null when collection is empty.
      */
      get last() {
        return this._items[this.length - 1] || null;
      }
      /**
      * Adds an item into the collection.
      *
      * If the item does not have an id, then it will be automatically generated and set on the item.
      *
      * @param item
      * @param index The position of the item in the collection. The item
      * is pushed to the collection when `index` not specified.
      * @fires add
      * @fires change
      */
      add(item, index2) {
        return this.addMany([
          item
        ], index2);
      }
      /**
      * Adds multiple items into the collection.
      *
      * Any item not containing an id will get an automatically generated one.
      *
      * @param items
      * @param index The position of the insertion. Items will be appended if no `index` is specified.
      * @fires add
      * @fires change
      */
      addMany(items, index2) {
        if (index2 === void 0) {
          index2 = this._items.length;
        } else if (index2 > this._items.length || index2 < 0) {
          throw new CKEditorError("collection-add-item-invalid-index", this);
        }
        let offset = 0;
        for (const item of items) {
          const itemId = this._getItemIdBeforeAdding(item);
          const currentItemIndex = index2 + offset;
          this._items.splice(currentItemIndex, 0, item);
          this._itemMap.set(itemId, item);
          this.fire("add", item, currentItemIndex);
          offset++;
        }
        this.fire("change", {
          added: items,
          removed: [],
          index: index2
        });
        return this;
      }
      /**
      * Gets an item by its ID or index.
      *
      * @param idOrIndex The item ID or index in the collection.
      * @returns The requested item or `null` if such item does not exist.
      */
      get(idOrIndex) {
        let item;
        if (typeof idOrIndex == "string") {
          item = this._itemMap.get(idOrIndex);
        } else if (typeof idOrIndex == "number") {
          item = this._items[idOrIndex];
        } else {
          throw new CKEditorError("collection-get-invalid-arg", this);
        }
        return item || null;
      }
      /**
      * Returns a Boolean indicating whether the collection contains an item.
      *
      * @param itemOrId The item or its ID in the collection.
      * @returns `true` if the collection contains the item, `false` otherwise.
      */
      has(itemOrId) {
        if (typeof itemOrId == "string") {
          return this._itemMap.has(itemOrId);
        } else {
          const idProperty = this._idProperty;
          const id = itemOrId[idProperty];
          return id && this._itemMap.has(id);
        }
      }
      /**
      * Gets an index of an item in the collection.
      * When an item is not defined in the collection, the index will equal -1.
      *
      * @param itemOrId The item or its ID in the collection.
      * @returns The index of a given item.
      */
      getIndex(itemOrId) {
        let item;
        if (typeof itemOrId == "string") {
          item = this._itemMap.get(itemOrId);
        } else {
          item = itemOrId;
        }
        return item ? this._items.indexOf(item) : -1;
      }
      /**
      * Removes an item from the collection.
      *
      * @param subject The item to remove, its ID or index in the collection.
      * @returns The removed item.
      * @fires remove
      * @fires change
      */
      remove(subject) {
        const [item, index2] = this._remove(subject);
        this.fire("change", {
          added: [],
          removed: [
            item
          ],
          index: index2
        });
        return item;
      }
      /**
      * Executes the callback for each item in the collection and composes an array or values returned by this callback.
      *
      * @typeParam U The result type of the callback.
      * @param callback
      * @param ctx Context in which the `callback` will be called.
      * @returns The result of mapping.
      */
      map(callback, ctx) {
        return this._items.map(callback, ctx);
      }
      /**
      * Performs the specified action for each item in the collection.
      *
      * @param ctx Context in which the `callback` will be called.
      */
      forEach(callback, ctx) {
        this._items.forEach(callback, ctx);
      }
      /**
      * Finds the first item in the collection for which the `callback` returns a true value.
      *
      * @param callback
      * @param ctx Context in which the `callback` will be called.
      * @returns The item for which `callback` returned a true value.
      */
      find(callback, ctx) {
        return this._items.find(callback, ctx);
      }
      /**
      * Returns an array with items for which the `callback` returned a true value.
      *
      * @param callback
      * @param ctx Context in which the `callback` will be called.
      * @returns The array with matching items.
      */
      filter(callback, ctx) {
        return this._items.filter(callback, ctx);
      }
      /**
      * Removes all items from the collection and destroys the binding created using
      * {@link #bindTo}.
      *
      * @fires remove
      * @fires change
      */
      clear() {
        if (this._bindToCollection) {
          this.stopListening(this._bindToCollection);
          this._bindToCollection = null;
        }
        const removedItems = Array.from(this._items);
        while (this.length) {
          this._remove(0);
        }
        this.fire("change", {
          added: [],
          removed: removedItems,
          index: 0
        });
      }
      /**
      * Binds and synchronizes the collection with another one.
      *
      * The binding can be a simple factory:
      *
      * ```ts
      * class FactoryClass {
      * 	public label: string;
      *
      * 	constructor( data: { label: string } ) {
      * 		this.label = data.label;
      * 	}
      * }
      *
      * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
      * const target = new Collection<FactoryClass>();
      *
      * target.bindTo( source ).as( FactoryClass );
      *
      * source.add( { label: 'foo' } );
      * source.add( { label: 'bar' } );
      *
      * console.log( target.length ); // 2
      * console.log( target.get( 1 ).label ); // 'bar'
      *
      * source.remove( 0 );
      * console.log( target.length ); // 1
      * console.log( target.get( 0 ).label ); // 'bar'
      * ```
      *
      * or the factory driven by a custom callback:
      *
      * ```ts
      * class FooClass {
      * 	public label: string;
      *
      * 	constructor( data: { label: string } ) {
      * 		this.label = data.label;
      * 	}
      * }
      *
      * class BarClass {
      * 	public label: string;
      *
      * 	constructor( data: { label: string } ) {
      * 		this.label = data.label;
      * 	}
      * }
      *
      * const source = new Collection<{ label: string }>( { idProperty: 'label' } );
      * const target = new Collection<FooClass | BarClass>();
      *
      * target.bindTo( source ).using( ( item ) => {
      * 	if ( item.label == 'foo' ) {
      * 		return new FooClass( item );
      * 	} else {
      * 		return new BarClass( item );
      * 	}
      * } );
      *
      * source.add( { label: 'foo' } );
      * source.add( { label: 'bar' } );
      *
      * console.log( target.length ); // 2
      * console.log( target.get( 0 ) instanceof FooClass ); // true
      * console.log( target.get( 1 ) instanceof BarClass ); // true
      * ```
      *
      * or the factory out of property name:
      *
      * ```ts
      * const source = new Collection<{ nested: { value: string } }>();
      * const target = new Collection<{ value: string }>();
      *
      * target.bindTo( source ).using( 'nested' );
      *
      * source.add( { nested: { value: 'foo' } } );
      * source.add( { nested: { value: 'bar' } } );
      *
      * console.log( target.length ); // 2
      * console.log( target.get( 0 ).value ); // 'foo'
      * console.log( target.get( 1 ).value ); // 'bar'
      * ```
      *
      * It's possible to skip specified items by returning null value:
      *
      * ```ts
      * const source = new Collection<{ hidden: boolean }>();
      * const target = new Collection<{ hidden: boolean }>();
      *
      * target.bindTo( source ).using( item => {
      * 	if ( item.hidden ) {
      * 		return null;
      * 	}
      *
      * 	return item;
      * } );
      *
      * source.add( { hidden: true } );
      * source.add( { hidden: false } );
      *
      * console.log( source.length ); // 2
      * console.log( target.length ); // 1
      * ```
      *
      * **Note**: {@link #clear} can be used to break the binding.
      *
      * @typeParam S The type of `externalCollection` element.
      * @param externalCollection A collection to be bound.
      * @returns The binding chain object.
      */
      bindTo(externalCollection) {
        if (this._bindToCollection) {
          throw new CKEditorError("collection-bind-to-rebind", this);
        }
        this._bindToCollection = externalCollection;
        return {
          as: (Class) => {
            this._setUpBindToBinding((item) => new Class(item));
          },
          using: (callbackOrProperty) => {
            if (typeof callbackOrProperty == "function") {
              this._setUpBindToBinding(callbackOrProperty);
            } else {
              this._setUpBindToBinding((item) => item[callbackOrProperty]);
            }
          }
        };
      }
      /**
      * Finalizes and activates a binding initiated by {@link #bindTo}.
      *
      * @param factory A function which produces collection items.
      */
      _setUpBindToBinding(factory) {
        const externalCollection = this._bindToCollection;
        const addItem = (evt, externalItem, index2) => {
          const isExternalBoundToThis = externalCollection._bindToCollection == this;
          const externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem);
          if (isExternalBoundToThis && externalItemBound) {
            this._bindToExternalToInternalMap.set(externalItem, externalItemBound);
            this._bindToInternalToExternalMap.set(externalItemBound, externalItem);
          } else {
            const item = factory(externalItem);
            if (!item) {
              this._skippedIndexesFromExternal.push(index2);
              return;
            }
            let finalIndex = index2;
            for (const skipped of this._skippedIndexesFromExternal) {
              if (index2 > skipped) {
                finalIndex--;
              }
            }
            for (const skipped of externalCollection._skippedIndexesFromExternal) {
              if (finalIndex >= skipped) {
                finalIndex++;
              }
            }
            this._bindToExternalToInternalMap.set(externalItem, item);
            this._bindToInternalToExternalMap.set(item, externalItem);
            this.add(item, finalIndex);
            for (let i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {
              if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {
                externalCollection._skippedIndexesFromExternal[i]++;
              }
            }
          }
        };
        for (const externalItem of externalCollection) {
          addItem(null, externalItem, externalCollection.getIndex(externalItem));
        }
        this.listenTo(externalCollection, "add", addItem);
        this.listenTo(externalCollection, "remove", (evt, externalItem, index2) => {
          const item = this._bindToExternalToInternalMap.get(externalItem);
          if (item) {
            this.remove(item);
          }
          this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((result, skipped) => {
            if (index2 < skipped) {
              result.push(skipped - 1);
            }
            if (index2 > skipped) {
              result.push(skipped);
            }
            return result;
          }, []);
        });
      }
      /**
      * Returns an unique id property for a given `item`.
      *
      * The method will generate new id and assign it to the `item` if it doesn't have any.
      *
      * @param item Item to be added.
      */
      _getItemIdBeforeAdding(item) {
        const idProperty = this._idProperty;
        let itemId;
        if (idProperty in item) {
          itemId = item[idProperty];
          if (typeof itemId != "string") {
            throw new CKEditorError("collection-add-invalid-id", this);
          }
          if (this.get(itemId)) {
            throw new CKEditorError("collection-add-item-already-exists", this);
          }
        } else {
          item[idProperty] = itemId = uid();
        }
        return itemId;
      }
      /**
      * Core {@link #remove} method implementation shared in other functions.
      *
      * In contrast this method **does not** fire the {@link #event:change} event.
      *
      * @param subject The item to remove, its id or index in the collection.
      * @returns Returns an array with the removed item and its index.
      * @fires remove
      */
      _remove(subject) {
        let index2, id, item;
        let itemDoesNotExist = false;
        const idProperty = this._idProperty;
        if (typeof subject == "string") {
          id = subject;
          item = this._itemMap.get(id);
          itemDoesNotExist = !item;
          if (item) {
            index2 = this._items.indexOf(item);
          }
        } else if (typeof subject == "number") {
          index2 = subject;
          item = this._items[index2];
          itemDoesNotExist = !item;
          if (item) {
            id = item[idProperty];
          }
        } else {
          item = subject;
          id = item[idProperty];
          index2 = this._items.indexOf(item);
          itemDoesNotExist = index2 == -1 || !this._itemMap.get(id);
        }
        if (itemDoesNotExist) {
          throw new CKEditorError("collection-remove-404", this);
        }
        this._items.splice(index2, 1);
        this._itemMap.delete(id);
        const externalItem = this._bindToInternalToExternalMap.get(item);
        this._bindToInternalToExternalMap.delete(item);
        this._bindToExternalToInternalMap.delete(externalItem);
        this.fire("remove", item, index2);
        return [
          item,
          index2
        ];
      }
      /**
      * Iterable interface.
      */
      [Symbol.iterator]() {
        return this._items[Symbol.iterator]();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function first(iterator) {
      const iteratorItem = iterator.next();
      if (iteratorItem.done) {
        return null;
      }
      return iteratorItem.value;
    }
    class FocusTracker extends (/* @__PURE__ */ DomEmitterMixin(/* @__PURE__ */ ObservableMixin())) {
      constructor() {
        super();
        /**
        * List of registered elements.
        *
        * @internal
        */
        __publicField(this, "_elements", /* @__PURE__ */ new Set());
        /**
        * Event loop timeout.
        */
        __publicField(this, "_nextEventLoopTimeout", null);
        this.set("isFocused", false);
        this.set("focusedElement", null);
      }
      /**
      * Starts tracking the specified element.
      */
      add(element) {
        if (this._elements.has(element)) {
          throw new CKEditorError("focustracker-add-element-already-exist", this);
        }
        this.listenTo(element, "focus", () => this._focus(element), {
          useCapture: true
        });
        this.listenTo(element, "blur", () => this._blur(), {
          useCapture: true
        });
        this._elements.add(element);
      }
      /**
      * Stops tracking the specified element and stops listening on this element.
      */
      remove(element) {
        if (element === this.focusedElement) {
          this._blur();
        }
        if (this._elements.has(element)) {
          this.stopListening(element);
          this._elements.delete(element);
        }
      }
      /**
      * Destroys the focus tracker by:
      * - Disabling all event listeners attached to tracked elements.
      * - Removing all tracked elements that were previously added.
      */
      destroy() {
        this.stopListening();
      }
      /**
      * Stores currently focused element and set {@link #isFocused} as `true`.
      */
      _focus(element) {
        clearTimeout(this._nextEventLoopTimeout);
        this.focusedElement = element;
        this.isFocused = true;
      }
      /**
      * Clears currently focused element and set {@link #isFocused} as `false`.
      * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
      */
      _blur() {
        clearTimeout(this._nextEventLoopTimeout);
        this._nextEventLoopTimeout = setTimeout(() => {
          this.focusedElement = null;
          this.isFocused = false;
        }, 0);
      }
    }
    class KeystrokeHandler {
      /**
      * Creates an instance of the keystroke handler.
      */
      constructor() {
        /**
        * Listener used to listen to events for easier keystroke handler destruction.
        */
        __publicField(this, "_listener");
        this._listener = new (DomEmitterMixin())();
      }
      /**
      * Starts listening for `keydown` events from a given emitter.
      */
      listenTo(emitter) {
        this._listener.listenTo(emitter, "keydown", (evt, keyEvtData) => {
          this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
        });
      }
      /**
      * Registers a handler for the specified keystroke.
      *
      * @param keystroke Keystroke defined in a format accepted by
      * the {@link module:utils/keyboard~parseKeystroke} function.
      * @param callback A function called with the
      * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
      * a helper function to call both `preventDefault()` and `stopPropagation()` on the underlying event.
      * @param options Additional options.
      * @param options.priority The priority of the keystroke
      * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
      * are called in the order they were added.
      */
      set(keystroke, callback, options = {}) {
        const keyCode = parseKeystroke(keystroke);
        const priority = options.priority;
        this._listener.listenTo(this._listener, "_keydown:" + keyCode, (evt, keyEvtData) => {
          callback(keyEvtData, () => {
            keyEvtData.preventDefault();
            keyEvtData.stopPropagation();
            evt.stop();
          });
          evt.return = true;
        }, {
          priority
        });
      }
      /**
      * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
      *
      * @param keyEvtData Key event data.
      * @returns Whether the keystroke was handled.
      */
      press(keyEvtData) {
        return !!this._listener.fire("_keydown:" + getCode(keyEvtData), keyEvtData);
      }
      /**
      * Stops listening to `keydown` events from the given emitter.
      */
      stopListening(emitter) {
        this._listener.stopListening(emitter);
      }
      /**
      * Destroys the keystroke handler.
      */
      destroy() {
        this.stopListening();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function objectToMap(obj) {
      const map = /* @__PURE__ */ new Map();
      for (const key in obj) {
        map.set(key, obj[key]);
      }
      return map;
    }
    function toMap(data) {
      if (isIterable(data)) {
        return new Map(data);
      } else {
        return objectToMap(data);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const BIG_CHUNK_SIZE = 1e4;
    function spliceArray(target, source, start, count2) {
      if (Math.max(source.length, target.length) > BIG_CHUNK_SIZE) {
        return target.slice(0, start).concat(source).concat(target.slice(start + count2, target.length));
      } else {
        const newTarget = Array.from(target);
        newTarget.splice(start, count2, ...source);
        return newTarget;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function delay(func, wait) {
      let timer;
      function delayed(...args) {
        delayed.cancel();
        timer = setTimeout(() => func(...args), wait);
      }
      delayed.cancel = () => {
        clearTimeout(timer);
      };
      return delayed;
    }
    function verifyLicense(token) {
      function oldTokenCheck(token2) {
        if (token2.length >= 40 && token2.length <= 255) {
          return "VALID";
        } else {
          return "INVALID";
        }
      }
      if (!token) {
        return "INVALID";
      }
      let decryptedData = "";
      try {
        decryptedData = atob(token);
      } catch (e) {
        return "INVALID";
      }
      const splittedDecryptedData = decryptedData.split("-");
      const firstElement = splittedDecryptedData[0];
      const secondElement = splittedDecryptedData[1];
      if (!secondElement) {
        return oldTokenCheck(token);
      }
      try {
        atob(secondElement);
      } catch (e) {
        try {
          atob(firstElement);
          if (!atob(firstElement).length) {
            return oldTokenCheck(token);
          }
        } catch (e2) {
          return oldTokenCheck(token);
        }
      }
      if (firstElement.length < 40 || firstElement.length > 255) {
        return "INVALID";
      }
      let decryptedSecondElement = "";
      try {
        atob(firstElement);
        decryptedSecondElement = atob(secondElement);
      } catch (e) {
        return "INVALID";
      }
      if (decryptedSecondElement.length !== 8) {
        return "INVALID";
      }
      const year = Number(decryptedSecondElement.substring(0, 4));
      const monthIndex = Number(decryptedSecondElement.substring(4, 6)) - 1;
      const day = Number(decryptedSecondElement.substring(6, 8));
      const date = new Date(year, monthIndex, day);
      if (date < releaseDate || isNaN(Number(date))) {
        return "INVALID";
      }
      return "VALID";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isCombiningMark(character) {
      return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
    }
    function isHighSurrogateHalf(character) {
      return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
    }
    function isLowSurrogateHalf(character) {
      return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
    }
    function isInsideSurrogatePair(string, offset) {
      return isHighSurrogateHalf(string.charAt(offset - 1)) && isLowSurrogateHalf(string.charAt(offset));
    }
    function isInsideCombinedSymbol(string, offset) {
      return isCombiningMark(string.charAt(offset));
    }
    const EMOJI_PATTERN = /* @__PURE__ */ buildEmojiRegexp();
    function isInsideEmojiSequence(string, offset) {
      const matches = String(string).matchAll(EMOJI_PATTERN);
      return Array.from(matches).some((match) => match.index < offset && offset < match.index + match[0].length);
    }
    function buildEmojiRegexp() {
      const parts = [
        // Emoji Tag Sequence (ETS)
        new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"),
        // Emoji Keycap Sequence
        new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"),
        // Emoji Presentation Sequence
        new RegExp("\\p{Emoji}\\u{FE0F}", "u"),
        // Single-Character Emoji / Emoji Modifier Sequence
        new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")
      ];
      const flagSequence = new RegExp("\\p{Regional_Indicator}{2}", "u").source;
      const emoji = "(?:" + parts.map((part) => part.source).join("|") + ")";
      const sequence = `${flagSequence}|${emoji}(?:‍${emoji})*`;
      return new RegExp(sequence, "ug");
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const documentPlaceholders = /* @__PURE__ */ new WeakMap();
    let hasDisplayedPlaceholderDeprecationWarning = false;
    function enablePlaceholder({ view, element, text: text2, isDirectHost = true, keepOnFocus = false }) {
      const doc = view.document;
      if (!documentPlaceholders.has(doc)) {
        documentPlaceholders.set(doc, /* @__PURE__ */ new Map());
        doc.registerPostFixer((writer) => updateDocumentPlaceholders(doc, writer));
        doc.on("change:isComposing", () => {
          view.change((writer) => updateDocumentPlaceholders(doc, writer));
        }, {
          priority: "high"
        });
      }
      if (element.is("editableElement")) {
        element.on("change:placeholder", (evtInfo, evt, text3) => {
          setPlaceholder(text3);
        });
      }
      if (element.placeholder) {
        setPlaceholder(element.placeholder);
      } else if (text2) {
        setPlaceholder(text2);
      }
      if (text2) {
        showPlaceholderTextDeprecationWarning();
      }
      function setPlaceholder(text3) {
        documentPlaceholders.get(doc).set(element, {
          text: text3,
          isDirectHost,
          keepOnFocus,
          hostElement: isDirectHost ? element : null
        });
        view.change((writer) => updateDocumentPlaceholders(doc, writer));
      }
    }
    function showPlaceholder(writer, element) {
      if (!element.hasClass("ck-placeholder")) {
        writer.addClass("ck-placeholder", element);
        return true;
      }
      return false;
    }
    function hidePlaceholder(writer, element) {
      if (element.hasClass("ck-placeholder")) {
        writer.removeClass("ck-placeholder", element);
        return true;
      }
      return false;
    }
    function needsPlaceholder(element, keepOnFocus) {
      if (!element.isAttached()) {
        return false;
      }
      const hasContent = Array.from(element.getChildren()).some((element2) => !element2.is("uiElement"));
      if (hasContent) {
        return false;
      }
      const doc = element.document;
      const viewSelection = doc.selection;
      const selectionAnchor = viewSelection.anchor;
      if (doc.isComposing && selectionAnchor && selectionAnchor.parent === element) {
        return false;
      }
      if (keepOnFocus) {
        return true;
      }
      if (!doc.isFocused) {
        return true;
      }
      return !!selectionAnchor && selectionAnchor.parent !== element;
    }
    function updateDocumentPlaceholders(doc, writer) {
      const placeholders = documentPlaceholders.get(doc);
      const directHostElements = [];
      let wasViewModified = false;
      for (const [element, config] of placeholders) {
        if (config.isDirectHost) {
          directHostElements.push(element);
          if (updatePlaceholder(writer, element, config)) {
            wasViewModified = true;
          }
        }
      }
      for (const [element, config] of placeholders) {
        if (config.isDirectHost) {
          continue;
        }
        const hostElement = getChildPlaceholderHostSubstitute(element);
        if (!hostElement) {
          continue;
        }
        if (directHostElements.includes(hostElement)) {
          continue;
        }
        config.hostElement = hostElement;
        if (updatePlaceholder(writer, element, config)) {
          wasViewModified = true;
        }
      }
      return wasViewModified;
    }
    function updatePlaceholder(writer, element, config) {
      const { text: text2, isDirectHost, hostElement } = config;
      let wasViewModified = false;
      if (hostElement.getAttribute("data-placeholder") !== text2) {
        writer.setAttribute("data-placeholder", text2, hostElement);
        wasViewModified = true;
      }
      const isOnlyChild = isDirectHost || element.childCount == 1;
      if (isOnlyChild && needsPlaceholder(hostElement, config.keepOnFocus)) {
        if (showPlaceholder(writer, hostElement)) {
          wasViewModified = true;
        }
      } else if (hidePlaceholder(writer, hostElement)) {
        wasViewModified = true;
      }
      return wasViewModified;
    }
    function getChildPlaceholderHostSubstitute(parent2) {
      if (parent2.childCount) {
        const firstChild = parent2.getChild(0);
        if (firstChild.is("element") && !firstChild.is("uiElement") && !firstChild.is("attributeElement")) {
          return firstChild;
        }
      }
      return null;
    }
    function showPlaceholderTextDeprecationWarning() {
      if (!hasDisplayedPlaceholderDeprecationWarning) {
        logWarning("enableplaceholder-deprecated-text-option");
      }
      hasDisplayedPlaceholderDeprecationWarning = true;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    let TypeCheckable$1 = class TypeCheckable {
      /* istanbul ignore next -- @preserve */
      is() {
        throw new Error("is() method is abstract");
      }
    };
    let Node$2 = class Node extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      /**
      * Creates a tree view node.
      *
      * @param document The document instance to which this node belongs.
      */
      constructor(document2) {
        super();
        /**
        * The document instance to which this node belongs.
        */
        __publicField(this, "document");
        /**
        * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.
        */
        __publicField(this, "parent");
        this.document = document2;
        this.parent = null;
      }
      /**
      * Index of the node in the parent element or null if the node has no parent.
      *
      * Accessing this property throws an error if this node's parent element does not contain it.
      * This means that view tree got broken.
      */
      get index() {
        let pos;
        if (!this.parent) {
          return null;
        }
        if ((pos = this.parent.getChildIndex(this)) == -1) {
          throw new CKEditorError("view-node-not-found-in-parent", this);
        }
        return pos;
      }
      /**
      * Node's next sibling, or `null` if it is the last child.
      */
      get nextSibling() {
        const index2 = this.index;
        return index2 !== null && this.parent.getChild(index2 + 1) || null;
      }
      /**
      * Node's previous sibling, or `null` if it is the first child.
      */
      get previousSibling() {
        const index2 = this.index;
        return index2 !== null && this.parent.getChild(index2 - 1) || null;
      }
      /**
      * Top-most ancestor of the node. If the node has no parent it is the root itself.
      */
      get root() {
        let root2 = this;
        while (root2.parent) {
          root2 = root2.parent;
        }
        return root2;
      }
      /**
      * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
      */
      isAttached() {
        return this.root.is("rootElement");
      }
      /**
      * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
      * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
      *
      * ```ts
      * const abc = downcastWriter.createText( 'abc' );
      * const foo = downcastWriter.createText( 'foo' );
      * const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
      * const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
      * const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
      * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
      * h1.getPath(); // Returns [ 0 ].
      * div.getPath(); // Returns [].
      * ```
      *
      * @returns The path.
      */
      getPath() {
        const path = [];
        let node = this;
        while (node.parent) {
          path.unshift(node.index);
          node = node.parent;
        }
        return path;
      }
      /**
      * Returns ancestors array of this node.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true` this node will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
      * otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
      /**
      * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
      * which is a common ancestor of both nodes.
      *
      * @param node The second node.
      * @param options Options object.
      * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
      * Which means that if e.g. node A is inside B, then their common ancestor will be B.
      */
      getCommonAncestor(node, options = {}) {
        const ancestorsA = this.getAncestors(options);
        const ancestorsB = node.getAncestors(options);
        let i = 0;
        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
          i++;
        }
        return i === 0 ? null : ancestorsA[i - 1];
      }
      /**
      * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isBefore(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        const thisPath = this.getPath();
        const nodePath = node.getPath();
        const result = compareArrays(thisPath, nodePath);
        switch (result) {
          case "prefix":
            return true;
          case "extension":
            return false;
          default:
            return thisPath[result] < nodePath[result];
        }
      }
      /**
      * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isAfter(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        return !this.isBefore(node);
      }
      /**
      * Removes node from parent.
      *
      * @internal
      */
      _remove() {
        this.parent._removeChildren(this.index);
      }
      /**
      * @internal
      * @param type Type of the change.
      * @param node Changed node.
      * @fires change
      */
      _fireChange(type, node) {
        this.fire(`change:${type}`, node);
        if (this.parent) {
          this.parent._fireChange(type, node);
        }
      }
      /**
      * Custom toJSON method to solve child-parent circular dependencies.
      *
      * @returns Clone of this object with the parent property removed.
      */
      toJSON() {
        const json = clone$1(this);
        delete json.parent;
        return json;
      }
    };
    Node$2.prototype.is = function(type) {
      return type === "node" || type === "view:node";
    };
    let Text$1 = class Text2 extends Node$2 {
      /**
      * Creates a tree view text node.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createText
      * @internal
      * @param document The document instance to which this text node belongs.
      * @param data The text's data.
      */
      constructor(document2, data) {
        super(document2);
        /**
        * The text content.
        *
        * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.
        */
        __publicField(this, "_textData");
        this._textData = data;
      }
      /**
      * The text content.
      */
      get data() {
        return this._textData;
      }
      /**
      * The `_data` property is controlled by a getter and a setter.
      *
      * The getter is required when using the addition assignment operator on protected property:
      *
      * ```ts
      * const foo = downcastWriter.createText( 'foo' );
      * const bar = downcastWriter.createText( 'bar' );
      *
      * foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
      * console.log( foo.data ); // prints: 'foobar'
      * ```
      *
      * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
      *
      * The setter sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
      *
      * @internal
      */
      get _data() {
        return this.data;
      }
      set _data(data) {
        this._fireChange("text", this);
        this._textData = data;
      }
      /**
      * Checks if this text node is similar to other text node.
      * Both nodes should have the same data to be considered as similar.
      *
      * @param otherNode Node to check if it is same as this node.
      */
      isSimilar(otherNode) {
        if (!(otherNode instanceof Text2)) {
          return false;
        }
        return this === otherNode || this.data === otherNode.data;
      }
      /**
      * Clones this node.
      *
      * @internal
      * @returns Text node that is a clone of this node.
      */
      _clone() {
        return new Text2(this.document, this.data);
      }
    };
    Text$1.prototype.is = function(type) {
      return type === "$text" || type === "view:$text" || // This are legacy values kept for backward compatibility.
      type === "text" || type === "view:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === "node" || type === "view:node";
    };
    let TextProxy$1 = class TextProxy extends TypeCheckable$1 {
      /**
      * Creates a text proxy.
      *
      * @internal
      * @param textNode Text node which part is represented by this text proxy.
      * @param offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
      * from which the text proxy starts.
      * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
      * @constructor
      */
      constructor(textNode, offsetInText, length) {
        super();
        /**
        * Reference to the {@link module:engine/view/text~Text} element which TextProxy is a substring.
        */
        __publicField(this, "textNode");
        /**
        * Text data represented by this text proxy.
        */
        __publicField(this, "data");
        /**
        * Offset in the `textNode` where this `TextProxy` instance starts.
        */
        __publicField(this, "offsetInText");
        this.textNode = textNode;
        if (offsetInText < 0 || offsetInText > textNode.data.length) {
          throw new CKEditorError("view-textproxy-wrong-offsetintext", this);
        }
        if (length < 0 || offsetInText + length > textNode.data.length) {
          throw new CKEditorError("view-textproxy-wrong-length", this);
        }
        this.data = textNode.data.substring(offsetInText, offsetInText + length);
        this.offsetInText = offsetInText;
      }
      /**
      * Offset size of this node.
      */
      get offsetSize() {
        return this.data.length;
      }
      /**
      * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
      * (`true`) or the whole text node (`false`).
      *
      * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
      * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
      * text node size.
      */
      get isPartial() {
        return this.data.length !== this.textNode.data.length;
      }
      /**
      * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
      */
      get parent() {
        return this.textNode.parent;
      }
      /**
      * Root of this text proxy, which is same as root of text node represented by this text proxy.
      */
      get root() {
        return this.textNode.root;
      }
      /**
      * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
      */
      get document() {
        return this.textNode.document;
      }
      /**
      * Returns ancestors array of this text proxy.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true`, textNode will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to
      * root element, otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this.textNode : this.parent;
        while (parent2 !== null) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
    };
    TextProxy$1.prototype.is = function(type) {
      return type === "$textProxy" || type === "view:$textProxy" || // This are legacy values kept for backward compatibility.
      type === "textProxy" || type === "view:textProxy";
    };
    class Matcher {
      /**
      * Creates new instance of Matcher.
      *
      * @param pattern Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for more information.
      */
      constructor(...pattern) {
        __publicField(this, "_patterns", []);
        this.add(...pattern);
      }
      /**
      * Adds pattern or patterns to matcher instance.
      *
      * ```ts
      * // String.
      * matcher.add( 'div' );
      *
      * // Regular expression.
      * matcher.add( /^\w/ );
      *
      * // Single class.
      * matcher.add( {
      * 	classes: 'foobar'
      * } );
      * ```
      *
      * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
      *
      * Multiple patterns can be added in one call:
      *
      * ```ts
      * matcher.add( 'div', { classes: 'foobar' } );
      * ```
      *
      * @param pattern Object describing pattern details. If string or regular expression
      * is provided it will be used to match element's name. Pattern can be also provided in a form
      * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
      * Function's return value will be stored under `match` key of the object returned from
      * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
      */
      add(...pattern) {
        for (let item of pattern) {
          if (typeof item == "string" || item instanceof RegExp) {
            item = {
              name: item
            };
          }
          this._patterns.push(item);
        }
      }
      /**
      * Matches elements for currently stored patterns. Returns match information about first found
      * {@link module:engine/view/element~Element element}, otherwise returns `null`.
      *
      * Example of returned object:
      *
      * ```ts
      * {
      * 	element: <instance of found element>,
      * 	pattern: <pattern used to match found element>,
      * 	match: {
      * 		name: true,
      * 		attributes: [ 'title', 'href' ],
      * 		classes: [ 'foo' ],
      * 		styles: [ 'color', 'position' ]
      * 	}
      * }
      * ```
      *
      * @see module:engine/view/matcher~Matcher#add
      * @see module:engine/view/matcher~Matcher#matchAll
      * @param element View element to match against stored patterns.
      */
      match(...element) {
        for (const singleElement of element) {
          for (const pattern of this._patterns) {
            const match = isElementMatching(singleElement, pattern);
            if (match) {
              return {
                element: singleElement,
                pattern,
                match
              };
            }
          }
        }
        return null;
      }
      /**
      * Matches elements for currently stored patterns. Returns array of match information with all found
      * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
      *
      * @see module:engine/view/matcher~Matcher#add
      * @see module:engine/view/matcher~Matcher#match
      * @param element View element to match against stored patterns.
      * @returns Array with match information about found elements or `null`. For more information
      * see {@link module:engine/view/matcher~Matcher#match match method} description.
      */
      matchAll(...element) {
        const results = [];
        for (const singleElement of element) {
          for (const pattern of this._patterns) {
            const match = isElementMatching(singleElement, pattern);
            if (match) {
              results.push({
                element: singleElement,
                pattern,
                match
              });
            }
          }
        }
        return results.length > 0 ? results : null;
      }
      /**
      * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
      * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
      *
      * @returns Element name trying to match.
      */
      getElementName() {
        if (this._patterns.length !== 1) {
          return null;
        }
        const pattern = this._patterns[0];
        const name = pattern.name;
        return typeof pattern != "function" && name && !(name instanceof RegExp) ? name : null;
      }
    }
    function isElementMatching(element, pattern) {
      if (typeof pattern == "function") {
        return pattern(element);
      }
      const match = {};
      if (pattern.name) {
        match.name = matchName(pattern.name, element.name);
        if (!match.name) {
          return null;
        }
      }
      if (pattern.attributes) {
        match.attributes = matchAttributes(pattern.attributes, element);
        if (!match.attributes) {
          return null;
        }
      }
      if (pattern.classes) {
        match.classes = matchClasses(pattern.classes, element);
        if (!match.classes) {
          return null;
        }
      }
      if (pattern.styles) {
        match.styles = matchStyles(pattern.styles, element);
        if (!match.styles) {
          return null;
        }
      }
      return match;
    }
    function matchName(pattern, name) {
      if (pattern instanceof RegExp) {
        return !!name.match(pattern);
      }
      return pattern === name;
    }
    function matchPatterns(patterns, keys2, valueGetter) {
      const normalizedPatterns = normalizePatterns(patterns);
      const normalizedItems = Array.from(keys2);
      const match = [];
      normalizedPatterns.forEach(([patternKey, patternValue]) => {
        normalizedItems.forEach((itemKey) => {
          if (isKeyMatched(patternKey, itemKey) && isValueMatched(patternValue, itemKey, valueGetter)) {
            match.push(itemKey);
          }
        });
      });
      if (!normalizedPatterns.length || match.length < normalizedPatterns.length) {
        return void 0;
      }
      return match;
    }
    function normalizePatterns(patterns) {
      if (Array.isArray(patterns)) {
        return patterns.map((pattern) => {
          if (isPlainObject(pattern)) {
            if (pattern.key === void 0 || pattern.value === void 0) {
              logWarning("matcher-pattern-missing-key-or-value", pattern);
            }
            return [
              pattern.key,
              pattern.value
            ];
          }
          return [
            pattern,
            true
          ];
        });
      }
      if (isPlainObject(patterns)) {
        return Object.entries(patterns);
      }
      return [
        [
          patterns,
          true
        ]
      ];
    }
    function isKeyMatched(patternKey, itemKey) {
      return patternKey === true || patternKey === itemKey || patternKey instanceof RegExp && itemKey.match(patternKey);
    }
    function isValueMatched(patternValue, itemKey, valueGetter) {
      if (patternValue === true) {
        return true;
      }
      const itemValue = valueGetter(itemKey);
      return patternValue === itemValue || patternValue instanceof RegExp && !!String(itemValue).match(patternValue);
    }
    function matchAttributes(patterns, element) {
      const attributeKeys = new Set(element.getAttributeKeys());
      if (isPlainObject(patterns)) {
        if (patterns.style !== void 0) {
          logWarning("matcher-pattern-deprecated-attributes-style-key", patterns);
        }
        if (patterns.class !== void 0) {
          logWarning("matcher-pattern-deprecated-attributes-class-key", patterns);
        }
      } else {
        attributeKeys.delete("style");
        attributeKeys.delete("class");
      }
      return matchPatterns(patterns, attributeKeys, (key) => element.getAttribute(key));
    }
    function matchClasses(patterns, element) {
      return matchPatterns(
        patterns,
        element.getClassNames(),
        /* istanbul ignore next -- @preserve */
        () => {
        }
      );
    }
    function matchStyles(patterns, element) {
      return matchPatterns(patterns, element.getStyleNames(true), (key) => element.getStyle(key));
    }
    class StylesMap {
      /**
      * Creates Styles instance.
      */
      constructor(styleProcessor) {
        /**
        * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and
        * value access model using lodash's get, set, unset, etc methods.
        *
        * When no style processor rules are defined it acts as simple key-value storage.
        */
        __publicField(this, "_styles");
        /**
        * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.
        */
        __publicField(this, "_styleProcessor");
        this._styles = {};
        this._styleProcessor = styleProcessor;
      }
      /**
      * Returns true if style map has no styles set.
      */
      get isEmpty() {
        const entries = Object.entries(this._styles);
        return !entries.length;
      }
      /**
      * Number of styles defined.
      */
      get size() {
        if (this.isEmpty) {
          return 0;
        }
        return this.getStyleNames().length;
      }
      /**
      * Set styles map to a new value.
      *
      * ```ts
      * styles.setTo( 'border:1px solid blue;margin-top:1px;' );
      * ```
      */
      setTo(inlineStyle) {
        this.clear();
        const parsedStyles = parseInlineStyles(inlineStyle);
        for (const [key, value] of parsedStyles) {
          this._styleProcessor.toNormalizedForm(key, value, this._styles);
        }
      }
      /**
      * Checks if a given style is set.
      *
      * ```ts
      * styles.setTo( 'margin-left:1px;' );
      *
      * styles.has( 'margin-left' );    // -> true
      * styles.has( 'padding' );        // -> false
      * ```
      *
      * **Note**: This check supports normalized style names.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * styles.setTo( 'margin:2px;' );
      *
      * styles.has( 'margin' );         // -> true
      * styles.has( 'margin-top' );     // -> true
      * styles.has( 'margin-left' );    // -> true
      *
      * styles.remove( 'margin-top' );
      *
      * styles.has( 'margin' );         // -> false
      * styles.has( 'margin-top' );     // -> false
      * styles.has( 'margin-left' );    // -> true
      * ```
      *
      * @param name Style name.
      */
      has(name) {
        if (this.isEmpty) {
          return false;
        }
        const styles = this._styleProcessor.getReducedForm(name, this._styles);
        const propertyDescriptor = styles.find(([property2]) => property2 === name);
        return Array.isArray(propertyDescriptor);
      }
      set(nameOrObject, valueOrObject) {
        if (isObject$1(nameOrObject)) {
          for (const [key, value] of Object.entries(nameOrObject)) {
            this._styleProcessor.toNormalizedForm(key, value, this._styles);
          }
        } else {
          this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
        }
      }
      /**
      * Removes given style.
      *
      * ```ts
      * styles.setTo( 'background:#f00;margin-right:2px;' );
      *
      * styles.remove( 'background' );
      *
      * styles.toString();   // -> 'margin-right:2px;'
      * ```
      *
      * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
      * enabled style processor rules} to normalize passed values.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * styles.setTo( 'margin:1px' );
      *
      * styles.remove( 'margin-top' );
      * styles.remove( 'margin-right' );
      *
      * styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
      * ```
      *
      * @param name Style name.
      */
      remove(name) {
        const path = toPath(name);
        unset(this._styles, path);
        delete this._styles[name];
        this._cleanEmptyObjectsOnPath(path);
      }
      /**
      * Returns a normalized style object or a single value.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * const styles = new Styles();
      * styles.setTo( 'margin:1px 2px 3em;' );
      *
      * styles.getNormalized( 'margin' );
      * // will log:
      * // {
      * //     top: '1px',
      * //     right: '2px',
      * //     bottom: '3em',
      * //     left: '2px'     // normalized value from margin shorthand
      * // }
      *
      * styles.getNormalized( 'margin-left' ); // -> '2px'
      * ```
      *
      * **Note**: This method will only return normalized styles if a style processor was defined.
      *
      * @param name Style name.
      */
      getNormalized(name) {
        return this._styleProcessor.getNormalized(name, this._styles);
      }
      /**
      * Returns a normalized style string. Styles are sorted by name.
      *
      * ```ts
      * styles.set( 'margin' , '1px' );
      * styles.set( 'background', '#f00' );
      *
      * styles.toString(); // -> 'background:#f00;margin:1px;'
      * ```
      *
      * **Note**: This method supports normalized styles if defined.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * styles.set( 'margin' , '1px' );
      * styles.set( 'background', '#f00' );
      * styles.remove( 'margin-top' );
      * styles.remove( 'margin-right' );
      *
      * styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
      * ```
      */
      toString() {
        if (this.isEmpty) {
          return "";
        }
        return this.getStylesEntries().map((arr) => arr.join(":")).sort().join(";") + ";";
      }
      /**
      * Returns property as a value string or undefined if property is not set.
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      * styles.set( 'margin-bottom', '3em' );
      *
      * styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
      * ```
      *
      * Note, however, that all sub-values must be set for the longhand property name to return a value:
      *
      * ```ts
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      * styles.remove( 'margin-bottom' );
      *
      * styles.getAsString( 'margin' ); // -> undefined
      * ```
      *
      * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
      * Instead, you should use:
      *
      * ```ts
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      * styles.remove( 'margin-bottom' );
      *
      * for ( const styleName of styles.getStyleNames() ) {
      * 	console.log( styleName, styles.getAsString( styleName ) );
      * }
      * // 'margin-top', '1px'
      * // 'margin-right', '1px'
      * // 'margin-left', '1px'
      * ```
      *
      * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
      * the currently set style values. So, if all the 4 margin values would be set
      * the for-of loop above would yield only `'margin'`, `'1px'`:
      *
      * ```ts
      * const styles = new Styles();
      * styles.setTo( 'margin:1px;' );
      *
      * for ( const styleName of styles.getStyleNames() ) {
      * 	console.log( styleName, styles.getAsString( styleName ) );
      * }
      * // 'margin', '1px'
      * ```
      *
      * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
      */
      getAsString(propertyName) {
        if (this.isEmpty) {
          return;
        }
        if (this._styles[propertyName] && !isObject$1(this._styles[propertyName])) {
          return this._styles[propertyName];
        }
        const styles = this._styleProcessor.getReducedForm(propertyName, this._styles);
        const propertyDescriptor = styles.find(([property2]) => property2 === propertyName);
        if (Array.isArray(propertyDescriptor)) {
          return propertyDescriptor[1];
        }
      }
      /**
      * Returns all style properties names as they would appear when using {@link #toString `#toString()`}.
      *
      * When `expand` is set to true and there's a shorthand style property set, it will also return all equivalent styles:
      *
      * ```ts
      * stylesMap.setTo( 'margin: 1em' )
      * ```
      *
      * will be expanded to:
      *
      * ```ts
      * [ 'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ]
      * ```
      *
      * @param expand Expand shorthand style properties and all return equivalent style representations.
      */
      getStyleNames(expand = false) {
        if (this.isEmpty) {
          return [];
        }
        if (expand) {
          return this._styleProcessor.getStyleNames(this._styles);
        }
        const entries = this.getStylesEntries();
        return entries.map(([key]) => key);
      }
      /**
      * Removes all styles.
      */
      clear() {
        this._styles = {};
      }
      /**
      * Returns normalized styles entries for further processing.
      */
      getStylesEntries() {
        const parsed = [];
        const keys2 = Object.keys(this._styles);
        for (const key of keys2) {
          parsed.push(...this._styleProcessor.getReducedForm(key, this._styles));
        }
        return parsed;
      }
      /**
      * Removes empty objects upon removing an entry from internal object.
      */
      _cleanEmptyObjectsOnPath(path) {
        const pathParts = path.split(".");
        const isChildPath = pathParts.length > 1;
        if (!isChildPath) {
          return;
        }
        const parentPath = pathParts.splice(0, pathParts.length - 1).join(".");
        const parentObject = get(this._styles, parentPath);
        if (!parentObject) {
          return;
        }
        const isParentEmpty = !Object.keys(parentObject).length;
        if (isParentEmpty) {
          this.remove(parentPath);
        }
      }
    }
    class StylesProcessor {
      /**
      * Creates StylesProcessor instance.
      *
      * @internal
      */
      constructor() {
        __publicField(this, "_normalizers");
        __publicField(this, "_extractors");
        __publicField(this, "_reducers");
        __publicField(this, "_consumables");
        this._normalizers = /* @__PURE__ */ new Map();
        this._extractors = /* @__PURE__ */ new Map();
        this._reducers = /* @__PURE__ */ new Map();
        this._consumables = /* @__PURE__ */ new Map();
      }
      /**
      * Parse style string value to a normalized object and appends it to styles object.
      *
      * ```ts
      * const styles = {};
      *
      * stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
      *
      * // styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
      * ```
      *
      * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
      *
      * @param name Name of style property.
      * @param propertyValue Value of style property.
      * @param styles Object holding normalized styles.
      */
      toNormalizedForm(name, propertyValue, styles) {
        if (isObject$1(propertyValue)) {
          appendStyleValue(styles, toPath(name), propertyValue);
          return;
        }
        if (this._normalizers.has(name)) {
          const normalizer = this._normalizers.get(name);
          const { path, value } = normalizer(propertyValue);
          appendStyleValue(styles, path, value);
        } else {
          appendStyleValue(styles, name, propertyValue);
        }
      }
      /**
      * Returns a normalized version of a style property.
      *
      * ```ts
      * const styles = {
      * 	margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
      * 	background: { color: '#f00' }
      * };
      *
      * stylesProcessor.getNormalized( 'background' );
      * // will return: { color: '#f00' }
      *
      * stylesProcessor.getNormalized( 'margin-top' );
      * // will return: '1px'
      * ```
      *
      * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
      *
      * @param name Name of style property.
      * @param styles Object holding normalized styles.
      */
      getNormalized(name, styles) {
        if (!name) {
          return merge$1({}, styles);
        }
        if (styles[name] !== void 0) {
          return styles[name];
        }
        if (this._extractors.has(name)) {
          const extractor = this._extractors.get(name);
          if (typeof extractor === "string") {
            return get(styles, extractor);
          }
          const value = extractor(name, styles);
          if (value) {
            return value;
          }
        }
        return get(styles, toPath(name));
      }
      /**
      * Returns a reduced form of style property form normalized object.
      *
      * For default margin reducer, the below code:
      *
      * ```ts
      * stylesProcessor.getReducedForm( 'margin', {
      * 	margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
      * } );
      * ```
      *
      * will return:
      *
      * ```ts
      * [
      * 	[ 'margin', '1px 1px 2px' ]
      * ]
      * ```
      *
      * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
      *
      * ```ts
      * [
      * 	[ 'margin-top', '1px' ],
      * 	[ 'margin-right', '1px' ],
      * 	[ 'margin-bottom', '2px' ]
      * 	// the 'left' value is missing - cannot use 'margin' shorthand.
      * ]
      * ```
      *
      * **Note**: To define reducer callbacks use {@link #setReducer}.
      *
      * @param name Name of style property.
      */
      getReducedForm(name, styles) {
        const normalizedValue = this.getNormalized(name, styles);
        if (normalizedValue === void 0) {
          return [];
        }
        if (this._reducers.has(name)) {
          const reducer = this._reducers.get(name);
          return reducer(normalizedValue);
        }
        return [
          [
            name,
            normalizedValue
          ]
        ];
      }
      /**
      * Return all style properties. Also expand shorthand properties (e.g. `margin`, `background`) if respective extractor is available.
      *
      * @param styles Object holding normalized styles.
      */
      getStyleNames(styles) {
        const expandedStyleNames = Array.from(this._consumables.keys()).filter((name) => {
          const style = this.getNormalized(name, styles);
          if (style && typeof style == "object") {
            return Object.keys(style).length;
          }
          return style;
        });
        const styleNamesKeysSet = /* @__PURE__ */ new Set([
          ...expandedStyleNames,
          ...Object.keys(styles)
        ]);
        return Array.from(styleNamesKeysSet);
      }
      /**
      * Returns related style names.
      *
      * ```ts
      * stylesProcessor.getRelatedStyles( 'margin' );
      * // will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
      *
      * stylesProcessor.getRelatedStyles( 'margin-top' );
      * // will return: [ 'margin' ];
      * ```
      *
      * **Note**: To define new style relations load an existing style processor or use
      * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
      */
      getRelatedStyles(name) {
        return this._consumables.get(name) || [];
      }
      /**
      * Adds a normalizer method for a style property.
      *
      * A normalizer returns describing how the value should be normalized.
      *
      * For instance 'margin' style is a shorthand for four margin values:
      *
      * - 'margin-top'
      * - 'margin-right'
      * - 'margin-bottom'
      * - 'margin-left'
      *
      * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
      * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
      *
      * A normalizer should parse various margin notations as a single object:
      *
      * ```ts
      * const styles = {
      * 	margin: {
      * 		top: '1px',
      * 		right: '2em',
      * 		bottom: '1px',
      * 		left: '2em'
      * 	}
      * };
      * ```
      *
      * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
      *
      * ```ts
      * const returnValue = {
      * 	path: 'margin',
      * 	value: {
      * 		top: '1px',
      * 		right: '2em',
      * 		bottom: '1px',
      * 		left: '2em'
      * 	}
      * };
      * ```
      *
      * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
      * is an example for 'margin-top' style property normalizer:
      *
      * ```ts
      * stylesProcessor.setNormalizer( 'margin-top', valueString => {
      * 	return {
      * 		path: 'margin.top',
      * 		value: valueString
      * 	}
      * } );
      * ```
      */
      setNormalizer(name, callback) {
        this._normalizers.set(name, callback);
      }
      /**
      * Adds a extractor callback for a style property.
      *
      * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
      *
      * ```ts
      * const styles = {
      * 	margin: {
      * 		top: 'value'
      * 	}
      * }
      * ```
      *
      * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
      * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
      * shorthands. The default border styles processors stores styles as:
      *
      * ```ts
      * const styles = {
      * 	border: {
      * 		style: {
      * 			top: 'solid'
      * 		}
      * 	}
      * }
      * ```
      *
      * as it is better to modify border style independently from other values. On the other part the output of the border might be
      * desired as `border-top`, `border-left`, etc notation.
      *
      * In the above example an extractor should return a side border value that combines style, color and width:
      *
      * ```ts
      * styleProcessor.setExtractor( 'border-top', styles => {
      * 	return {
      * 		color: styles.border.color.top,
      * 		style: styles.border.style.top,
      * 		width: styles.border.width.top
      * 	}
      * } );
      * ```
      *
      * @param callbackOrPath Callback that return a requested value or path string for single values.
      */
      setExtractor(name, callbackOrPath) {
        this._extractors.set(name, callbackOrPath);
      }
      /**
      * Adds a reducer callback for a style property.
      *
      * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
      * by default the direct value from style path is taken.
      *
      * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
      * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
      *
      * ```ts
      * const marginShortHandTuple = [
      * 	[ 'margin', '1px 1px 2px' ]
      * ];
      * ```
      *
      * or a longhand tuples for defined values:
      *
      * ```ts
      * // Considering margin.bottom and margin.left are undefined.
      * const marginLonghandsTuples = [
      * 	[ 'margin-top', '1px' ],
      * 	[ 'margin-right', '1px' ]
      * ];
      * ```
      *
      * A reducer obtains a normalized style value:
      *
      * ```ts
      * // Simplified reducer that always outputs 4 values which are always present:
      * stylesProcessor.setReducer( 'margin', margin => {
      * 	return [
      * 		[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
      * 	]
      * } );
      * ```
      */
      setReducer(name, callback) {
        this._reducers.set(name, callback);
      }
      /**
      * Defines a style shorthand relation to other style notations.
      *
      * ```ts
      * stylesProcessor.setStyleRelation( 'margin', [
      * 	'margin-top',
      * 	'margin-right',
      * 	'margin-bottom',
      * 	'margin-left'
      * ] );
      * ```
      *
      * This enables expanding of style names for shorthands. For instance, if defined,
      * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
      * for long-hand margin style notation alongside the `'margin'` item.
      *
      * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
      * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
      * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
      * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
      */
      setStyleRelation(shorthandName, styleNames) {
        this._mapStyleNames(shorthandName, styleNames);
        for (const alsoName of styleNames) {
          this._mapStyleNames(alsoName, [
            shorthandName
          ]);
        }
      }
      /**
      * Set two-way binding of style names.
      */
      _mapStyleNames(name, styleNames) {
        if (!this._consumables.has(name)) {
          this._consumables.set(name, []);
        }
        this._consumables.get(name).push(...styleNames);
      }
    }
    function parseInlineStyles(stylesString) {
      let quoteType = null;
      let propertyNameStart = 0;
      let propertyValueStart = 0;
      let propertyName = null;
      const stylesMap = /* @__PURE__ */ new Map();
      if (stylesString === "") {
        return stylesMap;
      }
      if (stylesString.charAt(stylesString.length - 1) != ";") {
        stylesString = stylesString + ";";
      }
      for (let i = 0; i < stylesString.length; i++) {
        const char = stylesString.charAt(i);
        if (quoteType === null) {
          switch (char) {
            case ":":
              if (!propertyName) {
                propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart);
                propertyValueStart = i + 1;
              }
              break;
            case '"':
            case "'":
              quoteType = char;
              break;
            case ";": {
              const propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);
              if (propertyName) {
                stylesMap.set(propertyName.trim(), propertyValue.trim());
              }
              propertyName = null;
              propertyNameStart = i + 1;
              break;
            }
          }
        } else if (char === quoteType) {
          quoteType = null;
        }
      }
      return stylesMap;
    }
    function toPath(name) {
      return name.replace("-", ".");
    }
    function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
      let valueToSet = valueOrObject;
      if (isObject$1(valueOrObject)) {
        valueToSet = merge$1({}, get(stylesObject, nameOrPath), valueOrObject);
      }
      set(stylesObject, nameOrPath, valueToSet);
    }
    let Element$1 = class Element2 extends Node$2 {
      /**
      * Creates a view element.
      *
      * Attributes can be passed in various formats:
      *
      * ```ts
      * new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
      * new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
      * new Element( viewDocument, 'div', mapOfAttributes ); // map
      * ```
      *
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2);
        /**
        * Name of the element.
        */
        __publicField(this, "name");
        /**
        * A list of attribute names that should be rendered in the editing pipeline even though filtering mechanisms
        * implemented in the {@link module:engine/view/domconverter~DomConverter} (for instance,
        * {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute}) would filter them out.
        *
        * These attributes can be specified as an option when the element is created by
        * the {@link module:engine/view/downcastwriter~DowncastWriter}. To check whether an unsafe an attribute should
        * be permitted, use the {@link #shouldRenderUnsafeAttribute} method.
        *
        * @internal
        */
        __publicField(this, "_unsafeAttributesToRender", []);
        /**
        * Map of attributes, where attributes names are keys and attributes values are values.
        */
        __publicField(this, "_attrs");
        /**
        * Array of child nodes.
        */
        __publicField(this, "_children");
        /**
        * Set of classes associated with element instance.
        */
        __publicField(this, "_classes");
        /**
        * Normalized styles.
        */
        __publicField(this, "_styles");
        /**
        * Map of custom properties.
        * Custom properties can be added to element instance, will be cloned but not rendered into DOM.
        */
        __publicField(this, "_customProperties", /* @__PURE__ */ new Map());
        this.name = name;
        this._attrs = parseAttributes(attrs);
        this._children = [];
        if (children) {
          this._insertChild(0, children);
        }
        this._classes = /* @__PURE__ */ new Set();
        if (this._attrs.has("class")) {
          const classString = this._attrs.get("class");
          parseClasses(this._classes, classString);
          this._attrs.delete("class");
        }
        this._styles = new StylesMap(this.document.stylesProcessor);
        if (this._attrs.has("style")) {
          this._styles.setTo(this._attrs.get("style"));
          this._attrs.delete("style");
        }
      }
      /**
      * Number of element's children.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Is `true` if there are no nodes inside this element, `false` otherwise.
      */
      get isEmpty() {
        return this._children.length === 0;
      }
      /**
      * Gets child at the given index.
      *
      * @param index Index of child.
      * @returns Child node.
      */
      getChild(index2) {
        return this._children[index2];
      }
      /**
      * Gets index of the given child node. Returns `-1` if child node is not found.
      *
      * @param node Child node.
      * @returns Index of the child node.
      */
      getChildIndex(node) {
        return this._children.indexOf(node);
      }
      /**
      * Gets child nodes iterator.
      *
      * @returns Child nodes iterator.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
      *
      * @returns Keys for attributes.
      */
      *getAttributeKeys() {
        if (this._classes.size > 0) {
          yield "class";
        }
        if (!this._styles.isEmpty) {
          yield "style";
        }
        yield* this._attrs.keys();
      }
      /**
      * Returns iterator that iterates over this element's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      *getAttributes() {
        yield* this._attrs.entries();
        if (this._classes.size > 0) {
          yield [
            "class",
            this.getAttribute("class")
          ];
        }
        if (!this._styles.isEmpty) {
          yield [
            "style",
            this.getAttribute("style")
          ];
        }
      }
      /**
      * Gets attribute by key. If attribute is not present - returns undefined.
      *
      * @param key Attribute key.
      * @returns Attribute value.
      */
      getAttribute(key) {
        if (key == "class") {
          if (this._classes.size > 0) {
            return [
              ...this._classes
            ].join(" ");
          }
          return void 0;
        }
        if (key == "style") {
          const inlineStyle = this._styles.toString();
          return inlineStyle == "" ? void 0 : inlineStyle;
        }
        return this._attrs.get(key);
      }
      /**
      * Returns a boolean indicating whether an attribute with the specified key exists in the element.
      *
      * @param key Attribute key.
      * @returns `true` if attribute with the specified key exists in the element, `false` otherwise.
      */
      hasAttribute(key) {
        if (key == "class") {
          return this._classes.size > 0;
        }
        if (key == "style") {
          return !this._styles.isEmpty;
        }
        return this._attrs.has(key);
      }
      /**
      * Checks if this element is similar to other element.
      * Both elements should have the same name and attributes to be considered as similar. Two similar elements
      * can contain different set of children nodes.
      */
      isSimilar(otherElement) {
        if (!(otherElement instanceof Element2)) {
          return false;
        }
        if (this === otherElement) {
          return true;
        }
        if (this.name != otherElement.name) {
          return false;
        }
        if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
          return false;
        }
        for (const [key, value] of this._attrs) {
          if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
            return false;
          }
        }
        for (const className of this._classes) {
          if (!otherElement._classes.has(className)) {
            return false;
          }
        }
        for (const property2 of this._styles.getStyleNames()) {
          if (!otherElement._styles.has(property2) || otherElement._styles.getAsString(property2) !== this._styles.getAsString(property2)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns true if class is present.
      * If more then one class is provided - returns true only when all classes are present.
      *
      * ```ts
      * element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
      * element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
      * ```
      */
      hasClass(...className) {
        for (const name of className) {
          if (!this._classes.has(name)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns iterator that contains all class names.
      */
      getClassNames() {
        return this._classes.keys();
      }
      /**
      * Returns style value for the given property mae.
      * If the style does not exist `undefined` is returned.
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
      *
      * For an element with style set to `'margin:1px'`:
      *
      * ```ts
      * // Enable 'margin' shorthand processing:
      * editor.data.addStyleProcessorRules( addMarginRules );
      *
      * const element = view.change( writer => {
      * 	const element = writer.createElement();
      * 	writer.setStyle( 'margin', '1px' );
      * 	writer.setStyle( 'margin-bottom', '3em' );
      *
      * 	return element;
      * } );
      *
      * element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
      * ```
      */
      getStyle(property2) {
        return this._styles.getAsString(property2);
      }
      /**
      * Returns a normalized style object or single style value.
      *
      * For an element with style set to: margin:1px 2px 3em;
      *
      * ```ts
      * element.getNormalizedStyle( 'margin' ) );
      * ```
      *
      * will return:
      *
      * ```ts
      * {
      * 	top: '1px',
      * 	right: '2px',
      * 	bottom: '3em',
      * 	left: '2px'    // a normalized value from margin shorthand
      * }
      * ```
      *
      * and reading for single style value:
      *
      * ```ts
      * styles.getNormalizedStyle( 'margin-left' );
      * ```
      *
      * Will return a `2px` string.
      *
      * **Note**: This method will return normalized values only if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
      *
      * @param property Name of CSS property
      */
      getNormalizedStyle(property2) {
        return this._styles.getNormalized(property2);
      }
      /**
      * Returns iterator that contains all style names.
      *
      * @param expand Expand shorthand style properties and return all equivalent style representations.
      */
      getStyleNames(expand) {
        return this._styles.getStyleNames(expand);
      }
      /**
      * Returns true if style keys are present.
      * If more then one style property is provided - returns true only when all properties are present.
      *
      * ```ts
      * element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
      * element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
      * ```
      */
      hasStyle(...property2) {
        for (const name of property2) {
          if (!this._styles.has(name)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns ancestor element that match specified pattern.
      * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
      *
      * @see module:engine/view/matcher~Matcher
      * @param patterns Patterns used to match correct ancestor. See {@link module:engine/view/matcher~Matcher}.
      * @returns Found element or `null` if no matching ancestor was found.
      */
      findAncestor(...patterns) {
        const matcher = new Matcher(...patterns);
        let parent2 = this.parent;
        while (parent2 && !parent2.is("documentFragment")) {
          if (matcher.match(parent2)) {
            return parent2;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Returns the custom property value for the given key.
      */
      getCustomProperty(key) {
        return this._customProperties.get(key);
      }
      /**
      * Returns an iterator which iterates over this element's custom properties.
      * Iterator provides `[ key, value ]` pairs for each stored property.
      */
      *getCustomProperties() {
        yield* this._customProperties.entries();
      }
      /**
      * Returns identity string based on element's name, styles, classes and other attributes.
      * Two elements that {@link #isSimilar are similar} will have same identity string.
      * It has the following format:
      *
      * ```ts
      * 'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
      * ```
       *
      * For example:
      *
      * ```ts
      * const element = writer.createContainerElement( 'foo', {
      * 	banana: '10',
      * 	apple: '20',
      * 	style: 'color: red; border-color: white;',
      * 	class: 'baz'
      * } );
      *
      * // returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
      * element.getIdentity();
      * ```
      *
      * **Note**: Classes, styles and other attributes are sorted alphabetically.
      */
      getIdentity() {
        const classes = Array.from(this._classes).sort().join(",");
        const styles = this._styles.toString();
        const attributes = Array.from(this._attrs).map((i) => `${i[0]}="${i[1]}"`).sort().join(" ");
        return this.name + (classes == "" ? "" : ` class="${classes}"`) + (!styles ? "" : ` style="${styles}"`) + (attributes == "" ? "" : ` ${attributes}`);
      }
      /**
      * Decides whether an unsafe attribute is whitelisted and should be rendered in the editing pipeline even though filtering mechanisms
      * like {@link module:engine/view/domconverter~DomConverter#shouldRenderAttribute} say it should not.
      *
      * Unsafe attribute names can be specified when creating an element via {@link module:engine/view/downcastwriter~DowncastWriter}.
      *
      * @param attributeName The name of the attribute to be checked.
      */
      shouldRenderUnsafeAttribute(attributeName) {
        return this._unsafeAttributesToRender.includes(attributeName);
      }
      /**
      * Clones provided element.
      *
      * @internal
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns Clone of this element.
      */
      _clone(deep = false) {
        const childrenClone = [];
        if (deep) {
          for (const child of this.getChildren()) {
            childrenClone.push(child._clone(deep));
          }
        }
        const cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone);
        cloned._classes = new Set(this._classes);
        cloned._styles.set(this._styles.getNormalized());
        cloned._customProperties = new Map(this._customProperties);
        cloned.getFillerOffset = this.getFillerOffset;
        cloned._unsafeAttributesToRender = this._unsafeAttributesToRender;
        return cloned;
      }
      /**
      * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
      * and sets the parent of these nodes to this element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#insert
      * @internal
      * @param items Items to be inserted.
      * @fires change
      * @returns Number of appended nodes.
      */
      _appendChild(items) {
        return this._insertChild(this.childCount, items);
      }
      /**
      * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
      * this element.
      *
      * @internal
      * @see module:engine/view/downcastwriter~DowncastWriter#insert
      * @param index Position where nodes should be inserted.
      * @param items Items to be inserted.
      * @fires change
      * @returns Number of inserted nodes.
      */
      _insertChild(index2, items) {
        this._fireChange("children", this);
        let count2 = 0;
        const nodes = normalize$3(this.document, items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
          node.document = this.document;
          this._children.splice(index2, 0, node);
          index2++;
          count2++;
        }
        return count2;
      }
      /**
      * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#remove
      * @internal
      * @param index Number of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @fires change
      * @returns The array of removed nodes.
      */
      _removeChildren(index2, howMany = 1) {
        this._fireChange("children", this);
        for (let i = index2; i < index2 + howMany; i++) {
          this._children[i].parent = null;
        }
        return this._children.splice(index2, howMany);
      }
      /**
      * Adds or overwrite attribute with a specified key and value.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
      * @internal
      * @param key Attribute key.
      * @param value Attribute value.
      * @fires change
      */
      _setAttribute(key, value) {
        const stringValue = String(value);
        this._fireChange("attributes", this);
        if (key == "class") {
          parseClasses(this._classes, stringValue);
        } else if (key == "style") {
          this._styles.setTo(stringValue);
        } else {
          this._attrs.set(key, stringValue);
        }
      }
      /**
      * Removes attribute from the element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
      * @internal
      * @param key Attribute key.
      * @returns Returns true if an attribute existed and has been removed.
      * @fires change
      */
      _removeAttribute(key) {
        this._fireChange("attributes", this);
        if (key == "class") {
          if (this._classes.size > 0) {
            this._classes.clear();
            return true;
          }
          return false;
        }
        if (key == "style") {
          if (!this._styles.isEmpty) {
            this._styles.clear();
            return true;
          }
          return false;
        }
        return this._attrs.delete(key);
      }
      /**
      * Adds specified class.
      *
      * ```ts
      * element._addClass( 'foo' ); // Adds 'foo' class.
      * element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
      * ```
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#addClass
      * @internal
      * @fires change
      */
      _addClass(className) {
        this._fireChange("attributes", this);
        for (const name of toArray$1(className)) {
          this._classes.add(name);
        }
      }
      /**
      * Removes specified class.
      *
      * ```ts
      * element._removeClass( 'foo' );  // Removes 'foo' class.
      * element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
      * ```
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
      * @internal
      * @fires change
      */
      _removeClass(className) {
        this._fireChange("attributes", this);
        for (const name of toArray$1(className)) {
          this._classes.delete(name);
        }
      }
      _setStyle(property2, value) {
        this._fireChange("attributes", this);
        if (typeof property2 != "string") {
          this._styles.set(property2);
        } else {
          this._styles.set(property2, value);
        }
      }
      /**
      * Removes specified style.
      *
      * ```ts
      * element._removeStyle( 'color' );  // Removes 'color' style.
      * element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
      * ```
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
      * @internal
      * @fires change
      */
      _removeStyle(property2) {
        this._fireChange("attributes", this);
        for (const name of toArray$1(property2)) {
          this._styles.remove(name);
        }
      }
      /**
      * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
      * so they can be used to add special data to elements.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
      * @internal
      */
      _setCustomProperty(key, value) {
        this._customProperties.set(key, value);
      }
      /**
      * Removes the custom property stored under the given key.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
      * @internal
      * @returns Returns true if property was removed.
      */
      _removeCustomProperty(key) {
        return this._customProperties.delete(key);
      }
    };
    Element$1.prototype.is = function(type, name) {
      if (!name) {
        return type === "element" || type === "view:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "element" || type === "view:element");
      }
    };
    function parseAttributes(attrs) {
      const attrsMap = toMap(attrs);
      for (const [key, value] of attrsMap) {
        if (value === null) {
          attrsMap.delete(key);
        } else if (typeof value != "string") {
          attrsMap.set(key, String(value));
        }
      }
      return attrsMap;
    }
    function parseClasses(classesSet, classesString) {
      const classArray = classesString.split(/\s+/);
      classesSet.clear();
      classArray.forEach((name) => classesSet.add(name));
    }
    function normalize$3(document2, nodes) {
      if (typeof nodes == "string") {
        return [
          new Text$1(document2, nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text$1(document2, node);
        }
        if (node instanceof TextProxy$1) {
          return new Text$1(document2, node.data);
        }
        return node;
      });
    }
    class ContainerElement extends Element$1 {
      /**
      * Creates a container element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
      * @see module:engine/view/element~Element
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        this.getFillerOffset = getFillerOffset$4;
      }
    }
    ContainerElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "containerElement" || type === "view:containerElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$4() {
      const children = [
        ...this.getChildren()
      ];
      const lastChild = children[this.childCount - 1];
      if (lastChild && lastChild.is("element", "br")) {
        return this.childCount;
      }
      for (const child of children) {
        if (!child.is("uiElement")) {
          return null;
        }
      }
      return this.childCount;
    }
    class EditableElement extends (/* @__PURE__ */ ObservableMixin(ContainerElement)) {
      /**
      * Creates an editable element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attributes, children) {
        super(document2, name, attributes, children);
        this.set("isReadOnly", false);
        this.set("isFocused", false);
        this.set("placeholder", void 0);
        this.bind("isReadOnly").to(document2);
        this.bind("isFocused").to(document2, "isFocused", (isFocused) => isFocused && document2.selection.editableElement == this);
        this.listenTo(document2.selection, "change", () => {
          this.isFocused = document2.isFocused && document2.selection.editableElement == this;
        });
      }
      destroy() {
        this.stopListening();
      }
    }
    EditableElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "editableElement" || type === "view:editableElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
      }
    };
    const rootNameSymbol = Symbol("rootName");
    class RootEditableElement extends EditableElement {
      /**
      * Creates root editable element.
      *
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      */
      constructor(document2, name) {
        super(document2, name);
        this.rootName = "main";
      }
      /**
      * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
      * other name is set, `main` name is used.
      *
      * @readonly
      */
      get rootName() {
        return this.getCustomProperty(rootNameSymbol);
      }
      set rootName(rootName) {
        this._setCustomProperty(rootNameSymbol, rootName);
      }
      /**
      * Overrides old element name and sets new one.
      * This is needed because view roots are created before they are attached to the DOM.
      * The name of the root element is temporary at this stage. It has to be changed when the
      * view root element is attached to the DOM element.
      *
      * @internal
      * @param name The new name of element.
      */
      set _name(name) {
        this.name = name;
      }
    }
    RootEditableElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "rootElement" || type === "view:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "editableElement" || type === "view:editableElement" || type === "containerElement" || type === "view:containerElement" || type === "element" || type === "view:element");
      }
    };
    let TreeWalker$1 = class TreeWalker {
      /**
      * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
      *
      * @param options Object with configuration.
      */
      constructor(options = {}) {
        /**
        * Walking direction. Defaults `'forward'`.
        */
        __publicField(this, "direction");
        /**
        * Iterator boundaries.
        *
        * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
        * on the start of boundary, then `{ done: true }` is returned.
        *
        * If boundaries are not defined they are set before first and after last child of the root node.
        */
        __publicField(this, "boundaries");
        /**
        * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one
        * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.
        */
        __publicField(this, "singleCharacters");
        /**
        * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
        * iterated node will not be returned along with `elementEnd` tag.
        */
        __publicField(this, "shallow");
        /**
        * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
        * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.
        * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
        */
        __publicField(this, "ignoreElementEnd");
        /**
        * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
        * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
        */
        __publicField(this, "_position");
        /**
        * Start boundary parent.
        */
        __publicField(this, "_boundaryStartParent");
        /**
        * End boundary parent.
        */
        __publicField(this, "_boundaryEndParent");
        if (!options.boundaries && !options.startPosition) {
          throw new CKEditorError("view-tree-walker-no-start-position", null);
        }
        if (options.direction && options.direction != "forward" && options.direction != "backward") {
          throw new CKEditorError("view-tree-walker-unknown-direction", options.startPosition, {
            direction: options.direction
          });
        }
        this.boundaries = options.boundaries || null;
        if (options.startPosition) {
          this._position = Position$1._createAt(options.startPosition);
        } else {
          this._position = Position$1._createAt(options.boundaries[options.direction == "backward" ? "end" : "start"]);
        }
        this.direction = options.direction || "forward";
        this.singleCharacters = !!options.singleCharacters;
        this.shallow = !!options.shallow;
        this.ignoreElementEnd = !!options.ignoreElementEnd;
        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
      }
      /**
      * Iterable interface.
      */
      [Symbol.iterator]() {
        return this;
      }
      /**
      * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
      * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
      */
      get position() {
        return this._position;
      }
      /**
      * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
      *
      * For example:
      *
      * ```ts
      * walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
      * walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
      * walker.skip( value => false ); // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      */
      skip(skip) {
        let nextResult;
        let prevPosition;
        do {
          prevPosition = this.position;
          nextResult = this.next();
        } while (!nextResult.done && skip(nextResult.value));
        if (!nextResult.done) {
          this._position = prevPosition;
        }
      }
      /**
      * Gets the next tree walker's value.
      *
      * @returns Object implementing iterator interface, returning
      * information about taken step.
      */
      next() {
        if (this.direction == "forward") {
          return this._next();
        } else {
          return this._previous();
        }
      }
      /**
      * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
      */
      _next() {
        let position = this.position.clone();
        const previousPosition = this.position;
        const parent2 = position.parent;
        if (parent2.parent === null && position.offset === parent2.childCount) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        let node;
        if (parent2 instanceof Text$1) {
          if (position.isAtEnd) {
            this._position = Position$1._createAfter(parent2);
            return this._next();
          }
          node = parent2.data[position.offset];
        } else {
          node = parent2.getChild(position.offset);
        }
        if (node instanceof Element$1) {
          if (!this.shallow) {
            position = new Position$1(node, 0);
          } else {
            if (this.boundaries && this.boundaries.end.isBefore(position)) {
              return {
                done: true,
                value: void 0
              };
            }
            position.offset++;
          }
          this._position = position;
          return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
        }
        if (node instanceof Text$1) {
          if (this.singleCharacters) {
            position = new Position$1(node, 0);
            this._position = position;
            return this._next();
          }
          let charactersCount = node.data.length;
          let item;
          if (node == this._boundaryEndParent) {
            charactersCount = this.boundaries.end.offset;
            item = new TextProxy$1(node, 0, charactersCount);
            position = Position$1._createAfter(item);
          } else {
            item = new TextProxy$1(node, 0, node.data.length);
            position.offset++;
          }
          this._position = position;
          return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        if (typeof node == "string") {
          let textLength;
          if (this.singleCharacters) {
            textLength = 1;
          } else {
            const endOffset = parent2 === this._boundaryEndParent ? this.boundaries.end.offset : parent2.data.length;
            textLength = endOffset - position.offset;
          }
          const textProxy = new TextProxy$1(parent2, position.offset, textLength);
          position.offset += textLength;
          this._position = position;
          return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
        }
        position = Position$1._createAfter(parent2);
        this._position = position;
        if (this.ignoreElementEnd) {
          return this._next();
        }
        return this._formatReturnValue("elementEnd", parent2, previousPosition, position);
      }
      /**
      * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
      */
      _previous() {
        let position = this.position.clone();
        const previousPosition = this.position;
        const parent2 = position.parent;
        if (parent2.parent === null && position.offset === 0) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        let node;
        if (parent2 instanceof Text$1) {
          if (position.isAtStart) {
            this._position = Position$1._createBefore(parent2);
            return this._previous();
          }
          node = parent2.data[position.offset - 1];
        } else {
          node = parent2.getChild(position.offset - 1);
        }
        if (node instanceof Element$1) {
          if (this.shallow) {
            position.offset--;
            this._position = position;
            return this._formatReturnValue("elementStart", node, previousPosition, position, 1);
          }
          position = new Position$1(node, node.childCount);
          this._position = position;
          if (this.ignoreElementEnd) {
            return this._previous();
          }
          return this._formatReturnValue("elementEnd", node, previousPosition, position);
        }
        if (node instanceof Text$1) {
          if (this.singleCharacters) {
            position = new Position$1(node, node.data.length);
            this._position = position;
            return this._previous();
          }
          let charactersCount = node.data.length;
          let item;
          if (node == this._boundaryStartParent) {
            const offset = this.boundaries.start.offset;
            item = new TextProxy$1(node, offset, node.data.length - offset);
            charactersCount = item.data.length;
            position = Position$1._createBefore(item);
          } else {
            item = new TextProxy$1(node, 0, node.data.length);
            position.offset--;
          }
          this._position = position;
          return this._formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        if (typeof node == "string") {
          let textLength;
          if (!this.singleCharacters) {
            const startOffset = parent2 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
            textLength = position.offset - startOffset;
          } else {
            textLength = 1;
          }
          position.offset -= textLength;
          const textProxy = new TextProxy$1(parent2, position.offset, textLength);
          this._position = position;
          return this._formatReturnValue("text", textProxy, previousPosition, position, textLength);
        }
        position = Position$1._createBefore(parent2);
        this._position = position;
        return this._formatReturnValue("elementStart", parent2, previousPosition, position, 1);
      }
      /**
      * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
      *
      * @param type Type of step.
      * @param item Item between old and new position.
      * @param previousPosition Previous position of iterator.
      * @param nextPosition Next position of iterator.
      * @param length Length of the item.
      */
      _formatReturnValue(type, item, previousPosition, nextPosition, length) {
        if (item instanceof TextProxy$1) {
          if (item.offsetInText + item.data.length == item.textNode.data.length) {
            if (this.direction == "forward" && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
              nextPosition = Position$1._createAfter(item.textNode);
              this._position = nextPosition;
            } else {
              previousPosition = Position$1._createAfter(item.textNode);
            }
          }
          if (item.offsetInText === 0) {
            if (this.direction == "backward" && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
              nextPosition = Position$1._createBefore(item.textNode);
              this._position = nextPosition;
            } else {
              previousPosition = Position$1._createBefore(item.textNode);
            }
          }
        }
        return {
          done: false,
          value: {
            type,
            item,
            previousPosition,
            nextPosition,
            length
          }
        };
      }
    };
    let Position$1 = class Position2 extends TypeCheckable$1 {
      /**
      * Creates a position.
      *
      * @param parent Position parent.
      * @param offset Position offset.
      */
      constructor(parent2, offset) {
        super();
        /**
        * Position parent.
        */
        __publicField(this, "parent");
        /**
        * Position offset.
        */
        __publicField(this, "offset");
        this.parent = parent2;
        this.offset = offset;
      }
      /**
      * Node directly after the position. Equals `null` when there is no node after position or position is located
      * inside text node.
      */
      get nodeAfter() {
        if (this.parent.is("$text")) {
          return null;
        }
        return this.parent.getChild(this.offset) || null;
      }
      /**
      * Node directly before the position. Equals `null` when there is no node before position or position is located
      * inside text node.
      */
      get nodeBefore() {
        if (this.parent.is("$text")) {
          return null;
        }
        return this.parent.getChild(this.offset - 1) || null;
      }
      /**
      * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
      */
      get isAtStart() {
        return this.offset === 0;
      }
      /**
      * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
      */
      get isAtEnd() {
        const endOffset = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
        return this.offset === endOffset;
      }
      /**
      * Position's root, that is the root of the position's parent element.
      */
      get root() {
        return this.parent.root;
      }
      /**
      * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
      * position is not inside an editable element.
      */
      get editableElement() {
        let editable = this.parent;
        while (!(editable instanceof EditableElement)) {
          if (editable.parent) {
            editable = editable.parent;
          } else {
            return null;
          }
        }
        return editable;
      }
      /**
      * Returns a new instance of Position with offset incremented by `shift` value.
      *
      * @param shift How position offset should get changed. Accepts negative values.
      * @returns Shifted position.
      */
      getShiftedBy(shift) {
        const shifted = Position2._createAt(this);
        const offset = shifted.offset + shift;
        shifted.offset = offset < 0 ? 0 : offset;
        return shifted;
      }
      /**
      * Gets the farthest position which matches the callback using
      * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
      *
      * For example:
      *
      * ```ts
      * getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
      * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
      * getLastMatchingPosition( value => false ); // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      * @returns The position after the last item which matches the `skip` callback test.
      */
      getLastMatchingPosition(skip, options = {}) {
        options.startPosition = this;
        const treeWalker = new TreeWalker$1(options);
        treeWalker.skip(skip);
        return treeWalker.position;
      }
      /**
      * Returns ancestors array of this position, that is this position's parent and it's ancestors.
      *
      * @returns Array with ancestors.
      */
      getAncestors() {
        if (this.parent.is("documentFragment")) {
          return [
            this.parent
          ];
        } else {
          return this.parent.getAncestors({
            includeSelf: true
          });
        }
      }
      /**
      * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
      * which is a common ancestor of both positions.
      */
      getCommonAncestor(position) {
        const ancestorsA = this.getAncestors();
        const ancestorsB = position.getAncestors();
        let i = 0;
        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
          i++;
        }
        return i === 0 ? null : ancestorsA[i - 1];
      }
      /**
      * Checks whether this position equals given position.
      *
      * @param otherPosition Position to compare with.
      * @returns True if positions are same.
      */
      isEqual(otherPosition) {
        return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
      }
      /**
      * Checks whether this position is located before given position. When method returns `false` it does not mean that
      * this position is after give one. Two positions may be located inside separate roots and in that situation this
      * method will still return `false`.
      *
      * @see module:engine/view/position~Position#isAfter
      * @see module:engine/view/position~Position#compareWith
      * @param otherPosition Position to compare with.
      * @returns Returns `true` if this position is before given position.
      */
      isBefore(otherPosition) {
        return this.compareWith(otherPosition) == "before";
      }
      /**
      * Checks whether this position is located after given position. When method returns `false` it does not mean that
      * this position is before give one. Two positions may be located inside separate roots and in that situation this
      * method will still return `false`.
      *
      * @see module:engine/view/position~Position#isBefore
      * @see module:engine/view/position~Position#compareWith
      * @param otherPosition Position to compare with.
      * @returns Returns `true` if this position is after given position.
      */
      isAfter(otherPosition) {
        return this.compareWith(otherPosition) == "after";
      }
      /**
      * Checks whether this position is before, after or in same position that other position. Two positions may be also
      * different when they are located in separate roots.
      *
      * @param otherPosition Position to compare with.
      */
      compareWith(otherPosition) {
        if (this.root !== otherPosition.root) {
          return "different";
        }
        if (this.isEqual(otherPosition)) {
          return "same";
        }
        const thisPath = this.parent.is("node") ? this.parent.getPath() : [];
        const otherPath = otherPosition.parent.is("node") ? otherPosition.parent.getPath() : [];
        thisPath.push(this.offset);
        otherPath.push(otherPosition.offset);
        const result = compareArrays(thisPath, otherPath);
        switch (result) {
          case "prefix":
            return "before";
          case "extension":
            return "after";
          default:
            return thisPath[result] < otherPath[result] ? "before" : "after";
        }
      }
      /**
      * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
      */
      getWalker(options = {}) {
        options.startPosition = this;
        return new TreeWalker$1(options);
      }
      /**
      * Clones this position.
      */
      clone() {
        return new Position2(this.parent, this.offset);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link module:engine/view/position~Position._createBefore},
      * * {@link module:engine/view/position~Position._createAfter}.
      *
      * @internal
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      static _createAt(itemOrPosition, offset) {
        if (itemOrPosition instanceof Position2) {
          return new this(itemOrPosition.parent, itemOrPosition.offset);
        } else {
          const node = itemOrPosition;
          if (offset == "end") {
            offset = node.is("$text") ? node.data.length : node.childCount;
          } else if (offset == "before") {
            return this._createBefore(node);
          } else if (offset == "after") {
            return this._createAfter(node);
          } else if (offset !== 0 && !offset) {
            throw new CKEditorError("view-createpositionat-offset-required", node);
          }
          return new Position2(node, offset);
        }
      }
      /**
      * Creates a new position after given view item.
      *
      * @internal
      * @param item View item after which the position should be located.
      */
      static _createAfter(item) {
        if (item.is("$textProxy")) {
          return new Position2(item.textNode, item.offsetInText + item.data.length);
        }
        if (!item.parent) {
          throw new CKEditorError("view-position-after-root", item, {
            root: item
          });
        }
        return new Position2(item.parent, item.index + 1);
      }
      /**
      * Creates a new position before given view item.
      *
      * @internal
      * @param item View item before which the position should be located.
      */
      static _createBefore(item) {
        if (item.is("$textProxy")) {
          return new Position2(item.textNode, item.offsetInText);
        }
        if (!item.parent) {
          throw new CKEditorError("view-position-before-root", item, {
            root: item
          });
        }
        return new Position2(item.parent, item.index);
      }
    };
    Position$1.prototype.is = function(type) {
      return type === "position" || type === "view:position";
    };
    let Range$1 = class Range2 extends TypeCheckable$1 {
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at the `start` position.
      */
      constructor(start, end = null) {
        super();
        /**
        * Start position.
        */
        __publicField(this, "start");
        /**
        * End position.
        */
        __publicField(this, "end");
        this.start = start.clone();
        this.end = end ? end.clone() : start.clone();
      }
      /**
      * Iterable interface.
      *
      * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
      * them together with additional information like length or {@link module:engine/view/position~Position positions},
      * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
      *
      * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
      * `ignoreElementEnd` option
      * set to `true`.
      */
      *[Symbol.iterator]() {
        yield* new TreeWalker$1({
          boundaries: this,
          ignoreElementEnd: true
        });
      }
      /**
      * Returns whether the range is collapsed, that is it start and end positions are equal.
      */
      get isCollapsed() {
        return this.start.isEqual(this.end);
      }
      /**
      * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
      * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
      */
      get isFlat() {
        return this.start.parent === this.end.parent;
      }
      /**
      * Range root element.
      */
      get root() {
        return this.start.root;
      }
      /**
      * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
      * and at the end).
      *
      * For example:
      *
      * ```html
      * <p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
      * <p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
      * ```
      *
      * Note that in the sample above:
      *
      * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
      * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
      * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
      *
      * @returns Enlarged range.
      */
      getEnlarged() {
        let start = this.start.getLastMatchingPosition(enlargeTrimSkip, {
          direction: "backward"
        });
        let end = this.end.getLastMatchingPosition(enlargeTrimSkip);
        if (start.parent.is("$text") && start.isAtStart) {
          start = Position$1._createBefore(start.parent);
        }
        if (end.parent.is("$text") && end.isAtEnd) {
          end = Position$1._createAfter(end.parent);
        }
        return new Range2(start, end);
      }
      /**
      * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
      * and at the end).
      *
      * For example:
      *
      * ```html
      * <p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
      * <p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
      * ```
      *
      * Note that in the sample above:
      *
      * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
      * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
      * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
      *
      * @returns Shrunk range.
      */
      getTrimmed() {
        let start = this.start.getLastMatchingPosition(enlargeTrimSkip);
        if (start.isAfter(this.end) || start.isEqual(this.end)) {
          return new Range2(start, start);
        }
        let end = this.end.getLastMatchingPosition(enlargeTrimSkip, {
          direction: "backward"
        });
        const nodeAfterStart = start.nodeAfter;
        const nodeBeforeEnd = end.nodeBefore;
        if (nodeAfterStart && nodeAfterStart.is("$text")) {
          start = new Position$1(nodeAfterStart, 0);
        }
        if (nodeBeforeEnd && nodeBeforeEnd.is("$text")) {
          end = new Position$1(nodeBeforeEnd, nodeBeforeEnd.data.length);
        }
        return new Range2(start, end);
      }
      /**
      * Two ranges are equal if their start and end positions are equal.
      *
      * @param otherRange Range to compare with.
      * @returns `true` if ranges are equal, `false` otherwise
      */
      isEqual(otherRange) {
        return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
      }
      /**
      * Checks whether this range contains given {@link module:engine/view/position~Position position}.
      *
      * @param position Position to check.
      * @returns `true` if given {@link module:engine/view/position~Position position} is contained in this range, `false` otherwise.
      */
      containsPosition(position) {
        return position.isAfter(this.start) && position.isBefore(this.end);
      }
      /**
      * Checks whether this range contains given {@link module:engine/view/range~Range range}.
      *
      * @param otherRange Range to check.
      * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
      * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
      * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
      * @returns `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
      * otherwise.
      */
      containsRange(otherRange, loose = false) {
        if (otherRange.isCollapsed) {
          loose = false;
        }
        const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
        const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
        return containsStart && containsEnd;
      }
      /**
      * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
      * {@link module:engine/view/range~Range range}.
      * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
      *
      * Examples:
      *
      * ```ts
      * let foo = downcastWriter.createText( 'foo' );
      * let img = downcastWriter.createContainerElement( 'img' );
      * let bar = downcastWriter.createText( 'bar' );
      * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
      *
      * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
      * let otherRange = view.createRange( // "oo", img, "ba" are in range.
      * 	view.createPositionAt( foo, 1 ),
      * 	view.createPositionAt( bar, 2 )
      * );
      * let transformed = range.getDifference( otherRange );
      * // transformed array has no ranges because `otherRange` contains `range`
      *
      * otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
      * transformed = range.getDifference( otherRange );
      * // transformed array has one range: from ( p, 2 ) to ( bar, 1 )
      *
      * otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
      * transformed = range.getDifference( otherRange );
      * // transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
      * ```
      *
      * @param otherRange Range to differentiate against.
      * @returns The difference between ranges.
      */
      getDifference(otherRange) {
        const ranges = [];
        if (this.isIntersecting(otherRange)) {
          if (this.containsPosition(otherRange.start)) {
            ranges.push(new Range2(this.start, otherRange.start));
          }
          if (this.containsPosition(otherRange.end)) {
            ranges.push(new Range2(otherRange.end, this.end));
          }
        } else {
          ranges.push(this.clone());
        }
        return ranges;
      }
      /**
      * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
      * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
      *
      * Examples:
      *
      * ```ts
      * let foo = downcastWriter.createText( 'foo' );
      * let img = downcastWriter.createContainerElement( 'img' );
      * let bar = downcastWriter.createText( 'bar' );
      * let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
      *
      * let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
      * let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
      * let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
      *
      * otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
      * transformed = range.getIntersection( otherRange ); // null - no common part.
      * ```
      *
      * @param otherRange Range to check for intersection.
      * @returns A common part of given ranges or `null` if ranges have no common part.
      */
      getIntersection(otherRange) {
        if (this.isIntersecting(otherRange)) {
          let commonRangeStart = this.start;
          let commonRangeEnd = this.end;
          if (this.containsPosition(otherRange.start)) {
            commonRangeStart = otherRange.start;
          }
          if (this.containsPosition(otherRange.end)) {
            commonRangeEnd = otherRange.end;
          }
          return new Range2(commonRangeStart, commonRangeEnd);
        }
        return null;
      }
      /**
      * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      */
      getWalker(options = {}) {
        options.boundaries = this;
        return new TreeWalker$1(options);
      }
      /**
      * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
      * which is a common ancestor of range's both ends (in which the entire range is contained).
      */
      getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
      }
      /**
      * Returns an {@link module:engine/view/element~Element Element} contained by the range.
      * The element will be returned when it is the **only** node within the range and **fully–contained**
      * at the same time.
      */
      getContainedElement() {
        if (this.isCollapsed) {
          return null;
        }
        let nodeAfterStart = this.start.nodeAfter;
        let nodeBeforeEnd = this.end.nodeBefore;
        if (this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling) {
          nodeAfterStart = this.start.parent.nextSibling;
        }
        if (this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling) {
          nodeBeforeEnd = this.end.parent.previousSibling;
        }
        if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
          return nodeAfterStart;
        }
        return null;
      }
      /**
      * Clones this range.
      */
      clone() {
        return new Range2(this.start, this.end);
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
      * them.
      *
      * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
      * set to `true`. However it returns only {@link module:engine/view/item~Item items},
      * not {@link module:engine/view/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      */
      *getItems(options = {}) {
        options.boundaries = this;
        options.ignoreElementEnd = true;
        const treeWalker = new TreeWalker$1(options);
        for (const value of treeWalker) {
          yield value.item;
        }
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
      * contained in this range.
      *
      * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
      * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
      */
      *getPositions(options = {}) {
        options.boundaries = this;
        const treeWalker = new TreeWalker$1(options);
        yield treeWalker.position;
        for (const value of treeWalker) {
          yield value.nextPosition;
        }
      }
      /**
      * Checks and returns whether this range intersects with the given range.
      *
      * @param otherRange Range to compare with.
      * @returns True if ranges intersect.
      */
      isIntersecting(otherRange) {
        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
      }
      /**
      * Creates a range from the given parents and offsets.
      *
      * @internal
      * @param startElement Start position parent element.
      * @param startOffset Start position offset.
      * @param endElement End position parent element.
      * @param endOffset End position offset.
      * @returns Created range.
      */
      static _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
        return new this(new Position$1(startElement, startOffset), new Position$1(endElement, endOffset));
      }
      /**
      * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
      * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
      *
      * @internal
      * @param position Beginning of the range.
      * @param shift How long the range should be.
      */
      static _createFromPositionAndShift(position, shift) {
        const start = position;
        const end = position.getShiftedBy(shift);
        return shift > 0 ? new this(start, end) : new this(end, start);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @internal
      * @param element Element which is a parent for the range.
      */
      static _createIn(element) {
        return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      *
      * @internal
      */
      static _createOn(item) {
        const size = item.is("$textProxy") ? item.offsetSize : 1;
        return this._createFromPositionAndShift(Position$1._createBefore(item), size);
      }
    };
    Range$1.prototype.is = function(type) {
      return type === "range" || type === "view:range";
    };
    function enlargeTrimSkip(value) {
      if (value.item.is("attributeElement") || value.item.is("uiElement")) {
        return true;
      }
      return false;
    }
    let Selection$1 = class Selection2 extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      /**
      * Creates new selection instance.
      *
      * **Note**: The selection constructor is available as a factory method:
      *
      * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
      * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
      *
      * ```ts
      * // Creates empty selection without ranges.
      * const selection = writer.createSelection();
      *
      * // Creates selection at the given range.
      * const range = writer.createRange( start, end );
      * const selection = writer.createSelection( range );
      *
      * // Creates selection at the given ranges
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * const selection = writer.createSelection( ranges );
      *
      * // Creates selection from the other selection.
      * const otherSelection = writer.createSelection();
      * const selection = writer.createSelection( otherSelection );
      *
      * // Creates selection from the document selection.
      * const selection = writer.createSelection( editor.editing.view.document.selection );
      *
      * // Creates selection at the given position.
      * const position = writer.createPositionFromPath( root, path );
      * const selection = writer.createSelection( position );
      *
      * // Creates collapsed selection at the position of given item and offset.
      * const paragraph = writer.createContainerElement( 'paragraph' );
      * const selection = writer.createSelection( paragraph, offset );
      *
      * // Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
      * // first child of that element and ends after the last child of that element.
      * const selection = writer.createSelection( paragraph, 'in' );
      *
      * // Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
      * // just after the item.
      * const selection = writer.createSelection( paragraph, 'on' );
      * ```
      *
      * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
      *
      * ```ts
      * // Creates backward selection.
      * const selection = writer.createSelection( range, { backward: true } );
      * ```
      *
      * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
      * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
      * represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
      * (and be  properly handled by screen readers).
      *
      * ```ts
      * // Creates fake selection with label.
      * const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
      * ```
      *
      * @internal
      */
      constructor(...args) {
        super();
        /**
        * Stores all ranges that are selected.
        */
        __publicField(this, "_ranges");
        /**
        * Specifies whether the last added range was added as a backward or forward range.
        */
        __publicField(this, "_lastRangeBackward");
        /**
        * Specifies whether selection instance is fake.
        */
        __publicField(this, "_isFake");
        /**
        * Fake selection's label.
        */
        __publicField(this, "_fakeSelectionLabel");
        this._ranges = [];
        this._lastRangeBackward = false;
        this._isFake = false;
        this._fakeSelectionLabel = "";
        if (args.length) {
          this.setTo(...args);
        }
      }
      /**
      * Returns true if selection instance is marked as `fake`.
      *
      * @see #setTo
      */
      get isFake() {
        return this._isFake;
      }
      /**
      * Returns fake selection label.
      *
      * @see #setTo
      */
      get fakeSelectionLabel() {
        return this._fakeSelectionLabel;
      }
      /**
      * Selection anchor. Anchor may be described as a position where the selection starts. Together with
      * {@link #focus focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
      * It may be a bit unintuitive when there are multiple ranges in selection.
      *
      * @see #focus
      */
      get anchor() {
        if (!this._ranges.length) {
          return null;
        }
        const range = this._ranges[this._ranges.length - 1];
        const anchor = this._lastRangeBackward ? range.end : range.start;
        return anchor.clone();
      }
      /**
      * Selection focus. Focus is a position where the selection ends.
      *
      * @see #anchor
      */
      get focus() {
        if (!this._ranges.length) {
          return null;
        }
        const range = this._ranges[this._ranges.length - 1];
        const focus = this._lastRangeBackward ? range.start : range.end;
        return focus.clone();
      }
      /**
      * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
      * collapsed.
      */
      get isCollapsed() {
        return this.rangeCount === 1 && this._ranges[0].isCollapsed;
      }
      /**
      * Returns number of ranges in selection.
      */
      get rangeCount() {
        return this._ranges.length;
      }
      /**
      * Specifies whether the {@link #focus} precedes {@link #anchor}.
      */
      get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
      }
      /**
      * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
      * if the selection is not inside an editable element.
      */
      get editableElement() {
        if (this.anchor) {
          return this.anchor.editableElement;
        }
        return null;
      }
      /**
      * Returns an iterable that contains copies of all ranges added to the selection.
      */
      *getRanges() {
        for (const range of this._ranges) {
          yield range.clone();
        }
      }
      /**
      * Returns copy of the first range in the selection. First range is the one which
      * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
      * position of all other ranges (not to confuse with the first range added to the selection).
      * Returns `null` if no ranges are added to selection.
      */
      getFirstRange() {
        let first2 = null;
        for (const range of this._ranges) {
          if (!first2 || range.start.isBefore(first2.start)) {
            first2 = range;
          }
        }
        return first2 ? first2.clone() : null;
      }
      /**
      * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
      * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
      * with the last range added to the selection). Returns `null` if no ranges are added to selection.
      */
      getLastRange() {
        let last2 = null;
        for (const range of this._ranges) {
          if (!last2 || range.end.isAfter(last2.end)) {
            last2 = range;
          }
        }
        return last2 ? last2.clone() : null;
      }
      /**
      * Returns copy of the first position in the selection. First position is the position that
      * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getFirstPosition() {
        const firstRange = this.getFirstRange();
        return firstRange ? firstRange.start.clone() : null;
      }
      /**
      * Returns copy of the last position in the selection. Last position is the position that
      * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getLastPosition() {
        const lastRange = this.getLastRange();
        return lastRange ? lastRange.end.clone() : null;
      }
      /**
      * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
      * same number of ranges and all ranges from one selection equal to a range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are equal, `false` otherwise.
      */
      isEqual(otherSelection) {
        if (this.isFake != otherSelection.isFake) {
          return false;
        }
        if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
          return false;
        }
        if (this.rangeCount != otherSelection.rangeCount) {
          return false;
        } else if (this.rangeCount === 0) {
          return true;
        }
        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
          return false;
        }
        for (const thisRange of this._ranges) {
          let found = false;
          for (const otherRange of otherSelection._ranges) {
            if (thisRange.isEqual(otherRange)) {
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      /**
      * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
      * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
      * equal to any trimmed range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are similar, `false` otherwise.
      */
      isSimilar(otherSelection) {
        if (this.isBackward != otherSelection.isBackward) {
          return false;
        }
        const numOfRangesA = count(this.getRanges());
        const numOfRangesB = count(otherSelection.getRanges());
        if (numOfRangesA != numOfRangesB) {
          return false;
        }
        if (numOfRangesA == 0) {
          return true;
        }
        for (let rangeA of this.getRanges()) {
          rangeA = rangeA.getTrimmed();
          let found = false;
          for (let rangeB of otherSelection.getRanges()) {
            rangeB = rangeB.getTrimmed();
            if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        if (this.rangeCount !== 1) {
          return null;
        }
        return this.getFirstRange().getContainedElement();
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/view/selection~Selectable selectable}.
      *
      * ```ts
      * // Sets selection to the given range.
      * const range = writer.createRange( start, end );
      * selection.setTo( range );
      *
      * // Sets selection to given ranges.
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * selection.setTo( range );
      *
      * // Sets selection to the other selection.
      * const otherSelection = writer.createSelection();
      * selection.setTo( otherSelection );
      *
      * // Sets selection to contents of DocumentSelection.
      * selection.setTo( editor.editing.view.document.selection );
      *
      * // Sets collapsed selection at the given position.
      * const position = writer.createPositionAt( root, path );
      * selection.setTo( position );
      *
      * // Sets collapsed selection at the position of given item and offset.
      * selection.setTo( paragraph, offset );
      * ```
      *
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * ```ts
      * selection.setTo( paragraph, 'in' );
      * ```
      *
      * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
      *
      * ```ts
      * selection.setTo( paragraph, 'on' );
      *
      * // Clears selection. Removes all ranges.
      * selection.setTo( null );
      * ```
      *
      * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
      *
      * ```ts
      * // Sets selection as backward.
      * selection.setTo( range, { backward: true } );
      * ```
      *
      * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
      * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
      * represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
      * (and be  properly handled by screen readers).
      *
      * ```ts
      * // Creates fake selection with label.
      * selection.setTo( range, { fake: true, label: 'foo' } );
      * ```
      *
      * @fires change
      */
      setTo(...args) {
        let [selectable, placeOrOffset, options] = args;
        if (typeof placeOrOffset == "object") {
          options = placeOrOffset;
          placeOrOffset = void 0;
        }
        if (selectable === null) {
          this._setRanges([]);
          this._setFakeOptions(options);
        } else if (selectable instanceof Selection2 || selectable instanceof DocumentSelection$1) {
          this._setRanges(selectable.getRanges(), selectable.isBackward);
          this._setFakeOptions({
            fake: selectable.isFake,
            label: selectable.fakeSelectionLabel
          });
        } else if (selectable instanceof Range$1) {
          this._setRanges([
            selectable
          ], options && options.backward);
          this._setFakeOptions(options);
        } else if (selectable instanceof Position$1) {
          this._setRanges([
            new Range$1(selectable)
          ]);
          this._setFakeOptions(options);
        } else if (selectable instanceof Node$2) {
          const backward = !!options && !!options.backward;
          let range;
          if (placeOrOffset === void 0) {
            throw new CKEditorError("view-selection-setto-required-second-parameter", this);
          } else if (placeOrOffset == "in") {
            range = Range$1._createIn(selectable);
          } else if (placeOrOffset == "on") {
            range = Range$1._createOn(selectable);
          } else {
            range = new Range$1(Position$1._createAt(selectable, placeOrOffset));
          }
          this._setRanges([
            range
          ], backward);
          this._setFakeOptions(options);
        } else if (isIterable(selectable)) {
          this._setRanges(selectable, options && options.backward);
          this._setFakeOptions(options);
        } else {
          throw new CKEditorError("view-selection-setto-not-selectable", this);
        }
        this.fire("change");
      }
      /**
      * Moves {@link #focus} to the specified location.
      *
      * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
      * parameters.
      *
      * @fires change
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      setFocus(itemOrPosition, offset) {
        if (this.anchor === null) {
          throw new CKEditorError("view-selection-setfocus-no-ranges", this);
        }
        const newFocus = Position$1._createAt(itemOrPosition, offset);
        if (newFocus.compareWith(this.focus) == "same") {
          return;
        }
        const anchor = this.anchor;
        this._ranges.pop();
        if (newFocus.compareWith(anchor) == "before") {
          this._addRange(new Range$1(newFocus, anchor), true);
        } else {
          this._addRange(new Range$1(anchor, newFocus));
        }
        this.fire("change");
      }
      /**
      * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
      * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
      * Accepts a flag describing in which way the selection is made.
      *
      * @param newRanges Iterable object of ranges to set.
      * @param isLastBackward Flag describing if last added range was selected forward - from start to end
      * (`false`) or backward - from end to start (`true`). Defaults to `false`.
      */
      _setRanges(newRanges, isLastBackward = false) {
        newRanges = Array.from(newRanges);
        this._ranges = [];
        for (const range of newRanges) {
          this._addRange(range);
        }
        this._lastRangeBackward = !!isLastBackward;
      }
      /**
      * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
      * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
      * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
      * properly handled by screen readers).
      */
      _setFakeOptions(options = {}) {
        this._isFake = !!options.fake;
        this._fakeSelectionLabel = options.fake ? options.label || "" : "";
      }
      /**
      * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
      * selection instance and you can safely operate on it.
      *
      * Accepts a flag describing in which way the selection is made - passed range might be selected from
      * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
      * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
      * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
      * with ranges already stored in Selection instance.
      */
      _addRange(range, isBackward = false) {
        if (!(range instanceof Range$1)) {
          throw new CKEditorError("view-selection-add-range-not-range", this);
        }
        this._pushRange(range);
        this._lastRangeBackward = !!isBackward;
      }
      /**
      * Adds range to selection - creates copy of given range so it can be safely used and modified.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
      * with ranges already stored in selection instance.
      */
      _pushRange(range) {
        for (const storedRange of this._ranges) {
          if (range.isIntersecting(storedRange)) {
            throw new CKEditorError("view-selection-range-intersects", this, {
              addedRange: range,
              intersectingRange: storedRange
            });
          }
        }
        this._ranges.push(new Range$1(range.start, range.end));
      }
    };
    Selection$1.prototype.is = function(type) {
      return type === "selection" || type === "view:selection";
    };
    let DocumentSelection$1 = class DocumentSelection extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      constructor(...args) {
        super();
        /**
        * Selection is used internally (`DocumentSelection` is a proxy to that selection).
        */
        __publicField(this, "_selection");
        this._selection = new Selection$1();
        this._selection.delegate("change").to(this);
        if (args.length) {
          this._selection.setTo(...args);
        }
      }
      /**
      * Returns true if selection instance is marked as `fake`.
      *
      * @see #_setTo
      */
      get isFake() {
        return this._selection.isFake;
      }
      /**
      * Returns fake selection label.
      *
      * @see #_setTo
      */
      get fakeSelectionLabel() {
        return this._selection.fakeSelectionLabel;
      }
      /**
      * Selection anchor. Anchor may be described as a position where the selection starts. Together with
      * {@link #focus focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
      * It may be a bit unintuitive when there are multiple ranges in selection.
      *
      * @see #focus
      */
      get anchor() {
        return this._selection.anchor;
      }
      /**
      * Selection focus. Focus is a position where the selection ends.
      *
      * @see #anchor
      */
      get focus() {
        return this._selection.focus;
      }
      /**
      * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
      * collapsed.
      */
      get isCollapsed() {
        return this._selection.isCollapsed;
      }
      /**
      * Returns number of ranges in selection.
      */
      get rangeCount() {
        return this._selection.rangeCount;
      }
      /**
      * Specifies whether the {@link #focus} precedes {@link #anchor}.
      */
      get isBackward() {
        return this._selection.isBackward;
      }
      /**
      * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
      * if the selection is not inside an editable element.
      */
      get editableElement() {
        return this._selection.editableElement;
      }
      /**
      * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
      *
      * @internal
      */
      get _ranges() {
        return this._selection._ranges;
      }
      /**
      * Returns an iterable that contains copies of all ranges added to the selection.
      */
      *getRanges() {
        yield* this._selection.getRanges();
      }
      /**
      * Returns copy of the first range in the selection. First range is the one which
      * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
      * position of all other ranges (not to confuse with the first range added to the selection).
      * Returns `null` if no ranges are added to selection.
      */
      getFirstRange() {
        return this._selection.getFirstRange();
      }
      /**
      * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
      * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
      * with the last range added to the selection). Returns `null` if no ranges are added to selection.
      */
      getLastRange() {
        return this._selection.getLastRange();
      }
      /**
      * Returns copy of the first position in the selection. First position is the position that
      * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getFirstPosition() {
        return this._selection.getFirstPosition();
      }
      /**
      * Returns copy of the last position in the selection. Last position is the position that
      * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
      * Returns `null` if no ranges are added to selection.
      */
      getLastPosition() {
        return this._selection.getLastPosition();
      }
      /**
      * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        return this._selection.getSelectedElement();
      }
      /**
      * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
      * same number of ranges and all ranges from one selection equal to a range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are equal, `false` otherwise.
      */
      isEqual(otherSelection) {
        return this._selection.isEqual(otherSelection);
      }
      /**
      * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
      * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
      * equal to any trimmed range from other selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are similar, `false` otherwise.
      */
      isSimilar(otherSelection) {
        return this._selection.isSimilar(otherSelection);
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/view/selection~Selectable selectable}.
      *
      * ```ts
      * // Sets selection to the given range.
      * const range = writer.createRange( start, end );
      * documentSelection._setTo( range );
      *
      * // Sets selection to given ranges.
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
      * documentSelection._setTo( range );
      *
      * // Sets selection to the other selection.
      * const otherSelection = writer.createSelection();
      * documentSelection._setTo( otherSelection );
      *
      * // Sets collapsed selection at the given position.
      * const position = writer.createPositionAt( root, offset );
      * documentSelection._setTo( position );
      *
      * // Sets collapsed selection at the position of given item and offset.
      * documentSelection._setTo( paragraph, offset );
      * ```
      *
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * ```ts
      * documentSelection._setTo( paragraph, 'in' );
      * ```
      *
      * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
      *
      * ```ts
      * documentSelection._setTo( paragraph, 'on' );
      *
      * // Clears selection. Removes all ranges.
      * documentSelection._setTo( null );
      * ```
      *
      * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
      *
      * ```ts
      * // Sets selection as backward.
      * documentSelection._setTo( range, { backward: true } );
      * ```
      *
      * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
      * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
      * represented in other way, for example by applying proper CSS class.
      *
      * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
      * (and be  properly handled by screen readers).
      *
      * ```ts
      * // Creates fake selection with label.
      * documentSelection._setTo( range, { fake: true, label: 'foo' } );
      * ```
      *
      * @internal
      * @fires change
      */
      _setTo(...args) {
        this._selection.setTo(...args);
      }
      /**
      * Moves {@link #focus} to the specified location.
      *
      * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
      * parameters.
      *
      * @internal
      * @fires change
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      _setFocus(itemOrPosition, offset) {
        this._selection.setFocus(itemOrPosition, offset);
      }
    };
    DocumentSelection$1.prototype.is = function(type) {
      return type === "selection" || type == "documentSelection" || type == "view:selection" || type == "view:documentSelection";
    };
    class BubblingEventInfo extends EventInfo {
      /**
      * @param source The emitter.
      * @param name The event name.
      * @param startRange The view range that the bubbling should start from.
      */
      constructor(source, name, startRange) {
        super(source, name);
        /**
        * The view range that the bubbling should start from.
        */
        __publicField(this, "startRange");
        /**
        * The current event phase.
        */
        __publicField(this, "_eventPhase");
        /**
        * The current bubbling target.
        */
        __publicField(this, "_currentTarget");
        this.startRange = startRange;
        this._eventPhase = "none";
        this._currentTarget = null;
      }
      /**
      * The current event phase.
      */
      get eventPhase() {
        return this._eventPhase;
      }
      /**
      * The current bubbling target.
      */
      get currentTarget() {
        return this._currentTarget;
      }
    }
    const contextsSymbol = Symbol("bubbling contexts");
    function BubblingEmitterMixin(base) {
      class Mixin extends base {
        fire(eventOrInfo, ...eventArgs) {
          try {
            const eventInfo = eventOrInfo instanceof EventInfo ? eventOrInfo : new EventInfo(this, eventOrInfo);
            const eventContexts = getBubblingContexts(this);
            if (!eventContexts.size) {
              return;
            }
            updateEventInfo(eventInfo, "capturing", this);
            if (fireListenerFor(eventContexts, "$capture", eventInfo, ...eventArgs)) {
              return eventInfo.return;
            }
            const startRange = eventInfo.startRange || this.selection.getFirstRange();
            const selectedElement = startRange ? startRange.getContainedElement() : null;
            const isCustomContext = selectedElement ? Boolean(getCustomContext(eventContexts, selectedElement)) : false;
            let node = selectedElement || getDeeperRangeParent(startRange);
            updateEventInfo(eventInfo, "atTarget", node);
            if (!isCustomContext) {
              if (fireListenerFor(eventContexts, "$text", eventInfo, ...eventArgs)) {
                return eventInfo.return;
              }
              updateEventInfo(eventInfo, "bubbling", node);
            }
            while (node) {
              if (node.is("rootElement")) {
                if (fireListenerFor(eventContexts, "$root", eventInfo, ...eventArgs)) {
                  return eventInfo.return;
                }
              } else if (node.is("element")) {
                if (fireListenerFor(eventContexts, node.name, eventInfo, ...eventArgs)) {
                  return eventInfo.return;
                }
              }
              if (fireListenerFor(eventContexts, node, eventInfo, ...eventArgs)) {
                return eventInfo.return;
              }
              node = node.parent;
              updateEventInfo(eventInfo, "bubbling", node);
            }
            updateEventInfo(eventInfo, "bubbling", this);
            fireListenerFor(eventContexts, "$document", eventInfo, ...eventArgs);
            return eventInfo.return;
          } catch (err) {
            /* istanbul ignore next -- @preserve */
            CKEditorError.rethrowUnexpectedError(err, this);
          }
        }
        _addEventListener(event, callback, options) {
          const contexts = toArray$1(options.context || "$document");
          const eventContexts = getBubblingContexts(this);
          for (const context of contexts) {
            let emitter = eventContexts.get(context);
            if (!emitter) {
              emitter = new (EmitterMixin())();
              eventContexts.set(context, emitter);
            }
            this.listenTo(emitter, event, callback, options);
          }
        }
        _removeEventListener(event, callback) {
          const eventContexts = getBubblingContexts(this);
          for (const emitter of eventContexts.values()) {
            this.stopListening(emitter, event, callback);
          }
        }
      }
      return Mixin;
    }
    {
      const mixin = BubblingEmitterMixin(Object);
      [
        "fire",
        "_addEventListener",
        "_removeEventListener"
      ].forEach((key) => {
        BubblingEmitterMixin[key] = mixin.prototype[key];
      });
    }
    function updateEventInfo(eventInfo, eventPhase, currentTarget) {
      if (eventInfo instanceof BubblingEventInfo) {
        eventInfo._eventPhase = eventPhase;
        eventInfo._currentTarget = currentTarget;
      }
    }
    function fireListenerFor(eventContexts, context, eventInfo, ...eventArgs) {
      const emitter = typeof context == "string" ? eventContexts.get(context) : getCustomContext(eventContexts, context);
      if (!emitter) {
        return false;
      }
      emitter.fire(eventInfo, ...eventArgs);
      return eventInfo.stop.called;
    }
    function getCustomContext(eventContexts, node) {
      for (const [context, emitter] of eventContexts) {
        if (typeof context == "function" && context(node)) {
          return emitter;
        }
      }
      return null;
    }
    function getBubblingContexts(source) {
      if (!source[contextsSymbol]) {
        source[contextsSymbol] = /* @__PURE__ */ new Map();
      }
      return source[contextsSymbol];
    }
    function getDeeperRangeParent(range) {
      if (!range) {
        return null;
      }
      const startParent = range.start.parent;
      const endParent = range.end.parent;
      const startPath = startParent.getPath();
      const endPath = endParent.getPath();
      return startPath.length > endPath.length ? startParent : endParent;
    }
    let Document$1 = class Document extends (/* @__PURE__ */ BubblingEmitterMixin(/* @__PURE__ */ ObservableMixin())) {
      /**
      * Creates a Document instance.
      *
      * @param stylesProcessor The styles processor instance.
      */
      constructor(stylesProcessor) {
        super();
        /**
        * Selection done on this document.
        */
        __publicField(this, "selection");
        /**
        * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.
        *
        * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and
        * {@link module:engine/model/document~Document#roots} and this is handled by
        * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create
        * model root using {@link module:engine/model/document~Document#createRoot}.
        */
        __publicField(this, "roots");
        /**
        * The styles processor instance used by this document when normalizing styles.
        */
        __publicField(this, "stylesProcessor");
        /**
        * Post-fixer callbacks registered to the view document.
        */
        __publicField(this, "_postFixers", /* @__PURE__ */ new Set());
        this.selection = new DocumentSelection$1();
        this.roots = new Collection({
          idProperty: "rootName"
        });
        this.stylesProcessor = stylesProcessor;
        this.set("isReadOnly", false);
        this.set("isFocused", false);
        this.set("isSelecting", false);
        this.set("isComposing", false);
      }
      /**
      * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
      * specific "main" root is returned.
      *
      * @param name Name of the root.
      * @returns The view root element with the specified name or null when there is no root of given name.
      */
      getRoot(name = "main") {
        return this.roots.get(name);
      }
      /**
      * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
      * to the DOM.
      *
      * Post-fixers are executed right after all changes from the outermost change block were applied but
      * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
      * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
      * not be fixed in the new document tree state.
      *
      * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
      * changes executed in a view post-fixer should not break model-view mapping.
      *
      * The types of changes which should be safe:
      *
      * * adding or removing attribute from elements,
      * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
      * * {@link module:engine/controller/editingcontroller~EditingController#reconvertItem marking some of the model elements to be
      * re-converted}.
      *
      * Try to avoid changes which touch view structure:
      *
      * * you should not add or remove nor wrap or unwrap any view elements,
      * * you should not change the editor data model in a view post-fixer.
      *
      * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
      *
      * Typically, a post-fixer will look like this:
      *
      * ```ts
      * editor.editing.view.document.registerPostFixer( writer => {
      * 	if ( checkSomeCondition() ) {
      * 		writer.doSomething();
      *
      * 		// Let other post-fixers know that something changed.
      * 		return true;
      * 	}
      *
      * 	return false;
      * } );
      * ```
      *
      * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
      * That is because adding a post-fixer does not execute it.
      * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
      * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
      * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
      *
      * If you need to register a callback which is executed when DOM elements are already updated,
      * use {@link module:engine/view/view~View#event:render render event}.
      */
      registerPostFixer(postFixer) {
        this._postFixers.add(postFixer);
      }
      /**
      * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
      */
      destroy() {
        this.roots.forEach((root2) => root2.destroy());
        this.stopListening();
      }
      /**
      * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
      *
      * @internal
      */
      _callPostFixers(writer) {
        let wasFixed = false;
        do {
          for (const callback of this._postFixers) {
            wasFixed = callback(writer);
            if (wasFixed) {
              break;
            }
          }
        } while (wasFixed);
      }
    };
    const DEFAULT_PRIORITY = 10;
    class AttributeElement extends Element$1 {
      /**
      * Creates an attribute element.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
      * @see module:engine/view/element~Element
      * @protected
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        /**
        * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
        *
        * @internal
        * @readonly
        */
        __publicField(this, "_priority", DEFAULT_PRIORITY);
        /**
        * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
        * and then two elements are considered similar if, and only if they have the same `_id`.
        *
        * @internal
        * @readonly
        */
        __publicField(this, "_id", null);
        /**
        * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~AttributeElement#id ids}
        * and still exist in the view tree.
        *
        * This property is managed by {@link module:engine/view/downcastwriter~DowncastWriter}.
        */
        __publicField(this, "_clonesGroup", null);
        this.getFillerOffset = getFillerOffset$3;
      }
      /**
      * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
      */
      get priority() {
        return this._priority;
      }
      /**
      * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
      * and then two elements are considered similar if, and only if they have the same `id`.
      */
      get id() {
        return this._id;
      }
      /**
      * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
      * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
      *
      * Note: If this element has been removed from the tree, returned set will not include it.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
      * if this element has no `id`.
      *
      * @returns Set containing all the attribute elements
      * with the same `id` that were added and not removed from the view tree.
      */
      getElementsWithSameId() {
        if (this.id === null) {
          throw new CKEditorError("attribute-element-get-elements-with-same-id-no-id", this);
        }
        return new Set(this._clonesGroup);
      }
      /**
      * Checks if this element is similar to other element.
      *
      * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
      * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
      * different set of children nodes.
      *
      * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
      * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
      * considered similar.
      *
      * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
      *
      * * two following similar elements can be merged together into one, longer element,
      * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
      * decide whether processed element should be unwrapped,
      * * etc.
      */
      isSimilar(otherElement) {
        if (this.id !== null || otherElement.id !== null) {
          return this.id === otherElement.id;
        }
        return super.isSimilar(otherElement) && this.priority == otherElement.priority;
      }
      /**
      * Clones provided element with priority.
      *
      * @internal
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns Clone of this element.
      */
      _clone(deep = false) {
        const cloned = super._clone(deep);
        cloned._priority = this._priority;
        cloned._id = this._id;
        return cloned;
      }
    }
    __publicField(AttributeElement, "DEFAULT_PRIORITY", DEFAULT_PRIORITY);
    AttributeElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "attributeElement" || type === "view:attributeElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$3() {
      if (nonUiChildrenCount(this)) {
        return null;
      }
      let element = this.parent;
      while (element && element.is("attributeElement")) {
        if (nonUiChildrenCount(element) > 1) {
          return null;
        }
        element = element.parent;
      }
      if (!element || nonUiChildrenCount(element) > 1) {
        return null;
      }
      return this.childCount;
    }
    function nonUiChildrenCount(element) {
      return Array.from(element.getChildren()).filter((element2) => !element2.is("uiElement")).length;
    }
    class EmptyElement extends Element$1 {
      /**
      * Creates new instance of EmptyElement.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
      * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attributes, children) {
        super(document2, name, attributes, children);
        this.getFillerOffset = getFillerOffset$2;
      }
      /**
      * Overrides {@link module:engine/view/element~Element#_insertChild} method.
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
      * adding any child nodes to EmptyElement.
      *
      * @internal
      */
      _insertChild(index2, items) {
        if (items && (items instanceof Node$2 || Array.from(items).length > 0)) {
          throw new CKEditorError("view-emptyelement-cannot-add", [
            this,
            items
          ]);
        }
        return 0;
      }
    }
    EmptyElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "emptyElement" || type === "view:emptyElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "emptyElement" || type === "view:emptyElement" || type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$2() {
      return null;
    }
    class UIElement extends Element$1 {
      /**
      * Creates new instance of UIElement.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
      * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        this.getFillerOffset = getFillerOffset$1;
      }
      /**
      * Overrides {@link module:engine/view/element~Element#_insertChild} method.
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
      * to UIElement.
      *
      * @internal
      */
      _insertChild(index2, items) {
        if (items && (items instanceof Node$2 || Array.from(items).length > 0)) {
          throw new CKEditorError("view-uielement-cannot-add", [
            this,
            items
          ]);
        }
        return 0;
      }
      /**
      * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
      * {@link module:engine/view/domconverter~DomConverter}.
      * Do not use inheritance to create custom rendering method, replace `render()` method instead:
      *
      * ```ts
      * const myUIElement = downcastWriter.createUIElement( 'span' );
      * myUIElement.render = function( domDocument, domConverter ) {
      * 	const domElement = this.toDomElement( domDocument );
      *
      * 	domConverter.setContentOf( domElement, '<b>this is ui element</b>' );
      *
      * 	return domElement;
      * };
      * ```
      *
      * If changes in your UI element should trigger some editor UI update you should call
      * the {@link module:ui/editorui/editorui~EditorUI#update `editor.ui.update()`} method
      * after rendering your UI element.
      *
      * @param domConverter Instance of the DomConverter used to optimize the output.
      */
      render(domDocument, domConverter) {
        return this.toDomElement(domDocument);
      }
      /**
      * Creates DOM element based on this view UIElement.
      * Note that each time this method is called new DOM element is created.
      */
      toDomElement(domDocument) {
        const domElement = domDocument.createElement(this.name);
        for (const key of this.getAttributeKeys()) {
          domElement.setAttribute(key, this.getAttribute(key));
        }
        return domElement;
      }
    }
    UIElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "uiElement" || type === "view:uiElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "uiElement" || type === "view:uiElement" || type === "element" || type === "view:element");
      }
    };
    function injectUiElementHandling(view) {
      view.document.on("arrowKey", (evt, data) => jumpOverUiElement(evt, data, view.domConverter), {
        priority: "low"
      });
    }
    function getFillerOffset$1() {
      return null;
    }
    function jumpOverUiElement(evt, data, domConverter) {
      if (data.keyCode == keyCodes.arrowright) {
        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
        const domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed;
        if (domSelectionCollapsed || data.shiftKey) {
          const domParent = domSelection.focusNode;
          const domOffset = domSelection.focusOffset;
          const viewPosition = domConverter.domPositionToView(domParent, domOffset);
          if (viewPosition === null) {
            return;
          }
          let jumpedOverAnyUiElement = false;
          const nextViewPosition = viewPosition.getLastMatchingPosition((value) => {
            if (value.item.is("uiElement")) {
              jumpedOverAnyUiElement = true;
            }
            if (value.item.is("uiElement") || value.item.is("attributeElement")) {
              return true;
            }
            return false;
          });
          if (jumpedOverAnyUiElement) {
            const newDomPosition = domConverter.viewPositionToDom(nextViewPosition);
            if (domSelectionCollapsed) {
              domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
            } else {
              domSelection.extend(newDomPosition.parent, newDomPosition.offset);
            }
          }
        }
      }
    }
    class RawElement extends Element$1 {
      /**
      * Creates a new instance of a raw element.
      *
      * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} when the `children`
      * parameter is passed to inform that the usage of `RawElement` is incorrect (adding child nodes to `RawElement` is forbidden).
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#createRawElement
      * @internal
      * @param document The document instance to which this element belongs.
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      */
      constructor(document2, name, attrs, children) {
        super(document2, name, attrs, children);
        this.getFillerOffset = getFillerOffset$5;
      }
      /**
      * Overrides the {@link module:engine/view/element~Element#_insertChild} method.
      * Throws the `view-rawelement-cannot-add` {@link module:utils/ckeditorerror~CKEditorError CKEditorError} to prevent
      * adding any child nodes to a raw element.
      *
      * @internal
      */
      _insertChild(index2, items) {
        if (items && (items instanceof Node$2 || Array.from(items).length > 0)) {
          throw new CKEditorError("view-rawelement-cannot-add", [
            this,
            items
          ]);
        }
        return 0;
      }
      /**
      * This allows rendering the children of a {@link module:engine/view/rawelement~RawElement} on the DOM level.
      * This method is called by the {@link module:engine/view/domconverter~DomConverter} with the raw DOM element
      * passed as an argument, leaving the number and shape of the children up to the integrator.
      *
      * This method **must be defined** for the raw element to work:
      *
      * ```ts
      * const myRawElement = downcastWriter.createRawElement( 'div' );
      *
      * myRawElement.render = function( domElement, domConverter ) {
      * 	domConverter.setContentOf( domElement, '<b>This is the raw content of myRawElement.</b>' );
      * };
      * ```
      *
      * @param domElement The native DOM element representing the raw view element.
      * @param domConverter Instance of the DomConverter used to optimize the output.
      */
      render(domElement, domConverter) {
      }
    }
    RawElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "rawElement" || type === "view:rawElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === "view:" + this.name || type === "element" || type === "view:element" || type === "node" || type === "view:node";
      } else {
        return name === this.name && (type === "rawElement" || type === "view:rawElement" || type === "element" || type === "view:element");
      }
    };
    function getFillerOffset$5() {
      return null;
    }
    let DocumentFragment$1 = class DocumentFragment extends (/* @__PURE__ */ EmitterMixin(TypeCheckable$1)) {
      /**
      * Creates new DocumentFragment instance.
      *
      * @internal
      * @param document The document to which this document fragment belongs.
      * @param children A list of nodes to be inserted into the created document fragment.
      */
      constructor(document2, children) {
        super();
        /**
        * The document to which this document fragment belongs.
        */
        __publicField(this, "document");
        /**
        * Array of child nodes.
        */
        __publicField(this, "_children", []);
        /**
        * Map of custom properties.
        * Custom properties can be added to document fragment instance.
        */
        __publicField(this, "_customProperties", /* @__PURE__ */ new Map());
        this.document = document2;
        if (children) {
          this._insertChild(0, children);
        }
      }
      /**
      * Iterable interface.
      *
      * Iterates over nodes added to this document fragment.
      */
      [Symbol.iterator]() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Number of child nodes in this document fragment.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
      */
      get isEmpty() {
        return this.childCount === 0;
      }
      /**
      * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
      */
      get root() {
        return this;
      }
      /**
      * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
      */
      get parent() {
        return null;
      }
      /**
      * Artificial element name. Returns `undefined`. Added for compatibility reasons.
      */
      get name() {
        return void 0;
      }
      /**
      * Artificial element getFillerOffset. Returns `undefined`. Added for compatibility reasons.
      */
      get getFillerOffset() {
        return void 0;
      }
      /**
      * Returns the custom property value for the given key.
      */
      getCustomProperty(key) {
        return this._customProperties.get(key);
      }
      /**
      * Returns an iterator which iterates over this document fragment's custom properties.
      * Iterator provides `[ key, value ]` pairs for each stored property.
      */
      *getCustomProperties() {
        yield* this._customProperties.entries();
      }
      /**
      * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
      * and sets the parent of these nodes to this fragment.
      *
      * @internal
      * @param items Items to be inserted.
      * @returns Number of appended nodes.
      */
      _appendChild(items) {
        return this._insertChild(this.childCount, items);
      }
      /**
      * Gets child at the given index.
      *
      * @param index Index of child.
      * @returns Child node.
      */
      getChild(index2) {
        return this._children[index2];
      }
      /**
      * Gets index of the given child node. Returns `-1` if child node is not found.
      *
      * @param node Child node.
      * @returns Index of the child node.
      */
      getChildIndex(node) {
        return this._children.indexOf(node);
      }
      /**
      * Gets child nodes iterator.
      *
      * @returns Child nodes iterator.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
      * this fragment.
      *
      * @internal
      * @param index Position where nodes should be inserted.
      * @param items Items to be inserted.
      * @returns Number of inserted nodes.
      */
      _insertChild(index2, items) {
        this._fireChange("children", this);
        let count2 = 0;
        const nodes = normalize$2(this.document, items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
          this._children.splice(index2, 0, node);
          index2++;
          count2++;
        }
        return count2;
      }
      /**
      * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
      *
      * @internal
      * @param index Number of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns The array of removed nodes.
      */
      _removeChildren(index2, howMany = 1) {
        this._fireChange("children", this);
        for (let i = index2; i < index2 + howMany; i++) {
          this._children[i].parent = null;
        }
        return this._children.splice(index2, howMany);
      }
      /**
      * Fires `change` event with given type of the change.
      *
      * @internal
      * @param type Type of the change.
      * @param node Changed node.
      */
      _fireChange(type, node) {
        this.fire("change:" + type, node);
      }
      /**
      * Sets a custom property. They can be used to add special data to elements.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
      * @internal
      */
      _setCustomProperty(key, value) {
        this._customProperties.set(key, value);
      }
      /**
      * Removes the custom property stored under the given key.
      *
      * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
      * @internal
      * @returns Returns true if property was removed.
      */
      _removeCustomProperty(key) {
        return this._customProperties.delete(key);
      }
    };
    DocumentFragment$1.prototype.is = function(type) {
      return type === "documentFragment" || type === "view:documentFragment";
    };
    function normalize$2(document2, nodes) {
      if (typeof nodes == "string") {
        return [
          new Text$1(document2, nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text$1(document2, node);
        }
        if (node instanceof TextProxy$1) {
          return new Text$1(document2, node.data);
        }
        return node;
      });
    }
    class DowncastWriter {
      /**
      * @param document The view document instance.
      */
      constructor(document2) {
        /**
        * The view document instance in which this writer operates.
        */
        __publicField(this, "document");
        /**
        * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.
        * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.
        */
        __publicField(this, "_cloneGroups", /* @__PURE__ */ new Map());
        /**
        * The slot factory used by the `elementToStructure` downcast helper.
        */
        __publicField(this, "_slotFactory", null);
        this.document = document2;
      }
      setSelection(...args) {
        this.document.selection._setTo(...args);
      }
      /**
      * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
      *
      * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
      * parameters.
      *
      * @param Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
      */
      setSelectionFocus(itemOrPosition, offset) {
        this.document.selection._setFocus(itemOrPosition, offset);
      }
      /**
      * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
      *
      * @param children A list of nodes to be inserted into the created document fragment.
      * @returns The created document fragment.
      */
      createDocumentFragment(children) {
        return new DocumentFragment$1(this.document, children);
      }
      /**
      * Creates a new {@link module:engine/view/text~Text text node}.
      *
      * ```ts
      * writer.createText( 'foo' );
      * ```
      *
      * @param data The text's data.
      * @returns The created text node.
      */
      createText(data) {
        return new Text$1(this.document, data);
      }
      /**
      * Creates a new {@link module:engine/view/attributeelement~AttributeElement}.
      *
      * ```ts
      * writer.createAttributeElement( 'strong' );
      * writer.createAttributeElement( 'a', { href: 'foo.bar' } );
      *
      * // Make `<a>` element contain other attributes element so the `<a>` element is not broken.
      * writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
      *
      * // Set `id` of a marker element so it is not joined or merged with "normal" elements.
      * writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
      * ```
      *
      * @param name Name of the element.
      * @param attributes Element's attributes.
      * @param options Element's options.
      * @param options.priority Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
      * @param options.id Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns Created element.
      */
      createAttributeElement(name, attributes, options = {}) {
        const attributeElement = new AttributeElement(this.document, name, attributes);
        if (typeof options.priority === "number") {
          attributeElement._priority = options.priority;
        }
        if (options.id) {
          attributeElement._id = options.id;
        }
        if (options.renderUnsafeAttributes) {
          attributeElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return attributeElement;
      }
      createContainerElement(name, attributes, childrenOrOptions = {}, options = {}) {
        let children = null;
        if (isPlainObject(childrenOrOptions)) {
          options = childrenOrOptions;
        } else {
          children = childrenOrOptions;
        }
        const containerElement = new ContainerElement(this.document, name, attributes, children);
        if (options.renderUnsafeAttributes) {
          containerElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return containerElement;
      }
      /**
      * Creates a new {@link module:engine/view/editableelement~EditableElement}.
      *
      * ```ts
      * writer.createEditableElement( 'div' );
      * writer.createEditableElement( 'div', { id: 'foo-1234' } );
      * ```
      *
      * Note: The editable element is to be used in the editing pipeline. Usually, together with
      * {@link module:widget/utils~toWidgetEditable `toWidgetEditable()`}.
      *
      * @param name Name of the element.
      * @param attributes Elements attributes.
      * @param options Element's options.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns Created element.
      */
      createEditableElement(name, attributes, options = {}) {
        const editableElement = new EditableElement(this.document, name, attributes);
        if (options.renderUnsafeAttributes) {
          editableElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return editableElement;
      }
      /**
      * Creates a new {@link module:engine/view/emptyelement~EmptyElement}.
      *
      * ```ts
      * writer.createEmptyElement( 'img' );
      * writer.createEmptyElement( 'img', { id: 'foo-1234' } );
      * ```
      *
      * @param name Name of the element.
      * @param attributes Elements attributes.
      * @param options Element's options.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns Created element.
      */
      createEmptyElement(name, attributes, options = {}) {
        const emptyElement = new EmptyElement(this.document, name, attributes);
        if (options.renderUnsafeAttributes) {
          emptyElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return emptyElement;
      }
      /**
      * Creates a new {@link module:engine/view/uielement~UIElement}.
      *
      * ```ts
      * writer.createUIElement( 'span' );
      * writer.createUIElement( 'span', { id: 'foo-1234' } );
      * ```
      *
      * A custom render function can be provided as the third parameter:
      *
      * ```ts
      * writer.createUIElement( 'span', null, function( domDocument ) {
      * 	const domElement = this.toDomElement( domDocument );
      * 	domElement.innerHTML = '<b>this is ui element</b>';
      *
      * 	return domElement;
      * } );
      * ```
      *
      * Unlike {@link #createRawElement raw elements}, UI elements are by no means editor content, for instance,
      * they are ignored by the editor selection system.
      *
      * You should not use UI elements as data containers. Check out {@link #createRawElement} instead.
      *
      * @param name The name of the element.
      * @param attributes Element attributes.
      * @param renderFunction A custom render function.
      * @returns The created element.
      */
      createUIElement(name, attributes, renderFunction) {
        const uiElement = new UIElement(this.document, name, attributes);
        if (renderFunction) {
          uiElement.render = renderFunction;
        }
        return uiElement;
      }
      /**
      * Creates a new {@link module:engine/view/rawelement~RawElement}.
      *
      * ```ts
      * writer.createRawElement( 'span', { id: 'foo-1234' }, function( domElement ) {
      * 	domElement.innerHTML = '<b>This is the raw content of the raw element.</b>';
      * } );
      * ```
      *
      * Raw elements work as data containers ("wrappers", "sandboxes") but their children are not managed or
      * even recognized by the editor. This encapsulation allows integrations to maintain custom DOM structures
      * in the editor content without, for instance, worrying about compatibility with other editor features.
      * Raw elements are a perfect tool for integration with external frameworks and data sources.
      *
      * Unlike {@link #createUIElement UI elements}, raw elements act like "real" editor content (similar to
      * {@link module:engine/view/containerelement~ContainerElement} or {@link module:engine/view/emptyelement~EmptyElement}),
      * and they are considered by the editor selection.
      *
      * You should not use raw elements to render the UI in the editor content. Check out {@link #createUIElement `#createUIElement()`}
      * instead.
      *
      * @param name The name of the element.
      * @param attributes Element attributes.
      * @param renderFunction A custom render function.
      * @param options Element's options.
      * @param options.renderUnsafeAttributes A list of attribute names that should be rendered in the editing
      * pipeline even though they would normally be filtered out by unsafe attribute detection mechanisms.
      * @returns The created element.
      */
      createRawElement(name, attributes, renderFunction, options = {}) {
        const rawElement = new RawElement(this.document, name, attributes);
        if (renderFunction) {
          rawElement.render = renderFunction;
        }
        if (options.renderUnsafeAttributes) {
          rawElement._unsafeAttributesToRender.push(...options.renderUnsafeAttributes);
        }
        return rawElement;
      }
      /**
      * Adds or overwrites the element's attribute with a specified key and value.
      *
      * ```ts
      * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
      * ```
      *
      * @param key The attribute key.
      * @param value The attribute value.
      */
      setAttribute(key, value, element) {
        element._setAttribute(key, value);
      }
      /**
      * Removes attribute from the element.
      *
      * ```ts
      * writer.removeAttribute( 'href', linkElement );
      * ```
      *
      * @param key Attribute key.
      */
      removeAttribute(key, element) {
        element._removeAttribute(key);
      }
      /**
      * Adds specified class to the element.
      *
      * ```ts
      * writer.addClass( 'foo', linkElement );
      * writer.addClass( [ 'foo', 'bar' ], linkElement );
      * ```
      */
      addClass(className, element) {
        element._addClass(className);
      }
      /**
      * Removes specified class from the element.
      *
      * ```ts
      * writer.removeClass( 'foo', linkElement );
      * writer.removeClass( [ 'foo', 'bar' ], linkElement );
      * ```
      */
      removeClass(className, element) {
        element._removeClass(className);
      }
      setStyle(property2, value, element) {
        if (isPlainObject(property2) && element === void 0) {
          value._setStyle(property2);
        } else {
          element._setStyle(property2, value);
        }
      }
      /**
      * Removes specified style from the element.
      *
      * ```ts
      * writer.removeStyle( 'color', element ); // Removes 'color' style.
      * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
      * ```
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
      */
      removeStyle(property2, element) {
        element._removeStyle(property2);
      }
      /**
      * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
      * so they can be used to add special data to elements.
      */
      setCustomProperty(key, value, element) {
        element._setCustomProperty(key, value);
      }
      /**
      * Removes a custom property stored under the given key.
      *
      * @returns Returns true if property was removed.
      */
      removeCustomProperty(key, element) {
        return element._removeCustomProperty(key);
      }
      /**
      * Breaks attribute elements at the provided position or at the boundaries of a provided range. It breaks attribute elements
      * up to their first ancestor that is a container element.
      *
      * In following examples `<p>` is a container, `<b>` and `<u>` are attribute elements:
      *
      * ```html
      * <p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
      * <p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
      * <p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
      * <p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
      * ```
      *
      * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
      *
      * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
      * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
      * `breakContainer()` assumes that a given `position` is directly in the container element and breaks that container element.
      *
      * Throws the `view-writer-invalid-range-container` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * when the {@link module:engine/view/range~Range#start start}
      * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
      *
      * Throws the `view-writer-cannot-break-empty-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * when trying to break attributes inside an {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
      *
      * Throws the `view-writer-cannot-break-ui-element` {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * when trying to break attributes inside a {@link module:engine/view/uielement~UIElement UIElement}.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
      * @param positionOrRange The position where to break attribute elements.
      * @returns The new position or range, after breaking the attribute elements.
      */
      breakAttributes(positionOrRange) {
        if (positionOrRange instanceof Position$1) {
          return this._breakAttributes(positionOrRange);
        } else {
          return this._breakAttributesRange(positionOrRange);
        }
      }
      /**
      * Breaks a {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position.
      * The position has to be directly inside the container element and cannot be in the root. It does not break the conrainer view element
      * if the position is at the beginning or at the end of its parent element.
      *
      * ```html
      * <p>foo^bar</p> -> <p>foo</p><p>bar</p>
      * <div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
      * <p>^foobar</p> -> ^<p>foobar</p>
      * <p>foobar^</p> -> <p>foobar</p>^
      * ```
      *
      * **Note:** The difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes()} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer()} is that `breakAttributes()` breaks all
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of a given `position`,
      * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
      * `breakContainer()` assumes that the given `position` is directly in the container element and breaks that container element.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
      * @param position The position where to break the element.
      * @returns The position between broken elements. If an element has not been broken,
      * the returned position is placed either before or after it.
      */
      breakContainer(position) {
        const element = position.parent;
        if (!element.is("containerElement")) {
          throw new CKEditorError("view-writer-break-non-container-element", this.document);
        }
        if (!element.parent) {
          throw new CKEditorError("view-writer-break-root", this.document);
        }
        if (position.isAtStart) {
          return Position$1._createBefore(element);
        } else if (!position.isAtEnd) {
          const newElement = element._clone(false);
          this.insert(Position$1._createAfter(element), newElement);
          const sourceRange = new Range$1(position, Position$1._createAt(element, "end"));
          const targetPosition = new Position$1(newElement, 0);
          this.move(sourceRange, targetPosition);
        }
        return Position$1._createAfter(element);
      }
      /**
      * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
      * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
      *
      * In following examples `<p>` is a container and `<b>` is an attribute element:
      *
      * ```html
      * <p>foo[]bar</p> -> <p>foo{}bar</p>
      * <p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
      * <p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
      * ```
      *
      * It will also take care about empty attributes when merging:
      *
      * ```html
      * <p><b>[]</b></p> -> <p>[]</p>
      * <p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
      * ```
      *
      * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
      * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
      * @param position Merge position.
      * @returns Position after merge.
      */
      mergeAttributes(position) {
        const positionOffset = position.offset;
        const positionParent = position.parent;
        if (positionParent.is("$text")) {
          return position;
        }
        if (positionParent.is("attributeElement") && positionParent.childCount === 0) {
          const parent2 = positionParent.parent;
          const offset = positionParent.index;
          positionParent._remove();
          this._removeFromClonedElementsGroup(positionParent);
          return this.mergeAttributes(new Position$1(parent2, offset));
        }
        const nodeBefore = positionParent.getChild(positionOffset - 1);
        const nodeAfter = positionParent.getChild(positionOffset);
        if (!nodeBefore || !nodeAfter) {
          return position;
        }
        if (nodeBefore.is("$text") && nodeAfter.is("$text")) {
          return mergeTextNodes(nodeBefore, nodeAfter);
        } else if (nodeBefore.is("attributeElement") && nodeAfter.is("attributeElement") && nodeBefore.isSimilar(nodeAfter)) {
          const count2 = nodeBefore.childCount;
          nodeBefore._appendChild(nodeAfter.getChildren());
          nodeAfter._remove();
          this._removeFromClonedElementsGroup(nodeAfter);
          return this.mergeAttributes(new Position$1(nodeBefore, count2));
        }
        return position;
      }
      /**
      * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
      * Precisely, the element after the position is removed and it's contents are moved to element before the position.
      *
      * ```html
      * <p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
      * <div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
      * ```
      *
      * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
      * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
      * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
      * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
      *
      * @see module:engine/view/attributeelement~AttributeElement
      * @see module:engine/view/containerelement~ContainerElement
      * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
      * @param position Merge position.
      * @returns Position after merge.
      */
      mergeContainers(position) {
        const prev = position.nodeBefore;
        const next = position.nodeAfter;
        if (!prev || !next || !prev.is("containerElement") || !next.is("containerElement")) {
          throw new CKEditorError("view-writer-merge-containers-invalid-position", this.document);
        }
        const lastChild = prev.getChild(prev.childCount - 1);
        const newPosition = lastChild instanceof Text$1 ? Position$1._createAt(lastChild, "end") : Position$1._createAt(prev, "end");
        this.move(Range$1._createIn(next), Position$1._createAt(prev, "end"));
        this.remove(Range$1._createOn(next));
        return newPosition;
      }
      /**
      * Inserts a node or nodes at specified position. Takes care about breaking attributes before insertion
      * and merging them afterwards.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
      * contains instances that are not {@link module:engine/view/text~Text Texts},
      * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
      * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
      * {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
      * {@link module:engine/view/rawelement~RawElement RawElements} or
      * {@link module:engine/view/uielement~UIElement UIElements}.
      *
      * @param position Insertion position.
      * @param nodes Node or nodes to insert.
      * @returns Range around inserted nodes.
      */
      insert(position, nodes) {
        nodes = isIterable(nodes) ? [
          ...nodes
        ] : [
          nodes
        ];
        validateNodesToInsert(nodes, this.document);
        const nodeGroups = nodes.reduce((groups, node) => {
          const lastGroup = groups[groups.length - 1];
          const breakAttributes = !node.is("uiElement");
          if (!lastGroup || lastGroup.breakAttributes != breakAttributes) {
            groups.push({
              breakAttributes,
              nodes: [
                node
              ]
            });
          } else {
            lastGroup.nodes.push(node);
          }
          return groups;
        }, []);
        let start = null;
        let end = position;
        for (const { nodes: nodes2, breakAttributes } of nodeGroups) {
          const range = this._insertNodes(end, nodes2, breakAttributes);
          if (!start) {
            start = range.start;
          }
          end = range.end;
        }
        if (!start) {
          return new Range$1(position);
        }
        return new Range$1(start, end);
      }
      /**
      * Removes provided range from the container.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      *
      * @param rangeOrItem Range to remove from container
      * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
      * to a collapsed range showing the new position.
      * @returns Document fragment containing removed nodes.
      */
      remove(rangeOrItem) {
        const range = rangeOrItem instanceof Range$1 ? rangeOrItem : Range$1._createOn(rangeOrItem);
        validateRangeContainer(range, this.document);
        if (range.isCollapsed) {
          return new DocumentFragment$1(this.document);
        }
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
        const parentContainer = breakStart.parent;
        const count2 = breakEnd.offset - breakStart.offset;
        const removed = parentContainer._removeChildren(breakStart.offset, count2);
        for (const node of removed) {
          this._removeFromClonedElementsGroup(node);
        }
        const mergePosition = this.mergeAttributes(breakStart);
        range.start = mergePosition;
        range.end = mergePosition.clone();
        return new DocumentFragment$1(this.document, removed);
      }
      /**
      * Removes matching elements from given range.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      *
      * @param range Range to clear.
      * @param element Element to remove.
      */
      clear(range, element) {
        validateRangeContainer(range, this.document);
        const walker = range.getWalker({
          direction: "backward",
          ignoreElementEnd: true
        });
        for (const current of walker) {
          const item = current.item;
          let rangeToRemove;
          if (item.is("element") && element.isSimilar(item)) {
            rangeToRemove = Range$1._createOn(item);
          } else if (!current.nextPosition.isAfter(range.start) && item.is("$textProxy")) {
            const parentElement = item.getAncestors().find((ancestor) => {
              return ancestor.is("element") && element.isSimilar(ancestor);
            });
            if (parentElement) {
              rangeToRemove = Range$1._createIn(parentElement);
            }
          }
          if (rangeToRemove) {
            if (rangeToRemove.end.isAfter(range.end)) {
              rangeToRemove.end = range.end;
            }
            if (rangeToRemove.start.isBefore(range.start)) {
              rangeToRemove.start = range.start;
            }
            this.remove(rangeToRemove);
          }
        }
      }
      /**
      * Moves nodes from provided range to target position.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      *
      * @param sourceRange Range containing nodes to move.
      * @param targetPosition Position to insert.
      * @returns Range in target container. Inserted nodes are placed between
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
      */
      move(sourceRange, targetPosition) {
        let nodes;
        if (targetPosition.isAfter(sourceRange.end)) {
          targetPosition = this._breakAttributes(targetPosition, true);
          const parent2 = targetPosition.parent;
          const countBefore = parent2.childCount;
          sourceRange = this._breakAttributesRange(sourceRange, true);
          nodes = this.remove(sourceRange);
          targetPosition.offset += parent2.childCount - countBefore;
        } else {
          nodes = this.remove(sourceRange);
        }
        return this.insert(targetPosition, nodes);
      }
      /**
      * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
      *
      * If a collapsed range was passed and is same as selection, the selection
      * will be moved to the inside of the wrapped attribute element.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
      * when {@link module:engine/view/range~Range#start}
      * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
      * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
      * is collapsed and different than view selection.
      *
      * @param range Range to wrap.
      * @param attribute Attribute element to use as wrapper.
      * @returns range Range after wrapping, spanning over wrapping attribute element.
      */
      wrap(range, attribute) {
        if (!(attribute instanceof AttributeElement)) {
          throw new CKEditorError("view-writer-wrap-invalid-attribute", this.document);
        }
        validateRangeContainer(range, this.document);
        if (!range.isCollapsed) {
          return this._wrapRange(range, attribute);
        } else {
          let position = range.start;
          if (position.parent.is("element") && !_hasNonUiChildren(position.parent)) {
            position = position.getLastMatchingPosition((value) => value.item.is("uiElement"));
          }
          position = this._wrapPosition(position, attribute);
          const viewSelection = this.document.selection;
          if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {
            this.setSelection(position);
          }
          return new Range$1(position);
        }
      }
      /**
      * Unwraps nodes within provided range from attribute element.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
      * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
      * same parent container.
      */
      unwrap(range, attribute) {
        if (!(attribute instanceof AttributeElement)) {
          throw new CKEditorError("view-writer-unwrap-invalid-attribute", this.document);
        }
        validateRangeContainer(range, this.document);
        if (range.isCollapsed) {
          return range;
        }
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
        const parentContainer = breakStart.parent;
        const newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
        const start = this.mergeAttributes(newRange.start);
        if (!start.isEqual(newRange.start)) {
          newRange.end.offset--;
        }
        const end = this.mergeAttributes(newRange.end);
        return new Range$1(start, end);
      }
      /**
      * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
      * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
      * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
      *
      * New element has to be created because `Element#tagName` property in DOM is readonly.
      *
      * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
      *
      * @param newName New name for element.
      * @param viewElement Element to be renamed.
      * @returns Element created due to rename.
      */
      rename(newName, viewElement) {
        const newElement = new ContainerElement(this.document, newName, viewElement.getAttributes());
        this.insert(Position$1._createAfter(viewElement), newElement);
        this.move(Range$1._createIn(viewElement), Position$1._createAt(newElement, 0));
        this.remove(Range$1._createOn(viewElement));
        return newElement;
      }
      /**
      * Cleans up memory by removing obsolete cloned elements group from the writer.
      *
      * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
      * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
      * the group will no longer be needed.
      *
      * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
      * were removed from the view.
      *
      * Keep in mind that group names are equal to the `id` property of the attribute element.
      *
      * @param groupName Name of the group to clear.
      */
      clearClonedElementsGroup(groupName) {
        this._cloneGroups.delete(groupName);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link #createPositionBefore},
      * * {@link #createPositionAfter},
      *
      * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/view/item~Item view item}.
      */
      createPositionAt(itemOrPosition, offset) {
        return Position$1._createAt(itemOrPosition, offset);
      }
      /**
      * Creates a new position after given view item.
      *
      * @param item View item after which the position should be located.
      */
      createPositionAfter(item) {
        return Position$1._createAfter(item);
      }
      /**
      * Creates a new position before given view item.
      *
      * @param item View item before which the position should be located.
      */
      createPositionBefore(item) {
        return Position$1._createBefore(item);
      }
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start, end) {
        return new Range$1(start, end);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      */
      createRangeOn(item) {
        return Range$1._createOn(item);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range$1._createIn(element);
      }
      createSelection(...args) {
        return new Selection$1(...args);
      }
      /**
      * Creates placeholders for child elements of the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
      * `elementToStructure()`} conversion helper.
      *
      * ```ts
      * const viewSlot = conversionApi.writer.createSlot();
      * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
      *
      * conversionApi.writer.insert( viewPosition, viewSlot );
      * ```
      *
      * It could be filtered down to a specific subset of children (only `<foo>` model elements in this case):
      *
      * ```ts
      * const viewSlot = conversionApi.writer.createSlot( node => node.is( 'element', 'foo' ) );
      * const viewPosition = conversionApi.writer.createPositionAt( viewElement, 0 );
      *
      * conversionApi.writer.insert( viewPosition, viewSlot );
      * ```
      *
      * While providing a filtered slot, make sure to provide slots for all child nodes. A single node can not be downcasted into
      * multiple slots.
      *
      * **Note**: You should not change the order of nodes. View elements should be in the same order as model nodes.
      *
      * @param modeOrFilter The filter for child nodes.
      * @returns The slot element to be placed in to the view structure while processing
      * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure `elementToStructure()`}.
      */
      createSlot(modeOrFilter = "children") {
        if (!this._slotFactory) {
          throw new CKEditorError("view-writer-invalid-create-slot-context", this.document);
        }
        return this._slotFactory(this, modeOrFilter);
      }
      /**
      * Registers a slot factory.
      *
      * @internal
      * @param slotFactory The slot factory.
      */
      _registerSlotFactory(slotFactory) {
        this._slotFactory = slotFactory;
      }
      /**
      * Clears the registered slot factory.
      *
      * @internal
      */
      _clearSlotFactory() {
        this._slotFactory = null;
      }
      /**
      * Inserts a node or nodes at the specified position. Takes care of breaking attributes before insertion
      * and merging them afterwards if requested by the breakAttributes param.
      *
      * @param position Insertion position.
      * @param nodes Node or nodes to insert.
      * @param breakAttributes Whether attributes should be broken.
      * @returns Range around inserted nodes.
      */
      _insertNodes(position, nodes, breakAttributes) {
        let parentElement;
        if (breakAttributes) {
          parentElement = getParentContainer(position);
        } else {
          parentElement = position.parent.is("$text") ? position.parent.parent : position.parent;
        }
        if (!parentElement) {
          throw new CKEditorError("view-writer-invalid-position-container", this.document);
        }
        let insertionPosition;
        if (breakAttributes) {
          insertionPosition = this._breakAttributes(position, true);
        } else {
          insertionPosition = position.parent.is("$text") ? breakTextNode(position) : position;
        }
        const length = parentElement._insertChild(insertionPosition.offset, nodes);
        for (const node of nodes) {
          this._addToClonedElementsGroup(node);
        }
        const endPosition = insertionPosition.getShiftedBy(length);
        const start = this.mergeAttributes(insertionPosition);
        if (!start.isEqual(insertionPosition)) {
          endPosition.offset--;
        }
        const end = this.mergeAttributes(endPosition);
        return new Range$1(start, end);
      }
      /**
      * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
      * `startOffset` and `endOffset` will be wrapped.
      */
      _wrapChildren(parent2, startOffset, endOffset, wrapElement) {
        let i = startOffset;
        const wrapPositions = [];
        while (i < endOffset) {
          const child = parent2.getChild(i);
          const isText2 = child.is("$text");
          const isAttribute = child.is("attributeElement");
          if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {
            wrapPositions.push(new Position$1(parent2, i));
          } else if (isText2 || !isAttribute || shouldABeOutsideB(wrapElement, child)) {
            const newAttribute = wrapElement._clone();
            child._remove();
            newAttribute._appendChild(child);
            parent2._insertChild(i, newAttribute);
            this._addToClonedElementsGroup(newAttribute);
            wrapPositions.push(new Position$1(parent2, i));
          } else {
            this._wrapChildren(child, 0, child.childCount, wrapElement);
          }
          i++;
        }
        let offsetChange = 0;
        for (const position of wrapPositions) {
          position.offset -= offsetChange;
          if (position.offset == startOffset) {
            continue;
          }
          const newPosition = this.mergeAttributes(position);
          if (!newPosition.isEqual(position)) {
            offsetChange++;
            endOffset--;
          }
        }
        return Range$1._createFromParentsAndOffsets(parent2, startOffset, parent2, endOffset);
      }
      /**
      * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
      * `startOffset` and `endOffset` will be unwrapped.
      */
      _unwrapChildren(parent2, startOffset, endOffset, unwrapElement) {
        let i = startOffset;
        const unwrapPositions = [];
        while (i < endOffset) {
          const child = parent2.getChild(i);
          if (!child.is("attributeElement")) {
            i++;
            continue;
          }
          if (child.isSimilar(unwrapElement)) {
            const unwrapped = child.getChildren();
            const count2 = child.childCount;
            child._remove();
            parent2._insertChild(i, unwrapped);
            this._removeFromClonedElementsGroup(child);
            unwrapPositions.push(new Position$1(parent2, i), new Position$1(parent2, i + count2));
            i += count2;
            endOffset += count2 - 1;
            continue;
          }
          if (this._unwrapAttributeElement(unwrapElement, child)) {
            unwrapPositions.push(new Position$1(parent2, i), new Position$1(parent2, i + 1));
            i++;
            continue;
          }
          this._unwrapChildren(child, 0, child.childCount, unwrapElement);
          i++;
        }
        let offsetChange = 0;
        for (const position of unwrapPositions) {
          position.offset -= offsetChange;
          if (position.offset == startOffset || position.offset == endOffset) {
            continue;
          }
          const newPosition = this.mergeAttributes(position);
          if (!newPosition.isEqual(position)) {
            offsetChange++;
            endOffset--;
          }
        }
        return Range$1._createFromParentsAndOffsets(parent2, startOffset, parent2, endOffset);
      }
      /**
      * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
      * This method will also merge newly added attribute element with its siblings whenever possible.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
      * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      *
      * @returns New range after wrapping, spanning over wrapping attribute element.
      */
      _wrapRange(range, attribute) {
        const { start: breakStart, end: breakEnd } = this._breakAttributesRange(range, true);
        const parentContainer = breakStart.parent;
        const newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute);
        const start = this.mergeAttributes(newRange.start);
        if (!start.isEqual(newRange.start)) {
          newRange.end.offset--;
        }
        const end = this.mergeAttributes(newRange.end);
        return new Range$1(start, end);
      }
      /**
      * Helper function for {@link #wrap}. Wraps position with provided attribute element.
      * This method will also merge newly added attribute element with its siblings whenever possible.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
      * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
      *
      * @returns New position after wrapping.
      */
      _wrapPosition(position, attribute) {
        if (attribute.isSimilar(position.parent)) {
          return movePositionToTextNode(position.clone());
        }
        if (position.parent.is("$text")) {
          position = breakTextNode(position);
        }
        const fakeElement = this.createAttributeElement("_wrapPosition-fake-element");
        fakeElement._priority = Number.POSITIVE_INFINITY;
        fakeElement.isSimilar = () => false;
        position.parent._insertChild(position.offset, fakeElement);
        const wrapRange = new Range$1(position, position.getShiftedBy(1));
        this.wrap(wrapRange, attribute);
        const newPosition = new Position$1(fakeElement.parent, fakeElement.index);
        fakeElement._remove();
        const nodeBefore = newPosition.nodeBefore;
        const nodeAfter = newPosition.nodeAfter;
        if (nodeBefore instanceof Text$1 && nodeAfter instanceof Text$1) {
          return mergeTextNodes(nodeBefore, nodeAfter);
        }
        return movePositionToTextNode(newPosition);
      }
      /**
      * Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
      * merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
      * element to element being wrapped.
      *
      * @param wrapper Wrapper AttributeElement.
      * @param toWrap AttributeElement to wrap using wrapper element.
      * @returns Returns `true` if elements are merged.
      */
      _wrapAttributeElement(wrapper, toWrap) {
        if (!canBeJoined(wrapper, toWrap)) {
          return false;
        }
        if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
          return false;
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
            return false;
          }
        }
        for (const key of wrapper.getStyleNames()) {
          if (toWrap.hasStyle(key) && toWrap.getStyle(key) !== wrapper.getStyle(key)) {
            return false;
          }
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          if (!toWrap.hasAttribute(key)) {
            this.setAttribute(key, wrapper.getAttribute(key), toWrap);
          }
        }
        for (const key of wrapper.getStyleNames()) {
          if (!toWrap.hasStyle(key)) {
            this.setStyle(key, wrapper.getStyle(key), toWrap);
          }
        }
        for (const key of wrapper.getClassNames()) {
          if (!toWrap.hasClass(key)) {
            this.addClass(key, toWrap);
          }
        }
        return true;
      }
      /**
      * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
      * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
      * inside element being unwrapped.
      *
      * @param wrapper Wrapper AttributeElement.
      * @param toUnwrap AttributeElement to unwrap using wrapper element.
      * @returns Returns `true` if elements are unwrapped.
      **/
      _unwrapAttributeElement(wrapper, toUnwrap) {
        if (!canBeJoined(wrapper, toUnwrap)) {
          return false;
        }
        if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
          return false;
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
            return false;
          }
        }
        if (!toUnwrap.hasClass(...wrapper.getClassNames())) {
          return false;
        }
        for (const key of wrapper.getStyleNames()) {
          if (!toUnwrap.hasStyle(key) || toUnwrap.getStyle(key) !== wrapper.getStyle(key)) {
            return false;
          }
        }
        for (const key of wrapper.getAttributeKeys()) {
          if (key === "class" || key === "style") {
            continue;
          }
          this.removeAttribute(key, toUnwrap);
        }
        this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap);
        this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);
        return true;
      }
      /**
      * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
      *
      * @param range Range which `start` and `end` positions will be used to break attributes.
      * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
      * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
      * @returns New range with located at break positions.
      */
      _breakAttributesRange(range, forceSplitText = false) {
        const rangeStart = range.start;
        const rangeEnd = range.end;
        validateRangeContainer(range, this.document);
        if (range.isCollapsed) {
          const position = this._breakAttributes(range.start, forceSplitText);
          return new Range$1(position, position);
        }
        const breakEnd = this._breakAttributes(rangeEnd, forceSplitText);
        const count2 = breakEnd.parent.childCount;
        const breakStart = this._breakAttributes(rangeStart, forceSplitText);
        breakEnd.offset += breakEnd.parent.childCount - count2;
        return new Range$1(breakStart, breakEnd);
      }
      /**
      * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
      * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
      * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
      *
      * @param position Position where to break attributes.
      * @param forceSplitText If set to `true`, will break text nodes even if they are directly in container element.
      * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
      * @returns New position after breaking the attributes.
      */
      _breakAttributes(position, forceSplitText = false) {
        const positionOffset = position.offset;
        const positionParent = position.parent;
        if (position.parent.is("emptyElement")) {
          throw new CKEditorError("view-writer-cannot-break-empty-element", this.document);
        }
        if (position.parent.is("uiElement")) {
          throw new CKEditorError("view-writer-cannot-break-ui-element", this.document);
        }
        if (position.parent.is("rawElement")) {
          throw new CKEditorError("view-writer-cannot-break-raw-element", this.document);
        }
        if (!forceSplitText && positionParent.is("$text") && isContainerOrFragment(positionParent.parent)) {
          return position.clone();
        }
        if (isContainerOrFragment(positionParent)) {
          return position.clone();
        }
        if (positionParent.is("$text")) {
          return this._breakAttributes(breakTextNode(position), forceSplitText);
        }
        const length = positionParent.childCount;
        if (positionOffset == length) {
          const newPosition = new Position$1(positionParent.parent, positionParent.index + 1);
          return this._breakAttributes(newPosition, forceSplitText);
        } else {
          if (positionOffset === 0) {
            const newPosition = new Position$1(positionParent.parent, positionParent.index);
            return this._breakAttributes(newPosition, forceSplitText);
          } else {
            const offsetAfter = positionParent.index + 1;
            const clonedNode = positionParent._clone();
            positionParent.parent._insertChild(offsetAfter, clonedNode);
            this._addToClonedElementsGroup(clonedNode);
            const count2 = positionParent.childCount - positionOffset;
            const nodesToMove = positionParent._removeChildren(positionOffset, count2);
            clonedNode._appendChild(nodesToMove);
            const newPosition = new Position$1(positionParent.parent, offsetAfter);
            return this._breakAttributes(newPosition, forceSplitText);
          }
        }
      }
      /**
      * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
      * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
      * from the group now keep a reference to the given attribute element.
      *
      * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
      *
      * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
      *
      * @param element Attribute element to save.
      */
      _addToClonedElementsGroup(element) {
        if (!element.root.is("rootElement")) {
          return;
        }
        if (element.is("element")) {
          for (const child of element.getChildren()) {
            this._addToClonedElementsGroup(child);
          }
        }
        const id = element.id;
        if (!id) {
          return;
        }
        let group = this._cloneGroups.get(id);
        if (!group) {
          group = /* @__PURE__ */ new Set();
          this._cloneGroups.set(id, group);
        }
        group.add(element);
        element._clonesGroup = group;
      }
      /**
      * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
      * from its clones group.
      *
      * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
      * This allows to reference the whole group even if the element was already removed from the tree.
      *
      * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
      *
      * @param element Attribute element to remove.
      */
      _removeFromClonedElementsGroup(element) {
        if (element.is("element")) {
          for (const child of element.getChildren()) {
            this._removeFromClonedElementsGroup(child);
          }
        }
        const id = element.id;
        if (!id) {
          return;
        }
        const group = this._cloneGroups.get(id);
        if (!group) {
          return;
        }
        group.delete(element);
      }
    }
    function _hasNonUiChildren(parent2) {
      return Array.from(parent2.getChildren()).some((child) => !child.is("uiElement"));
    }
    function getParentContainer(position) {
      let parent2 = position.parent;
      while (!isContainerOrFragment(parent2)) {
        if (!parent2) {
          return void 0;
        }
        parent2 = parent2.parent;
      }
      return parent2;
    }
    function shouldABeOutsideB(a, b) {
      if (a.priority < b.priority) {
        return true;
      } else if (a.priority > b.priority) {
        return false;
      }
      return a.getIdentity() < b.getIdentity();
    }
    function movePositionToTextNode(position) {
      const nodeBefore = position.nodeBefore;
      if (nodeBefore && nodeBefore.is("$text")) {
        return new Position$1(nodeBefore, nodeBefore.data.length);
      }
      const nodeAfter = position.nodeAfter;
      if (nodeAfter && nodeAfter.is("$text")) {
        return new Position$1(nodeAfter, 0);
      }
      return position;
    }
    function breakTextNode(position) {
      if (position.offset == position.parent.data.length) {
        return new Position$1(position.parent.parent, position.parent.index + 1);
      }
      if (position.offset === 0) {
        return new Position$1(position.parent.parent, position.parent.index);
      }
      const textToMove = position.parent.data.slice(position.offset);
      position.parent._data = position.parent.data.slice(0, position.offset);
      position.parent.parent._insertChild(position.parent.index + 1, new Text$1(position.root.document, textToMove));
      return new Position$1(position.parent.parent, position.parent.index + 1);
    }
    function mergeTextNodes(t1, t2) {
      const nodeBeforeLength = t1.data.length;
      t1._data += t2.data;
      t2._remove();
      return new Position$1(t1, nodeBeforeLength);
    }
    const validNodesToInsert = [
      Text$1,
      AttributeElement,
      ContainerElement,
      EmptyElement,
      RawElement,
      UIElement
    ];
    function validateNodesToInsert(nodes, errorContext) {
      for (const node of nodes) {
        if (!validNodesToInsert.some((validNode) => node instanceof validNode)) {
          throw new CKEditorError("view-writer-insert-invalid-node-type", errorContext);
        }
        if (!node.is("$text")) {
          validateNodesToInsert(node.getChildren(), errorContext);
        }
      }
    }
    function isContainerOrFragment(node) {
      return node && (node.is("containerElement") || node.is("documentFragment"));
    }
    function validateRangeContainer(range, errorContext) {
      const startContainer = getParentContainer(range.start);
      const endContainer = getParentContainer(range.end);
      if (!startContainer || !endContainer || startContainer !== endContainer) {
        throw new CKEditorError("view-writer-invalid-range-container", errorContext);
      }
    }
    function canBeJoined(a, b) {
      return a.id === null && b.id === null;
    }
    const NBSP_FILLER = (domDocument) => domDocument.createTextNode(" ");
    const MARKED_NBSP_FILLER = (domDocument) => {
      const span = domDocument.createElement("span");
      span.dataset.ckeFiller = "true";
      span.innerText = " ";
      return span;
    };
    const BR_FILLER = (domDocument) => {
      const fillerBr = domDocument.createElement("br");
      fillerBr.dataset.ckeFiller = "true";
      return fillerBr;
    };
    const INLINE_FILLER_LENGTH = 7;
    const INLINE_FILLER = "⁠".repeat(INLINE_FILLER_LENGTH);
    function startsWithFiller(domNode) {
      if (typeof domNode == "string") {
        return domNode.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
      }
      return isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
    }
    function isInlineFiller(domText) {
      return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
    }
    function getDataWithoutFiller(domText) {
      const data = typeof domText == "string" ? domText : domText.data;
      if (startsWithFiller(domText)) {
        return data.slice(INLINE_FILLER_LENGTH);
      }
      return data;
    }
    function injectQuirksHandling(view) {
      view.document.on("arrowKey", jumpOverInlineFiller, {
        priority: "low"
      });
    }
    function jumpOverInlineFiller(evt, data) {
      if (data.keyCode == keyCodes.arrowleft) {
        const domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
        if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
          const domParent = domSelection.getRangeAt(0).startContainer;
          const domOffset = domSelection.getRangeAt(0).startOffset;
          if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
            domSelection.collapse(domParent, 0);
          }
        }
      }
    }
    let Renderer$1 = class Renderer extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a renderer instance.
      *
      * @param domConverter Converter instance.
      * @param selection View selection.
      */
      constructor(domConverter, selection) {
        super();
        /**
        * Set of DOM Documents instances.
        */
        __publicField(this, "domDocuments", /* @__PURE__ */ new Set());
        /**
        * Converter instance.
        */
        __publicField(this, "domConverter");
        /**
        * Set of nodes which attributes changed and may need to be rendered.
        */
        __publicField(this, "markedAttributes", /* @__PURE__ */ new Set());
        /**
        * Set of elements which child lists changed and may need to be rendered.
        */
        __publicField(this, "markedChildren", /* @__PURE__ */ new Set());
        /**
        * Set of text nodes which text data changed and may need to be rendered.
        */
        __publicField(this, "markedTexts", /* @__PURE__ */ new Set());
        /**
        * View selection. Renderer updates DOM selection based on the view selection.
        */
        __publicField(this, "selection");
        /**
        * The text node in which the inline filler was rendered.
        */
        __publicField(this, "_inlineFiller", null);
        /**
        * DOM element containing fake selection.
        */
        __publicField(this, "_fakeSelectionContainer", null);
        this.domConverter = domConverter;
        this.selection = selection;
        this.set("isFocused", false);
        this.set("isSelecting", false);
        if (env.isBlink && !env.isAndroid) {
          this.on("change:isSelecting", () => {
            if (!this.isSelecting) {
              this.render();
            }
          });
        }
        this.set("isComposing", false);
        this.on("change:isComposing", () => {
          if (!this.isComposing) {
            this.render();
          }
        });
      }
      /**
      * Marks a view node to be updated in the DOM by {@link #render `render()`}.
      *
      * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
      *
      * @see #markedAttributes
      * @see #markedChildren
      * @see #markedTexts
      *
      * @param type Type of the change.
      * @param node ViewNode to be marked.
      */
      markToSync(type, node) {
        if (type === "text") {
          if (this.domConverter.mapViewToDom(node.parent)) {
            this.markedTexts.add(node);
          }
        } else {
          if (!this.domConverter.mapViewToDom(node)) {
            return;
          }
          if (type === "attributes") {
            this.markedAttributes.add(node);
          } else if (type === "children") {
            this.markedChildren.add(node);
          } else {
            throw new CKEditorError("view-renderer-unknown-type", this);
          }
        }
      }
      /**
      * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
      * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
      *
      * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
      * so it does as little as it is needed to update the DOM.
      *
      * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
      * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
      * removed as long as the selection is in the text node which needed it at first.
      */
      render() {
        if (this.isComposing && !env.isAndroid) {
          return;
        }
        let inlineFillerPosition = null;
        const isInlineFillerRenderingPossible = env.isBlink && !env.isAndroid ? !this.isSelecting : true;
        for (const element of this.markedChildren) {
          this._updateChildrenMappings(element);
        }
        if (isInlineFillerRenderingPossible) {
          if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
            this._removeInlineFiller();
          }
          if (this._inlineFiller) {
            inlineFillerPosition = this._getInlineFillerPosition();
          } else if (this._needsInlineFillerAtSelection()) {
            inlineFillerPosition = this.selection.getFirstPosition();
            this.markedChildren.add(inlineFillerPosition.parent);
          }
        } else if (this._inlineFiller && this._inlineFiller.parentNode) {
          inlineFillerPosition = this.domConverter.domPositionToView(this._inlineFiller);
          if (inlineFillerPosition && inlineFillerPosition.parent.is("$text")) {
            inlineFillerPosition = Position$1._createBefore(inlineFillerPosition.parent);
          }
        }
        for (const element of this.markedAttributes) {
          this._updateAttrs(element);
        }
        for (const element of this.markedChildren) {
          this._updateChildren(element, {
            inlineFillerPosition
          });
        }
        for (const node of this.markedTexts) {
          if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {
            this._updateText(node, {
              inlineFillerPosition
            });
          }
        }
        if (isInlineFillerRenderingPossible) {
          if (inlineFillerPosition) {
            const fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);
            const domDocument = fillerDomPosition.parent.ownerDocument;
            if (!startsWithFiller(fillerDomPosition.parent)) {
              this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);
            } else {
              this._inlineFiller = fillerDomPosition.parent;
            }
          } else {
            this._inlineFiller = null;
          }
        }
        this._updateFocus();
        this._updateSelection();
        this.domConverter._clearTemporaryCustomProperties();
        this.markedTexts.clear();
        this.markedAttributes.clear();
        this.markedChildren.clear();
      }
      /**
      * Updates mappings of view element's children.
      *
      * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
      * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
      * Thanks to that these elements do not need to be re-rendered completely.
      *
      * @param viewElement The view element whose children mappings will be updated.
      */
      _updateChildrenMappings(viewElement) {
        const domElement = this.domConverter.mapViewToDom(viewElement);
        if (!domElement) {
          return;
        }
        const actualDomChildren = Array.from(domElement.childNodes);
        const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {
          withChildren: false
        }));
        const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
        const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areSimilarElements);
        if (actions.indexOf("update") !== -1) {
          const counter = {
            equal: 0,
            insert: 0,
            delete: 0
          };
          for (const action of actions) {
            if (action === "update") {
              const insertIndex = counter.equal + counter.insert;
              const deleteIndex = counter.equal + counter.delete;
              const viewChild = viewElement.getChild(insertIndex);
              if (viewChild && !viewChild.is("uiElement") && !viewChild.is("rawElement")) {
                this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);
              }
              remove$1(expectedDomChildren[insertIndex]);
              counter.equal++;
            } else {
              counter[action]++;
            }
          }
        }
      }
      /**
      * Updates mappings of a given view element.
      *
      * @param viewElement The view element whose mappings will be updated.
      * @param domElement The DOM element representing the given view element.
      */
      _updateElementMappings(viewElement, domElement) {
        this.domConverter.unbindDomElement(domElement);
        this.domConverter.bindElements(domElement, viewElement);
        this.markedChildren.add(viewElement);
        this.markedAttributes.add(viewElement);
      }
      /**
      * Gets the position of the inline filler based on the current selection.
      * Here, we assume that we know that the filler is needed and
      * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
      * it is somewhere at the selection position.
      *
      * Note: The filler position cannot be restored based on the filler's DOM text node, because
      * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
      * bindings are only dependable after rendering.
      */
      _getInlineFillerPosition() {
        const firstPos = this.selection.getFirstPosition();
        if (firstPos.parent.is("$text")) {
          return Position$1._createBefore(firstPos.parent);
        } else {
          return firstPos;
        }
      }
      /**
      * Returns `true` if the selection has not left the inline filler's text node.
      * If it is `true`, it means that the filler had been added for a reason and the selection did not
      * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
      *
      * @returns `true` if the inline filler and selection are in the same place.
      */
      _isSelectionInInlineFiller() {
        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
          return false;
        }
        const selectionPosition = this.selection.getFirstPosition();
        const position = this.domConverter.viewPositionToDom(selectionPosition);
        if (position && isText(position.parent) && startsWithFiller(position.parent)) {
          return true;
        }
        return false;
      }
      /**
      * Removes the inline filler.
      */
      _removeInlineFiller() {
        const domFillerNode = this._inlineFiller;
        if (!startsWithFiller(domFillerNode)) {
          throw new CKEditorError("view-renderer-filler-was-lost", this);
        }
        if (isInlineFiller(domFillerNode)) {
          domFillerNode.remove();
        } else {
          domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
        }
        this._inlineFiller = null;
      }
      /**
      * Checks if the inline {@link module:engine/view/filler filler} should be added.
      *
      * @returns `true` if the inline filler should be added.
      */
      _needsInlineFillerAtSelection() {
        if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
          return false;
        }
        const selectionPosition = this.selection.getFirstPosition();
        const selectionParent = selectionPosition.parent;
        const selectionOffset = selectionPosition.offset;
        if (!this.domConverter.mapViewToDom(selectionParent.root)) {
          return false;
        }
        if (!selectionParent.is("element")) {
          return false;
        }
        if (!isEditable(selectionParent)) {
          return false;
        }
        const nodeBefore = selectionPosition.nodeBefore;
        const nodeAfter = selectionPosition.nodeAfter;
        if (nodeBefore instanceof Text$1 || nodeAfter instanceof Text$1) {
          return false;
        }
        if (selectionOffset === selectionParent.getFillerOffset() && (!nodeBefore || !nodeBefore.is("element", "br"))) {
          return false;
        }
        if (env.isAndroid && (nodeBefore || nodeAfter)) {
          return false;
        }
        return true;
      }
      /**
      * Checks if text needs to be updated and possibly updates it.
      *
      * @param viewText View text to update.
      * @param options.inlineFillerPosition The position where the inline filler should be rendered.
      */
      _updateText(viewText, options) {
        const domText = this.domConverter.findCorrespondingDomText(viewText);
        const newDomText = this.domConverter.viewToDom(viewText);
        let expectedText = newDomText.data;
        const filler = options.inlineFillerPosition;
        if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
          expectedText = INLINE_FILLER + expectedText;
        }
        updateTextNode(domText, expectedText);
      }
      /**
      * Checks if attribute list needs to be updated and possibly updates it.
      *
      * @param viewElement The view element to update.
      */
      _updateAttrs(viewElement) {
        const domElement = this.domConverter.mapViewToDom(viewElement);
        if (!domElement) {
          return;
        }
        const domAttrKeys = Array.from(domElement.attributes).map((attr) => attr.name);
        const viewAttrKeys = viewElement.getAttributeKeys();
        for (const key of viewAttrKeys) {
          this.domConverter.setDomElementAttribute(domElement, key, viewElement.getAttribute(key), viewElement);
        }
        for (const key of domAttrKeys) {
          if (!viewElement.hasAttribute(key)) {
            this.domConverter.removeDomElementAttribute(domElement, key);
          }
        }
      }
      /**
      * Checks if elements child list needs to be updated and possibly updates it.
      *
      * Note that on Android, to reduce the risk of composition breaks, it tries to update data of an existing
      * child text nodes instead of replacing them completely.
      *
      * @param viewElement View element to update.
      * @param options.inlineFillerPosition The position where the inline filler should be rendered.
      */
      _updateChildren(viewElement, options) {
        const domElement = this.domConverter.mapViewToDom(viewElement);
        if (!domElement) {
          return;
        }
        if (env.isAndroid) {
          let previousDomNode = null;
          for (const domNode of Array.from(domElement.childNodes)) {
            if (previousDomNode && isText(previousDomNode) && isText(domNode)) {
              domElement.normalize();
              break;
            }
            previousDomNode = domNode;
          }
        }
        const inlineFillerPosition = options.inlineFillerPosition;
        const actualDomChildren = domElement.childNodes;
        const expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, {
          bind: true
        }));
        if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {
          addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);
        }
        const diff2 = this._diffNodeLists(actualDomChildren, expectedDomChildren);
        const actions = this._findUpdateActions(diff2, actualDomChildren, expectedDomChildren, areTextNodes);
        let i = 0;
        const nodesToUnbind = /* @__PURE__ */ new Set();
        for (const action of actions) {
          if (action === "delete") {
            nodesToUnbind.add(actualDomChildren[i]);
            remove$1(actualDomChildren[i]);
          } else if (action === "equal" || action === "update") {
            i++;
          }
        }
        i = 0;
        for (const action of actions) {
          if (action === "insert") {
            insertAt(domElement, i, expectedDomChildren[i]);
            i++;
          } else if (action === "update") {
            updateTextNode(actualDomChildren[i], expectedDomChildren[i].data);
            i++;
          } else if (action === "equal") {
            this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));
            i++;
          }
        }
        for (const node of nodesToUnbind) {
          if (!node.parentNode) {
            this.domConverter.unbindDomElement(node);
          }
        }
      }
      /**
      * Shorthand for diffing two arrays or node lists of DOM nodes.
      *
      * @param actualDomChildren Actual DOM children
      * @param expectedDomChildren Expected DOM children.
      * @returns The list of actions based on the {@link module:utils/diff~diff} function.
      */
      _diffNodeLists(actualDomChildren, expectedDomChildren) {
        actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);
        return diff(actualDomChildren, expectedDomChildren, sameNodes$1.bind(null, this.domConverter));
      }
      /**
      * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
      * within one `insert`/`delete` action group, for example:
      *
      * ```
      * Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
      * Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
      * Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
      * Output actions:	[ insert, replace, delete, equal, replace ]
      * ```
      *
      * @param actions Actions array which is a result of the {@link module:utils/diff~diff} function.
      * @param actualDom Actual DOM children
      * @param expectedDom Expected DOM children.
      * @param comparator A comparator function that should return `true` if the given node should be reused
      * (either by the update of a text node data or an element children list for similar elements).
      * @returns Actions array modified with the `update` actions.
      */
      _findUpdateActions(actions, actualDom, expectedDom, comparator) {
        if (actions.indexOf("insert") === -1 || actions.indexOf("delete") === -1) {
          return actions;
        }
        let newActions = [];
        let actualSlice = [];
        let expectedSlice = [];
        const counter = {
          equal: 0,
          insert: 0,
          delete: 0
        };
        for (const action of actions) {
          if (action === "insert") {
            expectedSlice.push(expectedDom[counter.equal + counter.insert]);
          } else if (action === "delete") {
            actualSlice.push(actualDom[counter.equal + counter.delete]);
          } else {
            newActions = newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action2) => action2 === "equal" ? "update" : action2));
            newActions.push("equal");
            actualSlice = [];
            expectedSlice = [];
          }
          counter[action]++;
        }
        return newActions.concat(diff(actualSlice, expectedSlice, comparator).map((action) => action === "equal" ? "update" : action));
      }
      /**
      * Marks text nodes to be synchronized.
      *
      * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
      *
      * @param viewNode View node to sync.
      */
      _markDescendantTextToSync(viewNode) {
        if (!viewNode) {
          return;
        }
        if (viewNode.is("$text")) {
          this.markedTexts.add(viewNode);
        } else if (viewNode.is("element")) {
          for (const child of viewNode.getChildren()) {
            this._markDescendantTextToSync(child);
          }
        }
      }
      /**
      * Checks if the selection needs to be updated and possibly updates it.
      */
      _updateSelection() {
        if (env.isBlink && !env.isAndroid && this.isSelecting && !this.markedChildren.size) {
          return;
        }
        if (this.selection.rangeCount === 0) {
          this._removeDomSelection();
          this._removeFakeSelection();
          return;
        }
        const domRoot = this.domConverter.mapViewToDom(this.selection.editableElement);
        if (!this.isFocused || !domRoot) {
          return;
        }
        if (this.selection.isFake) {
          this._updateFakeSelection(domRoot);
        } else if (this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected) {
          this._removeFakeSelection();
          this._updateDomSelection(domRoot);
        } else if (!(this.isComposing && env.isAndroid)) {
          this._updateDomSelection(domRoot);
        }
      }
      /**
      * Updates the fake selection.
      *
      * @param domRoot A valid DOM root where the fake selection container should be added.
      */
      _updateFakeSelection(domRoot) {
        const domDocument = domRoot.ownerDocument;
        if (!this._fakeSelectionContainer) {
          this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);
        }
        const container = this._fakeSelectionContainer;
        this.domConverter.bindFakeSelection(container, this.selection);
        if (!this._fakeSelectionNeedsUpdate(domRoot)) {
          return;
        }
        if (!container.parentElement || container.parentElement != domRoot) {
          domRoot.appendChild(container);
        }
        container.textContent = this.selection.fakeSelectionLabel || " ";
        const domSelection = domDocument.getSelection();
        const domRange = domDocument.createRange();
        domSelection.removeAllRanges();
        domRange.selectNodeContents(container);
        domSelection.addRange(domRange);
      }
      /**
      * Updates the DOM selection.
      *
      * @param domRoot A valid DOM root where the DOM selection should be rendered.
      */
      _updateDomSelection(domRoot) {
        const domSelection = domRoot.ownerDocument.defaultView.getSelection();
        if (!this._domSelectionNeedsUpdate(domSelection)) {
          return;
        }
        const anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
        const focus = this.domConverter.viewPositionToDom(this.selection.focus);
        domSelection.setBaseAndExtent(anchor.parent, anchor.offset, focus.parent, focus.offset);
        if (env.isGecko) {
          fixGeckoSelectionAfterBr(focus, domSelection);
        }
      }
      /**
      * Checks whether a given DOM selection needs to be updated.
      *
      * @param domSelection The DOM selection to check.
      */
      _domSelectionNeedsUpdate(domSelection) {
        if (!this.domConverter.isDomSelectionCorrect(domSelection)) {
          return true;
        }
        const oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);
        if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
          return false;
        }
        if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {
          return false;
        }
        return true;
      }
      /**
      * Checks whether the fake selection needs to be updated.
      *
      * @param domRoot A valid DOM root where a new fake selection container should be added.
      */
      _fakeSelectionNeedsUpdate(domRoot) {
        const container = this._fakeSelectionContainer;
        const domSelection = domRoot.ownerDocument.getSelection();
        if (!container || container.parentElement !== domRoot) {
          return true;
        }
        if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {
          return true;
        }
        return container.textContent !== this.selection.fakeSelectionLabel;
      }
      /**
      * Removes the DOM selection.
      */
      _removeDomSelection() {
        for (const doc of this.domDocuments) {
          const domSelection = doc.getSelection();
          if (domSelection.rangeCount) {
            const activeDomElement = doc.activeElement;
            const viewElement = this.domConverter.mapDomToView(activeDomElement);
            if (activeDomElement && viewElement) {
              domSelection.removeAllRanges();
            }
          }
        }
      }
      /**
      * Removes the fake selection.
      */
      _removeFakeSelection() {
        const container = this._fakeSelectionContainer;
        if (container) {
          container.remove();
        }
      }
      /**
      * Checks if focus needs to be updated and possibly updates it.
      */
      _updateFocus() {
        if (this.isFocused) {
          const editable = this.selection.editableElement;
          if (editable) {
            this.domConverter.focus(editable);
          }
        }
      }
    };
    function isEditable(element) {
      if (element.getAttribute("contenteditable") == "false") {
        return false;
      }
      const parent2 = element.findAncestor((element2) => element2.hasAttribute("contenteditable"));
      return !parent2 || parent2.getAttribute("contenteditable") == "true";
    }
    function addInlineFiller(domDocument, domParentOrArray, offset) {
      const childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
      const nodeAfterFiller = childNodes[offset];
      if (isText(nodeAfterFiller)) {
        nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;
        return nodeAfterFiller;
      } else {
        const fillerNode = domDocument.createTextNode(INLINE_FILLER);
        if (Array.isArray(domParentOrArray)) {
          childNodes.splice(offset, 0, fillerNode);
        } else {
          insertAt(domParentOrArray, offset, fillerNode);
        }
        return fillerNode;
      }
    }
    function areSimilarElements(node1, node2) {
      return isNode(node1) && isNode(node2) && !isText(node1) && !isText(node2) && !isComment(node1) && !isComment(node2) && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();
    }
    function areTextNodes(node1, node2) {
      return isNode(node1) && isNode(node2) && isText(node1) && isText(node2);
    }
    function sameNodes$1(domConverter, actualDomChild, expectedDomChild) {
      if (actualDomChild === expectedDomChild) {
        return true;
      } else if (isText(actualDomChild) && isText(expectedDomChild)) {
        return actualDomChild.data === expectedDomChild.data;
      } else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {
        return true;
      }
      return false;
    }
    function fixGeckoSelectionAfterBr(focus, domSelection) {
      let parent2 = focus.parent;
      let offset = focus.offset;
      if (isText(parent2) && isInlineFiller(parent2)) {
        offset = indexOf(parent2) + 1;
        parent2 = parent2.parentNode;
      }
      if (parent2.nodeType != Node.ELEMENT_NODE || offset != parent2.childNodes.length - 1) {
        return;
      }
      const childAtOffset = parent2.childNodes[offset];
      if (childAtOffset && childAtOffset.tagName == "BR") {
        domSelection.addRange(domSelection.getRangeAt(0));
      }
    }
    function filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {
      const childList = Array.from(domChildList);
      if (childList.length == 0 || !fakeSelectionContainer) {
        return childList;
      }
      const last2 = childList[childList.length - 1];
      if (last2 == fakeSelectionContainer) {
        childList.pop();
      }
      return childList;
    }
    function createFakeSelectionContainer(domDocument) {
      const container = domDocument.createElement("div");
      container.className = "ck-fake-selection-container";
      Object.assign(container.style, {
        position: "fixed",
        top: 0,
        left: "-9999px",
        // See https://github.com/ckeditor/ckeditor5/issues/752.
        width: "42px"
      });
      container.textContent = " ";
      return container;
    }
    function updateTextNode(domText, expectedText) {
      const actualText = domText.data;
      if (actualText == expectedText) {
        return;
      }
      const actions = fastDiff(actualText, expectedText);
      for (const action of actions) {
        if (action.type === "insert") {
          domText.insertData(action.index, action.values.join(""));
        } else {
          domText.deleteData(action.index, action.howMany);
        }
      }
    }
    const BR_FILLER_REF = BR_FILLER(global$1.document);
    const NBSP_FILLER_REF = NBSP_FILLER(global$1.document);
    const MARKED_NBSP_FILLER_REF = MARKED_NBSP_FILLER(global$1.document);
    const UNSAFE_ATTRIBUTE_NAME_PREFIX = "data-ck-unsafe-attribute-";
    const UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE = "data-ck-unsafe-element";
    class DomConverter {
      /**
      * Creates a DOM converter.
      *
      * @param document The view document instance.
      * @param options An object with configuration options.
      * @param options.blockFillerMode The type of the block filler to use.
      * Default value depends on the options.renderingMode:
      *  'nbsp' when options.renderingMode == 'data',
      *  'br' when options.renderingMode == 'editing'.
      * @param options.renderingMode Whether to leave the View-to-DOM conversion result unchanged
      * or improve editing experience by filtering out interactive data.
      */
      constructor(document2, { blockFillerMode, renderingMode = "editing" } = {}) {
        __publicField(this, "document");
        /**
        * Whether to leave the View-to-DOM conversion result unchanged or improve editing experience by filtering out interactive data.
        */
        __publicField(this, "renderingMode");
        /**
        * The mode of a block filler used by the DOM converter.
        */
        __publicField(this, "blockFillerMode");
        /**
        * Elements which are considered pre-formatted elements.
        */
        __publicField(this, "preElements");
        /**
        * Elements which are considered block elements (and hence should be filled with a
        * {@link #isBlockFiller block filler}).
        *
        * Whether an element is considered a block element also affects handling of trailing whitespaces.
        *
        * You can extend this array if you introduce support for block elements which are not yet recognized here.
        */
        __publicField(this, "blockElements");
        /**
        * A list of elements that exist inline (in text) but their inner structure cannot be edited because
        * of the way they are rendered by the browser. They are mostly HTML form elements but there are other
        * elements such as `<img>` or `<iframe>` that also have non-editable children or no children whatsoever.
        *
        * Whether an element is considered an inline object has an impact on white space rendering (trimming)
        * around (and inside of it). In short, white spaces in text nodes next to inline objects are not trimmed.
        *
        * You can extend this array if you introduce support for inline object elements which are not yet recognized here.
        */
        __publicField(this, "inlineObjectElements");
        /**
        * A list of elements which may affect the editing experience. To avoid this, those elements are replaced with
        * `<span data-ck-unsafe-element="[element name]"></span>` while rendering in the editing mode.
        */
        __publicField(this, "unsafeElements");
        /**
        * The DOM Document used to create DOM nodes.
        */
        __publicField(this, "_domDocument");
        /**
        * The DOM-to-view mapping.
        */
        __publicField(this, "_domToViewMapping", /* @__PURE__ */ new WeakMap());
        /**
        * The view-to-DOM mapping.
        */
        __publicField(this, "_viewToDomMapping", /* @__PURE__ */ new WeakMap());
        /**
        * Holds the mapping between fake selection containers and corresponding view selections.
        */
        __publicField(this, "_fakeSelectionMapping", /* @__PURE__ */ new WeakMap());
        /**
        * Matcher for view elements whose content should be treated as raw data
        * and not processed during the conversion from DOM nodes to view elements.
        */
        __publicField(this, "_rawContentElementMatcher", new Matcher());
        /**
        * Matcher for inline object view elements. This is an extension of a simple {@link #inlineObjectElements} array of element names.
        */
        __publicField(this, "_inlineObjectElementMatcher", new Matcher());
        /**
        * Set of elements with temporary custom properties that require clearing after render.
        */
        __publicField(this, "_elementsWithTemporaryCustomProperties", /* @__PURE__ */ new Set());
        this.document = document2;
        this.renderingMode = renderingMode;
        this.blockFillerMode = blockFillerMode || (renderingMode === "editing" ? "br" : "nbsp");
        this.preElements = [
          "pre"
        ];
        this.blockElements = [
          "address",
          "article",
          "aside",
          "blockquote",
          "caption",
          "center",
          "dd",
          "details",
          "dir",
          "div",
          "dl",
          "dt",
          "fieldset",
          "figcaption",
          "figure",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "legend",
          "li",
          "main",
          "menu",
          "nav",
          "ol",
          "p",
          "pre",
          "section",
          "summary",
          "table",
          "tbody",
          "td",
          "tfoot",
          "th",
          "thead",
          "tr",
          "ul"
        ];
        this.inlineObjectElements = [
          "object",
          "iframe",
          "input",
          "button",
          "textarea",
          "select",
          "option",
          "video",
          "embed",
          "audio",
          "img",
          "canvas"
        ];
        this.unsafeElements = [
          "script",
          "style"
        ];
        this._domDocument = this.renderingMode === "editing" ? global$1.document : global$1.document.implementation.createHTMLDocument("");
      }
      /**
      * Binds a given DOM element that represents fake selection to a **position** of a
      * {@link module:engine/view/documentselection~DocumentSelection document selection}.
      * Document selection copy is stored and can be retrieved by the
      * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
      */
      bindFakeSelection(domElement, viewDocumentSelection) {
        this._fakeSelectionMapping.set(domElement, new Selection$1(viewDocumentSelection));
      }
      /**
      * Returns a {@link module:engine/view/selection~Selection view selection} instance corresponding to a given
      * DOM element that represents fake selection. Returns `undefined` if binding to the given DOM element does not exist.
      */
      fakeSelectionToView(domElement) {
        return this._fakeSelectionMapping.get(domElement);
      }
      /**
      * Binds DOM and view elements, so it will be possible to get corresponding elements using
      * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
      * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
      *
      * @param domElement The DOM element to bind.
      * @param viewElement The view element to bind.
      */
      bindElements(domElement, viewElement) {
        this._domToViewMapping.set(domElement, viewElement);
        this._viewToDomMapping.set(viewElement, domElement);
      }
      /**
      * Unbinds a given DOM element from the view element it was bound to. Unbinding is deep, meaning that all children of
      * the DOM element will be unbound too.
      *
      * @param domElement The DOM element to unbind.
      */
      unbindDomElement(domElement) {
        const viewElement = this._domToViewMapping.get(domElement);
        if (viewElement) {
          this._domToViewMapping.delete(domElement);
          this._viewToDomMapping.delete(viewElement);
          for (const child of Array.from(domElement.children)) {
            this.unbindDomElement(child);
          }
        }
      }
      /**
      * Binds DOM and view document fragments, so it will be possible to get corresponding document fragments using
      * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
      * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
      *
      * @param domFragment The DOM document fragment to bind.
      * @param viewFragment The view document fragment to bind.
      */
      bindDocumentFragments(domFragment, viewFragment) {
        this._domToViewMapping.set(domFragment, viewFragment);
        this._viewToDomMapping.set(viewFragment, domFragment);
      }
      /**
      * Decides whether a given pair of attribute key and value should be passed further down the pipeline.
      *
      * @param elementName Element name in lower case.
      */
      shouldRenderAttribute(attributeKey, attributeValue, elementName) {
        if (this.renderingMode === "data") {
          return true;
        }
        attributeKey = attributeKey.toLowerCase();
        if (attributeKey.startsWith("on")) {
          return false;
        }
        if (attributeKey === "srcdoc" && attributeValue.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) {
          return false;
        }
        if (elementName === "img" && (attributeKey === "src" || attributeKey === "srcset")) {
          return true;
        }
        if (elementName === "source" && attributeKey === "srcset") {
          return true;
        }
        if (attributeValue.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i)) {
          return false;
        }
        return true;
      }
      /**
      * Set `domElement`'s content using provided `html` argument. Apply necessary filtering for the editing pipeline.
      *
      * @param domElement DOM element that should have `html` set as its content.
      * @param html Textual representation of the HTML that will be set on `domElement`.
      */
      setContentOf(domElement, html2) {
        if (this.renderingMode === "data") {
          domElement.innerHTML = html2;
          return;
        }
        const document2 = new DOMParser().parseFromString(html2, "text/html");
        const fragment = document2.createDocumentFragment();
        const bodyChildNodes = document2.body.childNodes;
        while (bodyChildNodes.length > 0) {
          fragment.appendChild(bodyChildNodes[0]);
        }
        const treeWalker = document2.createTreeWalker(fragment, NodeFilter.SHOW_ELEMENT);
        const nodes = [];
        let currentNode;
        while (currentNode = treeWalker.nextNode()) {
          nodes.push(currentNode);
        }
        for (const currentNode2 of nodes) {
          for (const attributeName of currentNode2.getAttributeNames()) {
            this.setDomElementAttribute(currentNode2, attributeName, currentNode2.getAttribute(attributeName));
          }
          const elementName = currentNode2.tagName.toLowerCase();
          if (this._shouldRenameElement(elementName)) {
            _logUnsafeElement(elementName);
            currentNode2.replaceWith(this._createReplacementDomElement(elementName, currentNode2));
          }
        }
        while (domElement.firstChild) {
          domElement.firstChild.remove();
        }
        domElement.append(fragment);
      }
      /**
      * Converts the view to the DOM. For all text nodes, not bound elements and document fragments new items will
      * be created. For bound elements and document fragments the method will return corresponding items.
      *
      * @param viewNode View node or document fragment to transform.
      * @param options Conversion options.
      * @param options.bind Determines whether new elements will be bound.
      * @param options.withChildren If `false`, node's and document fragment's children will not be converted.
      * @returns Converted node or DocumentFragment.
      */
      viewToDom(viewNode, options = {}) {
        if (viewNode.is("$text")) {
          const textData = this._processDataFromViewText(viewNode);
          return this._domDocument.createTextNode(textData);
        } else {
          const viewElementOrFragment = viewNode;
          if (this.mapViewToDom(viewElementOrFragment)) {
            if (viewElementOrFragment.getCustomProperty("editingPipeline:doNotReuseOnce")) {
              this._elementsWithTemporaryCustomProperties.add(viewElementOrFragment);
            } else {
              return this.mapViewToDom(viewElementOrFragment);
            }
          }
          let domElement;
          if (viewElementOrFragment.is("documentFragment")) {
            domElement = this._domDocument.createDocumentFragment();
            if (options.bind) {
              this.bindDocumentFragments(domElement, viewElementOrFragment);
            }
          } else if (viewElementOrFragment.is("uiElement")) {
            if (viewElementOrFragment.name === "$comment") {
              domElement = this._domDocument.createComment(viewElementOrFragment.getCustomProperty("$rawContent"));
            } else {
              domElement = viewElementOrFragment.render(this._domDocument, this);
            }
            if (options.bind) {
              this.bindElements(domElement, viewElementOrFragment);
            }
            return domElement;
          } else {
            if (this._shouldRenameElement(viewElementOrFragment.name)) {
              _logUnsafeElement(viewElementOrFragment.name);
              domElement = this._createReplacementDomElement(viewElementOrFragment.name);
            } else if (viewElementOrFragment.hasAttribute("xmlns")) {
              domElement = this._domDocument.createElementNS(viewElementOrFragment.getAttribute("xmlns"), viewElementOrFragment.name);
            } else {
              domElement = this._domDocument.createElement(viewElementOrFragment.name);
            }
            if (viewElementOrFragment.is("rawElement")) {
              viewElementOrFragment.render(domElement, this);
            }
            if (options.bind) {
              this.bindElements(domElement, viewElementOrFragment);
            }
            for (const key of viewElementOrFragment.getAttributeKeys()) {
              this.setDomElementAttribute(domElement, key, viewElementOrFragment.getAttribute(key), viewElementOrFragment);
            }
          }
          if (options.withChildren !== false) {
            for (const child of this.viewChildrenToDom(viewElementOrFragment, options)) {
              if (domElement instanceof HTMLTemplateElement) {
                domElement.content.appendChild(child);
              } else {
                domElement.appendChild(child);
              }
            }
          }
          return domElement;
        }
      }
      /**
      * Sets the attribute on a DOM element.
      *
      * **Note**: To remove the attribute, use {@link #removeDomElementAttribute}.
      *
      * @param domElement The DOM element the attribute should be set on.
      * @param key The name of the attribute.
      * @param value The value of the attribute.
      * @param relatedViewElement The view element related to the `domElement` (if there is any).
      * It helps decide whether the attribute set is unsafe. For instance, view elements created via the
      * {@link module:engine/view/downcastwriter~DowncastWriter} methods can allow certain attributes that would normally be filtered out.
      */
      setDomElementAttribute(domElement, key, value, relatedViewElement) {
        const shouldRenderAttribute = this.shouldRenderAttribute(key, value, domElement.tagName.toLowerCase()) || relatedViewElement && relatedViewElement.shouldRenderUnsafeAttribute(key);
        if (!shouldRenderAttribute) {
          logWarning("domconverter-unsafe-attribute-detected", {
            domElement,
            key,
            value
          });
        }
        if (!isValidAttributeName(key)) {
          logWarning("domconverter-invalid-attribute-detected", {
            domElement,
            key,
            value
          });
          return;
        }
        if (domElement.hasAttribute(key) && !shouldRenderAttribute) {
          domElement.removeAttribute(key);
        } else if (domElement.hasAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key) && shouldRenderAttribute) {
          domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
        }
        domElement.setAttribute(shouldRenderAttribute ? key : UNSAFE_ATTRIBUTE_NAME_PREFIX + key, value);
      }
      /**
      * Removes an attribute from a DOM element.
      *
      * **Note**: To set the attribute, use {@link #setDomElementAttribute}.
      *
      * @param domElement The DOM element the attribute should be removed from.
      * @param key The name of the attribute.
      */
      removeDomElementAttribute(domElement, key) {
        if (key == UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE) {
          return;
        }
        domElement.removeAttribute(key);
        domElement.removeAttribute(UNSAFE_ATTRIBUTE_NAME_PREFIX + key);
      }
      /**
      * Converts children of the view element to DOM using the
      * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
      * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
      *
      * @param viewElement Parent view element.
      * @param options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
      * @returns DOM nodes.
      */
      *viewChildrenToDom(viewElement, options = {}) {
        const fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
        let offset = 0;
        for (const childView of viewElement.getChildren()) {
          if (fillerPositionOffset === offset) {
            yield this._getBlockFiller();
          }
          const transparentRendering = childView.is("element") && !!childView.getCustomProperty("dataPipeline:transparentRendering") && !first(childView.getAttributes());
          if (transparentRendering && this.renderingMode == "data") {
            yield* this.viewChildrenToDom(childView, options);
          } else {
            if (transparentRendering) {
              logWarning("domconverter-transparent-rendering-unsupported-in-editing-pipeline", {
                viewElement: childView
              });
            }
            yield this.viewToDom(childView, options);
          }
          offset++;
        }
        if (fillerPositionOffset === offset) {
          yield this._getBlockFiller();
        }
      }
      /**
      * Converts view {@link module:engine/view/range~Range} to DOM range.
      * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
      *
      * @param viewRange View range.
      * @returns DOM range.
      */
      viewRangeToDom(viewRange) {
        const domStart = this.viewPositionToDom(viewRange.start);
        const domEnd = this.viewPositionToDom(viewRange.end);
        const domRange = this._domDocument.createRange();
        domRange.setStart(domStart.parent, domStart.offset);
        domRange.setEnd(domEnd.parent, domEnd.offset);
        return domRange;
      }
      /**
      * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
      *
      * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
      * If the converted position is directly before inline filler it is moved inside the filler.
      *
      * @param viewPosition View position.
      * @returns DOM position or `null` if view position could not be converted to DOM.
      * DOM position has two properties:
      * * `parent` - DOM position parent.
      * * `offset` - DOM position offset.
      */
      viewPositionToDom(viewPosition) {
        const viewParent = viewPosition.parent;
        if (viewParent.is("$text")) {
          const domParent = this.findCorrespondingDomText(viewParent);
          if (!domParent) {
            return null;
          }
          let offset = viewPosition.offset;
          if (startsWithFiller(domParent)) {
            offset += INLINE_FILLER_LENGTH;
          }
          return {
            parent: domParent,
            offset
          };
        } else {
          let domParent, domBefore, domAfter;
          if (viewPosition.offset === 0) {
            domParent = this.mapViewToDom(viewParent);
            if (!domParent) {
              return null;
            }
            domAfter = domParent.childNodes[0];
          } else {
            const nodeBefore = viewPosition.nodeBefore;
            domBefore = nodeBefore.is("$text") ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(nodeBefore);
            if (!domBefore) {
              return null;
            }
            domParent = domBefore.parentNode;
            domAfter = domBefore.nextSibling;
          }
          if (isText(domAfter) && startsWithFiller(domAfter)) {
            return {
              parent: domAfter,
              offset: INLINE_FILLER_LENGTH
            };
          }
          const offset = domBefore ? indexOf(domBefore) + 1 : 0;
          return {
            parent: domParent,
            offset
          };
        }
      }
      /**
      * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
      * be created. For bound elements and document fragments function will return corresponding items. For
      * {@link module:engine/view/filler fillers} `null` will be returned.
      * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
      *
      * @param domNode DOM node or document fragment to transform.
      * @param options Conversion options.
      * @param options.bind Determines whether new elements will be bound. False by default.
      * @param options.withChildren If `true`, node's and document fragment's children will be converted too. True by default.
      * @param options.keepOriginalCase If `false`, node's tag name will be converted to lower case. False by default.
      * @param options.skipComments If `false`, comment nodes will be converted to `$comment`
      * {@link module:engine/view/uielement~UIElement view UI elements}. False by default.
      * @returns Converted node or document fragment or `null` if DOM node is a {@link module:engine/view/filler filler}
      * or the given node is an empty text node.
      */
      domToView(domNode, options = {}) {
        const inlineNodes = [];
        const generator = this._domToView(domNode, options, inlineNodes);
        const node = generator.next().value;
        if (!node) {
          return null;
        }
        generator.next();
        this._processDomInlineNodes(null, inlineNodes, options);
        if (node.is("$text") && node.data.length == 0) {
          return null;
        }
        return node;
      }
      /**
      * Converts children of the DOM element to view nodes using
      * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
      * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
      *
      * @param domElement Parent DOM element.
      * @param options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
      * @param inlineNodes An array that will be populated with inline nodes. It's used internally for whitespace processing.
      * @returns View nodes.
      */
      *domChildrenToView(domElement, options = {}, inlineNodes = []) {
        let childNodes = [];
        if (domElement instanceof HTMLTemplateElement) {
          childNodes = [
            ...domElement.content.childNodes
          ];
        } else {
          childNodes = [
            ...domElement.childNodes
          ];
        }
        for (let i = 0; i < childNodes.length; i++) {
          const domChild = childNodes[i];
          const generator = this._domToView(domChild, options, inlineNodes);
          const viewChild = generator.next().value;
          if (viewChild !== null) {
            if (this._isBlockViewElement(viewChild)) {
              this._processDomInlineNodes(domElement, inlineNodes, options);
            }
            yield viewChild;
            generator.next();
          }
        }
        this._processDomInlineNodes(domElement, inlineNodes, options);
      }
      /**
      * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
      * Ranges which cannot be converted will be omitted.
      *
      * @param domSelection DOM selection.
      * @returns View selection.
      */
      domSelectionToView(domSelection) {
        if (isGeckoRestrictedDomSelection(domSelection)) {
          return new Selection$1([]);
        }
        if (domSelection.rangeCount === 1) {
          let container = domSelection.getRangeAt(0).startContainer;
          if (isText(container)) {
            container = container.parentNode;
          }
          const viewSelection = this.fakeSelectionToView(container);
          if (viewSelection) {
            return viewSelection;
          }
        }
        const isBackward = this.isDomSelectionBackward(domSelection);
        const viewRanges = [];
        for (let i = 0; i < domSelection.rangeCount; i++) {
          const domRange = domSelection.getRangeAt(i);
          const viewRange = this.domRangeToView(domRange);
          if (viewRange) {
            viewRanges.push(viewRange);
          }
        }
        return new Selection$1(viewRanges, {
          backward: isBackward
        });
      }
      /**
      * Converts DOM Range to view {@link module:engine/view/range~Range}.
      * If the start or end position can not be converted `null` is returned.
      *
      * @param domRange DOM range.
      * @returns View range.
      */
      domRangeToView(domRange) {
        const viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
        const viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);
        if (viewStart && viewEnd) {
          return new Range$1(viewStart, viewEnd);
        }
        return null;
      }
      /**
      * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
      *
      * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
      * position of the filler will be converted and returned.
      *
      * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
      * that position will be converted to view position before that UIElement.
      *
      * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
      *
      * @param domParent DOM position parent.
      * @param domOffset DOM position offset. You can skip it when converting the inline filler node.
      * @returns View position.
      */
      domPositionToView(domParent, domOffset = 0) {
        if (this.isBlockFiller(domParent)) {
          return this.domPositionToView(domParent.parentNode, indexOf(domParent));
        }
        const viewElement = this.mapDomToView(domParent);
        if (viewElement && (viewElement.is("uiElement") || viewElement.is("rawElement"))) {
          return Position$1._createBefore(viewElement);
        }
        if (isText(domParent)) {
          if (isInlineFiller(domParent)) {
            return this.domPositionToView(domParent.parentNode, indexOf(domParent));
          }
          const viewParent = this.findCorrespondingViewText(domParent);
          let offset = domOffset;
          if (!viewParent) {
            return null;
          }
          if (startsWithFiller(domParent)) {
            offset -= INLINE_FILLER_LENGTH;
            offset = offset < 0 ? 0 : offset;
          }
          return new Position$1(viewParent, offset);
        } else {
          if (domOffset === 0) {
            const viewParent = this.mapDomToView(domParent);
            if (viewParent) {
              return new Position$1(viewParent, 0);
            }
          } else {
            const domBefore = domParent.childNodes[domOffset - 1];
            if (isText(domBefore) && isInlineFiller(domBefore) || domBefore && this.isBlockFiller(domBefore)) {
              return this.domPositionToView(domBefore.parentNode, indexOf(domBefore));
            }
            const viewBefore = isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore);
            if (viewBefore && viewBefore.parent) {
              return new Position$1(viewBefore.parent, viewBefore.index + 1);
            }
          }
          return null;
        }
      }
      /**
      * Returns corresponding view {@link module:engine/view/element~Element Element} or
      * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
      * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
      * to the given DOM - `undefined` is returned.
      *
      * For all DOM elements rendered by a {@link module:engine/view/uielement~UIElement} or
      * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
      *
      * @param domElementOrDocumentFragment DOM element or document fragment.
      * @returns Corresponding view element, document fragment or `undefined` if no element was bound.
      */
      mapDomToView(domElementOrDocumentFragment) {
        const hostElement = this.getHostViewElement(domElementOrDocumentFragment);
        return hostElement || this._domToViewMapping.get(domElementOrDocumentFragment);
      }
      /**
      * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
      * corresponding text node is returned based on the sibling or parent.
      *
      * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
      * to find the corresponding text node.
      *
      * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
      * element, it is used to find the corresponding text node.
      *
      * For all text nodes rendered by a {@link module:engine/view/uielement~UIElement} or
      * a {@link module:engine/view/rawelement~RawElement}, the parent `UIElement` or `RawElement` will be returned.
      *
      * Otherwise `null` is returned.
      *
      * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
      *
      * @param domText DOM text node.
      * @returns Corresponding view text node or `null`, if it was not possible to find a corresponding node.
      */
      findCorrespondingViewText(domText) {
        if (isInlineFiller(domText)) {
          return null;
        }
        const hostElement = this.getHostViewElement(domText);
        if (hostElement) {
          return hostElement;
        }
        const previousSibling = domText.previousSibling;
        if (previousSibling) {
          if (!this.isElement(previousSibling)) {
            return null;
          }
          const viewElement = this.mapDomToView(previousSibling);
          if (viewElement) {
            const nextSibling = viewElement.nextSibling;
            if (nextSibling instanceof Text$1) {
              return nextSibling;
            } else {
              return null;
            }
          }
        } else {
          const viewElement = this.mapDomToView(domText.parentNode);
          if (viewElement) {
            const firstChild = viewElement.getChild(0);
            if (firstChild instanceof Text$1) {
              return firstChild;
            } else {
              return null;
            }
          }
        }
        return null;
      }
      mapViewToDom(documentFragmentOrElement) {
        return this._viewToDomMapping.get(documentFragmentOrElement);
      }
      /**
      * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
      * corresponding text node is returned based on the sibling or parent.
      *
      * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
      * to find the corresponding text node.
      *
      * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
      * element, it is used to find the corresponding text node.
      *
      * Otherwise `null` is returned.
      *
      * @param viewText View text node.
      * @returns Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
      */
      findCorrespondingDomText(viewText) {
        const previousSibling = viewText.previousSibling;
        if (previousSibling && this.mapViewToDom(previousSibling)) {
          return this.mapViewToDom(previousSibling).nextSibling;
        }
        if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
          return this.mapViewToDom(viewText.parent).childNodes[0];
        }
        return null;
      }
      /**
      * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
      */
      focus(viewEditable) {
        const domEditable = this.mapViewToDom(viewEditable);
        if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
          const { scrollX, scrollY } = global$1.window;
          const scrollPositions = [];
          forEachDomElementAncestor(domEditable, (node) => {
            const { scrollLeft, scrollTop } = node;
            scrollPositions.push([
              scrollLeft,
              scrollTop
            ]);
          });
          domEditable.focus();
          forEachDomElementAncestor(domEditable, (node) => {
            const [scrollLeft, scrollTop] = scrollPositions.shift();
            node.scrollLeft = scrollLeft;
            node.scrollTop = scrollTop;
          });
          global$1.window.scrollTo(scrollX, scrollY);
        }
      }
      /**
      * Remove DOM selection from blurred editable, so it won't interfere with clicking on dropdowns (especially on iOS).
      *
      * @internal
      */
      _clearDomSelection() {
        const domEditable = this.mapViewToDom(this.document.selection.editableElement);
        if (!domEditable) {
          return;
        }
        const domSelection = domEditable.ownerDocument.defaultView.getSelection();
        const newViewSelection = this.domSelectionToView(domSelection);
        const selectionInEditable = newViewSelection && newViewSelection.rangeCount > 0;
        if (selectionInEditable) {
          domSelection.removeAllRanges();
        }
      }
      /**
      * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
      *
      * @param node Node to check.
      */
      isElement(node) {
        return node && node.nodeType == Node.ELEMENT_NODE;
      }
      /**
      * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
      *
      * @param node Node to check.
      */
      isDocumentFragment(node) {
        return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
      }
      /**
      * Checks if the node is an instance of the block filler for this DOM converter.
      *
      * ```ts
      * const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
      *
      * converter.isBlockFiller( BR_FILLER( document ) ); // true
      * converter.isBlockFiller( NBSP_FILLER( document ) ); // false
      * ```
      *
      * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
      *
      * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
      *
      * @param domNode DOM node to check.
      * @returns True if a node is considered a block filler for given mode.
      */
      isBlockFiller(domNode) {
        if (this.blockFillerMode == "br") {
          return domNode.isEqualNode(BR_FILLER_REF);
        }
        if (domNode.tagName === "BR" && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {
          return true;
        }
        return domNode.isEqualNode(MARKED_NBSP_FILLER_REF) || isNbspBlockFiller(domNode, this.blockElements);
      }
      /**
      * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
      *
      * @param DOM Selection instance to check.
      */
      isDomSelectionBackward(selection) {
        if (selection.isCollapsed) {
          return false;
        }
        const range = this._domDocument.createRange();
        try {
          range.setStart(selection.anchorNode, selection.anchorOffset);
          range.setEnd(selection.focusNode, selection.focusOffset);
        } catch (e) {
          return false;
        }
        const backward = range.collapsed;
        range.detach();
        return backward;
      }
      /**
      * Returns a parent {@link module:engine/view/uielement~UIElement} or {@link module:engine/view/rawelement~RawElement}
      * that hosts the provided DOM node. Returns `null` if there is no such parent.
      */
      getHostViewElement(domNode) {
        const ancestors = getAncestors(domNode);
        ancestors.pop();
        while (ancestors.length) {
          const domNode2 = ancestors.pop();
          const viewNode = this._domToViewMapping.get(domNode2);
          if (viewNode && (viewNode.is("uiElement") || viewNode.is("rawElement"))) {
            return viewNode;
          }
        }
        return null;
      }
      /**
      * Checks if the given selection's boundaries are at correct places.
      *
      * The following places are considered as incorrect for selection boundaries:
      *
      * * before or in the middle of an inline filler sequence,
      * * inside a DOM element which represents {@link module:engine/view/uielement~UIElement a view UI element},
      * * inside a DOM element which represents {@link module:engine/view/rawelement~RawElement a view raw element}.
      *
      * @param domSelection The DOM selection object to be checked.
      * @returns `true` if the given selection is at a correct place, `false` otherwise.
      */
      isDomSelectionCorrect(domSelection) {
        return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
      * and not processed during the conversion from DOM nodes to view elements.
      *
      * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
      * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
      *
      * The raw data can be later accessed by a
      * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
      *
      * @param pattern Pattern matching a view element whose content should
      * be treated as raw data.
      */
      registerRawContentMatcher(pattern) {
        this._rawContentElementMatcher.add(pattern);
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} for inline object view elements.
      *
      * This is affecting how {@link module:engine/view/domconverter~DomConverter#domToView} and
      * {@link module:engine/view/domconverter~DomConverter#domChildrenToView} process DOM nodes.
      *
      * This is an extension of a simple {@link #inlineObjectElements} array of element names.
      *
      * @param pattern Pattern matching a view element which should be treated as an inline object.
      */
      registerInlineObjectMatcher(pattern) {
        this._inlineObjectElementMatcher.add(pattern);
      }
      /**
      * Clear temporary custom properties.
      *
      * @internal
      */
      _clearTemporaryCustomProperties() {
        for (const element of this._elementsWithTemporaryCustomProperties) {
          element._removeCustomProperty("editingPipeline:doNotReuseOnce");
        }
        this._elementsWithTemporaryCustomProperties.clear();
      }
      /**
      * Returns the block {@link module:engine/view/filler filler} node based on the current {@link #blockFillerMode} setting.
      */
      _getBlockFiller() {
        switch (this.blockFillerMode) {
          case "nbsp":
            return NBSP_FILLER(this._domDocument);
          case "markedNbsp":
            return MARKED_NBSP_FILLER(this._domDocument);
          case "br":
            return BR_FILLER(this._domDocument);
        }
      }
      /**
      * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
      *
      * @param domParent Position parent.
      * @param offset Position offset.
      * @returns `true` if given position is at a correct place for selection boundary, `false` otherwise.
      */
      _isDomSelectionPositionCorrect(domParent, offset) {
        if (isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {
          return false;
        }
        if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {
          return false;
        }
        const viewParent = this.mapDomToView(domParent);
        if (viewParent && (viewParent.is("uiElement") || viewParent.is("rawElement"))) {
          return false;
        }
        return true;
      }
      /**
      * Internal generator for {@link #domToView}. Also used by {@link #domChildrenToView}.
      * Separates DOM nodes conversion from whitespaces processing.
      *
      * @param domNode DOM node or document fragment to transform.
      * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
      * Used later to process whitespaces.
      */
      *_domToView(domNode, options, inlineNodes) {
        if (this.isBlockFiller(domNode)) {
          return null;
        }
        const hostElement = this.getHostViewElement(domNode);
        if (hostElement) {
          return hostElement;
        }
        if (isComment(domNode) && options.skipComments) {
          return null;
        }
        if (isText(domNode)) {
          if (isInlineFiller(domNode)) {
            return null;
          } else {
            const textData = domNode.data;
            if (textData === "") {
              return null;
            }
            const textNode = new Text$1(this.document, textData);
            inlineNodes.push(textNode);
            return textNode;
          }
        } else {
          let viewElement = this.mapDomToView(domNode);
          if (viewElement) {
            if (this._isInlineObjectElement(viewElement)) {
              inlineNodes.push(viewElement);
            }
            return viewElement;
          }
          if (this.isDocumentFragment(domNode)) {
            viewElement = new DocumentFragment$1(this.document);
            if (options.bind) {
              this.bindDocumentFragments(domNode, viewElement);
            }
          } else {
            viewElement = this._createViewElement(domNode, options);
            if (options.bind) {
              this.bindElements(domNode, viewElement);
            }
            const attrs = domNode.attributes;
            if (attrs) {
              for (let l = attrs.length, i = 0; i < l; i++) {
                viewElement._setAttribute(attrs[i].name, attrs[i].value);
              }
            }
            if (this._isViewElementWithRawContent(viewElement, options)) {
              viewElement._setCustomProperty("$rawContent", domNode.innerHTML);
              if (!this._isBlockViewElement(viewElement)) {
                inlineNodes.push(viewElement);
              }
              return viewElement;
            }
            if (isComment(domNode)) {
              viewElement._setCustomProperty("$rawContent", domNode.data);
              return viewElement;
            }
          }
          yield viewElement;
          const nestedInlineNodes = [];
          if (options.withChildren !== false) {
            for (const child of this.domChildrenToView(domNode, options, nestedInlineNodes)) {
              viewElement._appendChild(child);
            }
          }
          if (this._isInlineObjectElement(viewElement)) {
            inlineNodes.push(viewElement);
          } else {
            for (const inlineNode of nestedInlineNodes) {
              inlineNodes.push(inlineNode);
            }
          }
        }
      }
      /**
      * Internal helper that walks the list of inline view nodes already generated from DOM nodes
      * and handles whitespaces and NBSPs.
      *
      * @param domParent The DOM parent of the given inline nodes. This should be a document fragment or
      * a block element to whitespace processing start cleaning.
      * @param inlineNodes An array of recently encountered inline nodes truncated to the block element boundaries.
      */
      _processDomInlineNodes(domParent, inlineNodes, options) {
        if (!inlineNodes.length) {
          return;
        }
        if (domParent && !this.isDocumentFragment(domParent) && !this._isBlockDomElement(domParent)) {
          return;
        }
        let prevNodeEndsWithSpace = false;
        for (let i = 0; i < inlineNodes.length; i++) {
          const node = inlineNodes[i];
          if (!node.is("$text")) {
            prevNodeEndsWithSpace = false;
            continue;
          }
          let data;
          let nodeEndsWithSpace = false;
          if (this._isPreFormatted(node)) {
            data = getDataWithoutFiller(node.data);
          } else {
            data = node.data.replace(/[ \n\t\r]{1,}/g, " ");
            nodeEndsWithSpace = /[^\S\u00A0]/.test(data.charAt(data.length - 1));
            const prevNode = i > 0 ? inlineNodes[i - 1] : null;
            const nextNode = i + 1 < inlineNodes.length ? inlineNodes[i + 1] : null;
            const shouldLeftTrim = !prevNode || prevNode.is("element") && prevNode.name == "br" || prevNodeEndsWithSpace;
            const shouldRightTrim = nextNode ? false : !startsWithFiller(node.data);
            if (options.withChildren !== false) {
              if (shouldLeftTrim) {
                data = data.replace(/^ /, "");
              }
              if (shouldRightTrim) {
                data = data.replace(/ $/, "");
              }
            }
            data = getDataWithoutFiller(data);
            data = data.replace(/ \u00A0/g, "  ");
            const isNextNodeInlineObjectElement = nextNode && nextNode.is("element") && nextNode.name != "br";
            const isNextNodeStartingWithSpace = nextNode && nextNode.is("$text") && nextNode.data.charAt(0) == " ";
            if (/[ \u00A0]\u00A0$/.test(data) || !nextNode || isNextNodeInlineObjectElement || isNextNodeStartingWithSpace) {
              data = data.replace(/\u00A0$/, " ");
            }
            if (shouldLeftTrim || prevNode && prevNode.is("element") && prevNode.name != "br") {
              data = data.replace(/^\u00A0/, " ");
            }
          }
          if (data.length == 0 && node.parent) {
            node._remove();
            inlineNodes.splice(i, 1);
            i--;
          } else {
            node._data = data;
            prevNodeEndsWithSpace = nodeEndsWithSpace;
          }
        }
        inlineNodes.length = 0;
      }
      /**
      * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
      * it is correctly displayed in the DOM.
      *
      * Following changes are done:
      *
      * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
      * element or if a previous text node ends with a space character,
      * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
      * starts with a space or if it is the last text node in its container,
      * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
      *
      * Content of {@link #preElements} is not processed.
      *
      * @param node View text node to process.
      * @returns Processed text data.
      */
      _processDataFromViewText(node) {
        let data = node.data;
        if (this._isPreFormatted(node)) {
          return data;
        }
        if (data.charAt(0) == " ") {
          const prevNode = this._getTouchingInlineViewNode(node, false);
          const prevEndsWithSpace = prevNode && prevNode.is("$textProxy") && this._nodeEndsWithSpace(prevNode);
          if (prevEndsWithSpace || !prevNode) {
            data = " " + data.substr(1);
          }
        }
        if (data.charAt(data.length - 1) == " ") {
          const nextNode = this._getTouchingInlineViewNode(node, true);
          const nextStartsWithSpace = nextNode && nextNode.is("$textProxy") && nextNode.data.charAt(0) == " ";
          if (data.charAt(data.length - 2) == " " || !nextNode || nextStartsWithSpace) {
            data = data.substr(0, data.length - 1) + " ";
          }
        }
        return data.replace(/ {2}/g, "  ");
      }
      /**
      * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
      *
      * @param  node Node to check.
      * @returns `true` if given `node` ends with space, `false` otherwise.
      */
      _nodeEndsWithSpace(node) {
        if (this._isPreFormatted(node)) {
          return false;
        }
        const data = this._processDataFromViewText(node);
        return data.charAt(data.length - 1) == " ";
      }
      /**
      * Checks whether given text contains preformatted white space. This is the case if
      * * any of node ancestors has a name which is in `preElements` array, or
      * * the closest ancestor that has the `white-space` CSS property sets it to a value that preserves spaces
      *
      * @param node Node to check
      * @returns `true` if given node contains preformatted white space, `false` otherwise.
      */
      _isPreFormatted(node) {
        if (_hasViewParentOfType(node, this.preElements)) {
          return true;
        }
        for (const ancestor of node.getAncestors({
          parentFirst: true
        })) {
          if (!ancestor.is("element") || !ancestor.hasStyle("white-space") || ancestor.getStyle("white-space") === "inherit") {
            continue;
          }
          return [
            "pre",
            "pre-wrap",
            "break-spaces"
          ].includes(ancestor.getStyle("white-space"));
        }
        return false;
      }
      /**
      * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
      * that is contained in the same container element. If there is no such sibling, `null` is returned.
      *
      * @param node Reference node.
      * @returns Touching text node, an inline object
      * or `null` if there is no next or previous touching text node.
      */
      _getTouchingInlineViewNode(node, getNext) {
        const treeWalker = new TreeWalker$1({
          startPosition: getNext ? Position$1._createAfter(node) : Position$1._createBefore(node),
          direction: getNext ? "forward" : "backward"
        });
        for (const value of treeWalker) {
          if (value.item.is("element", "br")) {
            return null;
          } else if (this._isInlineObjectElement(value.item)) {
            return value.item;
          } else if (value.item.is("containerElement")) {
            return null;
          } else if (value.item.is("$textProxy")) {
            return value.item;
          }
        }
        return null;
      }
      /**
      * Returns `true` if a DOM node belongs to {@link #blockElements}. `false` otherwise.
      */
      _isBlockDomElement(node) {
        return this.isElement(node) && this.blockElements.includes(node.tagName.toLowerCase());
      }
      /**
      * Returns `true` if a view node belongs to {@link #blockElements}. `false` otherwise.
      */
      _isBlockViewElement(node) {
        return node.is("element") && this.blockElements.includes(node.name);
      }
      /**
      * Returns `true` if a DOM node belongs to {@link #inlineObjectElements}. `false` otherwise.
      */
      _isInlineObjectElement(node) {
        if (!node.is("element")) {
          return false;
        }
        return node.name == "br" || this.inlineObjectElements.includes(node.name) || !!this._inlineObjectElementMatcher.match(node);
      }
      /**
      * Creates view element basing on the node type.
      *
      * @param node DOM node to check.
      * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
      */
      _createViewElement(node, options) {
        if (isComment(node)) {
          return new UIElement(this.document, "$comment");
        }
        const viewName = options.keepOriginalCase ? node.tagName : node.tagName.toLowerCase();
        return new Element$1(this.document, viewName);
      }
      /**
      * Checks if view element's content should be treated as a raw data.
      *
      * @param viewElement View element to check.
      * @param options Conversion options. See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
      */
      _isViewElementWithRawContent(viewElement, options) {
        return options.withChildren !== false && viewElement.is("element") && !!this._rawContentElementMatcher.match(viewElement);
      }
      /**
      * Checks whether a given element name should be renamed in a current rendering mode.
      *
      * @param elementName The name of view element.
      */
      _shouldRenameElement(elementName) {
        const name = elementName.toLowerCase();
        return this.renderingMode === "editing" && this.unsafeElements.includes(name);
      }
      /**
      * Return a <span> element with a special attribute holding the name of the original element.
      * Optionally, copy all the attributes of the original element if that element is provided.
      *
      * @param elementName The name of view element.
      * @param originalDomElement The original DOM element to copy attributes and content from.
      */
      _createReplacementDomElement(elementName, originalDomElement) {
        const newDomElement = this._domDocument.createElement("span");
        newDomElement.setAttribute(UNSAFE_ELEMENT_REPLACEMENT_ATTRIBUTE, elementName);
        if (originalDomElement) {
          while (originalDomElement.firstChild) {
            newDomElement.appendChild(originalDomElement.firstChild);
          }
          for (const attributeName of originalDomElement.getAttributeNames()) {
            newDomElement.setAttribute(attributeName, originalDomElement.getAttribute(attributeName));
          }
        }
        return newDomElement;
      }
    }
    function _hasViewParentOfType(node, types) {
      return node.getAncestors().some((parent2) => parent2.is("element") && types.includes(parent2.name));
    }
    function forEachDomElementAncestor(element, callback) {
      let node = element;
      while (node) {
        callback(node);
        node = node.parentElement;
      }
    }
    function isNbspBlockFiller(domNode, blockElements) {
      const isNBSP = domNode.isEqualNode(NBSP_FILLER_REF);
      return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
    }
    function hasBlockParent(domNode, blockElements) {
      const parent2 = domNode.parentNode;
      return !!parent2 && !!parent2.tagName && blockElements.includes(parent2.tagName.toLowerCase());
    }
    function _logUnsafeElement(elementName) {
      if (elementName === "script") {
        logWarning("domconverter-unsafe-script-element-detected");
      }
      if (elementName === "style") {
        logWarning("domconverter-unsafe-style-element-detected");
      }
    }
    function isGeckoRestrictedDomSelection(domSelection) {
      if (!env.isGecko) {
        return false;
      }
      if (!domSelection.rangeCount) {
        return false;
      }
      const container = domSelection.getRangeAt(0).startContainer;
      try {
        Object.prototype.toString.call(container);
      } catch (error) {
        return true;
      }
      return false;
    }
    class Observer extends (/* @__PURE__ */ DomEmitterMixin()) {
      /**
      * Creates an instance of the observer.
      */
      constructor(view) {
        super();
        /**
        * An instance of the view controller.
        */
        __publicField(this, "view");
        /**
        * A reference to the {@link module:engine/view/document~Document} object.
        */
        __publicField(this, "document");
        /**
        * The state of the observer. If it is disabled, no events will be fired.
        */
        __publicField(this, "_isEnabled", false);
        this.view = view;
        this.document = view.document;
      }
      /**
      * The state of the observer. If it is disabled, no events will be fired.
      */
      get isEnabled() {
        return this._isEnabled;
      }
      /**
      * Enables the observer. This method is called when the observer is registered to the
      * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
      * (all observers are {@link #disable disabled} before rendering).
      *
      * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
      * However, a child class may not need to be disabled, so it can implement an empty method.
      *
      * @see module:engine/view/observer/observer~Observer#disable
      */
      enable() {
        this._isEnabled = true;
      }
      /**
      * Disables the observer. This method is called before
      * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
      *
      * @see module:engine/view/observer/observer~Observer#enable
      */
      disable() {
        this._isEnabled = false;
      }
      /**
      * Disables and destroys the observer, among others removes event listeners created by the observer.
      */
      destroy() {
        this.disable();
        this.stopListening();
      }
      /**
      * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
      *
      * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
      * This attribute can be used inside the structures generated by
      * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
      * fired within a UI that should be excluded from CKEditor 5's realms.
      *
      * @param domTarget The DOM event target to check (usually an element, sometimes a text node and
      * potentially sometimes a document, too).
      * @returns Whether this event should be ignored by the observer.
      */
      checkShouldIgnoreEventFromTarget(domTarget) {
        if (domTarget && domTarget.nodeType === 3) {
          domTarget = domTarget.parentNode;
        }
        if (!domTarget || domTarget.nodeType !== 1) {
          return false;
        }
        return domTarget.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
      }
    }
    class DomEventData {
      /**
      * @param view The instance of the view controller.
      * @param domEvent The DOM event.
      * @param additionalData Additional properties that the instance should contain.
      */
      constructor(view, domEvent, additionalData) {
        /**
        * Instance of the view controller.
        */
        __publicField(this, "view");
        /**
        * The instance of the document.
        */
        __publicField(this, "document");
        /**
        * The DOM event.
        */
        __publicField(this, "domEvent");
        /**
        * The DOM target.
        */
        __publicField(this, "domTarget");
        this.view = view;
        this.document = view.document;
        this.domEvent = domEvent;
        this.domTarget = domEvent.target;
        assignIn(this, additionalData);
      }
      /**
      * The tree view element representing the target.
      */
      get target() {
        return this.view.domConverter.mapDomToView(this.domTarget);
      }
      /**
      * Prevents the native's event default action.
      */
      preventDefault() {
        this.domEvent.preventDefault();
      }
      /**
      * Stops native event propagation.
      */
      stopPropagation() {
        this.domEvent.stopPropagation();
      }
    }
    class DomEventObserver extends Observer {
      constructor() {
        super(...arguments);
        /**
        * If set to `true` DOM events will be listened on the capturing phase.
        * Default value is `false`.
        */
        __publicField(this, "useCapture", false);
      }
      /**
      * @inheritDoc
      */
      observe(domElement) {
        const types = typeof this.domEventType == "string" ? [
          this.domEventType
        ] : this.domEventType;
        types.forEach((type) => {
          this.listenTo(domElement, type, (eventInfo, domEvent) => {
            if (this.isEnabled && !this.checkShouldIgnoreEventFromTarget(domEvent.target)) {
              this.onDomEvent(domEvent);
            }
          }, {
            useCapture: this.useCapture
          });
        });
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        this.stopListening(domElement);
      }
      /**
      * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
      *
      * @see module:utils/emittermixin~Emitter#fire
      * @param eventType The event type (name).
      * @param domEvent The DOM event.
      * @param additionalData The additional data which should extend the
      * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
      */
      fire(eventType, domEvent, additionalData) {
        if (this.isEnabled) {
          this.document.fire(eventType, new DomEventData(this.view, domEvent, additionalData));
        }
      }
    }
    class KeyObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "keydown",
          "keyup"
        ]);
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvt) {
        const data = {
          keyCode: domEvt.keyCode,
          altKey: domEvt.altKey,
          ctrlKey: domEvt.ctrlKey,
          shiftKey: domEvt.shiftKey,
          metaKey: domEvt.metaKey,
          get keystroke() {
            return getCode(this);
          }
        };
        this.fire(domEvt.type, domEvt, data);
      }
    }
    class FakeSelectionObserver extends Observer {
      /**
      * Creates new FakeSelectionObserver instance.
      */
      constructor(view) {
        super(view);
        /**
        * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
        */
        __publicField(this, "_fireSelectionChangeDoneDebounced");
        this._fireSelectionChangeDoneDebounced = debounce((data) => {
          this.document.fire("selectionChangeDone", data);
        }, 200);
      }
      /**
      * @inheritDoc
      */
      observe() {
        const document2 = this.document;
        document2.on("arrowKey", (eventInfo, data) => {
          const selection = document2.selection;
          if (selection.isFake && this.isEnabled) {
            data.preventDefault();
          }
        }, {
          context: "$capture"
        });
        document2.on("arrowKey", (eventInfo, data) => {
          const selection = document2.selection;
          if (selection.isFake && this.isEnabled) {
            this._handleSelectionMove(data.keyCode);
          }
        }, {
          priority: "lowest"
        });
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._fireSelectionChangeDoneDebounced.cancel();
      }
      /**
      * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
      * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
      *
      * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
      * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
      * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
      */
      _handleSelectionMove(keyCode) {
        const selection = this.document.selection;
        const newSelection = new Selection$1(selection.getRanges(), {
          backward: selection.isBackward,
          fake: false
        });
        if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
          newSelection.setTo(newSelection.getFirstPosition());
        }
        if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
          newSelection.setTo(newSelection.getLastPosition());
        }
        const data = {
          oldSelection: selection,
          newSelection,
          domSelection: null
        };
        this.document.fire("selectionChange", data);
        this._fireSelectionChangeDoneDebounced(data);
      }
    }
    let MutationObserver$1 = class MutationObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * Reference to the {@link module:engine/view/view~View#domConverter}.
        */
        __publicField(this, "domConverter");
        /**
        * Reference to the {@link module:engine/view/view~View#_renderer}.
        */
        __publicField(this, "renderer");
        /**
        * Native mutation observer config.
        */
        __publicField(this, "_config");
        /**
        * Observed DOM elements.
        */
        __publicField(this, "_domElements");
        /**
        * Native mutation observer.
        */
        __publicField(this, "_mutationObserver");
        this._config = {
          childList: true,
          characterData: true,
          subtree: true
        };
        this.domConverter = view.domConverter;
        this.renderer = view._renderer;
        this._domElements = /* @__PURE__ */ new Set();
        this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
      }
      /**
      * Synchronously handles mutations and empties the queue.
      */
      flush() {
        this._onMutations(this._mutationObserver.takeRecords());
      }
      /**
      * @inheritDoc
      */
      observe(domElement) {
        this._domElements.add(domElement);
        if (this.isEnabled) {
          this._mutationObserver.observe(domElement, this._config);
        }
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        this._domElements.delete(domElement);
        if (this.isEnabled) {
          this._mutationObserver.disconnect();
          for (const domElement2 of this._domElements) {
            this._mutationObserver.observe(domElement2, this._config);
          }
        }
      }
      /**
      * @inheritDoc
      */
      enable() {
        super.enable();
        for (const domElement of this._domElements) {
          this._mutationObserver.observe(domElement, this._config);
        }
      }
      /**
      * @inheritDoc
      */
      disable() {
        super.disable();
        this._mutationObserver.disconnect();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._mutationObserver.disconnect();
      }
      /**
      * Handles mutations. Mark view elements to sync and call render.
      *
      * @param domMutations Array of native mutations.
      */
      _onMutations(domMutations) {
        if (domMutations.length === 0) {
          return;
        }
        const domConverter = this.domConverter;
        const mutatedTextNodes = /* @__PURE__ */ new Set();
        const elementsWithMutatedChildren = /* @__PURE__ */ new Set();
        for (const mutation of domMutations) {
          const element = domConverter.mapDomToView(mutation.target);
          if (!element) {
            continue;
          }
          if (element.is("uiElement") || element.is("rawElement")) {
            continue;
          }
          if (mutation.type === "childList" && !this._isBogusBrMutation(mutation)) {
            elementsWithMutatedChildren.add(element);
          }
        }
        for (const mutation of domMutations) {
          const element = domConverter.mapDomToView(mutation.target);
          if (element && (element.is("uiElement") || element.is("rawElement"))) {
            continue;
          }
          if (mutation.type === "characterData") {
            const text2 = domConverter.findCorrespondingViewText(mutation.target);
            if (text2 && !elementsWithMutatedChildren.has(text2.parent)) {
              mutatedTextNodes.add(text2);
            } else if (!text2 && startsWithFiller(mutation.target)) {
              elementsWithMutatedChildren.add(domConverter.mapDomToView(mutation.target.parentNode));
            }
          }
        }
        let hasMutations = false;
        for (const textNode of mutatedTextNodes) {
          hasMutations = true;
          this.renderer.markToSync("text", textNode);
        }
        for (const viewElement of elementsWithMutatedChildren) {
          const domElement = domConverter.mapViewToDom(viewElement);
          const viewChildren = Array.from(viewElement.getChildren());
          const newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {
            withChildren: false
          }));
          if (!isEqualWith(viewChildren, newViewChildren, sameNodes)) {
            hasMutations = true;
            this.renderer.markToSync("children", viewElement);
          }
        }
        if (hasMutations) {
          this.view.forceRender();
        }
      }
      /**
      * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
      * Such mutations are generated while pressing space or performing native spellchecker correction
      * on the end of the block element in Firefox browser.
      *
      * @param mutation Native mutation object.
      */
      _isBogusBrMutation(mutation) {
        let addedNode = null;
        if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {
          addedNode = this.domConverter.domToView(mutation.addedNodes[0], {
            withChildren: false
          });
        }
        return addedNode && addedNode.is("element", "br");
      }
    };
    function sameNodes(child1, child2) {
      if (Array.isArray(child1)) {
        return;
      }
      if (child1 === child2) {
        return true;
      } else if (child1.is("$text") && child2.is("$text")) {
        return child1.data === child2.data;
      }
      return false;
    }
    class FocusObserver extends DomEventObserver {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * Identifier of the timeout currently used by focus listener to delay rendering execution.
        */
        __publicField(this, "_renderTimeoutId");
        /**
        * Set to `true` if the document is in the process of setting the focus.
        *
        * The flag is used to indicate that setting the focus is in progress.
        */
        __publicField(this, "_isFocusChanging", false);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "focus",
          "blur"
        ]);
        this.useCapture = true;
        const document2 = this.document;
        document2.on("focus", () => {
          this._isFocusChanging = true;
          this._renderTimeoutId = setTimeout(() => {
            this.flush();
            view.change(() => {
            });
          }, 50);
        });
        document2.on("blur", (evt, data) => {
          const selectedEditable = document2.selection.editableElement;
          if (selectedEditable === null || selectedEditable === data.target) {
            document2.isFocused = false;
            this._isFocusChanging = false;
            view.change(() => {
            });
          }
        });
      }
      /**
      * Finishes setting the document focus state.
      */
      flush() {
        if (this._isFocusChanging) {
          this._isFocusChanging = false;
          this.document.isFocused = true;
        }
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._renderTimeoutId) {
          clearTimeout(this._renderTimeoutId);
        }
        super.destroy();
      }
    }
    class SelectionObserver extends Observer {
      constructor(view) {
        super(view);
        /**
        * Instance of the mutation observer. Selection observer calls
        * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled
        * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.
        */
        __publicField(this, "mutationObserver");
        /**
        * Instance of the focus observer. Focus observer calls
        * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
        */
        __publicField(this, "focusObserver");
        /**
        * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare
        * new selection with it.
        */
        __publicField(this, "selection");
        /**
        * Reference to the {@link module:engine/view/view~View#domConverter}.
        */
        __publicField(this, "domConverter");
        /**
        * A set of documents which have added `selectionchange` listener to avoid adding a listener twice to the same
        * document.
        */
        __publicField(this, "_documents");
        /**
        * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
        */
        __publicField(this, "_fireSelectionChangeDoneDebounced");
        /**
        * When called, starts clearing the {@link #_loopbackCounter} counter in time intervals. When the number of selection
        * changes exceeds a certain limit within the interval of time, the observer will not fire `selectionChange` but warn about
        * possible infinite selection loop.
        */
        __publicField(this, "_clearInfiniteLoopInterval");
        /**
        * Unlocks the `isSelecting` state of the view document in case the selection observer did not record this fact
        * correctly (for whatever reason). It is a safeguard (paranoid check), that returns document to the normal state
        * after a certain period of time (debounced, postponed by each selectionchange event).
        */
        __publicField(this, "_documentIsSelectingInactivityTimeoutDebounced");
        /**
        * Private property to check if the code does not enter infinite loop.
        */
        __publicField(this, "_loopbackCounter");
        this.mutationObserver = view.getObserver(MutationObserver$1);
        this.focusObserver = view.getObserver(FocusObserver);
        this.selection = this.document.selection;
        this.domConverter = view.domConverter;
        this._documents = /* @__PURE__ */ new WeakSet();
        this._fireSelectionChangeDoneDebounced = debounce((data) => {
          this.document.fire("selectionChangeDone", data);
        }, 200);
        this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3);
        this._documentIsSelectingInactivityTimeoutDebounced = debounce(() => this.document.isSelecting = false, 5e3);
        this._loopbackCounter = 0;
      }
      /**
      * @inheritDoc
      */
      observe(domElement) {
        const domDocument = domElement.ownerDocument;
        const startDocumentIsSelecting = () => {
          this.document.isSelecting = true;
          this._documentIsSelectingInactivityTimeoutDebounced();
        };
        const endDocumentIsSelecting = () => {
          if (!this.document.isSelecting) {
            return;
          }
          this._handleSelectionChange(null, domDocument);
          this.document.isSelecting = false;
          this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        };
        this.listenTo(domElement, "selectstart", startDocumentIsSelecting, {
          priority: "highest"
        });
        this.listenTo(domElement, "keydown", endDocumentIsSelecting, {
          priority: "highest",
          useCapture: true
        });
        this.listenTo(domElement, "keyup", endDocumentIsSelecting, {
          priority: "highest",
          useCapture: true
        });
        if (this._documents.has(domDocument)) {
          return;
        }
        this.listenTo(domDocument, "mouseup", endDocumentIsSelecting, {
          priority: "highest",
          useCapture: true
        });
        this.listenTo(domDocument, "selectionchange", (evt, domEvent) => {
          if (this.document.isComposing && !env.isAndroid) {
            return;
          }
          this._handleSelectionChange(domEvent, domDocument);
          this._documentIsSelectingInactivityTimeoutDebounced();
        });
        this._documents.add(domDocument);
      }
      /**
      * @inheritDoc
      */
      stopObserving(domElement) {
        this.stopListening(domElement);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        clearInterval(this._clearInfiniteLoopInterval);
        this._fireSelectionChangeDoneDebounced.cancel();
        this._documentIsSelectingInactivityTimeoutDebounced.cancel();
      }
      /* istanbul ignore next -- @preserve */
      _reportInfiniteLoop() {
      }
      /**
      * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
      * a selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
      * and {@link module:engine/view/document~Document#event:selectionChangeDone} when a selection stop changing.
      *
      * @param domEvent DOM event.
      * @param domDocument DOM document.
      */
      _handleSelectionChange(domEvent, domDocument) {
        if (!this.isEnabled) {
          return;
        }
        const domSelection = domDocument.defaultView.getSelection();
        if (this.checkShouldIgnoreEventFromTarget(domSelection.anchorNode)) {
          return;
        }
        this.mutationObserver.flush();
        const newViewSelection = this.domConverter.domSelectionToView(domSelection);
        if (newViewSelection.rangeCount == 0) {
          this.view.hasDomSelection = false;
          return;
        }
        this.view.hasDomSelection = true;
        this.focusObserver.flush();
        if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {
          return;
        }
        if (++this._loopbackCounter > 60) {
          this._reportInfiniteLoop();
          return;
        }
        if (this.selection.isSimilar(newViewSelection)) {
          this.view.forceRender();
        } else {
          const data = {
            oldSelection: this.selection,
            newSelection: newViewSelection,
            domSelection
          };
          this.document.fire("selectionChange", data);
          this._fireSelectionChangeDoneDebounced(data);
        }
      }
      /**
      * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
      */
      _clearInfiniteLoop() {
        this._loopbackCounter = 0;
      }
    }
    class CompositionObserver extends DomEventObserver {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "compositionstart",
          "compositionupdate",
          "compositionend"
        ]);
        const document2 = this.document;
        document2.on("compositionstart", () => {
          document2.isComposing = true;
        }, {
          priority: "low"
        });
        document2.on("compositionend", () => {
          document2.isComposing = false;
        }, {
          priority: "low"
        });
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent, {
          data: domEvent.data
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class DataTransfer {
      /**
      * @param nativeDataTransfer The native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
      * @param options.cacheFiles Whether `files` list should be initialized in the constructor.
      */
      constructor(nativeDataTransfer, options = {}) {
        /**
        * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
        */
        __publicField(this, "_files");
        /**
        * The native DataTransfer object.
        */
        __publicField(this, "_native");
        this._files = options.cacheFiles ? getFiles(nativeDataTransfer) : null;
        this._native = nativeDataTransfer;
      }
      /**
      * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
      */
      get files() {
        if (!this._files) {
          this._files = getFiles(this._native);
        }
        return this._files;
      }
      /**
      * Returns an array of available native content types.
      */
      get types() {
        return this._native.types;
      }
      /**
      * Gets the data from the data transfer by its MIME type.
      *
      * ```ts
      * dataTransfer.getData( 'text/plain' );
      * ```
      *
      * @param type The MIME type. E.g. `text/html` or `text/plain`.
      */
      getData(type) {
        return this._native.getData(type);
      }
      /**
      * Sets the data in the data transfer.
      *
      * @param type The MIME type. E.g. `text/html` or `text/plain`.
      */
      setData(type, data) {
        this._native.setData(type, data);
      }
      /**
      * The effect that is allowed for a drag operation.
      */
      set effectAllowed(value) {
        this._native.effectAllowed = value;
      }
      get effectAllowed() {
        return this._native.effectAllowed;
      }
      /**
      * The actual drop effect.
      */
      set dropEffect(value) {
        this._native.dropEffect = value;
      }
      get dropEffect() {
        return this._native.dropEffect;
      }
      /**
      * Set a preview image of the dragged content.
      */
      setDragImage(image2, x, y) {
        this._native.setDragImage(image2, x, y);
      }
      /**
      * Whether the dragging operation was canceled.
      */
      get isCanceled() {
        return this._native.dropEffect == "none" || !!this._native.mozUserCancelled;
      }
    }
    function getFiles(nativeDataTransfer) {
      const files = Array.from(nativeDataTransfer.files || []);
      const items = Array.from(nativeDataTransfer.items || []);
      if (files.length) {
        return files;
      }
      return items.filter((item) => item.kind === "file").map((item) => item.getAsFile());
    }
    class InputObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", "beforeinput");
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        const domTargetRanges = domEvent.getTargetRanges();
        const view = this.view;
        const viewDocument = view.document;
        let dataTransfer = null;
        let data = null;
        let targetRanges = [];
        if (domEvent.dataTransfer) {
          dataTransfer = new DataTransfer(domEvent.dataTransfer);
        }
        if (domEvent.data !== null) {
          data = domEvent.data;
        } else if (dataTransfer) {
          data = dataTransfer.getData("text/plain");
        }
        if (viewDocument.selection.isFake) {
          targetRanges = Array.from(viewDocument.selection.getRanges());
        } else if (domTargetRanges.length) {
          targetRanges = domTargetRanges.map((domRange) => {
            const viewStart = view.domConverter.domPositionToView(domRange.startContainer, domRange.startOffset);
            const viewEnd = view.domConverter.domPositionToView(domRange.endContainer, domRange.endOffset);
            if (viewStart) {
              return view.createRange(viewStart, viewEnd);
            } else if (viewEnd) {
              return view.createRange(viewEnd);
            }
          }).filter((range) => !!range);
        } else if (env.isAndroid) {
          const domSelection = domEvent.target.ownerDocument.defaultView.getSelection();
          targetRanges = Array.from(view.domConverter.domSelectionToView(domSelection).getRanges());
        }
        if (env.isAndroid && domEvent.inputType == "insertCompositionText" && data && data.endsWith("\n")) {
          this.fire(domEvent.type, domEvent, {
            inputType: "insertParagraph",
            targetRanges: [
              view.createRange(targetRanges[0].end)
            ]
          });
          return;
        }
        if (domEvent.inputType == "insertText" && data && data.includes("\n")) {
          const parts = data.split(/\n{1,2}/g);
          let partTargetRanges = targetRanges;
          for (let i = 0; i < parts.length; i++) {
            const dataPart = parts[i];
            if (dataPart != "") {
              this.fire(domEvent.type, domEvent, {
                data: dataPart,
                dataTransfer,
                targetRanges: partTargetRanges,
                inputType: domEvent.inputType,
                isComposing: domEvent.isComposing
              });
              partTargetRanges = [
                viewDocument.selection.getFirstRange()
              ];
            }
            if (i + 1 < parts.length) {
              this.fire(domEvent.type, domEvent, {
                inputType: "insertParagraph",
                targetRanges: partTargetRanges
              });
              partTargetRanges = [
                viewDocument.selection.getFirstRange()
              ];
            }
          }
          return;
        }
        this.fire(domEvent.type, domEvent, {
          data,
          dataTransfer,
          targetRanges,
          inputType: domEvent.inputType,
          isComposing: domEvent.isComposing
        });
      }
    }
    class ArrowKeysObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        this.document.on("keydown", (event, data) => {
          if (this.isEnabled && isArrowKeyCode(data.keyCode)) {
            const eventInfo = new BubblingEventInfo(this.document, "arrowKey", this.document.selection.getFirstRange());
            this.document.fire(eventInfo, data);
            if (eventInfo.stop.called) {
              event.stop();
            }
          }
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    class TabObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        const doc = this.document;
        doc.on("keydown", (evt, data) => {
          if (!this.isEnabled || data.keyCode != keyCodes.tab || data.ctrlKey) {
            return;
          }
          const event = new BubblingEventInfo(doc, "tab", doc.selection.getFirstRange());
          doc.fire(event, data);
          if (event.stop.called) {
            evt.stop();
          }
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    let View$1 = class View extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * @param stylesProcessor The styles processor instance.
      */
      constructor(stylesProcessor) {
        super();
        /**
        * Instance of the {@link module:engine/view/document~Document} associated with this view controller.
        */
        __publicField(this, "document");
        /**
        * Instance of the {@link module:engine/view/domconverter~DomConverter domConverter} used by
        * {@link module:engine/view/view~View#_renderer renderer}
        * and {@link module:engine/view/observer/observer~Observer observers}.
        */
        __publicField(this, "domConverter");
        /**
        * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
        */
        __publicField(this, "domRoots", /* @__PURE__ */ new Map());
        /**
        * Instance of the {@link module:engine/view/renderer~Renderer renderer}.
        *
        * @internal
        */
        __publicField(this, "_renderer");
        /**
        * A DOM root attributes cache. It saves the initial values of DOM root attributes before the DOM element
        * is {@link module:engine/view/view~View#attachDomRoot attached} to the view so later on, when
        * the view is destroyed ({@link module:engine/view/view~View#detachDomRoot}), they can be easily restored.
        * This way, the DOM element can go back to the (clean) state as if the editing view never used it.
        */
        __publicField(this, "_initialDomRootAttributes", /* @__PURE__ */ new WeakMap());
        /**
        * Map of registered {@link module:engine/view/observer/observer~Observer observers}.
        */
        __publicField(this, "_observers", /* @__PURE__ */ new Map());
        /**
        * DowncastWriter instance used in {@link #change change method} callbacks.
        */
        __publicField(this, "_writer");
        /**
        * Is set to `true` when {@link #change view changes} are currently in progress.
        */
        __publicField(this, "_ongoingChange", false);
        /**
        * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.
        */
        __publicField(this, "_postFixersInProgress", false);
        /**
        * Internal flag to temporary disable rendering. See the usage in the {@link #_disableRendering}.
        */
        __publicField(this, "_renderingDisabled", false);
        /**
        * Internal flag that disables rendering when there are no changes since the last rendering.
        * It stores information about changed selection and changed elements from attached document roots.
        */
        __publicField(this, "_hasChangedSinceTheLastRendering", false);
        this.document = new Document$1(stylesProcessor);
        this.domConverter = new DomConverter(this.document);
        this.set("isRenderingInProgress", false);
        this.set("hasDomSelection", false);
        this._renderer = new Renderer$1(this.domConverter, this.document.selection);
        this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing");
        this._writer = new DowncastWriter(this.document);
        this.addObserver(MutationObserver$1);
        this.addObserver(FocusObserver);
        this.addObserver(SelectionObserver);
        this.addObserver(KeyObserver);
        this.addObserver(FakeSelectionObserver);
        this.addObserver(CompositionObserver);
        this.addObserver(ArrowKeysObserver);
        this.addObserver(InputObserver);
        this.addObserver(TabObserver);
        injectQuirksHandling(this);
        injectUiElementHandling(this);
        this.on("render", () => {
          this._render();
          this.document.fire("layoutChanged");
          this._hasChangedSinceTheLastRendering = false;
        });
        this.listenTo(this.document.selection, "change", () => {
          this._hasChangedSinceTheLastRendering = true;
        });
        this.listenTo(this.document, "change:isFocused", () => {
          this._hasChangedSinceTheLastRendering = true;
        });
        if (env.isiOS) {
          this.listenTo(this.document, "blur", (evt, data) => {
            const relatedViewElement = this.domConverter.mapDomToView(data.domEvent.relatedTarget);
            if (!relatedViewElement) {
              this.domConverter._clearDomSelection();
            }
          });
        }
      }
      /**
      * Attaches a DOM root element to the view element and enable all observers on that element.
      * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
      * with the view what means that all child nodes will be removed and replaced with content of the view root.
      *
      * This method also will change view element name as the same as tag name of given dom root.
      * Name is always transformed to lower case.
      *
      * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
      *
      * @param domRoot DOM root element.
      * @param name Name of the root.
      */
      attachDomRoot(domRoot, name = "main") {
        const viewRoot = this.document.getRoot(name);
        viewRoot._name = domRoot.tagName.toLowerCase();
        const initialDomRootAttributes = {};
        for (const { name: name2, value } of Array.from(domRoot.attributes)) {
          initialDomRootAttributes[name2] = value;
          if (name2 === "class") {
            this._writer.addClass(value.split(" "), viewRoot);
          } else {
            this._writer.setAttribute(name2, value, viewRoot);
          }
        }
        this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);
        const updateContenteditableAttribute = () => {
          this._writer.setAttribute("contenteditable", (!viewRoot.isReadOnly).toString(), viewRoot);
          if (viewRoot.isReadOnly) {
            this._writer.addClass("ck-read-only", viewRoot);
          } else {
            this._writer.removeClass("ck-read-only", viewRoot);
          }
        };
        updateContenteditableAttribute();
        this.domRoots.set(name, domRoot);
        this.domConverter.bindElements(domRoot, viewRoot);
        this._renderer.markToSync("children", viewRoot);
        this._renderer.markToSync("attributes", viewRoot);
        this._renderer.domDocuments.add(domRoot.ownerDocument);
        viewRoot.on("change:children", (evt, node) => this._renderer.markToSync("children", node));
        viewRoot.on("change:attributes", (evt, node) => this._renderer.markToSync("attributes", node));
        viewRoot.on("change:text", (evt, node) => this._renderer.markToSync("text", node));
        viewRoot.on("change:isReadOnly", () => this.change(updateContenteditableAttribute));
        viewRoot.on("change", () => {
          this._hasChangedSinceTheLastRendering = true;
        });
        for (const observer of this._observers.values()) {
          observer.observe(domRoot, name);
        }
      }
      /**
      * Detaches a DOM root element from the view element and restores its attributes to the state before
      * {@link #attachDomRoot `attachDomRoot()`}.
      *
      * @param name Name of the root to detach.
      */
      detachDomRoot(name) {
        const domRoot = this.domRoots.get(name);
        Array.from(domRoot.attributes).forEach(({ name: name2 }) => domRoot.removeAttribute(name2));
        const initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot);
        for (const attribute in initialDomRootAttributes) {
          domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);
        }
        this.domRoots.delete(name);
        this.domConverter.unbindDomElement(domRoot);
        for (const observer of this._observers.values()) {
          observer.stopObserving(domRoot);
        }
      }
      /**
      * Gets DOM root element.
      *
      * @param name  Name of the root.
      * @returns DOM root element instance.
      */
      getDomRoot(name = "main") {
        return this.domRoots.get(name);
      }
      /**
      * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
      * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
      * {@link #domRoots DOM roots}.
      *
      * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
      * when registered for the first time. This means that features and other components can register a single observer
      * multiple times without caring whether it has been already added or not.
      *
      * @param ObserverConstructor The constructor of an observer to add.
      * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
      * @returns Added observer instance.
      */
      addObserver(ObserverConstructor) {
        let observer = this._observers.get(ObserverConstructor);
        if (observer) {
          return observer;
        }
        observer = new ObserverConstructor(this);
        this._observers.set(ObserverConstructor, observer);
        for (const [name, domElement] of this.domRoots) {
          observer.observe(domElement, name);
        }
        observer.enable();
        return observer;
      }
      /**
      * Returns observer of the given type or `undefined` if such observer has not been added yet.
      *
      * @param ObserverConstructor The constructor of an observer to get.
      * @returns Observer instance or undefined.
      */
      getObserver(ObserverConstructor) {
        return this._observers.get(ObserverConstructor);
      }
      /**
      * Disables all added observers.
      */
      disableObservers() {
        for (const observer of this._observers.values()) {
          observer.disable();
        }
      }
      /**
      * Enables all added observers.
      */
      enableObservers() {
        for (const observer of this._observers.values()) {
          observer.enable();
        }
      }
      /**
      * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
      * caret, **if not already visible to the user**.
      *
      * **Note**: Calling this method fires the {@link module:engine/view/view~ViewScrollToTheSelectionEvent} event that
      * allows custom behaviors.
      *
      * @param options Additional configuration of the scrolling behavior.
      * @param options.viewportOffset A distance between the DOM selection and the viewport boundary to be maintained
      * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
      * the viewport boundary.
      * @param options.ancestorOffset A distance between the DOM selection and scrollable DOM root ancestor(s) to be maintained
      * while scrolling to the selection (default is 20px). Setting this value to `0` will reveal the selection precisely at
      * the scrollable ancestor(s) boundary.
      * @param options.alignToTop When set `true`, the DOM selection will be aligned to the top of the viewport if not already visible
      * (see `forceScroll` to learn more).
      * @param options.forceScroll When set `true`, the DOM selection will be aligned to the top of the viewport and scrollable ancestors
      * whether it is already visible or not. This option will only work when `alignToTop` is `true`.
      */
      scrollToTheSelection({ alignToTop, forceScroll, viewportOffset = 20, ancestorOffset = 20 } = {}) {
        const range = this.document.selection.getFirstRange();
        if (!range) {
          return;
        }
        const originalArgs = cloneDeep({
          alignToTop,
          forceScroll,
          viewportOffset,
          ancestorOffset
        });
        if (typeof viewportOffset === "number") {
          viewportOffset = {
            top: viewportOffset,
            bottom: viewportOffset,
            left: viewportOffset,
            right: viewportOffset
          };
        }
        const options = {
          target: this.domConverter.viewRangeToDom(range),
          viewportOffset,
          ancestorOffset,
          alignToTop,
          forceScroll
        };
        this.fire("scrollToTheSelection", options, originalArgs);
        scrollViewportToShowTarget(options);
      }
      /**
      * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
      * that is currently having selection inside.
      */
      focus() {
        if (!this.document.isFocused) {
          const editable = this.document.selection.editableElement;
          if (editable) {
            this.domConverter.focus(editable);
            this.forceRender();
          }
        }
      }
      /**
      * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
      * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
      * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
      * to nest calls one inside another and still performs a single rendering after all those changes are made.
      * It also returns the return value of its callback.
      *
      * ```ts
      * const text = view.change( writer => {
      * 	const newText = writer.createText( 'foo' );
      * 	writer.insert( position1, newText );
      *
      * 	view.change( writer => {
      * 		writer.insert( position2, writer.createText( 'bar' ) );
      * 	} );
      *
      * 	writer.remove( range );
      *
      * 	return newText;
      * } );
      * ```
      *
      * When the outermost change block is done and rendering to the DOM is over the
      * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
      *
      * This method throws a `applying-view-changes-on-rendering` error when
      * the change block is used after rendering to the DOM has started.
      *
      * @param callback Callback function which may modify the view.
      * @returns Value returned by the callback.
      */
      change(callback) {
        if (this.isRenderingInProgress || this._postFixersInProgress) {
          throw new CKEditorError("cannot-change-view-tree", this);
        }
        try {
          if (this._ongoingChange) {
            return callback(this._writer);
          }
          this._ongoingChange = true;
          const callbackResult = callback(this._writer);
          this._ongoingChange = false;
          if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
            this._postFixersInProgress = true;
            this.document._callPostFixers(this._writer);
            this._postFixersInProgress = false;
            this.fire("render");
          }
          return callbackResult;
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      /**
      * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
      * currently in progress, rendering will start after all {@link #change change blocks} are processed.
      *
      * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
      * block and the view will automatically check whether it needs to render DOM or not.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
      * trying to re-render when rendering to DOM has already started.
      */
      forceRender() {
        this._hasChangedSinceTheLastRendering = true;
        this.getObserver(FocusObserver).flush();
        this.change(() => {
        });
      }
      /**
      * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
      */
      destroy() {
        for (const observer of this._observers.values()) {
          observer.destroy();
        }
        this.document.destroy();
        this.stopListening();
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link #createPositionBefore},
      * * {@link #createPositionAfter},
      *
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      createPositionAt(itemOrPosition, offset) {
        return Position$1._createAt(itemOrPosition, offset);
      }
      /**
      * Creates a new position after given view item.
      *
      * @param item View item after which the position should be located.
      */
      createPositionAfter(item) {
        return Position$1._createAfter(item);
      }
      /**
      * Creates a new position before given view item.
      *
      * @param item View item before which the position should be located.
      */
      createPositionBefore(item) {
        return Position$1._createBefore(item);
      }
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start, end) {
        return new Range$1(start, end);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      */
      createRangeOn(item) {
        return Range$1._createOn(item);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range$1._createIn(element);
      }
      createSelection(...args) {
        return new Selection$1(...args);
      }
      /**
      * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
      * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
      *
      * @internal
      * @param flag A flag indicates whether the rendering should be disabled.
      */
      _disableRendering(flag) {
        this._renderingDisabled = flag;
        if (flag == false) {
          this.change(() => {
          });
        }
      }
      /**
      * Renders all changes. In order to avoid triggering the observers (e.g. selection) all observers are disabled
      * before rendering and re-enabled after that.
      */
      _render() {
        this.isRenderingInProgress = true;
        this.disableObservers();
        this._renderer.render();
        this.enableObservers();
        this.isRenderingInProgress = false;
      }
    };
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class TypeCheckable {
      /* istanbul ignore next -- @preserve */
      is() {
        throw new Error("is() method is abstract");
      }
    }
    let Node$1 = class Node extends TypeCheckable {
      /**
      * Creates a model node.
      *
      * This is an abstract class, so this constructor should not be used directly.
      *
      * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
      */
      constructor(attrs) {
        super();
        /**
        * Parent of this node. It could be {@link module:engine/model/element~Element}
        * or {@link module:engine/model/documentfragment~DocumentFragment}.
        * Equals to `null` if the node has no parent.
        */
        __publicField(this, "parent", null);
        /**
        * Attributes set on this node.
        */
        __publicField(this, "_attrs");
        this._attrs = toMap(attrs);
      }
      /**
      * {@link module:engine/model/document~Document Document} that owns this root element.
      */
      get document() {
        return null;
      }
      /**
      * Index of this node in its parent or `null` if the node has no parent.
      *
      * Accessing this property throws an error if this node's parent element does not contain it.
      * This means that model tree got broken.
      */
      get index() {
        let pos;
        if (!this.parent) {
          return null;
        }
        if ((pos = this.parent.getChildIndex(this)) === null) {
          throw new CKEditorError("model-node-not-found-in-parent", this);
        }
        return pos;
      }
      /**
      * Offset at which this node starts in its parent. It is equal to the sum of {@link #offsetSize offsetSize}
      * of all its previous siblings. Equals to `null` if node has no parent.
      *
      * Accessing this property throws an error if this node's parent element does not contain it.
      * This means that model tree got broken.
      */
      get startOffset() {
        let pos;
        if (!this.parent) {
          return null;
        }
        if ((pos = this.parent.getChildStartOffset(this)) === null) {
          throw new CKEditorError("model-node-not-found-in-parent", this);
        }
        return pos;
      }
      /**
      * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
      * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position
      * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
      * than one entity, i.e. {@link module:engine/model/text~Text text node}.
      */
      get offsetSize() {
        return 1;
      }
      /**
      * Offset at which this node ends in it's parent. It is equal to the sum of this node's
      * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
      * Equals to `null` if the node has no parent.
      */
      get endOffset() {
        if (!this.parent) {
          return null;
        }
        return this.startOffset + this.offsetSize;
      }
      /**
      * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
      */
      get nextSibling() {
        const index2 = this.index;
        return index2 !== null && this.parent.getChild(index2 + 1) || null;
      }
      /**
      * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
      */
      get previousSibling() {
        const index2 = this.index;
        return index2 !== null && this.parent.getChild(index2 - 1) || null;
      }
      /**
      * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
      * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
      */
      get root() {
        let root2 = this;
        while (root2.parent) {
          root2 = root2.parent;
        }
        return root2;
      }
      /**
      * Returns `true` if the node is inside a document root that is attached to the document.
      */
      isAttached() {
        return this.parent === null ? false : this.root.isAttached();
      }
      /**
      * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
      * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
      * create {@link module:engine/model/position~Position Position} instance.
      *
      * ```ts
      * const abc = new Text( 'abc' );
      * const foo = new Text( 'foo' );
      * const h1 = new Element( 'h1', null, new Text( 'header' ) );
      * const p = new Element( 'p', null, [ abc, foo ] );
      * const div = new Element( 'div', null, [ h1, p ] );
      * foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
      * h1.getPath(); // Returns [ 0 ].
      * div.getPath(); // Returns [].
      * ```
      */
      getPath() {
        const path = [];
        let node = this;
        while (node.parent) {
          path.unshift(node.startOffset);
          node = node.parent;
        }
        return path;
      }
      /**
      * Returns ancestors array of this node.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true` this node will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from node's parent to root element,
      * otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
      /**
      * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
      * which is a common ancestor of both nodes.
      *
      * @param node The second node.
      * @param options Options object.
      * @param options.includeSelf When set to `true` both nodes will be considered "ancestors" too.
      * Which means that if e.g. node A is inside B, then their common ancestor will be B.
      */
      getCommonAncestor(node, options = {}) {
        const ancestorsA = this.getAncestors(options);
        const ancestorsB = node.getAncestors(options);
        let i = 0;
        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
          i++;
        }
        return i === 0 ? null : ancestorsA[i - 1];
      }
      /**
      * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isBefore(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        const thisPath = this.getPath();
        const nodePath = node.getPath();
        const result = compareArrays(thisPath, nodePath);
        switch (result) {
          case "prefix":
            return true;
          case "extension":
            return false;
          default:
            return thisPath[result] < nodePath[result];
        }
      }
      /**
      * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
      * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
      *
      * @param node Node to compare with.
      */
      isAfter(node) {
        if (this == node) {
          return false;
        }
        if (this.root !== node.root) {
          return false;
        }
        return !this.isBefore(node);
      }
      /**
      * Checks if the node has an attribute with given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on node, `false` otherwise.
      */
      hasAttribute(key) {
        return this._attrs.has(key);
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this._attrs.get(key);
      }
      /**
      * Returns iterator that iterates over this node's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this._attrs.entries();
      }
      /**
      * Returns iterator that iterates over this node's attribute keys.
      */
      getAttributeKeys() {
        return this._attrs.keys();
      }
      /**
      * Converts `Node` to plain object and returns it.
      *
      * @returns `Node` converted to plain object.
      */
      toJSON() {
        const json = {};
        if (this._attrs.size) {
          json.attributes = Array.from(this._attrs).reduce((result, attr) => {
            result[attr[0]] = attr[1];
            return result;
          }, {});
        }
        return json;
      }
      /**
      * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
      *
      * @internal
      * @returns Node with same attributes as this node.
      */
      _clone(_deep) {
        return new this.constructor(this._attrs);
      }
      /**
      * Removes this node from it's parent.
      *
      * @internal
      * @see module:engine/model/writer~Writer#remove
      */
      _remove() {
        this.parent._removeChildren(this.index);
      }
      /**
      * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
      *
      * @see module:engine/model/writer~Writer#setAttribute
      * @internal
      * @param key Key of attribute to set.
      * @param value Attribute value.
      */
      _setAttribute(key, value) {
        this._attrs.set(key, value);
      }
      /**
      * Removes all attributes from the node and sets given attributes.
      *
      * @see module:engine/model/writer~Writer#setAttributes
      * @internal
      * @param attrs Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
      */
      _setAttributesTo(attrs) {
        this._attrs = toMap(attrs);
      }
      /**
      * Removes an attribute with given key from the node.
      *
      * @see module:engine/model/writer~Writer#removeAttribute
      * @internal
      * @param key Key of attribute to remove.
      * @returns `true` if the attribute was set on the element, `false` otherwise.
      */
      _removeAttribute(key) {
        return this._attrs.delete(key);
      }
      /**
      * Removes all attributes from the node.
      *
      * @see module:engine/model/writer~Writer#clearAttributes
      * @internal
      */
      _clearAttributes() {
        this._attrs.clear();
      }
    };
    Node$1.prototype.is = function(type) {
      return type === "node" || type === "model:node";
    };
    class NodeList {
      /**
      * Creates an empty node list.
      *
      * @internal
      * @param nodes Nodes contained in this node list.
      */
      constructor(nodes) {
        /**
        * Nodes contained in this node list.
        */
        __publicField(this, "_nodes", []);
        if (nodes) {
          this._insertNodes(0, nodes);
        }
      }
      /**
      * Iterable interface.
      *
      * Iterates over all nodes contained inside this node list.
      */
      [Symbol.iterator]() {
        return this._nodes[Symbol.iterator]();
      }
      /**
      * Number of nodes contained inside this node list.
      */
      get length() {
        return this._nodes.length;
      }
      /**
      * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
      */
      get maxOffset() {
        return this._nodes.reduce((sum, node) => sum + node.offsetSize, 0);
      }
      /**
      * Gets the node at the given index. Returns `null` if incorrect index was passed.
      */
      getNode(index2) {
        return this._nodes[index2] || null;
      }
      /**
      * Returns an index of the given node. Returns `null` if given node is not inside this node list.
      */
      getNodeIndex(node) {
        const index2 = this._nodes.indexOf(node);
        return index2 == -1 ? null : index2;
      }
      /**
      * Returns the starting offset of given node. Starting offset is equal to the sum of
      * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
      */
      getNodeStartOffset(node) {
        const index2 = this.getNodeIndex(node);
        return index2 === null ? null : this._nodes.slice(0, index2).reduce((sum, node2) => sum + node2.offsetSize, 0);
      }
      /**
      * Converts index to offset in node list.
      *
      * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.
      */
      indexToOffset(index2) {
        if (index2 == this._nodes.length) {
          return this.maxOffset;
        }
        const node = this._nodes[index2];
        if (!node) {
          throw new CKEditorError("model-nodelist-index-out-of-bounds", this);
        }
        return this.getNodeStartOffset(node);
      }
      /**
      * Converts offset in node list to index.
      *
      * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
      * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.
      */
      offsetToIndex(offset) {
        let totalOffset = 0;
        for (const node of this._nodes) {
          if (offset >= totalOffset && offset < totalOffset + node.offsetSize) {
            return this.getNodeIndex(node);
          }
          totalOffset += node.offsetSize;
        }
        if (totalOffset != offset) {
          throw new CKEditorError("model-nodelist-offset-out-of-bounds", this, {
            offset,
            nodeList: this
          });
        }
        return this.length;
      }
      /**
      * Inserts given nodes at given index.
      *
      * @internal
      * @param index Index at which nodes should be inserted.
      * @param nodes Nodes to be inserted.
      */
      _insertNodes(index2, nodes) {
        for (const node of nodes) {
          if (!(node instanceof Node$1)) {
            throw new CKEditorError("model-nodelist-insertnodes-not-node", this);
          }
        }
        this._nodes = spliceArray(this._nodes, Array.from(nodes), index2, 0);
      }
      /**
      * Removes one or more nodes starting at the given index.
      *
      * @internal
      * @param indexStart Index of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns Array containing removed nodes.
      */
      _removeNodes(indexStart, howMany = 1) {
        return this._nodes.splice(indexStart, howMany);
      }
      /**
      * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
      * are also converted to their plain object representation.
      *
      * @returns `NodeList` instance converted to `Array`.
      */
      toJSON() {
        return this._nodes.map((node) => node.toJSON());
      }
    }
    class Text extends Node$1 {
      /**
      * Creates a text node.
      *
      * **Note:** Constructor of this class shouldn't be used directly in the code.
      * Use the {@link module:engine/model/writer~Writer#createText} method instead.
      *
      * @internal
      * @param data Node's text.
      * @param attrs Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
      */
      constructor(data, attrs) {
        super(attrs);
        /**
        * Text data contained in this text node.
        *
        * @internal
        */
        __publicField(this, "_data");
        this._data = data || "";
      }
      /**
      * @inheritDoc
      */
      get offsetSize() {
        return this.data.length;
      }
      /**
      * Returns a text data contained in the node.
      */
      get data() {
        return this._data;
      }
      /**
      * Converts `Text` instance to plain object and returns it.
      *
      * @returns`Text` instance converted to plain object.
      */
      toJSON() {
        const json = super.toJSON();
        json.data = this.data;
        return json;
      }
      /**
      * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
      *
      * @internal
      * @returns `Text` instance created using given plain object.
      */
      _clone() {
        return new Text(this.data, this.getAttributes());
      }
      /**
      * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
      *
      * @param json Plain object to be converted to `Text`.
      * @returns `Text` instance created using given plain object.
      */
      static fromJSON(json) {
        return new Text(json.data, json.attributes);
      }
    }
    Text.prototype.is = function(type) {
      return type === "$text" || type === "model:$text" || // This are legacy values kept for backward compatibility.
      type === "text" || type === "model:text" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === "node" || type === "model:node";
    };
    class TextProxy extends TypeCheckable {
      /**
      * Creates a text proxy.
      *
      * @internal
      * @param textNode Text node which part is represented by this text proxy.
      * @param offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
      * starts.
      * @param length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
      */
      constructor(textNode, offsetInText, length) {
        super();
        /**
        * Text node which part is represented by this text proxy.
        */
        __publicField(this, "textNode");
        /**
        * Text data represented by this text proxy.
        */
        __publicField(this, "data");
        /**
        * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.
        */
        __publicField(this, "offsetInText");
        this.textNode = textNode;
        if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
          throw new CKEditorError("model-textproxy-wrong-offsetintext", this);
        }
        if (length < 0 || offsetInText + length > textNode.offsetSize) {
          throw new CKEditorError("model-textproxy-wrong-length", this);
        }
        this.data = textNode.data.substring(offsetInText, offsetInText + length);
        this.offsetInText = offsetInText;
      }
      /**
      * Offset at which this text proxy starts in it's parent.
      *
      * @see module:engine/model/node~Node#startOffset
      */
      get startOffset() {
        return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
      }
      /**
      * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
      *
      * @see module:engine/model/node~Node#offsetSize
      */
      get offsetSize() {
        return this.data.length;
      }
      /**
      * Offset at which this text proxy ends in it's parent.
      *
      * @see module:engine/model/node~Node#endOffset
      */
      get endOffset() {
        return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
      }
      /**
      * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
      * (`true`) or the whole text node (`false`).
      *
      * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
      * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
      * text node size.
      */
      get isPartial() {
        return this.offsetSize !== this.textNode.offsetSize;
      }
      /**
      * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
      */
      get parent() {
        return this.textNode.parent;
      }
      /**
      * Root of this text proxy, which is same as root of text node represented by this text proxy.
      */
      get root() {
        return this.textNode.root;
      }
      /**
      * Gets path to this text proxy.
      *
      * @see module:engine/model/node~Node#getPath
      */
      getPath() {
        const path = this.textNode.getPath();
        if (path.length > 0) {
          path[path.length - 1] += this.offsetInText;
        }
        return path;
      }
      /**
      * Returns ancestors array of this text proxy.
      *
      * @param options Options object.
      * @param options.includeSelf When set to `true` this text proxy will be also included in parent's array.
      * @param options.parentFirst When set to `true`, array will be sorted from text proxy parent to root element,
      * otherwise root element will be the first item in the array.
      * @returns Array with ancestors.
      */
      getAncestors(options = {}) {
        const ancestors = [];
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          ancestors[options.parentFirst ? "push" : "unshift"](parent2);
          parent2 = parent2.parent;
        }
        return ancestors;
      }
      /**
      * Checks if this text proxy has an attribute for given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on text proxy, `false` otherwise.
      */
      hasAttribute(key) {
        return this.textNode.hasAttribute(key);
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this.textNode.getAttribute(key);
      }
      /**
      * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
      * items. First one is attribute key and second is attribute value.
      *
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this.textNode.getAttributes();
      }
      /**
      * Returns iterator that iterates over this node's attribute keys.
      */
      getAttributeKeys() {
        return this.textNode.getAttributeKeys();
      }
    }
    TextProxy.prototype.is = function(type) {
      return type === "$textProxy" || type === "model:$textProxy" || // This are legacy values kept for backward compatibility.
      type === "textProxy" || type === "model:textProxy";
    };
    class Element extends Node$1 {
      /**
      * Creates a model element.
      *
      * **Note:** Constructor of this class shouldn't be used directly in the code.
      * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
      *
      * @internal
      * @param name Element's name.
      * @param attrs Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
      * @param children One or more nodes to be inserted as children of created element.
      */
      constructor(name, attrs, children) {
        super(attrs);
        /**
        * Element name.
        */
        __publicField(this, "name");
        /**
        * List of children nodes.
        */
        __publicField(this, "_children", new NodeList());
        this.name = name;
        if (children) {
          this._insertChild(0, children);
        }
      }
      /**
      * Number of this element's children.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
      */
      get maxOffset() {
        return this._children.maxOffset;
      }
      /**
      * Is `true` if there are no nodes inside this element, `false` otherwise.
      */
      get isEmpty() {
        return this.childCount === 0;
      }
      /**
      * Gets the child at the given index.
      */
      getChild(index2) {
        return this._children.getNode(index2);
      }
      /**
      * Returns an iterator that iterates over all of this element's children.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
      *
      * @param node Child node to look for.
      * @returns Child node's index in this element.
      */
      getChildIndex(node) {
        return this._children.getNodeIndex(node);
      }
      /**
      * Returns the starting offset of given child. Starting offset is equal to the sum of
      * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
      * given node is not a child of this element.
      *
      * @param node Child node to look for.
      * @returns Child node's starting offset.
      */
      getChildStartOffset(node) {
        return this._children.getNodeStartOffset(node);
      }
      /**
      * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
      * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
      *
      * ```ts
      * const textNode = new Text( 'foo' );
      * const pElement = new Element( 'p' );
      * const divElement = new Element( [ textNode, pElement ] );
      * divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
      * divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
      * divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
      * divElement.offsetToIndex( 2 ); // Returns 0.
      * divElement.offsetToIndex( 3 ); // Returns 1.
      * divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
      * ```
      */
      offsetToIndex(offset) {
        return this._children.offsetToIndex(offset);
      }
      /**
      * Returns a descendant node by its path relative to this element.
      *
      * ```ts
      * // <this>a<b>c</b></this>
      * this.getNodeByPath( [ 0 ] );     // -> "a"
      * this.getNodeByPath( [ 1 ] );     // -> <b>
      * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
      * ```
      *
      * @param relativePath Path of the node to find, relative to this element.
      */
      getNodeByPath(relativePath) {
        let node = this;
        for (const index2 of relativePath) {
          node = node.getChild(node.offsetToIndex(index2));
        }
        return node;
      }
      /**
      * Returns the parent element of the given name. Returns null if the element is not inside the desired parent.
      *
      * @param parentName The name of the parent element to find.
      * @param options Options object.
      * @param options.includeSelf When set to `true` this node will be also included while searching.
      */
      findAncestor(parentName, options = {}) {
        let parent2 = options.includeSelf ? this : this.parent;
        while (parent2) {
          if (parent2.name === parentName) {
            return parent2;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
      *
      * @returns `Element` instance converted to plain object.
      */
      toJSON() {
        const json = super.toJSON();
        json.name = this.name;
        if (this._children.length > 0) {
          json.children = [];
          for (const node of this._children) {
            json.children.push(node.toJSON());
          }
        }
        return json;
      }
      /**
      * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
      * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
      *
      * @internal
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any child.
      */
      _clone(deep = false) {
        const children = deep ? Array.from(this._children).map((node) => node._clone(true)) : void 0;
        return new Element(this.name, this.getAttributes(), children);
      }
      /**
      * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
      *
      * @see module:engine/model/writer~Writer#append
      * @internal
      * @param nodes Nodes to be inserted.
      */
      _appendChild(nodes) {
        this._insertChild(this.childCount, nodes);
      }
      /**
      * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
      * to this element.
      *
      * @see module:engine/model/writer~Writer#insert
      * @internal
      * @param index Index at which nodes should be inserted.
      * @param items Items to be inserted.
      */
      _insertChild(index2, items) {
        const nodes = normalize$1(items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
        }
        this._children._insertNodes(index2, nodes);
      }
      /**
      * Removes one or more nodes starting at the given index and sets
      * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
      *
      * @see module:engine/model/writer~Writer#remove
      * @internal
      * @param index Index of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns Array containing removed nodes.
      */
      _removeChildren(index2, howMany = 1) {
        const nodes = this._children._removeNodes(index2, howMany);
        for (const node of nodes) {
          node.parent = null;
        }
        return nodes;
      }
      /**
      * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
      * Converts `Element` children to proper nodes.
      *
      * @param json Plain object to be converted to `Element`.
      * @returns `Element` instance created using given plain object.
      */
      static fromJSON(json) {
        let children;
        if (json.children) {
          children = [];
          for (const child of json.children) {
            if (child.name) {
              children.push(Element.fromJSON(child));
            } else {
              children.push(Text.fromJSON(child));
            }
          }
        }
        return new Element(json.name, json.attributes, children);
      }
    }
    Element.prototype.is = function(type, name) {
      if (!name) {
        return type === "element" || type === "model:element" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "node" || type === "model:node";
      }
      return name === this.name && (type === "element" || type === "model:element");
    };
    function normalize$1(nodes) {
      if (typeof nodes == "string") {
        return [
          new Text(nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text(node);
        }
        if (node instanceof TextProxy) {
          return new Text(node.data, node.getAttributes());
        }
        return node;
      });
    }
    class TreeWalker {
      /**
      * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
      *
      * @param options Object with configuration.
      */
      constructor(options) {
        /**
        * Walking direction. Defaults `'forward'`.
        */
        __publicField(this, "direction");
        /**
        * Iterator boundaries.
        *
        * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
        * on the start of boundary, then `{ done: true }` is returned.
        *
        * If boundaries are not defined they are set before first and after last child of the root node.
        */
        __publicField(this, "boundaries");
        /**
        * Flag indicating whether all consecutive characters with the same attributes should be
        * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).
        */
        __publicField(this, "singleCharacters");
        /**
        * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
        * iterated node will not be returned along with `elementEnd` tag.
        */
        __publicField(this, "shallow");
        /**
        * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not
        * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will
        * be returned once, while if the option is `false` they might be returned twice:
        * for `'elementStart'` and `'elementEnd'`.
        */
        __publicField(this, "ignoreElementEnd");
        /**
        * Iterator position. This is always static position, even if the initial position was a
        * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
        * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
        * is `'backward'` position starts from the end.
        */
        __publicField(this, "_position");
        /**
        * Start boundary cached for optimization purposes.
        */
        __publicField(this, "_boundaryStartParent");
        /**
        * End boundary cached for optimization purposes.
        */
        __publicField(this, "_boundaryEndParent");
        /**
        * Parent of the most recently visited node. Cached for optimization purposes.
        */
        __publicField(this, "_visitedParent");
        if (!options || !options.boundaries && !options.startPosition) {
          throw new CKEditorError("model-tree-walker-no-start-position", null);
        }
        const direction = options.direction || "forward";
        if (direction != "forward" && direction != "backward") {
          throw new CKEditorError("model-tree-walker-unknown-direction", options, {
            direction
          });
        }
        this.direction = direction;
        this.boundaries = options.boundaries || null;
        if (options.startPosition) {
          this._position = options.startPosition.clone();
        } else {
          this._position = Position._createAt(this.boundaries[this.direction == "backward" ? "end" : "start"]);
        }
        this.position.stickiness = "toNone";
        this.singleCharacters = !!options.singleCharacters;
        this.shallow = !!options.shallow;
        this.ignoreElementEnd = !!options.ignoreElementEnd;
        this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
        this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        this._visitedParent = this.position.parent;
      }
      /**
      * Iterable interface.
      *
      * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
      */
      [Symbol.iterator]() {
        return this;
      }
      /**
      * Iterator position. This is always static position, even if the initial position was a
      * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
      * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
      * is `'backward'` position starts from the end.
      */
      get position() {
        return this._position;
      }
      /**
      * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
      *
      * For example:
      *
      * ```ts
      * walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
      * walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
      * walker.skip( () => false ); // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      */
      skip(skip) {
        let done, value, prevPosition, prevVisitedParent;
        do {
          prevPosition = this.position;
          prevVisitedParent = this._visitedParent;
          ({ done, value } = this.next());
        } while (!done && skip(value));
        if (!done) {
          this._position = prevPosition;
          this._visitedParent = prevVisitedParent;
        }
      }
      /**
      * Gets the next tree walker's value.
      */
      next() {
        if (this.direction == "forward") {
          return this._next();
        } else {
          return this._previous();
        }
      }
      /**
      * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
      */
      _next() {
        const previousPosition = this.position;
        const position = this.position.clone();
        const parent2 = this._visitedParent;
        if (parent2.parent === null && position.offset === parent2.maxOffset) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        const textNodeAtPosition = getTextNodeAtPosition(position, parent2);
        const node = textNodeAtPosition || getNodeAfterPosition(position, parent2, textNodeAtPosition);
        if (node instanceof Element) {
          if (!this.shallow) {
            position.path.push(0);
            this._visitedParent = node;
          } else {
            if (this.boundaries && this.boundaries.end.isBefore(position)) {
              return {
                done: true,
                value: void 0
              };
            }
            position.offset++;
          }
          this._position = position;
          return formatReturnValue("elementStart", node, previousPosition, position, 1);
        }
        if (node instanceof Text) {
          let charactersCount;
          if (this.singleCharacters) {
            charactersCount = 1;
          } else {
            let offset = node.endOffset;
            if (this._boundaryEndParent == parent2 && this.boundaries.end.offset < offset) {
              offset = this.boundaries.end.offset;
            }
            charactersCount = offset - position.offset;
          }
          const offsetInTextNode = position.offset - node.startOffset;
          const item = new TextProxy(node, offsetInTextNode, charactersCount);
          position.offset += charactersCount;
          this._position = position;
          return formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        position.path.pop();
        position.offset++;
        this._position = position;
        this._visitedParent = parent2.parent;
        if (this.ignoreElementEnd) {
          return this._next();
        }
        return formatReturnValue("elementEnd", parent2, previousPosition, position);
      }
      /**
      * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
      */
      _previous() {
        const previousPosition = this.position;
        const position = this.position.clone();
        const parent2 = this._visitedParent;
        if (parent2.parent === null && position.offset === 0) {
          return {
            done: true,
            value: void 0
          };
        }
        if (parent2 == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
          return {
            done: true,
            value: void 0
          };
        }
        const positionParent = position.parent;
        const textNodeAtPosition = getTextNodeAtPosition(position, positionParent);
        const node = textNodeAtPosition || getNodeBeforePosition(position, positionParent, textNodeAtPosition);
        if (node instanceof Element) {
          position.offset--;
          if (this.shallow) {
            this._position = position;
            return formatReturnValue("elementStart", node, previousPosition, position, 1);
          }
          position.path.push(node.maxOffset);
          this._position = position;
          this._visitedParent = node;
          if (this.ignoreElementEnd) {
            return this._previous();
          }
          return formatReturnValue("elementEnd", node, previousPosition, position);
        }
        if (node instanceof Text) {
          let charactersCount;
          if (this.singleCharacters) {
            charactersCount = 1;
          } else {
            let offset = node.startOffset;
            if (this._boundaryStartParent == parent2 && this.boundaries.start.offset > offset) {
              offset = this.boundaries.start.offset;
            }
            charactersCount = position.offset - offset;
          }
          const offsetInTextNode = position.offset - node.startOffset;
          const item = new TextProxy(node, offsetInTextNode - charactersCount, charactersCount);
          position.offset -= charactersCount;
          this._position = position;
          return formatReturnValue("text", item, previousPosition, position, charactersCount);
        }
        position.path.pop();
        this._position = position;
        this._visitedParent = parent2.parent;
        return formatReturnValue("elementStart", parent2, previousPosition, position, 1);
      }
    }
    function formatReturnValue(type, item, previousPosition, nextPosition, length) {
      return {
        done: false,
        value: {
          type,
          item,
          previousPosition,
          nextPosition,
          length
        }
      };
    }
    class Position extends TypeCheckable {
      /**
      * Creates a position.
      *
      * @param root Root of the position.
      * @param path Position path. See {@link module:engine/model/position~Position#path}.
      * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
      */
      constructor(root2, path, stickiness = "toNone") {
        super();
        /**
        * Root of the position path.
        */
        __publicField(this, "root");
        /**
        * Position of the node in the tree. **Path contains offsets, not indexes.**
        *
        * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has
        * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are
        * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,
        * down to the position offset in it's parent.
        *
        * ```
        * ROOT
        *  |- P            before: [ 0 ]         after: [ 1 ]
        *  |- UL           before: [ 1 ]         after: [ 2 ]
        *     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]
        *     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]
        *     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]
        *        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]
        * ```
        *
        * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size
        * greater than `1` you can place position offset between their start and end:
        *
        * ```
        * ROOT
        *  |- P
        *  |- UL
        *     |- LI
        *     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]
        *     |- LI
        *        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]
        * ```
        */
        __publicField(this, "path");
        /**
        * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
        */
        __publicField(this, "stickiness");
        if (!root2.is("element") && !root2.is("documentFragment")) {
          throw new CKEditorError("model-position-root-invalid", root2);
        }
        if (!(path instanceof Array) || path.length === 0) {
          throw new CKEditorError("model-position-path-incorrect-format", root2, {
            path
          });
        }
        if (root2.is("rootElement")) {
          path = path.slice();
        } else {
          path = [
            ...root2.getPath(),
            ...path
          ];
          root2 = root2.root;
        }
        this.root = root2;
        this.path = path;
        this.stickiness = stickiness;
      }
      /**
      * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
      * to the last item in position {@link module:engine/model/position~Position#path path}.
      *
      * @type {Number}
      */
      get offset() {
        return this.path[this.path.length - 1];
      }
      set offset(newOffset) {
        this.path[this.path.length - 1] = newOffset;
      }
      /**
      * Parent element of this position.
      *
      * Keep in mind that `parent` value is calculated when the property is accessed.
      * If {@link module:engine/model/position~Position#path position path}
      * leads to a non-existing element, `parent` property will throw error.
      *
      * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
      */
      get parent() {
        let parent2 = this.root;
        for (let i = 0; i < this.path.length - 1; i++) {
          parent2 = parent2.getChild(parent2.offsetToIndex(this.path[i]));
          if (!parent2) {
            throw new CKEditorError("model-position-path-incorrect", this, {
              position: this
            });
          }
        }
        if (parent2.is("$text")) {
          throw new CKEditorError("model-position-path-incorrect", this, {
            position: this
          });
        }
        return parent2;
      }
      /**
      * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
      * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
      * in text node, position index is equal to the index of that text node.
      */
      get index() {
        return this.parent.offsetToIndex(this.offset);
      }
      /**
      * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
      * position is not in a text node.
      */
      get textNode() {
        return getTextNodeAtPosition(this, this.parent);
      }
      /**
      * Node directly after this position or `null` if this position is in text node.
      */
      get nodeAfter() {
        const parent2 = this.parent;
        return getNodeAfterPosition(this, parent2, getTextNodeAtPosition(this, parent2));
      }
      /**
      * Node directly before this position or `null` if this position is in text node.
      */
      get nodeBefore() {
        const parent2 = this.parent;
        return getNodeBeforePosition(this, parent2, getTextNodeAtPosition(this, parent2));
      }
      /**
      * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
      */
      get isAtStart() {
        return this.offset === 0;
      }
      /**
      * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
      */
      get isAtEnd() {
        return this.offset == this.parent.maxOffset;
      }
      /**
      * Checks whether this position is before or after given position.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      */
      compareWith(otherPosition) {
        if (this.root != otherPosition.root) {
          return "different";
        }
        const result = compareArrays(this.path, otherPosition.path);
        switch (result) {
          case "same":
            return "same";
          case "prefix":
            return "before";
          case "extension":
            return "after";
          default:
            return this.path[result] < otherPosition.path[result] ? "before" : "after";
        }
      }
      /**
      * Gets the farthest position which matches the callback using
      * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
      *
      * For example:
      *
      * ```ts
      * getLastMatchingPosition( value => value.type == 'text' );
      * // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
      *
      * getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
      * // <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
      *
      * getLastMatchingPosition( value => false );
      * // Do not move the position.
      * ```
      *
      * @param skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
      * return `true` if the value should be skipped or `false` if not.
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      *
      * @returns The position after the last item which matches the `skip` callback test.
      */
      getLastMatchingPosition(skip, options = {}) {
        options.startPosition = this;
        const treeWalker = new TreeWalker(options);
        treeWalker.skip(skip);
        return treeWalker.position;
      }
      /**
      * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
      * but without the last item.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @returns Path to the parent.
      */
      getParentPath() {
        return this.path.slice(0, -1);
      }
      /**
      * Returns ancestors array of this position, that is this position's parent and its ancestors.
      *
      * @returns Array with ancestors.
      */
      getAncestors() {
        const parent2 = this.parent;
        if (parent2.is("documentFragment")) {
          return [
            parent2
          ];
        } else {
          return parent2.getAncestors({
            includeSelf: true
          });
        }
      }
      /**
      * Returns the parent element of the given name. Returns null if the position is not inside the desired parent.
      *
      * @param parentName The name of the parent element to find.
      */
      findAncestor(parentName) {
        const parent2 = this.parent;
        if (parent2.is("element")) {
          return parent2.findAncestor(parentName, {
            includeSelf: true
          });
        }
        return null;
      }
      /**
      * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
      * of these two paths must be identical.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param position The second position.
      * @returns The common path.
      */
      getCommonPath(position) {
        if (this.root != position.root) {
          return [];
        }
        const cmp = compareArrays(this.path, position.path);
        const diffAt = typeof cmp == "string" ? Math.min(this.path.length, position.path.length) : cmp;
        return this.path.slice(0, diffAt);
      }
      /**
      * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
      * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
      *
      * @param position The second position.
      */
      getCommonAncestor(position) {
        const ancestorsA = this.getAncestors();
        const ancestorsB = position.getAncestors();
        let i = 0;
        while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
          i++;
        }
        return i === 0 ? null : ancestorsA[i - 1];
      }
      /**
      * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
      * is shifted by `shift` value (can be a negative value).
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param shift Offset shift. Can be a negative value.
      * @returns Shifted position.
      */
      getShiftedBy(shift) {
        const shifted = this.clone();
        const offset = shifted.offset + shift;
        shifted.offset = offset < 0 ? 0 : offset;
        return shifted;
      }
      /**
      * Checks whether this position is after given position.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @see module:engine/model/position~Position#isBefore
      * @param  otherPosition Position to compare with.
      * @returns True if this position is after given position.
      */
      isAfter(otherPosition) {
        return this.compareWith(otherPosition) == "after";
      }
      /**
      * Checks whether this position is before given position.
      *
      * **Note:** watch out when using negation of the value returned by this method, because the negation will also
      * be `true` if positions are in different roots and you might not expect this. You should probably use
      * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
      * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
      *
      * ```ts
      * if ( a.isBefore( b ) && c.isAfter( d ) ) {
      * 	// do A.
      * } else {
      * 	// do B.
      * }
      * ```
      *
      * or, if you have only one if-branch:
      *
      * ```ts
      * if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
      * 	// do B.
      * }
      * ```
      *
      * rather than:
      *
      * ```ts
      * if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
      * 	// do B.
      * } else {
      * 	// do A.
      * }
      * ```
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param otherPosition Position to compare with.
      * @returns True if this position is before given position.
      */
      isBefore(otherPosition) {
        return this.compareWith(otherPosition) == "before";
      }
      /**
      * Checks whether this position is equal to given position.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param otherPosition Position to compare with.
      * @returns True if positions are same.
      */
      isEqual(otherPosition) {
        return this.compareWith(otherPosition) == "same";
      }
      /**
      * Checks whether this position is touching given position. Positions touch when there are no text nodes
      * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
      * they are very similar or even indistinguishable.
      *
      * @param otherPosition Position to compare with.
      * @returns True if positions touch.
      */
      isTouching(otherPosition) {
        if (this.root !== otherPosition.root) {
          return false;
        }
        const commonLevel = Math.min(this.path.length, otherPosition.path.length);
        for (let level = 0; level < commonLevel; level++) {
          const diff2 = this.path[level] - otherPosition.path[level];
          if (diff2 < -1 || diff2 > 1) {
            return false;
          } else if (diff2 === 1) {
            return checkTouchingBranch(otherPosition, this, level);
          } else if (diff2 === -1) {
            return checkTouchingBranch(this, otherPosition, level);
          }
        }
        if (this.path.length === otherPosition.path.length) {
          return true;
        } else if (this.path.length > otherPosition.path.length) {
          return checkOnlyZeroes(this.path, commonLevel);
        } else {
          return checkOnlyZeroes(otherPosition.path, commonLevel);
        }
      }
      /**
      * Checks if two positions are in the same parent.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param position Position to compare with.
      * @returns `true` if positions have the same parent, `false` otherwise.
      */
      hasSameParentAs(position) {
        if (this.root !== position.root) {
          return false;
        }
        const thisParentPath = this.getParentPath();
        const posParentPath = position.getParentPath();
        return compareArrays(thisParentPath, posParentPath) == "same";
      }
      /**
      * Returns a copy of this position that is transformed by given `operation`.
      *
      * The new position's parameters are updated accordingly to the effect of the `operation`.
      *
      * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
      * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
      *
      * This method is safe to use it on non-existing positions (for example during operational transformation).
      *
      * @param operation Operation to transform by.
      * @returns Transformed position.
      */
      getTransformedByOperation(operation) {
        let result;
        switch (operation.type) {
          case "insert":
            result = this._getTransformedByInsertOperation(operation);
            break;
          case "move":
          case "remove":
          case "reinsert":
            result = this._getTransformedByMoveOperation(operation);
            break;
          case "split":
            result = this._getTransformedBySplitOperation(operation);
            break;
          case "merge":
            result = this._getTransformedByMergeOperation(operation);
            break;
          default:
            result = Position._createAt(this);
            break;
        }
        return result;
      }
      /**
      * Returns a copy of this position transformed by an insert operation.
      *
      * @internal
      */
      _getTransformedByInsertOperation(operation) {
        return this._getTransformedByInsertion(operation.position, operation.howMany);
      }
      /**
      * Returns a copy of this position transformed by a move operation.
      *
      * @internal
      */
      _getTransformedByMoveOperation(operation) {
        return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);
      }
      /**
      * Returns a copy of this position transformed by a split operation.
      *
      * @internal
      */
      _getTransformedBySplitOperation(operation) {
        const movedRange = operation.movedRange;
        const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == "toNext";
        if (isContained) {
          return this._getCombined(operation.splitPosition, operation.moveTargetPosition);
        } else {
          if (operation.graveyardPosition) {
            return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);
          } else {
            return this._getTransformedByInsertion(operation.insertionPosition, 1);
          }
        }
      }
      /**
      * Returns a copy of this position transformed by merge operation.
      *
      * @internal
      */
      _getTransformedByMergeOperation(operation) {
        const movedRange = operation.movedRange;
        const isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);
        let pos;
        if (isContained) {
          pos = this._getCombined(operation.sourcePosition, operation.targetPosition);
          if (operation.sourcePosition.isBefore(operation.targetPosition)) {
            pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);
          }
        } else if (this.isEqual(operation.deletionPosition)) {
          pos = Position._createAt(operation.deletionPosition);
        } else {
          pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);
        }
        return pos;
      }
      /**
      * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
      * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
      *
      * @internal
      * @param deletePosition Position before the first removed node.
      * @param howMany How many nodes are removed.
      * @returns Transformed position or `null`.
      */
      _getTransformedByDeletion(deletePosition, howMany) {
        const transformed = Position._createAt(this);
        if (this.root != deletePosition.root) {
          return transformed;
        }
        if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "same") {
          if (deletePosition.offset < this.offset) {
            if (deletePosition.offset + howMany > this.offset) {
              return null;
            } else {
              transformed.offset -= howMany;
            }
          }
        } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == "prefix") {
          const i = deletePosition.path.length - 1;
          if (deletePosition.offset <= this.path[i]) {
            if (deletePosition.offset + howMany > this.path[i]) {
              return null;
            } else {
              transformed.path[i] -= howMany;
            }
          }
        }
        return transformed;
      }
      /**
      * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
      *
      * @internal
      * @param insertPosition Position where nodes are inserted.
      * @param howMany How many nodes are inserted.
      * @returns Transformed position.
      */
      _getTransformedByInsertion(insertPosition, howMany) {
        const transformed = Position._createAt(this);
        if (this.root != insertPosition.root) {
          return transformed;
        }
        if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "same") {
          if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != "toPrevious") {
            transformed.offset += howMany;
          }
        } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == "prefix") {
          const i = insertPosition.path.length - 1;
          if (insertPosition.offset <= this.path[i]) {
            transformed.path[i] += howMany;
          }
        }
        return transformed;
      }
      /**
      * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
      *
      * @internal
      * @param sourcePosition Position before the first element to move.
      * @param targetPosition Position where moved elements will be inserted.
      * @param howMany How many consecutive nodes to move, starting from `sourcePosition`.
      * @returns Transformed position.
      */
      _getTransformedByMove(sourcePosition, targetPosition, howMany) {
        targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
        if (sourcePosition.isEqual(targetPosition)) {
          return Position._createAt(this);
        }
        const transformed = this._getTransformedByDeletion(sourcePosition, howMany);
        const isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == "toNext" || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == "toPrevious";
        if (isMoved) {
          return this._getCombined(sourcePosition, targetPosition);
        } else {
          return transformed._getTransformedByInsertion(targetPosition, howMany);
        }
      }
      /**
      * Returns a new position that is a combination of this position and given positions.
      *
      * The combined position is a copy of this position transformed by moving a range starting at `source` position
      * to the `target` position. It is expected that this position is inside the moved range.
      *
      * Example:
      *
      * ```ts
      * let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
      * let source = model.createPositionFromPath( root, [ 2, 2 ] );
      * let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
      * original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
      * ```
      *
      * Explanation:
      *
      * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
      * was inside moved nodes and now should point to the new place. The moved nodes will be after
      * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
      * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
      * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
      * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
      *
      * @internal
      * @param source Beginning of the moved range.
      * @param target Position where the range is moved.
      * @returns Combined position.
      */
      _getCombined(source, target) {
        const i = source.path.length - 1;
        const combined = Position._createAt(target);
        combined.stickiness = this.stickiness;
        combined.offset = combined.offset + this.path[i] - source.offset;
        combined.path = [
          ...combined.path,
          ...this.path.slice(i + 1)
        ];
        return combined;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        return {
          root: this.root.toJSON(),
          path: Array.from(this.path),
          stickiness: this.stickiness
        };
      }
      /**
      * Returns a new position that is equal to current position.
      */
      clone() {
        return new this.constructor(this.root, this.path, this.stickiness);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/model/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
      *
      * This method is a shortcut to other factory methods such as:
      *
      * * {@link module:engine/model/position~Position._createBefore},
      * * {@link module:engine/model/position~Position._createAfter}.
      *
      * @internal
      * @param offset Offset or one of the flags. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
      * @param stickiness Position stickiness. Used only when the first parameter is a {@link module:engine/model/item~Item model item}.
      */
      static _createAt(itemOrPosition, offset, stickiness = "toNone") {
        if (itemOrPosition instanceof Position) {
          return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);
        } else {
          const node = itemOrPosition;
          if (offset == "end") {
            offset = node.maxOffset;
          } else if (offset == "before") {
            return this._createBefore(node, stickiness);
          } else if (offset == "after") {
            return this._createAfter(node, stickiness);
          } else if (offset !== 0 && !offset) {
            throw new CKEditorError("model-createpositionat-offset-required", [
              this,
              itemOrPosition
            ]);
          }
          if (!node.is("element") && !node.is("documentFragment")) {
            throw new CKEditorError("model-position-parent-incorrect", [
              this,
              itemOrPosition
            ]);
          }
          const path = node.getPath();
          path.push(offset);
          return new this(node.root, path, stickiness);
        }
      }
      /**
      * Creates a new position, after given {@link module:engine/model/item~Item model item}.
      *
      * @internal
      * @param item Item after which the position should be placed.
      * @param stickiness Position stickiness.
      */
      static _createAfter(item, stickiness) {
        if (!item.parent) {
          throw new CKEditorError("model-position-after-root", [
            this,
            item
          ], {
            root: item
          });
        }
        return this._createAt(item.parent, item.endOffset, stickiness);
      }
      /**
      * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
      *
      * @internal
      * @param item Item before which the position should be placed.
      * @param stickiness Position stickiness.
      */
      static _createBefore(item, stickiness) {
        if (!item.parent) {
          throw new CKEditorError("model-position-before-root", item, {
            root: item
          });
        }
        return this._createAt(item.parent, item.startOffset, stickiness);
      }
      /**
      * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
      *
      * @param json Plain object to be converted to `Position`.
      * @param doc Document object that will be position owner.
      * @returns `Position` instance created using given plain object.
      */
      static fromJSON(json, doc) {
        if (json.root === "$graveyard") {
          const pos = new Position(doc.graveyard, json.path);
          pos.stickiness = json.stickiness;
          return pos;
        }
        if (!doc.getRoot(json.root)) {
          throw new CKEditorError("model-position-fromjson-no-root", doc, {
            rootName: json.root
          });
        }
        return new Position(doc.getRoot(json.root), json.path, json.stickiness);
      }
    }
    Position.prototype.is = function(type) {
      return type === "position" || type === "model:position";
    };
    function getTextNodeAtPosition(position, positionParent) {
      const node = positionParent.getChild(positionParent.offsetToIndex(position.offset));
      if (node && node.is("$text") && node.startOffset < position.offset) {
        return node;
      }
      return null;
    }
    function getNodeAfterPosition(position, positionParent, textNode) {
      if (textNode !== null) {
        return null;
      }
      return positionParent.getChild(positionParent.offsetToIndex(position.offset));
    }
    function getNodeBeforePosition(position, positionParent, textNode) {
      if (textNode !== null) {
        return null;
      }
      return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);
    }
    function checkTouchingBranch(left, right, level) {
      if (level + 1 === left.path.length) {
        return false;
      }
      if (!checkOnlyZeroes(right.path, level + 1)) {
        return false;
      }
      if (!checkOnlyMaxOffset(left, level + 1)) {
        return false;
      }
      return true;
    }
    function checkOnlyZeroes(arr, idx) {
      while (idx < arr.length) {
        if (arr[idx] !== 0) {
          return false;
        }
        idx++;
      }
      return true;
    }
    function checkOnlyMaxOffset(pos, level) {
      let parent2 = pos.parent;
      let idx = pos.path.length - 1;
      let add = 0;
      while (idx >= level) {
        if (pos.path[idx] + add !== parent2.maxOffset) {
          return false;
        }
        add = 1;
        idx--;
        parent2 = parent2.parent;
      }
      return true;
    }
    class Range extends TypeCheckable {
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * @param start The start position.
      * @param end The end position. If not set, the range will be collapsed at the `start` position.
      */
      constructor(start, end) {
        super();
        /**
        * Start position.
        */
        __publicField(this, "start");
        /**
        * End position.
        */
        __publicField(this, "end");
        this.start = Position._createAt(start);
        this.end = end ? Position._createAt(end) : Position._createAt(start);
        this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
        this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
      }
      /**
      * Iterable interface.
      *
      * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
      * them together with additional information like length or {@link module:engine/model/position~Position positions},
      * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
      * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
      * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
      *
      * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
      * and `ignoreElementEnd` option set to `true`.
      */
      *[Symbol.iterator]() {
        yield* new TreeWalker({
          boundaries: this,
          ignoreElementEnd: true
        });
      }
      /**
      * Describes whether the range is collapsed, that is if {@link #start} and
      * {@link #end} positions are equal.
      */
      get isCollapsed() {
        return this.start.isEqual(this.end);
      }
      /**
      * Describes whether this range is flat, that is if {@link #start} position and
      * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
      */
      get isFlat() {
        const startParentPath = this.start.getParentPath();
        const endParentPath = this.end.getParentPath();
        return compareArrays(startParentPath, endParentPath) == "same";
      }
      /**
      * Range root element.
      */
      get root() {
        return this.start.root;
      }
      /**
      * Checks whether this range contains given {@link module:engine/model/position~Position position}.
      *
      * @param position Position to check.
      * @returns `true` if given {@link module:engine/model/position~Position position} is contained
      * in this range,`false` otherwise.
      */
      containsPosition(position) {
        return position.isAfter(this.start) && position.isBefore(this.end);
      }
      /**
      * Checks whether this range contains given {@link ~Range range}.
      *
      * @param otherRange Range to check.
      * @param loose Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
      * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
      * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
      * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
      */
      containsRange(otherRange, loose = false) {
        if (otherRange.isCollapsed) {
          loose = false;
        }
        const containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
        const containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
        return containsStart && containsEnd;
      }
      /**
      * Checks whether given {@link module:engine/model/item~Item} is inside this range.
      */
      containsItem(item) {
        const pos = Position._createBefore(item);
        return this.containsPosition(pos) || this.start.isEqual(pos);
      }
      /**
      * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
      *
      * @param otherRange Range to compare with.
      * @returns `true` if ranges are equal, `false` otherwise.
      */
      isEqual(otherRange) {
        return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
      }
      /**
      * Checks and returns whether this range intersects with given range.
      *
      * @param otherRange Range to compare with.
      * @returns `true` if ranges intersect, `false` otherwise.
      */
      isIntersecting(otherRange) {
        return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
      }
      /**
      * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
      * Returned array contains zero, one or two {@link ~Range ranges}.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
      * let transformed = range.getDifference( otherRange );
      * // transformed array has no ranges because `otherRange` contains `range`
      *
      * otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
      * transformed = range.getDifference( otherRange );
      * // transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
      *
      * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
      * transformed = range.getDifference( otherRange );
      * // transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
      * ```
      *
      * @param otherRange Range to differentiate against.
      * @returns The difference between ranges.
      */
      getDifference(otherRange) {
        const ranges = [];
        if (this.isIntersecting(otherRange)) {
          if (this.containsPosition(otherRange.start)) {
            ranges.push(new Range(this.start, otherRange.start));
          }
          if (this.containsPosition(otherRange.end)) {
            ranges.push(new Range(otherRange.end, this.end));
          }
        } else {
          ranges.push(new Range(this.start, this.end));
        }
        return ranges;
      }
      /**
      * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
      * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
      * let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
      *
      * otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
      * transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
      * ```
      *
      * @param otherRange Range to check for intersection.
      * @returns A common part of given ranges or `null` if ranges have no common part.
      */
      getIntersection(otherRange) {
        if (this.isIntersecting(otherRange)) {
          let commonRangeStart = this.start;
          let commonRangeEnd = this.end;
          if (this.containsPosition(otherRange.start)) {
            commonRangeStart = otherRange.start;
          }
          if (this.containsPosition(otherRange.end)) {
            commonRangeEnd = otherRange.end;
          }
          return new Range(commonRangeStart, commonRangeEnd);
        }
        return null;
      }
      /**
      * Returns a range created by joining this {@link ~Range range} with the given {@link ~Range range}.
      * If ranges have no common part, returns `null`.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let otherRange = model.createRange(
      * 	model.createPositionFromPath( root, [ 1 ] ),
      * 	model.createPositionFromPath( root, [ 2 ] )
       * );
      * let transformed = range.getJoined( otherRange ); // null - ranges have no common part
      *
      * otherRange = model.createRange(
      * 	model.createPositionFromPath( root, [ 3 ] ),
      * 	model.createPositionFromPath( root, [ 5 ] )
      * );
      * transformed = range.getJoined( otherRange ); // range from [ 2, 7 ] to [ 5 ]
      * ```
      *
      * @param otherRange Range to be joined.
      * @param loose Whether the intersection check is loose or strict. If the check is strict (`false`),
      * ranges are tested for intersection or whether start/end positions are equal. If the check is loose (`true`),
      * compared range is also checked if it's {@link module:engine/model/position~Position#isTouching touching} current range.
      * @returns A sum of given ranges or `null` if ranges have no common part.
      */
      getJoined(otherRange, loose = false) {
        let shouldJoin = this.isIntersecting(otherRange);
        if (!shouldJoin) {
          if (this.start.isBefore(otherRange.start)) {
            shouldJoin = loose ? this.end.isTouching(otherRange.start) : this.end.isEqual(otherRange.start);
          } else {
            shouldJoin = loose ? otherRange.end.isTouching(this.start) : otherRange.end.isEqual(this.start);
          }
        }
        if (!shouldJoin) {
          return null;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (otherRange.start.isBefore(startPosition)) {
          startPosition = otherRange.start;
        }
        if (otherRange.end.isAfter(endPosition)) {
          endPosition = otherRange.end;
        }
        return new Range(startPosition, endPosition);
      }
      /**
      * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
      *
      * See an example of a model structure (`[` and `]` are range boundaries):
      *
      * ```
      * root                                                            root
      *  |- element DIV                         DIV             P2              P3             DIV
      *  |   |- element H                   H        P1        f o o           b a r       H         P4
      *  |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
      *  |   |- element P1
      *  |   |   |- "lorem"                                              ||
      *  |- element P2                                                   ||
      *  |   |- "foo"                                                    VV
      *  |- element P3
      *  |   |- "bar"                                                   root
      *  |- element DIV                         DIV             [P2             P3]             DIV
      *  |   |- element H                   H       [P1]       f o o           b a r        H         P4
      *  |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
      *  |   |- element P4
      *  |   |   |- "ipsum"
      * ```
      *
      * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
      * We are looking for minimal set of flat ranges that contains the same nodes.
      *
      * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
      *
      * ```
      * ( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
      * ( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
      * ( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
      * ( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
      * ```
      *
      * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
      * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
      * were omitted. Only their parts that were wholly in the range were returned.
      *
      * **Note:** this method is not returning flat ranges that contain no nodes.
      *
      * @returns Array of flat ranges covering this range.
      */
      getMinimalFlatRanges() {
        const ranges = [];
        const diffAt = this.start.getCommonPath(this.end).length;
        const pos = Position._createAt(this.start);
        let posParent = pos.parent;
        while (pos.path.length > diffAt + 1) {
          const howMany = posParent.maxOffset - pos.offset;
          if (howMany !== 0) {
            ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
          }
          pos.path = pos.path.slice(0, -1);
          pos.offset++;
          posParent = posParent.parent;
        }
        while (pos.path.length <= this.end.path.length) {
          const offset = this.end.path[pos.path.length - 1];
          const howMany = offset - pos.offset;
          if (howMany !== 0) {
            ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
          }
          pos.offset = offset;
          pos.path.push(0);
        }
        return ranges;
      }
      /**
      * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
      *
      * For example, to iterate over all items in the entire document root:
      *
      * ```ts
      * // Create a range spanning over the entire root content:
      * const range = editor.model.createRangeIn( editor.model.document.getRoot() );
      *
      * // Iterate over all items in this range:
      * for ( const value of range.getWalker() ) {
      * 	console.log( value.item );
      * }
      * ```
      *
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      */
      getWalker(options = {}) {
        options.boundaries = this;
        return new TreeWalker(options);
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
      * them.
      *
      * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
      * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
      * not {@link module:engine/model/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      */
      *getItems(options = {}) {
        options.boundaries = this;
        options.ignoreElementEnd = true;
        const treeWalker = new TreeWalker(options);
        for (const value of treeWalker) {
          yield value.item;
        }
      }
      /**
      * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
      * contained in this range.
      *
      * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
      * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
      *
      * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
      * a full list of available options.
      *
      * @param options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
      */
      *getPositions(options = {}) {
        options.boundaries = this;
        const treeWalker = new TreeWalker(options);
        yield treeWalker.position;
        for (const value of treeWalker) {
          yield value.nextPosition;
        }
      }
      /**
      * Returns a range that is a result of transforming this range by given `operation`.
      *
      * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
      * moved to a different part of document tree). For this reason, an array is returned by this method and it
      * may contain one or more `Range` instances.
      *
      * @param operation Operation to transform range by.
      * @returns Range which is the result of transformation.
      */
      getTransformedByOperation(operation) {
        switch (operation.type) {
          case "insert":
            return this._getTransformedByInsertOperation(operation);
          case "move":
          case "remove":
          case "reinsert":
            return this._getTransformedByMoveOperation(operation);
          case "split":
            return [
              this._getTransformedBySplitOperation(operation)
            ];
          case "merge":
            return [
              this._getTransformedByMergeOperation(operation)
            ];
        }
        return [
          new Range(this.start, this.end)
        ];
      }
      /**
      * Returns a range that is a result of transforming this range by multiple `operations`.
      *
      * @see ~Range#getTransformedByOperation
      * @param operations Operations to transform the range by.
      * @returns Range which is the result of transformation.
      */
      getTransformedByOperations(operations2) {
        const ranges = [
          new Range(this.start, this.end)
        ];
        for (const operation of operations2) {
          for (let i = 0; i < ranges.length; i++) {
            const result = ranges[i].getTransformedByOperation(operation);
            ranges.splice(i, 1, ...result);
            i += result.length - 1;
          }
        }
        for (let i = 0; i < ranges.length; i++) {
          const range = ranges[i];
          for (let j = i + 1; j < ranges.length; j++) {
            const next = ranges[j];
            if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {
              ranges.splice(j, 1);
            }
          }
        }
        return ranges;
      }
      /**
      * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
      * which is a common ancestor of the range's both ends (in which the entire range is contained).
      */
      getCommonAncestor() {
        return this.start.getCommonAncestor(this.end);
      }
      /**
      * Returns an {@link module:engine/model/element~Element Element} contained by the range.
      * The element will be returned when it is the **only** node within the range and **fully–contained**
      * at the same time.
      */
      getContainedElement() {
        if (this.isCollapsed) {
          return null;
        }
        const nodeAfterStart = this.start.nodeAfter;
        const nodeBeforeEnd = this.end.nodeBefore;
        if (nodeAfterStart && nodeAfterStart.is("element") && nodeAfterStart === nodeBeforeEnd) {
          return nodeAfterStart;
        }
        return null;
      }
      /**
      * Converts `Range` to plain object and returns it.
      *
      * @returns `Node` converted to plain object.
      */
      toJSON() {
        return {
          start: this.start.toJSON(),
          end: this.end.toJSON()
        };
      }
      /**
      * Returns a new range that is equal to current range.
      */
      clone() {
        return new this.constructor(this.start, this.end);
      }
      /**
      * Returns a result of transforming a copy of this range by insert operation.
      *
      * One or more ranges may be returned as a result of this transformation.
      *
      * @internal
      */
      _getTransformedByInsertOperation(operation, spread = false) {
        return this._getTransformedByInsertion(operation.position, operation.howMany, spread);
      }
      /**
      * Returns a result of transforming a copy of this range by move operation.
      *
      * One or more ranges may be returned as a result of this transformation.
      *
      * @internal
      */
      _getTransformedByMoveOperation(operation, spread = false) {
        const sourcePosition = operation.sourcePosition;
        const howMany = operation.howMany;
        const targetPosition = operation.targetPosition;
        return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);
      }
      /**
      * Returns a result of transforming a copy of this range by split operation.
      *
      * Always one range is returned. The transformation is done in a way to not break the range.
      *
      * @internal
      */
      _getTransformedBySplitOperation(operation) {
        const start = this.start._getTransformedBySplitOperation(operation);
        let end = this.end._getTransformedBySplitOperation(operation);
        if (this.end.isEqual(operation.insertionPosition)) {
          end = this.end.getShiftedBy(1);
        }
        if (start.root != end.root) {
          end = this.end.getShiftedBy(-1);
        }
        return new Range(start, end);
      }
      /**
      * Returns a result of transforming a copy of this range by merge operation.
      *
      * Always one range is returned. The transformation is done in a way to not break the range.
      *
      * @internal
      */
      _getTransformedByMergeOperation(operation) {
        if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {
          return new Range(this.start);
        }
        let start = this.start._getTransformedByMergeOperation(operation);
        let end = this.end._getTransformedByMergeOperation(operation);
        if (start.root != end.root) {
          end = this.end.getShiftedBy(-1);
        }
        if (start.isAfter(end)) {
          if (operation.sourcePosition.isBefore(operation.targetPosition)) {
            start = Position._createAt(end);
            start.offset = 0;
          } else {
            if (!operation.deletionPosition.isEqual(start)) {
              end = operation.deletionPosition;
            }
            start = operation.targetPosition;
          }
          return new Range(start, end);
        }
        return new Range(start, end);
      }
      /**
      * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
      * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
      * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
      *
      * Examples:
      *
      * ```ts
      * let range = model.createRange(
      * 	model.createPositionFromPath( root, [ 2, 7 ] ),
      * 	model.createPositionFromPath( root, [ 4, 0, 1 ] )
      * );
      * let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
      * // transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
      *
      * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
      * // transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
      *
      * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
      * // transformed array has one range, which is equal to original range
      *
      * transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
      * // transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
      * ```
      *
      * @internal
      * @param insertPosition Position where nodes are inserted.
      * @param howMany How many nodes are inserted.
      * @param spread Flag indicating whether this range should be spread if insertion
      * was inside the range. Defaults to `false`.
      * @returns Result of the transformation.
      */
      _getTransformedByInsertion(insertPosition, howMany, spread = false) {
        if (spread && this.containsPosition(insertPosition)) {
          return [
            new Range(this.start, insertPosition),
            new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))
          ];
        } else {
          const range = new Range(this.start, this.end);
          range.start = range.start._getTransformedByInsertion(insertPosition, howMany);
          range.end = range.end._getTransformedByInsertion(insertPosition, howMany);
          return [
            range
          ];
        }
      }
      /**
      * Returns an array containing {@link ~Range ranges} that are a result of transforming this
      * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
      *
      * @internal
      * @param sourcePosition Position from which nodes are moved.
      * @param targetPosition Position to where nodes are moved.
      * @param howMany How many nodes are moved.
      * @param spread Whether the range should be spread if the move points inside the range.
      * @returns  Result of the transformation.
      */
      _getTransformedByMove(sourcePosition, targetPosition, howMany, spread = false) {
        if (this.isCollapsed) {
          const newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
          return [
            new Range(newPos)
          ];
        }
        const moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);
        const insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);
        if (this.containsPosition(targetPosition) && !spread) {
          if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {
            const start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);
            const end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);
            return [
              new Range(start, end)
            ];
          }
        }
        let result;
        const differenceSet = this.getDifference(moveRange);
        let difference = null;
        const common = this.getIntersection(moveRange);
        if (differenceSet.length == 1) {
          difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
        } else if (differenceSet.length == 2) {
          difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
        }
        if (difference) {
          result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);
        } else {
          result = [];
        }
        if (common) {
          const transformedCommon = new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));
          if (result.length == 2) {
            result.splice(1, 0, transformedCommon);
          } else {
            result.push(transformedCommon);
          }
        }
        return result;
      }
      /**
      * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
      *
      * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
      *
      * If the deleted range contains transformed range, `null` will be returned.
      *
      * @internal
      * @param deletionPosition Position from which nodes are removed.
      * @param howMany How many nodes are removed.
      * @returns Result of the transformation.
      */
      _getTransformedByDeletion(deletePosition, howMany) {
        let newStart = this.start._getTransformedByDeletion(deletePosition, howMany);
        let newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);
        if (newStart == null && newEnd == null) {
          return null;
        }
        if (newStart == null) {
          newStart = deletePosition;
        }
        if (newEnd == null) {
          newEnd = deletePosition;
        }
        return new Range(newStart, newEnd);
      }
      /**
      * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
      * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
      *
      * @internal
      * @param position Beginning of the range.
      * @param shift How long the range should be.
      */
      static _createFromPositionAndShift(position, shift) {
        const start = position;
        const end = position.getShiftedBy(shift);
        return shift > 0 ? new this(start, end) : new this(end, start);
      }
      /**
      * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @internal
      * @param element Element which is a parent for the range.
      */
      static _createIn(element) {
        return new this(Position._createAt(element, 0), Position._createAt(element, element.maxOffset));
      }
      /**
      * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
      *
      * @internal
      */
      static _createOn(item) {
        return this._createFromPositionAndShift(Position._createBefore(item), item.offsetSize);
      }
      /**
      * Combines all ranges from the passed array into a one range. At least one range has to be passed.
      * Passed ranges must not have common parts.
      *
      * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
      * the reference range, they get combined into one range.
      *
      * ```
      * [  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
      * [    ]                                       // The result of the function if the first range was a reference range.
      *         [                           ]        // The result of the function if the third-to-seventh range was a reference range.
      *                                        [  ]  // The result of the function if the last range was a reference range.
      * ```
      *
      * @internal
      * @param ranges Ranges to combine.
      * @returns Combined range.
      */
      static _createFromRanges(ranges) {
        if (ranges.length === 0) {
          throw new CKEditorError("range-create-from-ranges-empty-array", null);
        } else if (ranges.length == 1) {
          return ranges[0].clone();
        }
        const ref = ranges[0];
        ranges.sort((a, b) => {
          return a.start.isAfter(b.start) ? 1 : -1;
        });
        const refIndex = ranges.indexOf(ref);
        const result = new this(ref.start, ref.end);
        if (refIndex > 0) {
          for (let i = refIndex - 1; true; i++) {
            if (ranges[i].end.isEqual(result.start)) {
              result.start = Position._createAt(ranges[i].start);
            } else {
              break;
            }
          }
        }
        for (let i = refIndex + 1; i < ranges.length; i++) {
          if (ranges[i].start.isEqual(result.end)) {
            result.end = Position._createAt(ranges[i].end);
          } else {
            break;
          }
        }
        return result;
      }
      /**
      * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
      *
      * @param json Plain object to be converted to `Range`.
      * @param doc Document object that will be range owner.
      * @returns `Range` instance created using given plain object.
      */
      static fromJSON(json, doc) {
        return new this(Position.fromJSON(json.start, doc), Position.fromJSON(json.end, doc));
      }
    }
    Range.prototype.is = function(type) {
      return type === "range" || type === "model:range";
    };
    class Mapper extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the mapper.
      */
      constructor() {
        super();
        /**
        * Model element to view element mapping.
        */
        __publicField(this, "_modelToViewMapping", /* @__PURE__ */ new WeakMap());
        /**
        * View element to model element mapping.
        */
        __publicField(this, "_viewToModelMapping", /* @__PURE__ */ new WeakMap());
        /**
        * A map containing callbacks between view element names and functions evaluating length of view elements
        * in model.
        */
        __publicField(this, "_viewToModelLengthCallbacks", /* @__PURE__ */ new Map());
        /**
        * Model marker name to view elements mapping.
        *
        * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.
        * One marker (name) can be mapped to multiple elements.
        */
        __publicField(this, "_markerNameToElements", /* @__PURE__ */ new Map());
        /**
        * View element to model marker names mapping.
        *
        * This is reverse to {@link ~Mapper#_markerNameToElements} map.
        */
        __publicField(this, "_elementToMarkerNames", /* @__PURE__ */ new Map());
        /**
        * The map of removed view elements with their current root (used for deferred unbinding).
        */
        __publicField(this, "_deferredBindingRemovals", /* @__PURE__ */ new Map());
        /**
        * Stores marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
        * has been removed, moved or renamed).
        */
        __publicField(this, "_unboundMarkerNames", /* @__PURE__ */ new Set());
        this.on("modelToViewPosition", (evt, data) => {
          if (data.viewPosition) {
            return;
          }
          const viewContainer = this._modelToViewMapping.get(data.modelPosition.parent);
          if (!viewContainer) {
            throw new CKEditorError("mapping-model-position-view-parent-not-found", this, {
              modelPosition: data.modelPosition
            });
          }
          data.viewPosition = this.findPositionIn(viewContainer, data.modelPosition.offset);
        }, {
          priority: "low"
        });
        this.on("viewToModelPosition", (evt, data) => {
          if (data.modelPosition) {
            return;
          }
          const viewBlock = this.findMappedViewAncestor(data.viewPosition);
          const modelParent = this._viewToModelMapping.get(viewBlock);
          const modelOffset = this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);
          data.modelPosition = Position._createAt(modelParent, modelOffset);
        }, {
          priority: "low"
        });
      }
      /**
      * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
      * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
      * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
      * The information that elements are bound is also used to translate positions.
      *
      * @param modelElement Model element.
      * @param viewElement View element.
      */
      bindElements(modelElement, viewElement) {
        this._modelToViewMapping.set(modelElement, viewElement);
        this._viewToModelMapping.set(viewElement, modelElement);
      }
      /**
      * Unbinds the given {@link module:engine/view/element~Element view element} from the map.
      *
      * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
      * will be removed only if model element is still bound to the passed `viewElement`.
      *
      * This behavior allows for re-binding model element to another view element without fear of losing the new binding
      * when the previously bound view element is unbound.
      *
      * @param viewElement View element to unbind.
      * @param options The options object.
      * @param options.defer Controls whether the binding should be removed immediately or deferred until a
      * {@link #flushDeferredBindings `flushDeferredBindings()`} call.
      */
      unbindViewElement(viewElement, options = {}) {
        const modelElement = this.toModelElement(viewElement);
        if (this._elementToMarkerNames.has(viewElement)) {
          for (const markerName of this._elementToMarkerNames.get(viewElement)) {
            this._unboundMarkerNames.add(markerName);
          }
        }
        if (options.defer) {
          this._deferredBindingRemovals.set(viewElement, viewElement.root);
        } else {
          this._viewToModelMapping.delete(viewElement);
          if (this._modelToViewMapping.get(modelElement) == viewElement) {
            this._modelToViewMapping.delete(modelElement);
          }
        }
      }
      /**
      * Unbinds the given {@link module:engine/model/element~Element model element} from the map.
      *
      * **Note:** the model-to-view binding will be removed, if it existed. However, the corresponding view-to-model binding
      * will be removed only if the view element is still bound to the passed `modelElement`.
      *
      * This behavior lets for re-binding view element to another model element without fear of losing the new binding
      * when the previously bound model element is unbound.
      *
      * @param modelElement Model element to unbind.
      */
      unbindModelElement(modelElement) {
        const viewElement = this.toViewElement(modelElement);
        this._modelToViewMapping.delete(modelElement);
        if (this._viewToModelMapping.get(viewElement) == modelElement) {
          this._viewToModelMapping.delete(viewElement);
        }
      }
      /**
      * Binds the given marker name with the given {@link module:engine/view/element~Element view element}. The element
      * will be added to the current set of elements bound with the given marker name.
      *
      * @param element Element to bind.
      * @param name Marker name.
      */
      bindElementToMarker(element, name) {
        const elements = this._markerNameToElements.get(name) || /* @__PURE__ */ new Set();
        elements.add(element);
        const names2 = this._elementToMarkerNames.get(element) || /* @__PURE__ */ new Set();
        names2.add(name);
        this._markerNameToElements.set(name, elements);
        this._elementToMarkerNames.set(element, names2);
      }
      /**
      * Unbinds an element from given marker name.
      *
      * @param element Element to unbind.
      * @param name Marker name.
      */
      unbindElementFromMarkerName(element, name) {
        const nameToElements = this._markerNameToElements.get(name);
        if (nameToElements) {
          nameToElements.delete(element);
          if (nameToElements.size == 0) {
            this._markerNameToElements.delete(name);
          }
        }
        const elementToNames = this._elementToMarkerNames.get(element);
        if (elementToNames) {
          elementToNames.delete(name);
          if (elementToNames.size == 0) {
            this._elementToMarkerNames.delete(element);
          }
        }
      }
      /**
      * Returns all marker names of markers which have changed due to unbinding a view element (so it is assumed that the view element
      * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
      */
      flushUnboundMarkerNames() {
        const markerNames = Array.from(this._unboundMarkerNames);
        this._unboundMarkerNames.clear();
        return markerNames;
      }
      /**
      * Unbinds all deferred binding removals of view elements that in the meantime were not re-attached to some root or document fragment.
      *
      * See: {@link #unbindViewElement `unbindViewElement()`}.
      */
      flushDeferredBindings() {
        for (const [viewElement, root2] of this._deferredBindingRemovals) {
          if (viewElement.root == root2) {
            this.unbindViewElement(viewElement);
          }
        }
        this._deferredBindingRemovals = /* @__PURE__ */ new Map();
      }
      /**
      * Removes all model to view and view to model bindings.
      */
      clearBindings() {
        this._modelToViewMapping = /* @__PURE__ */ new WeakMap();
        this._viewToModelMapping = /* @__PURE__ */ new WeakMap();
        this._markerNameToElements = /* @__PURE__ */ new Map();
        this._elementToMarkerNames = /* @__PURE__ */ new Map();
        this._unboundMarkerNames = /* @__PURE__ */ new Set();
        this._deferredBindingRemovals = /* @__PURE__ */ new Map();
      }
      toModelElement(viewElement) {
        return this._viewToModelMapping.get(viewElement);
      }
      toViewElement(modelElement) {
        return this._modelToViewMapping.get(modelElement);
      }
      /**
      * Gets the corresponding model range.
      *
      * @param viewRange View range.
      * @returns Corresponding model range.
      */
      toModelRange(viewRange) {
        return new Range(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
      }
      /**
      * Gets the corresponding view range.
      *
      * @param modelRange Model range.
      * @returns Corresponding view range.
      */
      toViewRange(modelRange) {
        return new Range$1(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
      }
      /**
      * Gets the corresponding model position.
      *
      * @fires viewToModelPosition
      * @param viewPosition View position.
      * @returns Corresponding model position.
      */
      toModelPosition(viewPosition) {
        const data = {
          viewPosition,
          mapper: this
        };
        this.fire("viewToModelPosition", data);
        return data.modelPosition;
      }
      /**
      * Gets the corresponding view position.
      *
      * @fires modelToViewPosition
      * @param modelPosition Model position.
      * @param options Additional options for position mapping process.
      * @param options.isPhantom Should be set to `true` if the model position to map is pointing to a place
      * in model tree which no longer exists. For example, it could be an end of a removed model range.
      * @returns Corresponding view position.
      */
      toViewPosition(modelPosition, options = {}) {
        const data = {
          modelPosition,
          mapper: this,
          isPhantom: options.isPhantom
        };
        this.fire("modelToViewPosition", data);
        return data.viewPosition;
      }
      /**
      * Gets all view elements bound to the given marker name.
      *
      * @param name Marker name.
      * @returns View elements bound with the given marker name or `null`
      * if no elements are bound to the given marker name.
      */
      markerNameToElements(name) {
        const boundElements = this._markerNameToElements.get(name);
        if (!boundElements) {
          return null;
        }
        const elements = /* @__PURE__ */ new Set();
        for (const element of boundElements) {
          if (element.is("attributeElement")) {
            for (const clone2 of element.getElementsWithSameId()) {
              elements.add(clone2);
            }
          } else {
            elements.add(element);
          }
        }
        return elements;
      }
      /**
      * Registers a callback that evaluates the length in the model of a view element with the given name.
      *
      * The callback is fired with one argument, which is a view element instance. The callback is expected to return
      * a number representing the length of the view element in the model.
      *
      * ```ts
      * // List item in view may contain nested list, which have other list items. In model though,
      * // the lists are represented by flat structure. Because of those differences, length of list view element
      * // may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
      *
      * function getViewListItemLength( element ) {
      * 	let length = 1;
      *
      * 	for ( let child of element.getChildren() ) {
      * 		if ( child.name == 'ul' || child.name == 'ol' ) {
      * 			for ( let item of child.getChildren() ) {
      * 				length += getViewListItemLength( item );
      * 			}
      * 		}
      * 	}
      *
      * 	return length;
      * }
      *
      * mapper.registerViewToModelLength( 'li', getViewListItemLength );
      * ```
      *
      * @param viewElementName Name of view element for which callback is registered.
      * @param lengthCallback Function return a length of view element instance in model.
      */
      registerViewToModelLength(viewElementName, lengthCallback) {
        this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
      }
      /**
      * For the given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
      * the model.
      *
      * @param viewPosition Position for which a mapped ancestor should be found.
      */
      findMappedViewAncestor(viewPosition) {
        let parent2 = viewPosition.parent;
        while (!this._viewToModelMapping.has(parent2)) {
          parent2 = parent2.parent;
        }
        return parent2;
      }
      /**
      * Calculates model offset based on the view position and the block element.
      *
      * Example:
      *
      * ```html
      * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
      * ```
      *
      * Is a sum of:
      *
      * ```html
      * <p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
      * <p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
      * ```
      *
      * @param viewParent Position parent.
      * @param viewOffset Position offset.
      * @param viewBlock Block used as a base to calculate offset.
      * @returns Offset in the model.
      */
      _toModelOffset(viewParent, viewOffset, viewBlock) {
        if (viewBlock != viewParent) {
          const offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);
          const offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);
          return offsetToParentStart + offsetInParent;
        }
        if (viewParent.is("$text")) {
          return viewOffset;
        }
        let modelOffset = 0;
        for (let i = 0; i < viewOffset; i++) {
          modelOffset += this.getModelLength(viewParent.getChild(i));
        }
        return modelOffset;
      }
      /**
      * Gets the length of the view element in the model.
      *
      * The length is calculated as follows:
      * * if a {@link #registerViewToModelLength length mapping callback} is provided for the given `viewNode`, it is used to
      * evaluate the model length (`viewNode` is used as first and only parameter passed to the callback),
      * * length of a {@link module:engine/view/text~Text text node} is equal to the length of its
      * {@link module:engine/view/text~Text#data data},
      * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
      * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
      * * length of a non-mapped {@link module:engine/view/element~Element element} is equal to the length of its children.
      *
      * Examples:
      *
      * ```
      * foo                          -> 3 // Text length is equal to its data length.
      * <p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
      * <b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
      * <div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
      * ```
      *
      * @param viewNode View node.
      * @returns Length of the node in the tree model.
      */
      getModelLength(viewNode) {
        if (this._viewToModelLengthCallbacks.get(viewNode.name)) {
          const callback = this._viewToModelLengthCallbacks.get(viewNode.name);
          return callback(viewNode);
        } else if (this._viewToModelMapping.has(viewNode)) {
          return 1;
        } else if (viewNode.is("$text")) {
          return viewNode.data.length;
        } else if (viewNode.is("uiElement")) {
          return 0;
        } else {
          let len = 0;
          for (const child of viewNode.getChildren()) {
            len += this.getModelLength(child);
          }
          return len;
        }
      }
      /**
      * Finds the position in the view node (or in its children) with the expected model offset.
      *
      * Example:
      *
      * ```
      * <p>fo<b>bar</b>bom</p> -> expected offset: 4
      *
      * findPositionIn( p, 4 ):
      * <p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
      * <p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
      * <p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
      *
      * findPositionIn( b, 4 - ( 5 - 3 ) ):
      * <p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
      * <p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
      *
      * findPositionIn( bar, 2 - ( 3 - 3 ) ):
      * We are in the text node so we can simple find the offset.
      * <p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
      * ```
      *
      * @param viewParent Tree view element in which we are looking for the position.
      * @param expectedOffset Expected offset.
      * @returns Found position.
      */
      findPositionIn(viewParent, expectedOffset) {
        let viewNode;
        let lastLength = 0;
        let modelOffset = 0;
        let viewOffset = 0;
        if (viewParent.is("$text")) {
          return new Position$1(viewParent, expectedOffset);
        }
        while (modelOffset < expectedOffset) {
          viewNode = viewParent.getChild(viewOffset);
          lastLength = this.getModelLength(viewNode);
          modelOffset += lastLength;
          viewOffset++;
        }
        if (modelOffset == expectedOffset) {
          return this._moveViewPositionToTextNode(new Position$1(viewParent, viewOffset));
        } else {
          return this.findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
        }
      }
      /**
      * Because we prefer positions in the text nodes over positions next to text nodes, if the view position was next to a text node,
      * it moves it into the text node instead.
      *
      * ```
      * <p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
      * <p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
      * <p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
      * ```
      *
      * @param viewPosition Position potentially next to the text node.
      * @returns Position in the text node if possible.
      */
      _moveViewPositionToTextNode(viewPosition) {
        const nodeBefore = viewPosition.nodeBefore;
        const nodeAfter = viewPosition.nodeAfter;
        if (nodeBefore instanceof Text$1) {
          return new Position$1(nodeBefore, nodeBefore.data.length);
        } else if (nodeAfter instanceof Text$1) {
          return new Position$1(nodeAfter, 0);
        }
        return viewPosition;
      }
    }
    class ModelConsumable {
      constructor() {
        /**
        * Contains list of consumable values.
        */
        __publicField(this, "_consumable", /* @__PURE__ */ new Map());
        /**
        * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds a parent
        * of that `TextProxy` and the start and end indices of that `TextProxy`. This allows identification of the `TextProxy`
        * instances that point to the same part of the model but are different instances. Each distinct `TextProxy`
        * is given a unique `Symbol` which is then registered as consumable. This process is transparent for the `ModelConsumable`
        * API user because whenever `TextProxy` is added, tested, consumed or reverted, the internal mechanisms of
        * `ModelConsumable` translate `TextProxy` to that unique `Symbol`.
        */
        __publicField(this, "_textProxyRegistry", /* @__PURE__ */ new Map());
      }
      /**
      * Adds a consumable value to the consumables list and links it with a given model item.
      *
      * ```ts
      * modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
      * modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
      * modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
      * modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
      * modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
      * ```
      *
      * @param item Model item, range or selection that has the consumable.
      * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
      * Second colon and everything after will be cut. Passing event name is a safe and good practice.
      */
      add(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        if (!this._consumable.has(item)) {
          this._consumable.set(item, /* @__PURE__ */ new Map());
        }
        this._consumable.get(item).set(type, true);
      }
      /**
      * Removes a given consumable value from a given model item.
      *
      * ```ts
      * modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
      * modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
      * modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
      * modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
      * modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
      * ```
      *
      * @param item Model item, range or selection from which consumable will be consumed.
      * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
      * Second colon and everything after will be cut. Passing event name is a safe and good practice.
      * @returns `true` if consumable value was available and was consumed, `false` otherwise.
      */
      consume(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        if (this.test(item, type)) {
          this._consumable.get(item).set(type, false);
          return true;
        } else {
          return false;
        }
      }
      /**
      * Tests whether there is a consumable value of a given type connected with a given model item.
      *
      * ```ts
      * modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
      * modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
      * modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
      * modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
      * modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
      * ```
      *
      * @param item Model item, range or selection to be tested.
      * @param type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
      * Second colon and everything after will be cut. Passing event name is a safe and good practice.
      * @returns `null` if such consumable was never added, `false` if the consumable values was
      * already consumed or `true` if it was added and not consumed yet.
      */
      test(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        const itemConsumables = this._consumable.get(item);
        if (itemConsumables === void 0) {
          return null;
        }
        const value = itemConsumables.get(type);
        if (value === void 0) {
          return null;
        }
        return value;
      }
      /**
      * Reverts consuming of a consumable value.
      *
      * ```ts
      * modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
      * modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
      * modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
      * modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
      * modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
      * ```
      *
      * @param item Model item, range or selection to be reverted.
      * @param type Consumable type.
      * @returns `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
      * never been added.
      */
      revert(item, type) {
        type = _normalizeConsumableType(type);
        if (item instanceof TextProxy) {
          item = this._getSymbolForTextProxy(item);
        }
        const test = this.test(item, type);
        if (test === false) {
          this._consumable.get(item).set(type, true);
          return true;
        } else if (test === true) {
          return false;
        }
        return null;
      }
      /**
      * Verifies if all events from the specified group were consumed.
      *
      * @param eventGroup The events group to verify.
      */
      verifyAllConsumed(eventGroup) {
        const items = [];
        for (const [item, consumables] of this._consumable) {
          for (const [event, canConsume] of consumables) {
            const eventPrefix = event.split(":")[0];
            if (canConsume && eventGroup == eventPrefix) {
              items.push({
                event,
                item: item.name || item.description
              });
            }
          }
        }
        if (items.length) {
          throw new CKEditorError("conversion-model-consumable-not-consumed", null, {
            items
          });
        }
      }
      /**
      * Gets a unique symbol for the passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
      * have same parent, same start index and same end index will get the same symbol.
      *
      * Used internally to correctly consume `TextProxy` instances.
      *
      * @internal
      * @param textProxy `TextProxy` instance to get a symbol for.
      * @returns Symbol representing all equal instances of `TextProxy`.
      */
      _getSymbolForTextProxy(textProxy) {
        let symbol = null;
        const startMap = this._textProxyRegistry.get(textProxy.startOffset);
        if (startMap) {
          const endMap = startMap.get(textProxy.endOffset);
          if (endMap) {
            symbol = endMap.get(textProxy.parent);
          }
        }
        if (!symbol) {
          symbol = this._addSymbolForTextProxy(textProxy);
        }
        return symbol;
      }
      /**
      * Adds a symbol for the given {@link module:engine/model/textproxy~TextProxy} instance.
      *
      * Used internally to correctly consume `TextProxy` instances.
      *
      * @param textProxy Text proxy instance.
      * @returns Symbol generated for given `TextProxy`.
      */
      _addSymbolForTextProxy(textProxy) {
        const start = textProxy.startOffset;
        const end = textProxy.endOffset;
        const parent2 = textProxy.parent;
        const symbol = Symbol("$textProxy:" + textProxy.data);
        let startMap;
        let endMap;
        startMap = this._textProxyRegistry.get(start);
        if (!startMap) {
          startMap = /* @__PURE__ */ new Map();
          this._textProxyRegistry.set(start, startMap);
        }
        endMap = startMap.get(end);
        if (!endMap) {
          endMap = /* @__PURE__ */ new Map();
          startMap.set(end, endMap);
        }
        endMap.set(parent2, symbol);
        return symbol;
      }
    }
    function _normalizeConsumableType(type) {
      const parts = type.split(":");
      if (parts[0] == "insert") {
        return parts[0];
      }
      if (parts[0] == "addMarker" || parts[0] == "removeMarker") {
        return type;
      }
      return parts.length > 1 ? parts[0] + ":" + parts[1] : parts[0];
    }
    class DowncastDispatcher extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates a downcast dispatcher instance.
      *
      * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
      *
      * @param conversionApi Additional properties for an interface that will be passed to events fired
      * by the downcast dispatcher.
      */
      constructor(conversionApi) {
        super();
        /**
        * A template for an interface passed by the dispatcher to the event callbacks.
        *
        * @internal
        */
        __publicField(this, "_conversionApi");
        /**
        * A map of already fired events for a given `ModelConsumable`.
        */
        __publicField(this, "_firedEventsMap");
        this._conversionApi = {
          dispatcher: this,
          ...conversionApi
        };
        this._firedEventsMap = /* @__PURE__ */ new WeakMap();
      }
      /**
      * Converts changes buffered in the given {@link module:engine/model/differ~Differ model differ}
      * and fires conversion events based on it.
      *
      * @fires insert
      * @fires remove
      * @fires attribute
      * @fires addMarker
      * @fires removeMarker
      * @fires reduceChanges
      * @param differ The differ object with buffered changes.
      * @param markers Markers related to the model fragment to convert.
      * @param writer The view writer that should be used to modify the view document.
      */
      convertChanges(differ, markers, writer) {
        const conversionApi = this._createConversionApi(writer, differ.getRefreshedItems());
        for (const change of differ.getMarkersToRemove()) {
          this._convertMarkerRemove(change.name, change.range, conversionApi);
        }
        const changes = this._reduceChanges(differ.getChanges());
        for (const entry of changes) {
          if (entry.type === "insert") {
            this._convertInsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);
          } else if (entry.type === "reinsert") {
            this._convertReinsert(Range._createFromPositionAndShift(entry.position, entry.length), conversionApi);
          } else if (entry.type === "remove") {
            this._convertRemove(entry.position, entry.length, entry.name, conversionApi);
          } else {
            this._convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, conversionApi);
          }
        }
        conversionApi.mapper.flushDeferredBindings();
        for (const markerName of conversionApi.mapper.flushUnboundMarkerNames()) {
          const markerRange = markers.get(markerName).getRange();
          this._convertMarkerRemove(markerName, markerRange, conversionApi);
          this._convertMarkerAdd(markerName, markerRange, conversionApi);
        }
        for (const change of differ.getMarkersToAdd()) {
          this._convertMarkerAdd(change.name, change.range, conversionApi);
        }
        conversionApi.consumable.verifyAllConsumed("insert");
      }
      /**
      * Starts a conversion of a model range and the provided markers.
      *
      * @fires insert
      * @fires attribute
      * @fires addMarker
      * @param range The inserted range.
      * @param markers The map of markers that should be down-casted.
      * @param writer The view writer that should be used to modify the view document.
      * @param options Optional options object passed to `convertionApi.options`.
      */
      convert(range, markers, writer, options = {}) {
        const conversionApi = this._createConversionApi(writer, void 0, options);
        this._convertInsert(range, conversionApi);
        for (const [name, range2] of markers) {
          this._convertMarkerAdd(name, range2, conversionApi);
        }
        conversionApi.consumable.verifyAllConsumed("insert");
      }
      /**
      * Starts the model selection conversion.
      *
      * Fires events for a given {@link module:engine/model/selection~Selection selection} to start the selection conversion.
      *
      * @fires selection
      * @fires addMarker
      * @fires attribute
      * @param selection The selection to convert.
      * @param markers Markers connected with the converted model.
      * @param writer View writer that should be used to modify the view document.
      */
      convertSelection(selection, markers, writer) {
        const conversionApi = this._createConversionApi(writer);
        this.fire("cleanSelection", {
          selection
        }, conversionApi);
        const modelRoot = selection.getFirstPosition().root;
        if (!conversionApi.mapper.toViewElement(modelRoot)) {
          return;
        }
        const markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));
        this._addConsumablesForSelection(conversionApi.consumable, selection, markersAtSelection);
        this.fire("selection", {
          selection
        }, conversionApi);
        if (!selection.isCollapsed) {
          return;
        }
        for (const marker of markersAtSelection) {
          if (conversionApi.consumable.test(selection, "addMarker:" + marker.name)) {
            const markerRange = marker.getRange();
            if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, conversionApi.mapper)) {
              continue;
            }
            const data = {
              item: selection,
              markerName: marker.name,
              markerRange
            };
            this.fire(`addMarker:${marker.name}`, data, conversionApi);
          }
        }
        for (const key of selection.getAttributeKeys()) {
          if (conversionApi.consumable.test(selection, "attribute:" + key)) {
            const data = {
              item: selection,
              range: selection.getFirstRange(),
              attributeKey: key,
              attributeOldValue: null,
              attributeNewValue: selection.getAttribute(key)
            };
            this.fire(`attribute:${key}:$text`, data, conversionApi);
          }
        }
      }
      /**
      * Fires insertion conversion of a range of nodes.
      *
      * For each node in the range, {@link #event:insert `insert` event is fired}. For each attribute on each node,
      * {@link #event:attribute `attribute` event is fired}.
      *
      * @fires insert
      * @fires attribute
      * @param range The inserted range.
      * @param conversionApi The conversion API object.
      * @param options.doNotAddConsumables Whether the ModelConsumable should not get populated
      * for items in the provided range.
      */
      _convertInsert(range, conversionApi, options = {}) {
        if (!options.doNotAddConsumables) {
          this._addConsumablesForInsert(conversionApi.consumable, range);
        }
        for (const data of Array.from(range.getWalker({
          shallow: true
        })).map(walkerValueToEventData)) {
          this._testAndFire("insert", data, conversionApi);
        }
      }
      /**
      * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
      *
      * @param position Position from which node was removed.
      * @param length Offset size of removed node.
      * @param name Name of removed node.
      * @param conversionApi The conversion API object.
      */
      _convertRemove(position, length, name, conversionApi) {
        this.fire(`remove:${name}`, {
          position,
          length
        }, conversionApi);
      }
      /**
      * Starts a conversion of an attribute change on a given `range`.
      *
      * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
      *
      * @fires attribute
      * @param range Changed range.
      * @param key Key of the attribute that has changed.
      * @param oldValue Attribute value before the change or `null` if the attribute has not been set before.
      * @param newValue New attribute value or `null` if the attribute has been removed.
      * @param conversionApi The conversion API object.
      */
      _convertAttribute(range, key, oldValue, newValue, conversionApi) {
        this._addConsumablesForRange(conversionApi.consumable, range, `attribute:${key}`);
        for (const value of range) {
          const data = {
            item: value.item,
            range: Range._createFromPositionAndShift(value.previousPosition, value.length),
            attributeKey: key,
            attributeOldValue: oldValue,
            attributeNewValue: newValue
          };
          this._testAndFire(`attribute:${key}`, data, conversionApi);
        }
      }
      /**
      * Fires re-insertion conversion (with a `reconversion` flag passed to `insert` events)
      * of a range of elements (only elements on the range depth, without children).
      *
      * For each node in the range on its depth (without children), {@link #event:insert `insert` event} is fired.
      * For each attribute on each node, {@link #event:attribute `attribute` event} is fired.
      *
      * @fires insert
      * @fires attribute
      * @param range The range to reinsert.
      * @param conversionApi The conversion API object.
      */
      _convertReinsert(range, conversionApi) {
        const walkerValues = Array.from(range.getWalker({
          shallow: true
        }));
        this._addConsumablesForInsert(conversionApi.consumable, walkerValues);
        for (const data of walkerValues.map(walkerValueToEventData)) {
          this._testAndFire("insert", {
            ...data,
            reconversion: true
          }, conversionApi);
        }
      }
      /**
      * Converts the added marker. Fires the {@link #event:addMarker `addMarker`} event for each item
      * in the marker's range. If the range is collapsed, a single event is dispatched. See the event description for more details.
      *
      * @fires addMarker
      * @param markerName Marker name.
      * @param markerRange The marker range.
      * @param conversionApi The conversion API object.
      */
      _convertMarkerAdd(markerName, markerRange, conversionApi) {
        if (markerRange.root.rootName == "$graveyard") {
          return;
        }
        const eventName = `addMarker:${markerName}`;
        conversionApi.consumable.add(markerRange, eventName);
        this.fire(eventName, {
          markerName,
          markerRange
        }, conversionApi);
        if (!conversionApi.consumable.consume(markerRange, eventName)) {
          return;
        }
        this._addConsumablesForRange(conversionApi.consumable, markerRange, eventName);
        for (const item of markerRange.getItems()) {
          if (!conversionApi.consumable.test(item, eventName)) {
            continue;
          }
          const data = {
            item,
            range: Range._createOn(item),
            markerName,
            markerRange
          };
          this.fire(eventName, data, conversionApi);
        }
      }
      /**
      * Fires the conversion of the marker removal. Fires the {@link #event:removeMarker `removeMarker`} event with the provided data.
      *
      * @fires removeMarker
      * @param markerName Marker name.
      * @param markerRange The marker range.
      * @param conversionApi The conversion API object.
      */
      _convertMarkerRemove(markerName, markerRange, conversionApi) {
        if (markerRange.root.rootName == "$graveyard") {
          return;
        }
        this.fire(`removeMarker:${markerName}`, {
          markerName,
          markerRange
        }, conversionApi);
      }
      /**
      * Fires the reduction of changes buffered in the {@link module:engine/model/differ~Differ `Differ`}.
      *
      * Features can replace selected {@link module:engine/model/differ~DiffItem `DiffItem`}s with `reinsert` entries to trigger
      * reconversion. The {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToStructure
      * `DowncastHelpers.elementToStructure()`} is using this event to trigger reconversion.
      *
      * @fires reduceChanges
      */
      _reduceChanges(changes) {
        const data = {
          changes
        };
        this.fire("reduceChanges", data);
        return data.changes;
      }
      /**
      * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from a given range,
      * assuming that the range has just been inserted to the model.
      *
      * @param consumable The consumable.
      * @param walkerValues The walker values for the inserted range.
      * @returns The values to consume.
      */
      _addConsumablesForInsert(consumable, walkerValues) {
        for (const value of walkerValues) {
          const item = value.item;
          if (consumable.test(item, "insert") === null) {
            consumable.add(item, "insert");
            for (const key of item.getAttributeKeys()) {
              consumable.add(item, "attribute:" + key);
            }
          }
        }
        return consumable;
      }
      /**
      * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for a given range.
      *
      * @param consumable The consumable.
      * @param range The affected range.
      * @param type Consumable type.
      * @returns The values to consume.
      */
      _addConsumablesForRange(consumable, range, type) {
        for (const item of range.getItems()) {
          consumable.add(item, type);
        }
        return consumable;
      }
      /**
      * Populates provided {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
      *
      * @param consumable The consumable.
      * @param selection The selection to create the consumable from.
      * @param markers Markers that contain the selection.
      * @returns The values to consume.
      */
      _addConsumablesForSelection(consumable, selection, markers) {
        consumable.add(selection, "selection");
        for (const marker of markers) {
          consumable.add(selection, "addMarker:" + marker.name);
        }
        for (const key of selection.getAttributeKeys()) {
          consumable.add(selection, "attribute:" + key);
        }
        return consumable;
      }
      /**
      * Tests whether given event wasn't already fired and if so, fires it.
      *
      * @fires insert
      * @fires attribute
      * @param type Event type.
      * @param data Event data.
      * @param conversionApi The conversion API object.
      */
      _testAndFire(type, data, conversionApi) {
        const eventName = getEventName(type, data);
        const itemKey = data.item.is("$textProxy") ? conversionApi.consumable._getSymbolForTextProxy(data.item) : data.item;
        const eventsFiredForConversion = this._firedEventsMap.get(conversionApi);
        const eventsFiredForItem = eventsFiredForConversion.get(itemKey);
        if (!eventsFiredForItem) {
          eventsFiredForConversion.set(itemKey, /* @__PURE__ */ new Set([
            eventName
          ]));
        } else if (!eventsFiredForItem.has(eventName)) {
          eventsFiredForItem.add(eventName);
        } else {
          return;
        }
        this.fire(eventName, data, conversionApi);
      }
      /**
      * Fires not already fired events for setting attributes on just inserted item.
      *
      * @param item The model item to convert attributes for.
      * @param conversionApi The conversion API object.
      */
      _testAndFireAddAttributes(item, conversionApi) {
        const data = {
          item,
          range: Range._createOn(item)
        };
        for (const key of data.item.getAttributeKeys()) {
          data.attributeKey = key;
          data.attributeOldValue = null;
          data.attributeNewValue = data.item.getAttribute(key);
          this._testAndFire(`attribute:${key}`, data, conversionApi);
        }
      }
      /**
      * Builds an instance of the {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi} from a template and a given
      * {@link module:engine/view/downcastwriter~DowncastWriter `DowncastWriter`} and options object.
      *
      * @param writer View writer that should be used to modify the view document.
      * @param refreshedItems A set of model elements that should not reuse their
      * previous view representations.
      * @param options Optional options passed to `convertionApi.options`.
      * @return The conversion API object.
      */
      _createConversionApi(writer, refreshedItems = /* @__PURE__ */ new Set(), options = {}) {
        const conversionApi = {
          ...this._conversionApi,
          consumable: new ModelConsumable(),
          writer,
          options,
          convertItem: (item) => this._convertInsert(Range._createOn(item), conversionApi),
          convertChildren: (element) => this._convertInsert(Range._createIn(element), conversionApi, {
            doNotAddConsumables: true
          }),
          convertAttributes: (item) => this._testAndFireAddAttributes(item, conversionApi),
          canReuseView: (viewElement) => !refreshedItems.has(conversionApi.mapper.toModelElement(viewElement))
        };
        this._firedEventsMap.set(conversionApi, /* @__PURE__ */ new Map());
        return conversionApi;
      }
    }
    function shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {
      const range = marker.getRange();
      const ancestors = Array.from(modelPosition.getAncestors());
      ancestors.shift();
      ancestors.reverse();
      const hasCustomHandling = ancestors.some((element) => {
        if (range.containsItem(element)) {
          const viewElement = mapper.toViewElement(element);
          return !!viewElement.getCustomProperty("addHighlight");
        }
      });
      return !hasCustomHandling;
    }
    function getEventName(type, data) {
      const name = data.item.is("element") ? data.item.name : "$text";
      return `${type}:${name}`;
    }
    function walkerValueToEventData(value) {
      const item = value.item;
      const itemRange = Range._createFromPositionAndShift(value.previousPosition, value.length);
      return {
        item,
        range: itemRange
      };
    }
    class Selection extends (/* @__PURE__ */ EmitterMixin(TypeCheckable)) {
      /**
      * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
      * or creates an empty selection if no arguments were passed.
      *
      * ```ts
      * // Creates empty selection without ranges.
      * const selection = writer.createSelection();
      *
      * // Creates selection at the given range.
      * const range = writer.createRange( start, end );
      * const selection = writer.createSelection( range );
      *
      * // Creates selection at the given ranges
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * const selection = writer.createSelection( ranges );
      *
      * // Creates selection from the other selection.
      * // Note: It doesn't copy selection attributes.
      * const otherSelection = writer.createSelection();
      * const selection = writer.createSelection( otherSelection );
      *
      * // Creates selection from the given document selection.
      * // Note: It doesn't copy selection attributes.
      * const documentSelection = model.document.selection;
      * const selection = writer.createSelection( documentSelection );
      *
      * // Creates selection at the given position.
      * const position = writer.createPositionFromPath( root, path );
      * const selection = writer.createSelection( position );
      *
      * // Creates selection at the given offset in the given element.
      * const paragraph = writer.createElement( 'paragraph' );
      * const selection = writer.createSelection( paragraph, offset );
      *
      * // Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
      * // first child of that element and ends after the last child of that element.
      * const selection = writer.createSelection( paragraph, 'in' );
      *
      * // Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
      * // just after the item.
      * const selection = writer.createSelection( paragraph, 'on' );
      * ```
      *
      * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
      *
      * ```ts
      * // Creates backward selection.
      * const selection = writer.createSelection( range, { backward: true } );
      * ```
      *
      * @internal
      */
      constructor(...args) {
        super();
        /**
        * Specifies whether the last added range was added as a backward or forward range.
        */
        __publicField(this, "_lastRangeBackward", false);
        /**
        * List of attributes set on current selection.
        */
        __publicField(this, "_attrs", /* @__PURE__ */ new Map());
        /** @internal */
        __publicField(this, "_ranges", []);
        if (args.length) {
          this.setTo(...args);
        }
      }
      /**
      * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
      * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
      *
      * Anchor and {@link #focus} define the direction of the selection, which is important
      * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
      *
      * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
      * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
      * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
      *
      * May be set to `null` if there are no ranges in the selection.
      *
      * @see #focus
      */
      get anchor() {
        if (this._ranges.length > 0) {
          const range = this._ranges[this._ranges.length - 1];
          return this._lastRangeBackward ? range.end : range.start;
        }
        return null;
      }
      /**
      * Selection focus. Focus is the position where the selection ends. If a user is making a selection
      * by dragging the mouse, the focus is where the mouse cursor is.
      *
      * May be set to `null` if there are no ranges in the selection.
      *
      * @see #anchor
      */
      get focus() {
        if (this._ranges.length > 0) {
          const range = this._ranges[this._ranges.length - 1];
          return this._lastRangeBackward ? range.start : range.end;
        }
        return null;
      }
      /**
      * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
      * and it is collapsed.
      */
      get isCollapsed() {
        const length = this._ranges.length;
        if (length === 1) {
          return this._ranges[0].isCollapsed;
        } else {
          return false;
        }
      }
      /**
      * Returns the number of ranges in the selection.
      */
      get rangeCount() {
        return this._ranges.length;
      }
      /**
      * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
      */
      get isBackward() {
        return !this.isCollapsed && this._lastRangeBackward;
      }
      /**
      * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
      * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
      *
      * @param otherSelection Selection to compare with.
      * @returns `true` if selections are equal, `false` otherwise.
      */
      isEqual(otherSelection) {
        if (this.rangeCount != otherSelection.rangeCount) {
          return false;
        } else if (this.rangeCount === 0) {
          return true;
        }
        if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
          return false;
        }
        for (const thisRange of this._ranges) {
          let found = false;
          for (const otherRange of otherSelection._ranges) {
            if (thisRange.isEqual(otherRange)) {
              found = true;
              break;
            }
          }
          if (!found) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns an iterable object that iterates over copies of selection ranges.
      */
      *getRanges() {
        for (const range of this._ranges) {
          yield new Range(range.start, range.end);
        }
      }
      /**
      * Returns a copy of the first range in the selection.
      * First range is the one which {@link module:engine/model/range~Range#start start} position
      * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
      * (not to confuse with the first range added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstRange() {
        let first2 = null;
        for (const range of this._ranges) {
          if (!first2 || range.start.isBefore(first2.start)) {
            first2 = range;
          }
        }
        return first2 ? new Range(first2.start, first2.end) : null;
      }
      /**
      * Returns a copy of the last range in the selection.
      * Last range is the one which {@link module:engine/model/range~Range#end end} position
      * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
      * recently added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastRange() {
        let last2 = null;
        for (const range of this._ranges) {
          if (!last2 || range.end.isAfter(last2.end)) {
            last2 = range;
          }
        }
        return last2 ? new Range(last2.start, last2.end) : null;
      }
      /**
      * Returns the first position in the selection.
      * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstPosition() {
        const first2 = this.getFirstRange();
        return first2 ? first2.start.clone() : null;
      }
      /**
      * Returns the last position in the selection.
      * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastPosition() {
        const lastRange = this.getLastRange();
        return lastRange ? lastRange.end.clone() : null;
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/model/selection~Selectable selectable}.
      *
      * ```ts
      * // Removes all selection's ranges.
      * selection.setTo( null );
      *
      * // Sets selection to the given range.
      * const range = writer.createRange( start, end );
      * selection.setTo( range );
      *
      * // Sets selection to given ranges.
      * const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
      * selection.setTo( ranges );
      *
      * // Sets selection to other selection.
      * // Note: It doesn't copy selection attributes.
      * const otherSelection = writer.createSelection();
      * selection.setTo( otherSelection );
      *
      * // Sets selection to the given document selection.
      * // Note: It doesn't copy selection attributes.
      * const documentSelection = new DocumentSelection( doc );
      * selection.setTo( documentSelection );
      *
      * // Sets collapsed selection at the given position.
      * const position = writer.createPositionFromPath( root, path );
      * selection.setTo( position );
      *
      * // Sets collapsed selection at the position of the given node and an offset.
      * selection.setTo( paragraph, offset );
      * ```
      *
      * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
       * that element and ends after the last child of that element.
      *
      * ```ts
      * selection.setTo( paragraph, 'in' );
      * ```
      *
      * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
      *
      * ```ts
      * selection.setTo( paragraph, 'on' );
      * ```
      *
      * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
      *
      * ```ts
      * // Sets backward selection.
      * const selection = writer.createSelection( range, { backward: true } );
      * ```
      */
      setTo(...args) {
        let [selectable, placeOrOffset, options] = args;
        if (typeof placeOrOffset == "object") {
          options = placeOrOffset;
          placeOrOffset = void 0;
        }
        if (selectable === null) {
          this._setRanges([]);
        } else if (selectable instanceof Selection) {
          this._setRanges(selectable.getRanges(), selectable.isBackward);
        } else if (selectable && typeof selectable.getRanges == "function") {
          this._setRanges(selectable.getRanges(), selectable.isBackward);
        } else if (selectable instanceof Range) {
          this._setRanges([
            selectable
          ], !!options && !!options.backward);
        } else if (selectable instanceof Position) {
          this._setRanges([
            new Range(selectable)
          ]);
        } else if (selectable instanceof Node$1) {
          const backward = !!options && !!options.backward;
          let range;
          if (placeOrOffset == "in") {
            range = Range._createIn(selectable);
          } else if (placeOrOffset == "on") {
            range = Range._createOn(selectable);
          } else if (placeOrOffset !== void 0) {
            range = new Range(Position._createAt(selectable, placeOrOffset));
          } else {
            throw new CKEditorError("model-selection-setto-required-second-parameter", [
              this,
              selectable
            ]);
          }
          this._setRanges([
            range
          ], backward);
        } else if (isIterable(selectable)) {
          this._setRanges(selectable, options && !!options.backward);
        } else {
          throw new CKEditorError("model-selection-setto-not-selectable", [
            this,
            selectable
          ]);
        }
      }
      /**
      * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
      * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
      * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
      *
      * @fires change:range
      * @param newRanges Ranges to set.
      * @param isLastBackward Flag describing if last added range was selected forward - from start to end (`false`)
      * or backward - from end to start (`true`).
      */
      _setRanges(newRanges, isLastBackward = false) {
        const ranges = Array.from(newRanges);
        const anyNewRange = ranges.some((newRange) => {
          if (!(newRange instanceof Range)) {
            throw new CKEditorError("model-selection-set-ranges-not-range", [
              this,
              newRanges
            ]);
          }
          return this._ranges.every((oldRange) => {
            return !oldRange.isEqual(newRange);
          });
        });
        if (ranges.length === this._ranges.length && !anyNewRange) {
          return;
        }
        this._replaceAllRanges(ranges);
        this._lastRangeBackward = !!isLastBackward;
        this.fire("change:range", {
          directChange: true
        });
      }
      /**
      * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
      *
      * The location can be specified in the same form as
      * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
      *
      * @fires change:range
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      setFocus(itemOrPosition, offset) {
        if (this.anchor === null) {
          throw new CKEditorError("model-selection-setfocus-no-ranges", [
            this,
            itemOrPosition
          ]);
        }
        const newFocus = Position._createAt(itemOrPosition, offset);
        if (newFocus.compareWith(this.focus) == "same") {
          return;
        }
        const anchor = this.anchor;
        if (this._ranges.length) {
          this._popRange();
        }
        if (newFocus.compareWith(anchor) == "before") {
          this._pushRange(new Range(newFocus, anchor));
          this._lastRangeBackward = true;
        } else {
          this._pushRange(new Range(anchor, newFocus));
          this._lastRangeBackward = false;
        }
        this.fire("change:range", {
          directChange: true
        });
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this._attrs.get(key);
      }
      /**
      * Returns iterable that iterates over this selection's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this._attrs.entries();
      }
      /**
      * Returns iterable that iterates over this selection's attribute keys.
      */
      getAttributeKeys() {
        return this._attrs.keys();
      }
      /**
      * Checks if the selection has an attribute for given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on selection, `false` otherwise.
      */
      hasAttribute(key) {
        return this._attrs.has(key);
      }
      /**
      * Removes an attribute with given key from the selection.
      *
      * If given attribute was set on the selection, fires the {@link #event:change:range} event with
      * removed attribute key.
      *
      * @fires change:attribute
      * @param key Key of attribute to remove.
      */
      removeAttribute(key) {
        if (this.hasAttribute(key)) {
          this._attrs.delete(key);
          this.fire("change:attribute", {
            attributeKeys: [
              key
            ],
            directChange: true
          });
        }
      }
      /**
      * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
      *
      * If the attribute value has changed, fires the {@link #event:change:range} event with
      * the attribute key.
      *
      * @fires change:attribute
      * @param key Key of attribute to set.
      * @param value Attribute value.
      */
      setAttribute(key, value) {
        if (this.getAttribute(key) !== value) {
          this._attrs.set(key, value);
          this.fire("change:attribute", {
            attributeKeys: [
              key
            ],
            directChange: true
          });
        }
      }
      /**
      * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        if (this.rangeCount !== 1) {
          return null;
        }
        return this.getFirstRange().getContainedElement();
      }
      /**
      * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
      *
      * This method's result can be used for example to apply block styling to all blocks covered by this selection.
      *
      * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
      * but will not return blocks nested in other blocks.
      *
      * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
      *
      * ```xml
      * <paragraph>[a</paragraph>
      * <blockQuote>
      * 	<paragraph>b</paragraph>
      * </blockQuote>
      * <paragraph>c]d</paragraph>
      * ```
      *
      * In this case the paragraph will also be returned, despite the collapsed selection:
      *
      * ```xml
      * <paragraph>[]a</paragraph>
      * ```
      *
      * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
      *
      * ```xml
      * [<blockA></blockA>
      * <blockB>
      * 	<blockC></blockC>
      * 	<blockD></blockD>
      * </blockB>
      * <blockE></blockE>]
      * ```
      *
      * If the selection is inside a block all the inner blocks (A & B) are returned:
      *
      * ```xml
      * <block>
      * 	<blockA>[a</blockA>
      * 	<blockB>b]</blockB>
      * </block>
      * ```
      *
      * **Special case**: Selection ignores first and/or last blocks if nothing (from user perspective) is selected in them.
      *
      * ```xml
      * // Selection ends and the beginning of the last block.
      * <paragraph>[a</paragraph>
      * <paragraph>b</paragraph>
      * <paragraph>]c</paragraph> // This block will not be returned
      *
      * // Selection begins at the end of the first block.
      * <paragraph>a[</paragraph> // This block will not be returned
      * <paragraph>b</paragraph>
      * <paragraph>c]</paragraph>
      *
      * // Selection begings at the end of the first block and ends at the beginning of the last block.
      * <paragraph>a[</paragraph> // This block will not be returned
      * <paragraph>b</paragraph>
      * <paragraph>]c</paragraph> // This block will not be returned
      * ```
      */
      *getSelectedBlocks() {
        const visited = /* @__PURE__ */ new WeakSet();
        for (const range of this.getRanges()) {
          const startBlock = getParentBlock$1(range.start, visited);
          if (isStartBlockSelected(startBlock, range)) {
            yield startBlock;
          }
          for (const value of range.getWalker()) {
            const block2 = value.item;
            if (value.type == "elementEnd" && isUnvisitedTopBlock(block2, visited, range)) {
              yield block2;
            }
          }
          const endBlock = getParentBlock$1(range.end, visited);
          if (isEndBlockSelected(endBlock, range)) {
            yield endBlock;
          }
        }
      }
      /**
      * Checks whether the selection contains the entire content of the given element. This means that selection must start
      * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
      * touching the element's end.
      *
      * By default, this method will check whether the entire content of the selection's current root is selected.
      * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
      */
      containsEntireContent(element = this.anchor.root) {
        const limitStartPosition = Position._createAt(element, 0);
        const limitEndPosition = Position._createAt(element, "end");
        return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());
      }
      /**
      * Adds given range to internal {@link #_ranges ranges array}. Throws an error
      * if given range is intersecting with any range that is already stored in this selection.
      */
      _pushRange(range) {
        this._checkRange(range);
        this._ranges.push(new Range(range.start, range.end));
      }
      /**
      * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
      */
      _checkRange(range) {
        for (let i = 0; i < this._ranges.length; i++) {
          if (range.isIntersecting(this._ranges[i])) {
            throw new CKEditorError("model-selection-range-intersects", [
              this,
              range
            ], {
              addedRange: range,
              intersectingRange: this._ranges[i]
            });
          }
        }
      }
      /**
      * Replaces all the ranges by the given ones.
      * Uses {@link #_popRange _popRange} and {@link #_pushRange _pushRange} to ensure proper ranges removal and addition.
      */
      _replaceAllRanges(ranges) {
        this._removeAllRanges();
        for (const range of ranges) {
          this._pushRange(range);
        }
      }
      /**
      * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
      * ensure proper ranges removal.
      */
      _removeAllRanges() {
        while (this._ranges.length > 0) {
          this._popRange();
        }
      }
      /**
      * Removes most recently added range from the selection.
      */
      _popRange() {
        this._ranges.pop();
      }
    }
    Selection.prototype.is = function(type) {
      return type === "selection" || type === "model:selection";
    };
    function isUnvisitedBlock(element, visited) {
      if (visited.has(element)) {
        return false;
      }
      visited.add(element);
      return element.root.document.model.schema.isBlock(element) && !!element.parent;
    }
    function isUnvisitedTopBlock(element, visited, range) {
      return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);
    }
    function getParentBlock$1(position, visited) {
      const element = position.parent;
      const schema = element.root.document.model.schema;
      const ancestors = position.parent.getAncestors({
        parentFirst: true,
        includeSelf: true
      });
      let hasParentLimit = false;
      const block2 = ancestors.find((element2) => {
        if (hasParentLimit) {
          return false;
        }
        hasParentLimit = schema.isLimit(element2);
        return !hasParentLimit && isUnvisitedBlock(element2, visited);
      });
      ancestors.forEach((element2) => visited.add(element2));
      return block2;
    }
    function isTopBlockInRange(block2, range) {
      const parentBlock = findAncestorBlock(block2);
      if (!parentBlock) {
        return true;
      }
      const isParentInRange = range.containsRange(Range._createOn(parentBlock), true);
      return !isParentInRange;
    }
    function isStartBlockSelected(startBlock, range) {
      if (!startBlock) {
        return false;
      }
      if (range.isCollapsed || startBlock.isEmpty) {
        return true;
      }
      if (range.start.isTouching(Position._createAt(startBlock, startBlock.maxOffset))) {
        return false;
      }
      return isTopBlockInRange(startBlock, range);
    }
    function isEndBlockSelected(endBlock, range) {
      if (!endBlock) {
        return false;
      }
      if (range.isCollapsed || endBlock.isEmpty) {
        return true;
      }
      if (range.end.isTouching(Position._createAt(endBlock, 0))) {
        return false;
      }
      return isTopBlockInRange(endBlock, range);
    }
    function findAncestorBlock(node) {
      const schema = node.root.document.model.schema;
      let parent2 = node.parent;
      while (parent2) {
        if (schema.isBlock(parent2)) {
          return parent2;
        }
        parent2 = parent2.parent;
      }
    }
    class LiveRange extends (/* @__PURE__ */ EmitterMixin(Range)) {
      /**
      * Creates a live range.
      *
      * @see module:engine/model/range~Range
      */
      constructor(start, end) {
        super(start, end);
        bindWithDocument$1.call(this);
      }
      /**
      * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
      * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
      * referring to it).
      */
      detach() {
        this.stopListening();
      }
      /**
      * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
      */
      toRange() {
        return new Range(this.start, this.end);
      }
      /**
      * Creates a `LiveRange` instance that is equal to the given range.
      */
      static fromRange(range) {
        return new LiveRange(range.start, range.end);
      }
    }
    LiveRange.prototype.is = function(type) {
      return type === "liveRange" || type === "model:liveRange" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type == "range" || type === "model:range";
    };
    function bindWithDocument$1() {
      this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
        const operation = args[0];
        if (!operation.isDocumentOperation) {
          return;
        }
        transform$2.call(this, operation);
      }, {
        priority: "low"
      });
    }
    function transform$2(operation) {
      const ranges = this.getTransformedByOperation(operation);
      const result = Range._createFromRanges(ranges);
      const boundariesChanged = !result.isEqual(this);
      const contentChanged = doesOperationChangeRangeContent(this, operation);
      let deletionPosition = null;
      if (boundariesChanged) {
        if (result.root.rootName == "$graveyard") {
          if (operation.type == "remove") {
            deletionPosition = operation.sourcePosition;
          } else {
            deletionPosition = operation.deletionPosition;
          }
        }
        const oldRange = this.toRange();
        this.start = result.start;
        this.end = result.end;
        this.fire("change:range", oldRange, {
          deletionPosition
        });
      } else if (contentChanged) {
        this.fire("change:content", this.toRange(), {
          deletionPosition
        });
      }
    }
    function doesOperationChangeRangeContent(range, operation) {
      switch (operation.type) {
        case "insert":
          return range.containsPosition(operation.position);
        case "move":
        case "remove":
        case "reinsert":
        case "merge":
          return range.containsPosition(operation.sourcePosition) || range.start.isEqual(operation.sourcePosition) || range.containsPosition(operation.targetPosition);
        case "split":
          return range.containsPosition(operation.splitPosition) || range.containsPosition(operation.insertionPosition);
      }
      return false;
    }
    const storePrefix = "selection:";
    class DocumentSelection extends (/* @__PURE__ */ EmitterMixin(TypeCheckable)) {
      /**
      * Creates an empty live selection for given {@link module:engine/model/document~Document}.
      *
      * @param doc Document which owns this selection.
      */
      constructor(doc) {
        super();
        /**
        * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).
        */
        __publicField(this, "_selection");
        this._selection = new LiveSelection(doc);
        this._selection.delegate("change:range").to(this);
        this._selection.delegate("change:attribute").to(this);
        this._selection.delegate("change:marker").to(this);
      }
      /**
      * Describes whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
      * collapsed.
      */
      get isCollapsed() {
        return this._selection.isCollapsed;
      }
      /**
      * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
      * Together with {@link #focus} they define the direction of selection, which is important
      * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
      * {@link module:engine/model/range~Range#end end} position of the most recently added range.
      *
      * Is set to `null` if there are no ranges in selection.
      *
      * @see #focus
      */
      get anchor() {
        return this._selection.anchor;
      }
      /**
      * Selection focus. Focus is a position where the selection ends.
      *
      * Is set to `null` if there are no ranges in selection.
      *
      * @see #anchor
      */
      get focus() {
        return this._selection.focus;
      }
      /**
      * Number of ranges in selection.
      */
      get rangeCount() {
        return this._selection.rangeCount;
      }
      /**
      * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
      * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
      */
      get hasOwnRange() {
        return this._selection.hasOwnRange;
      }
      /**
      * Specifies whether the {@link #focus}
      * precedes {@link #anchor}.
      *
      * @readonly
      * @type {Boolean}
      */
      get isBackward() {
        return this._selection.isBackward;
      }
      /**
      * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
      *
      * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
      */
      get isGravityOverridden() {
        return this._selection.isGravityOverridden;
      }
      /**
      * A collection of selection {@link module:engine/model/markercollection~Marker markers}.
      * Marker is a selection marker when selection range is inside the marker range.
      *
      * **Note**: Only markers from {@link ~DocumentSelection#observeMarkers observed markers groups} are collected.
      */
      get markers() {
        return this._selection.markers;
      }
      /**
      * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
      *
      * @internal
      */
      get _ranges() {
        return this._selection._ranges;
      }
      /**
      * Returns an iterable that iterates over copies of selection ranges.
      */
      getRanges() {
        return this._selection.getRanges();
      }
      /**
      * Returns the first position in the selection.
      * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstPosition() {
        return this._selection.getFirstPosition();
      }
      /**
      * Returns the last position in the selection.
      * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
      * any other position in the selection.
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastPosition() {
        return this._selection.getLastPosition();
      }
      /**
      * Returns a copy of the first range in the selection.
      * First range is the one which {@link module:engine/model/range~Range#start start} position
      * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
      * (not to confuse with the first range added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getFirstRange() {
        return this._selection.getFirstRange();
      }
      /**
      * Returns a copy of the last range in the selection.
      * Last range is the one which {@link module:engine/model/range~Range#end end} position
      * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
      * recently added to the selection).
      *
      * Returns `null` if there are no ranges in selection.
      */
      getLastRange() {
        return this._selection.getLastRange();
      }
      /**
      * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
      *
      * This method's result can be used for example to apply block styling to all blocks covered by this selection.
      *
      * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
      * but will not return blocks nested in other blocks.
      *
      * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
      *
      * ```
      * <paragraph>[a</paragraph>
      * <blockQuote>
      * 	<paragraph>b</paragraph>
      * </blockQuote>
      * <paragraph>c]d</paragraph>
      * ```
      *
      * In this case the paragraph will also be returned, despite the collapsed selection:
      *
      * ```
      * <paragraph>[]a</paragraph>
      * ```
      *
      * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
      *
      * ```
      * [<blockA></blockA>
      * <blockB>
      * 	<blockC></blockC>
      * 	<blockD></blockD>
      * </blockB>
      * <blockE></blockE>]
      * ```
      *
      * If the selection is inside a block all the inner blocks (A & B) are returned:
      *
      * ```
      * <block>
      * 	<blockA>[a</blockA>
      * 	<blockB>b]</blockB>
      * </block>
      * ```
      *
      * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
      * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
      *
      * ```
      * <paragraph>[a</paragraph>
      * <paragraph>b</paragraph>
      * <paragraph>]c</paragraph> // this block will not be returned
      * ```
      */
      getSelectedBlocks() {
        return this._selection.getSelectedBlocks();
      }
      /**
      * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
      * one range in the selection, and that range contains exactly one element.
      * Returns `null` if there is no selected element.
      */
      getSelectedElement() {
        return this._selection.getSelectedElement();
      }
      /**
      * Checks whether the selection contains the entire content of the given element. This means that selection must start
      * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
      * touching the element's end.
      *
      * By default, this method will check whether the entire content of the selection's current root is selected.
      * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
      */
      containsEntireContent(element) {
        return this._selection.containsEntireContent(element);
      }
      /**
      * Unbinds all events previously bound by document selection.
      */
      destroy() {
        this._selection.destroy();
      }
      /**
      * Returns iterable that iterates over this selection's attribute keys.
      */
      getAttributeKeys() {
        return this._selection.getAttributeKeys();
      }
      /**
      * Returns iterable that iterates over this selection's attributes.
      *
      * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
      * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
      */
      getAttributes() {
        return this._selection.getAttributes();
      }
      /**
      * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
      *
      * @param key Key of attribute to look for.
      * @returns Attribute value or `undefined`.
      */
      getAttribute(key) {
        return this._selection.getAttribute(key);
      }
      /**
      * Checks if the selection has an attribute for given key.
      *
      * @param key Key of attribute to check.
      * @returns `true` if attribute with given key is set on selection, `false` otherwise.
      */
      hasAttribute(key) {
        return this._selection.hasAttribute(key);
      }
      /**
      * Refreshes selection attributes and markers according to the current position in the model.
      */
      refresh() {
        this._selection.updateMarkers();
        this._selection._updateAttributes(false);
      }
      /**
      * Registers a marker group prefix or a marker name to be collected in the
      * {@link ~DocumentSelection#markers selection markers collection}.
      *
      * See also {@link module:engine/model/markercollection~MarkerCollection#getMarkersGroup `MarkerCollection#getMarkersGroup()`}.
      *
      * @param prefixOrName The marker group prefix or marker name.
      */
      observeMarkers(prefixOrName) {
        this._selection.observeMarkers(prefixOrName);
      }
      /**
      * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
      * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
      *
      * The location can be specified in the same form as
      * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
      *
      * @see module:engine/model/writer~Writer#setSelectionFocus
      * @internal
      * @param offset Offset or one of the flags. Used only when
      * first parameter is a {@link module:engine/model/item~Item model item}.
      */
      _setFocus(itemOrPosition, offset) {
        this._selection.setFocus(itemOrPosition, offset);
      }
      /**
      * Sets this selection's ranges and direction to the specified location based on the given
      * {@link module:engine/model/selection~Selectable selectable}.
      * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
      *
      * @see module:engine/model/writer~Writer#setSelection
      * @internal
      */
      _setTo(...args) {
        this._selection.setTo(...args);
      }
      /**
      * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
      * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
      *
      * @see module:engine/model/writer~Writer#setSelectionAttribute
      * @internal
      * @param key Key of the attribute to set.
      * @param value Attribute value.
      */
      _setAttribute(key, value) {
        this._selection.setAttribute(key, value);
      }
      /**
      * Removes an attribute with given key from the selection.
      * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
      * event with removed attribute key.
      * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
      *
      * @see module:engine/model/writer~Writer#removeSelectionAttribute
      * @internal
      * @param key Key of the attribute to remove.
      */
      _removeAttribute(key) {
        this._selection.removeAttribute(key);
      }
      /**
      * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
      *
      * @internal
      */
      _getStoredAttributes() {
        return this._selection.getStoredAttributes();
      }
      /**
      * Temporarily changes the gravity of the selection from the left to the right.
      *
      * The gravity defines from which direction the selection inherits its attributes. If it's the default left
      * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
      * This method allows to temporarily override this behavior by forcing the gravity to the right.
      *
      * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
      * of the process.
      *
      * @see module:engine/model/writer~Writer#overrideSelectionGravity
      * @internal
      * @returns The unique id which allows restoring the gravity.
      */
      _overrideGravity() {
        return this._selection.overrideGravity();
      }
      /**
      * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
      *
      * Restoring the gravity is only possible using the unique identifier returned by
      * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
      * the same number of times it was overridden.
      *
      * @see module:engine/model/writer~Writer#restoreSelectionGravity
      * @internal
      * @param uid The unique id returned by {@link #_overrideGravity}.
      */
      _restoreGravity(uid2) {
        this._selection.restoreGravity(uid2);
      }
      /**
      * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
      *
      * @internal
      * @param key Attribute key to convert.
      * @returns Converted attribute key, applicable for selection store.
      */
      static _getStoreAttributeKey(key) {
        return storePrefix + key;
      }
      /**
      * Checks whether the given attribute key is an attribute stored on an element.
      *
      * @internal
      */
      static _isStoreAttributeKey(key) {
        return key.startsWith(storePrefix);
      }
    }
    DocumentSelection.prototype.is = function(type) {
      return type === "selection" || type == "model:selection" || type == "documentSelection" || type == "model:documentSelection";
    };
    class LiveSelection extends Selection {
      /**
      * Creates an empty live selection for given {@link module:engine/model/document~Document}.
      *
      * @param doc Document which owns this selection.
      */
      constructor(doc) {
        super();
        /**
        * List of selection markers.
        * Marker is a selection marker when selection range is inside the marker range.
        */
        __publicField(this, "markers", new Collection({
          idProperty: "name"
        }));
        /**
        * Document which owns this selection.
        */
        __publicField(this, "_model");
        /**
        * Document which owns this selection.
        */
        __publicField(this, "_document");
        /**
        * Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)
        * last time. Possible values of priority are: `'low'` and `'normal'`.
        *
        * Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`
        * attributes API are set with `'normal'` priority.
        */
        __publicField(this, "_attributePriority", /* @__PURE__ */ new Map());
        /**
        * Position to which the selection should be set if the last selection range was moved to the graveyard.
        */
        __publicField(this, "_selectionRestorePosition", null);
        /**
        * Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.
        */
        __publicField(this, "_hasChangedRange", false);
        /**
        * Each overriding gravity adds an UID to the set and each removal removes it.
        * Gravity is overridden when there's at least one UID in the set.
        * Gravity is restored when the set is empty.
        * This is to prevent conflicts when gravity is overridden by more than one feature at the same time.
        */
        __publicField(this, "_overriddenGravityRegister", /* @__PURE__ */ new Set());
        /**
        * Prefixes of marker names that should affect `LiveSelection#markers` collection.
        */
        __publicField(this, "_observedMarkers", /* @__PURE__ */ new Set());
        this._model = doc.model;
        this._document = doc;
        this.listenTo(this._model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (!operation.isDocumentOperation || operation.type == "marker" || operation.type == "rename" || operation.type == "noop") {
            return;
          }
          if (this._ranges.length == 0 && this._selectionRestorePosition) {
            this._fixGraveyardSelection(this._selectionRestorePosition);
          }
          this._selectionRestorePosition = null;
          if (this._hasChangedRange) {
            this._hasChangedRange = false;
            this.fire("change:range", {
              directChange: false
            });
          }
        }, {
          priority: "lowest"
        });
        this.on("change:range", () => {
          this._validateSelectionRanges(this.getRanges());
        });
        this.listenTo(this._model.markers, "update", (evt, marker, oldRange, newRange) => {
          this._updateMarker(marker, newRange);
        });
        this.listenTo(this._document, "change", (evt, batch) => {
          clearAttributesStoredInElement(this._model, batch);
        });
      }
      get isCollapsed() {
        const length = this._ranges.length;
        return length === 0 ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
      }
      get anchor() {
        return super.anchor || this._document._getDefaultRange().start;
      }
      get focus() {
        return super.focus || this._document._getDefaultRange().end;
      }
      get rangeCount() {
        return this._ranges.length ? this._ranges.length : 1;
      }
      /**
      * Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
      * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
      */
      get hasOwnRange() {
        return this._ranges.length > 0;
      }
      /**
      * When set to `true` then selection attributes on node before the caret won't be taken
      * into consideration while updating selection attributes.
      */
      get isGravityOverridden() {
        return !!this._overriddenGravityRegister.size;
      }
      /**
      * Unbinds all events previously bound by live selection.
      */
      destroy() {
        for (let i = 0; i < this._ranges.length; i++) {
          this._ranges[i].detach();
        }
        this.stopListening();
      }
      *getRanges() {
        if (this._ranges.length) {
          yield* super.getRanges();
        } else {
          yield this._document._getDefaultRange();
        }
      }
      getFirstRange() {
        return super.getFirstRange() || this._document._getDefaultRange();
      }
      getLastRange() {
        return super.getLastRange() || this._document._getDefaultRange();
      }
      setTo(...args) {
        super.setTo(...args);
        this._updateAttributes(true);
        this.updateMarkers();
      }
      setFocus(itemOrPosition, offset) {
        super.setFocus(itemOrPosition, offset);
        this._updateAttributes(true);
        this.updateMarkers();
      }
      setAttribute(key, value) {
        if (this._setAttribute(key, value)) {
          const attributeKeys = [
            key
          ];
          this.fire("change:attribute", {
            attributeKeys,
            directChange: true
          });
        }
      }
      removeAttribute(key) {
        if (this._removeAttribute(key)) {
          const attributeKeys = [
            key
          ];
          this.fire("change:attribute", {
            attributeKeys,
            directChange: true
          });
        }
      }
      overrideGravity() {
        const overrideUid = uid();
        this._overriddenGravityRegister.add(overrideUid);
        if (this._overriddenGravityRegister.size === 1) {
          this._updateAttributes(true);
        }
        return overrideUid;
      }
      restoreGravity(uid2) {
        if (!this._overriddenGravityRegister.has(uid2)) {
          throw new CKEditorError("document-selection-gravity-wrong-restore", this, {
            uid: uid2
          });
        }
        this._overriddenGravityRegister.delete(uid2);
        if (!this.isGravityOverridden) {
          this._updateAttributes(true);
        }
      }
      observeMarkers(prefixOrName) {
        this._observedMarkers.add(prefixOrName);
        this.updateMarkers();
      }
      _replaceAllRanges(ranges) {
        this._validateSelectionRanges(ranges);
        super._replaceAllRanges(ranges);
      }
      _popRange() {
        this._ranges.pop().detach();
      }
      _pushRange(range) {
        const liveRange = this._prepareRange(range);
        if (liveRange) {
          this._ranges.push(liveRange);
        }
      }
      _validateSelectionRanges(ranges) {
        for (const range of ranges) {
          if (!this._document._validateSelectionRange(range)) {
            throw new CKEditorError("document-selection-wrong-position", this, {
              range
            });
          }
        }
      }
      /**
      * Prepares given range to be added to selection. Checks if it is correct,
      * converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
      * and sets listeners listening to the range's change event.
      */
      _prepareRange(range) {
        this._checkRange(range);
        if (range.root == this._document.graveyard) {
          return;
        }
        const liveRange = LiveRange.fromRange(range);
        liveRange.on("change:range", (evt, oldRange, data) => {
          this._hasChangedRange = true;
          if (liveRange.root == this._document.graveyard) {
            this._selectionRestorePosition = data.deletionPosition;
            const index2 = this._ranges.indexOf(liveRange);
            this._ranges.splice(index2, 1);
            liveRange.detach();
          }
        });
        return liveRange;
      }
      updateMarkers() {
        if (!this._observedMarkers.size) {
          return;
        }
        const markers = [];
        let changed = false;
        for (const marker of this._model.markers) {
          const markerGroup = marker.name.split(":", 1)[0];
          if (!this._observedMarkers.has(markerGroup)) {
            continue;
          }
          const markerRange = marker.getRange();
          for (const selectionRange of this.getRanges()) {
            if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
              markers.push(marker);
            }
          }
        }
        const oldMarkers = Array.from(this.markers);
        for (const marker of markers) {
          if (!this.markers.has(marker)) {
            this.markers.add(marker);
            changed = true;
          }
        }
        for (const marker of Array.from(this.markers)) {
          if (!markers.includes(marker)) {
            this.markers.remove(marker);
            changed = true;
          }
        }
        if (changed) {
          this.fire("change:marker", {
            oldMarkers,
            directChange: false
          });
        }
      }
      _updateMarker(marker, markerRange) {
        const markerGroup = marker.name.split(":", 1)[0];
        if (!this._observedMarkers.has(markerGroup)) {
          return;
        }
        let changed = false;
        const oldMarkers = Array.from(this.markers);
        const hasMarker = this.markers.has(marker);
        if (!markerRange) {
          if (hasMarker) {
            this.markers.remove(marker);
            changed = true;
          }
        } else {
          let contained = false;
          for (const selectionRange of this.getRanges()) {
            if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
              contained = true;
              break;
            }
          }
          if (contained && !hasMarker) {
            this.markers.add(marker);
            changed = true;
          } else if (!contained && hasMarker) {
            this.markers.remove(marker);
            changed = true;
          }
        }
        if (changed) {
          this.fire("change:marker", {
            oldMarkers,
            directChange: false
          });
        }
      }
      /**
      * Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
      */
      _updateAttributes(clearAll) {
        const newAttributes = toMap(this._getSurroundingAttributes());
        const oldAttributes = toMap(this.getAttributes());
        if (clearAll) {
          this._attributePriority = /* @__PURE__ */ new Map();
          this._attrs = /* @__PURE__ */ new Map();
        } else {
          for (const [key, priority] of this._attributePriority) {
            if (priority == "low") {
              this._attrs.delete(key);
              this._attributePriority.delete(key);
            }
          }
        }
        this._setAttributesTo(newAttributes);
        const changed = [];
        for (const [newKey, newValue] of this.getAttributes()) {
          if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
            changed.push(newKey);
          }
        }
        for (const [oldKey] of oldAttributes) {
          if (!this.hasAttribute(oldKey)) {
            changed.push(oldKey);
          }
        }
        if (changed.length > 0) {
          this.fire("change:attribute", {
            attributeKeys: changed,
            directChange: false
          });
        }
      }
      /**
      * Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
      * parameter).
      */
      _setAttribute(key, value, directChange = true) {
        const priority = directChange ? "normal" : "low";
        if (priority == "low" && this._attributePriority.get(key) == "normal") {
          return false;
        }
        const oldValue = super.getAttribute(key);
        if (oldValue === value) {
          return false;
        }
        this._attrs.set(key, value);
        this._attributePriority.set(key, priority);
        return true;
      }
      /**
      * Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
      * parameter).
      *
      * NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
      * be changed according to `directChange` parameter.
      */
      _removeAttribute(key, directChange = true) {
        const priority = directChange ? "normal" : "low";
        if (priority == "low" && this._attributePriority.get(key) == "normal") {
          return false;
        }
        this._attributePriority.set(key, priority);
        if (!super.hasAttribute(key)) {
          return false;
        }
        this._attrs.delete(key);
        return true;
      }
      /**
      * Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
      * `directChange` parameter).
      */
      _setAttributesTo(attrs) {
        const changed = /* @__PURE__ */ new Set();
        for (const [oldKey, oldValue] of this.getAttributes()) {
          if (attrs.get(oldKey) === oldValue) {
            continue;
          }
          this._removeAttribute(oldKey, false);
        }
        for (const [key, value] of attrs) {
          const gotAdded = this._setAttribute(key, value, false);
          if (gotAdded) {
            changed.add(key);
          }
        }
        return changed;
      }
      /**
      * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
      */
      *getStoredAttributes() {
        const selectionParent = this.getFirstPosition().parent;
        if (this.isCollapsed && selectionParent.isEmpty) {
          for (const key of selectionParent.getAttributeKeys()) {
            if (key.startsWith(storePrefix)) {
              const realKey = key.substr(storePrefix.length);
              yield [
                realKey,
                selectionParent.getAttribute(key)
              ];
            }
          }
        }
      }
      /**
      * Checks model text nodes that are closest to the selection's first position and returns attributes of first
      * found element. If there are no text nodes in selection's first position parent, it returns selection
      * attributes stored in that parent.
      */
      _getSurroundingAttributes() {
        const position = this.getFirstPosition();
        const schema = this._model.schema;
        if (position.root.rootName == "$graveyard") {
          return null;
        }
        let attrs = null;
        if (!this.isCollapsed) {
          const range = this.getFirstRange();
          for (const value of range) {
            if (value.item.is("element") && schema.isObject(value.item)) {
              attrs = getTextAttributes(value.item, schema);
              break;
            }
            if (value.type == "text") {
              attrs = value.item.getAttributes();
              break;
            }
          }
        } else {
          const nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
          const nodeAfter = position.textNode ? position.textNode : position.nodeAfter;
          if (!this.isGravityOverridden) {
            attrs = getTextAttributes(nodeBefore, schema);
          }
          if (!attrs) {
            attrs = getTextAttributes(nodeAfter, schema);
          }
          if (!this.isGravityOverridden && !attrs) {
            let node = nodeBefore;
            while (node && !attrs) {
              node = node.previousSibling;
              attrs = getTextAttributes(node, schema);
            }
          }
          if (!attrs) {
            let node = nodeAfter;
            while (node && !attrs) {
              node = node.nextSibling;
              attrs = getTextAttributes(node, schema);
            }
          }
          if (!attrs) {
            attrs = this.getStoredAttributes();
          }
        }
        return attrs;
      }
      /**
      * Fixes the selection after all its ranges got removed.
      * @param deletionPosition Position where the deletion happened.
      */
      _fixGraveyardSelection(deletionPosition) {
        const selectionRange = this._model.schema.getNearestSelectionRange(deletionPosition);
        if (selectionRange) {
          this._pushRange(selectionRange);
        }
      }
    }
    function getTextAttributes(node, schema) {
      if (!node) {
        return null;
      }
      if (node instanceof TextProxy || node instanceof Text) {
        return node.getAttributes();
      }
      if (!schema.isInline(node)) {
        return null;
      }
      if (!schema.isObject(node)) {
        return [];
      }
      const attributes = [];
      for (const [key, value] of node.getAttributes()) {
        if (schema.checkAttribute("$text", key) && schema.getAttributeProperties(key).copyFromObject !== false) {
          attributes.push([
            key,
            value
          ]);
        }
      }
      return attributes;
    }
    function clearAttributesStoredInElement(model, batch) {
      const differ = model.document.differ;
      for (const entry of differ.getChanges()) {
        if (entry.type != "insert") {
          continue;
        }
        const changeParent = entry.position.parent;
        const isNoLongerEmpty = entry.length === changeParent.maxOffset;
        if (isNoLongerEmpty) {
          model.enqueueChange(batch, (writer) => {
            const storedAttributes = Array.from(changeParent.getAttributeKeys()).filter((key) => key.startsWith(storePrefix));
            for (const key of storedAttributes) {
              writer.removeAttribute(key, changeParent);
            }
          });
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ConversionHelpers {
      /**
      * Creates a conversion helpers instance.
      */
      constructor(dispatchers) {
        __publicField(this, "_dispatchers");
        this._dispatchers = dispatchers;
      }
      /**
      * Registers a conversion helper.
      *
      * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
      * method description.
      *
      * @param conversionHelper The function to be called on event.
      */
      add(conversionHelper) {
        for (const dispatcher of this._dispatchers) {
          conversionHelper(dispatcher);
        }
        return this;
      }
    }
    class DowncastHelpers extends ConversionHelpers {
      /**
      * Model element to view element conversion helper.
      *
      * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'paragraph',
      * 	view: 'p'
      * } );
      *
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'paragraph',
      * 	view: 'div',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'fancyParagraph',
      * 	view: {
      * 		name: 'p',
      * 		classes: 'fancy'
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: 'heading',
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
      * 	}
      * } );
      * ```
      *
      * The element-to-element conversion supports the reconversion mechanism. It can be enabled by using either the `attributes` or
      * the `children` props on a model description. You will find a couple examples below.
      *
      * In order to reconvert an element if any of its direct children have been added or removed, use the `children` property on a `model`
      * description. For example, this model:
      *
      * ```xml
      * <box>
      * 	<paragraph>Some text.</paragraph>
      * </box>
      * ```
      *
      * will be converted into this structure in the view:
      *
      * ```html
      * <div class="box" data-type="single">
      * 	<p>Some text.</p>
      * </div>
      * ```
      *
      * But if more items were inserted in the model:
      *
      * ```xml
      * <box>
      * 	<paragraph>Some text.</paragraph>
      * 	<paragraph>Other item.</paragraph>
      * </box>
      * ```
      *
      * it will be converted into this structure in the view (note the element `data-type` change):
      *
      * ```html
      * <div class="box" data-type="multiple">
      * 	<p>Some text.</p>
      * 	<p>Other item.</p>
      * </div>
      * ```
      *
      * Such a converter would look like this (note that the `paragraph` elements are converted separately):
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: {
      * 		name: 'box',
      * 		children: true
      * 	},
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createContainerElement( 'div', {
      * 			class: 'box',
      * 			'data-type': modelElement.childCount == 1 ? 'single' : 'multiple'
      * 		} );
      * 	}
      * } );
      * ```
      *
      * In order to reconvert element if any of its attributes have been updated, use the `attributes` property on a `model`
      * description. For example, this model:
      *
      * ```xml
      * <heading level="2">Some text.</heading>
      * ```
      *
      * will be converted into this structure in the view:
      *
      * ```html
      * <h2>Some text.</h2>
      * ```
      *
      * But if the `heading` element's `level` attribute has been updated to `3` for example, then
      * it will be converted into this structure in the view:
      *
      * ```html
      * <h3>Some text.</h3>
      * ```
      *
      * Such a converter would look as follows:
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToElement( {
      * 	model: {
      * 		name: 'heading',
      * 		attributes: 'level'
      * 	},
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) );
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * You can read more about the element-to-element conversion in the
      * {@glink framework/deep-dive/conversion/downcast downcast conversion} guide.
      *
      * @param config Conversion configuration.
      * @param config.model The description or a name of the model element to convert.
      * @param config.model.attributes The list of attribute names that should be consumed while creating
      * the view element. Note that the view will be reconverted if any of the listed attributes changes.
       * @param config.model.children Specifies whether the view element requires reconversion if the list
      * of the model child nodes changed.
      * @param config.view A view element definition or a function that takes the model element and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as parameters and returns a view container element.
      */
      elementToElement(config) {
        return this.add(downcastElementToElement(config));
      }
      /**
      * The model element to view structure (several elements) conversion helper.
      *
      * This conversion results in creating a view structure with one or more slots defined for the child nodes.
      * For example, a model `<table>` may become this structure in the view:
      *
      * ```html
      * <figure class="table">
      * 	<table>
      * 		<tbody>${ slot for table rows }</tbody>
      * 	</table>
      * </figure>
      * ```
      *
      * The children of the model's `<table>` element will be inserted into the `<tbody>` element.
      * If the `elementToElement()` helper was used, the children would be inserted into the `<figure>`.
      *
      * Imagine a table feature where for this model structure:
      *
      * ```xml
      * <table headingRows="1">
      * 	<tableRow> ... table cells 1 ... </tableRow>
      * 	<tableRow> ... table cells 2 ... </tableRow>
      * 	<tableRow> ... table cells 3 ... </tableRow>
      * 	<caption>Caption text</caption>
      * </table>
      * ```
      *
      * we want to generate this view structure:
      *
      * ```html
      * <figure class="table">
      * 	<table>
      * 		<thead>
      * 			<tr> ... table cells 1 ... </tr>
      * 		</thead>
      * 		<tbody>
      * 			<tr> ... table cells 2 ... </tr>
      * 			<tr> ... table cells 3 ... </tr>
      * 		</tbody>
      * 	</table>
      * 	<figcaption>Caption text</figcaption>
      * </figure>
      * ```
      *
      * The converter has to take the `headingRows` attribute into consideration when allocating the `<tableRow>` elements
      * into the `<tbody>` and `<thead>` elements. Hence, we need two slots and need to define proper filter callbacks for them.
      *
      * Additionally, all elements other than `<tableRow>` should be placed outside the `<table>` tag.
      * In the example above, this will handle the table caption.
      *
      * Such a converter would look like this:
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).elementToStructure( {
      * 	model: {
      * 		name: 'table',
      * 		attributes: [ 'headingRows' ]
      * 	},
      * 	view: ( modelElement, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		const figureElement = writer.createContainerElement( 'figure', { class: 'table' } );
      * 		const tableElement = writer.createContainerElement( 'table' );
      *
      * 		writer.insert( writer.createPositionAt( figureElement, 0 ), tableElement );
      *
      * 		const headingRows = modelElement.getAttribute( 'headingRows' ) || 0;
      *
      * 		if ( headingRows > 0 ) {
      * 			const tableHead = writer.createContainerElement( 'thead' );
      *
      * 			const headSlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index < headingRows );
      *
      * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableHead );
      * 			writer.insert( writer.createPositionAt( tableHead, 0 ), headSlot );
      * 		}
      *
      * 		if ( headingRows < tableUtils.getRows( table ) ) {
      * 			const tableBody = writer.createContainerElement( 'tbody' );
      *
      * 			const bodySlot = writer.createSlot( node => node.is( 'element', 'tableRow' ) && node.index >= headingRows );
      *
      * 			writer.insert( writer.createPositionAt( tableElement, 'end' ), tableBody );
      * 			writer.insert( writer.createPositionAt( tableBody, 0 ), bodySlot );
      * 		}
      *
      * 		const restSlot = writer.createSlot( node => !node.is( 'element', 'tableRow' ) );
      *
      * 		writer.insert( writer.createPositionAt( figureElement, 'end' ), restSlot );
      *
      * 		return figureElement;
      * 	}
      * } );
      * ```
      *
      * Note: The children of a model element that's being converted must be allocated in the same order in the view
      * in which they are placed in the model.
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
       * @param config.model The description or a name of the model element to convert.
      * @param config.model.name The name of the model element to convert.
       * @param config.model.attributes The list of attribute names that should be consumed while creating
      * the view structure. Note that the view will be reconverted if any of the listed attributes will change.
      * @param config.view A function that takes the model element and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters
      * and returns a view container element with slots for model child nodes to be converted into.
      */
      elementToStructure(config) {
        return this.add(downcastElementToStructure(config));
      }
      /**
      * Model attribute to view element conversion helper.
      *
      * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
      * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'bold',
      * 	view: 'strong'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'bold',
      * 	view: 'b',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'invert',
      * 	view: {
      * 		name: 'span',
      * 		classes: [ 'font-light', 'bg-dark' ]
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: {
      * 		key: 'fontSize',
      * 		values: [ 'big', 'small' ]
      * 	},
      * 	view: {
      * 		big: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '1.2em'
      * 			}
      * 		},
      * 		small: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '0.8em'
      * 			}
      * 		}
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: 'bold',
      * 	view: ( modelAttributeValue, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createAttributeElement( 'span', {
      * 			style: 'font-weight:' + modelAttributeValue
      * 		} );
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToElement( {
      * 	model: {
      * 		key: 'color',
      * 		name: '$text'
      * 	},
      * 	view: ( modelAttributeValue, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createAttributeElement( 'span', {
      * 			style: 'color:' + modelAttributeValue
      * 		} );
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
      * of `String`s with possible values if the model attribute is an enumerable.
      * @param config.view A view element definition or a function
      * that takes the model attribute value and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as parameters and returns a view
      * attribute element. If `config.model.values` is given, `config.view` should be an object assigning values from `config.model.values`
      * to view element definitions or functions.
      * @param config.converterPriority Converter priority.
      */
      attributeToElement(config) {
        return this.add(downcastAttributeToElement(config));
      }
      /**
      * Model attribute to view attribute conversion helper.
      *
      * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
      * `<imageInline src='foo.jpg'></imageInline>` is converted to `<img src='foo.jpg'></img>`.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'source',
      * 	view: 'src'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'source',
      * 	view: 'href',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: {
      * 		name: 'imageInline',
      * 		key: 'source'
      * 	},
      * 	view: 'src'
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: {
      * 		name: 'styled',
      * 		values: [ 'dark', 'light' ]
      * 	},
      * 	view: {
      * 		dark: {
      * 			key: 'class',
      * 			value: [ 'styled', 'styled-dark' ]
      * 		},
      * 		light: {
      * 			key: 'class',
      * 			value: [ 'styled', 'styled-light' ]
      * 		}
      * 	}
      * } );
      *
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'styled',
      * 	view: modelAttributeValue => ( {
      * 		key: 'class',
      * 		value: 'styled-' + modelAttributeValue
      * 	} )
      * } );
      * ```
      *
      * **Note**: Downcasting to a style property requires providing `value` as an object:
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).attributeToAttribute( {
      * 	model: 'lineHeight',
      * 	view: modelAttributeValue => ( {
      * 		key: 'style',
      * 		value: {
      * 			'line-height': modelAttributeValue,
      * 			'border-bottom': '1px dotted #ba2'
      * 		}
      * 	} )
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
      * the attribute key, possible values and, optionally, an element name to convert from.
      * @param config.view A view attribute key, or a `{ key, value }` object or a function that takes the model attribute value and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as parameters and returns a `{ key, value }` object. If the `key` is `'class'`, the `value` can be a `String` or an
      * array of `String`s. If the `key` is `'style'`, the `value` is an object with key-value pairs. In other cases, `value` is a `String`.
      * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
      * `{ key, value }` objects or a functions.
      * @param config.converterPriority Converter priority.
      */
      attributeToAttribute(config) {
        return this.add(downcastAttributeToAttribute(config));
      }
      /**
      * Model marker to view element conversion helper.
      *
      * **Note**: This method should be used mainly for editing the downcast and it is recommended
      * to use the {@link #markerToData `#markerToData()`} helper instead.
      *
      * This helper may produce invalid HTML code (e.g. a span between table cells).
      * It should only be used when you are sure that the produced HTML will be semantically correct.
      *
      * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
      * is collapsed, only one element is created. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
      * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
      *
      * ```ts
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: 'marker-search'
      * } );
      *
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: 'search-result',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: {
      * 		name: 'span',
      * 		attributes: {
      * 			'data-marker': 'search'
      * 		}
      * 	}
      * } );
      *
      * editor.conversion.for( 'editingDowncast' ).markerToElement( {
      * 	model: 'search',
      * 	view: ( markerData, conversionApi ) => {
      * 		const { writer } = conversionApi;
      *
      * 		return writer.createUIElement( 'span', {
      * 			'data-marker': 'search',
      * 			'data-start': markerData.isOpening
      * 		} );
      * 	}
      * } );
      * ```
      *
      * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
      * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as a parameters and should return an instance of the
      * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
      * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
      * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` for
      * the marker end boundary element.
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The name of the model marker (or model marker group) to convert.
      * @param config.view A view element definition or a function that takes the model marker data and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
      * and returns a view UI element.
      * @param config.converterPriority Converter priority.
      */
      markerToElement(config) {
        return this.add(downcastMarkerToElement(config));
      }
      /**
      * Model marker to highlight conversion helper.
      *
      * This conversion results in creating a highlight on view nodes. For this kind of conversion,
      * the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
      *
      * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
      * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
      * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
      *
      * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
      * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
      * For example, a model marker set like this:
      * `[<imageInline src="foo.jpg"></imageInline>]` becomes `<img src="foo.jpg" class="comment"></img>` in the view.
      *
      * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
      * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
      * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
      *
      * ```ts
      * editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
      *
      * editor.conversion.for( 'downcast' ).markerToHighlight( {
      * 	model: 'comment',
      * 	view: { classes: 'comment' },
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'downcast' ).markerToHighlight( {
      * 	model: 'comment',
      * 	view: ( data, conversionApi ) => {
      * 		// Assuming that the marker name is in a form of comment:commentType:commentId.
      * 		const [ , commentType, commentId ] = data.markerName.split( ':' );
      *
      * 		return {
      * 			classes: [ 'comment', 'comment-' + commentType ],
      * 			attributes: { 'data-comment-id': commentId }
      * 		};
      * 	}
      * } );
      * ```
      *
      * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
      * receives the `data` object and {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API}
      * as the parameters and should return a
      * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
      * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The name of the model marker (or model marker group) to convert.
      * @param config.view A highlight descriptor that will be used for highlighting or a function that takes the model marker data and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as a parameters
      * and returns a highlight descriptor.
      * @param config.converterPriority Converter priority.
      */
      markerToHighlight(config) {
        return this.add(downcastMarkerToHighlight(config));
      }
      /**
      * Model marker converter for data downcast.
      *
      * This conversion creates a representation for model marker boundaries in the view:
      *
      * * If the marker boundary is before or after a model element, a view attribute is set on a corresponding view element.
      * * In other cases, a view element with the specified tag name is inserted at the corresponding view position.
      *
      * Typically, the marker names use the `group:uniqueId:otherData` convention. For example: `comment:e34zfk9k2n459df53sjl34:zx32c`.
      * The default configuration for this conversion is that the first part is the `group` part and the rest of
      * the marker name becomes the `name` part.
      *
      * Tag and attribute names and values are generated from the marker name:
      *
      * * The templates for attributes are `data-[group]-start-before="[name]"`, `data-[group]-start-after="[name]"`,
      * `data-[group]-end-before="[name]"` and `data-[group]-end-after="[name]"`.
      * * The templates for view elements are `<[group]-start name="[name]">` and `<[group]-end name="[name]">`.
      *
      * Attributes mark whether the given marker's start or end boundary is before or after the given element.
      * The `data-[group]-start-before` and `data-[group]-end-after` attributes are favored.
      * The other two are used when the former two cannot be used.
      *
      * The conversion configuration can take a function that will generate different group and name parts.
      * If such a function is set as the `config.view` parameter, it is passed a marker name and it is expected to return an object with two
      * properties: `group` and `name`. If the function returns a falsy value, the conversion will not take place.
      *
      * Basic usage:
      *
      * ```ts
      * // Using the default conversion.
      * // In this case, all markers with names starting with 'comment:' will be converted.
      * // The `group` parameter will be set to `comment`.
      * // The `name` parameter will be the rest of the marker name (without the `:`).
      * editor.conversion.for( 'dataDowncast' ).markerToData( {
      * 	model: 'comment'
      * } );
      * ```
      *
      * An example of a view that may be generated by this conversion (assuming a marker with the name `comment:commentId:uid` marked
      * by `[]`):
      *
      * ```
      * // Model:
      * <paragraph>Foo[bar</paragraph>
      * <imageBlock src="abc.jpg"></imageBlock>]
      *
      * // View:
      * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
      * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
      * ```
      *
      * In the example above, the comment starts before "bar" and ends after the image.
      *
      * If the `name` part is empty, the following view may be generated:
      *
      * ```html
      * <p>Foo <myMarker-start></myMarker-start>bar</p>
      * <figure data-myMarker-end-after="" class="image"><img src="abc.jpg" /></figure>
      * ```
      *
      * **Note:** A situation where some markers have the `name` part and some do not, is incorrect and should be avoided.
      *
      * Examples where `data-group-start-after` and `data-group-end-before` are used:
      *
      * ```
      * // Model:
      * <blockQuote>[]<paragraph>Foo</paragraph></blockQuote>
      *
      * // View:
      * <blockquote><p data-group-end-before="name" data-group-start-before="name">Foo</p></blockquote>
      * ```
      *
      * Similarly, when a marker is collapsed after the last element:
      *
      * ```
      * // Model:
      * <blockQuote><paragraph>Foo</paragraph>[]</blockQuote>
      *
      * // View:
      * <blockquote><p data-group-end-after="name" data-group-start-after="name">Foo</p></blockquote>
      * ```
      *
      * When there are multiple markers from the same group stored in the same attribute of the same element, their
      * name parts are put together in the attribute value, for example: `data-group-start-before="name1,name2,name3"`.
      *
      * Other examples of usage:
      *
      * ```ts
      * // Using a custom function which is the same as the default conversion:
      * editor.conversion.for( 'dataDowncast' ).markerToData( {
      * 	model: 'comment',
      * 	view: markerName => ( {
      * 		group: 'comment',
      * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
      * 	} )
      * } );
      *
      * // Using the converter priority:
      * editor.conversion.for( 'dataDowncast' ).markerToData( {
      * 	model: 'comment',
      * 	view: markerName => ( {
      * 		group: 'comment',
      * 		name: markerName.substr( 8 ) // Removes 'comment:' part.
      * 	} ),
      * 	converterPriority: 'high'
      * } );
      * ```
      *
      * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
      *
      * See the {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} API guide to learn how to
      * add a converter to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.model The name of the model marker (or the model marker group) to convert.
      * @param config.view A function that takes the model marker name and
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi downcast conversion API} as the parameters
      * and returns an object with the `group` and `name` properties.
      * @param config.converterPriority Converter priority.
      */
      markerToData(config) {
        return this.add(downcastMarkerToData(config));
      }
    }
    function insertText() {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        const viewText = viewWriter.createText(data.item.data);
        viewWriter.insert(viewPosition, viewText);
      };
    }
    function insertAttributesAndChildren() {
      return (evt, data, conversionApi) => {
        conversionApi.convertAttributes(data.item);
        if (!data.reconversion && data.item.is("element") && !data.item.isEmpty) {
          conversionApi.convertChildren(data.item);
        }
      };
    }
    function remove() {
      return (evt, data, conversionApi) => {
        const viewStart = conversionApi.mapper.toViewPosition(data.position);
        const modelEnd = data.position.getShiftedBy(data.length);
        const viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {
          isPhantom: true
        });
        const viewRange = conversionApi.writer.createRange(viewStart, viewEnd);
        const removed = conversionApi.writer.remove(viewRange.getTrimmed());
        for (const child of conversionApi.writer.createRangeIn(removed).getItems()) {
          conversionApi.mapper.unbindViewElement(child, {
            defer: true
          });
        }
      };
    }
    function createViewElementFromHighlightDescriptor(writer, descriptor) {
      const viewElement = writer.createAttributeElement("span", descriptor.attributes);
      if (descriptor.classes) {
        viewElement._addClass(descriptor.classes);
      }
      if (typeof descriptor.priority === "number") {
        viewElement._priority = descriptor.priority;
      }
      viewElement._id = descriptor.id;
      return viewElement;
    }
    function convertRangeSelection() {
      return (evt, data, conversionApi) => {
        const selection = data.selection;
        if (selection.isCollapsed) {
          return;
        }
        if (!conversionApi.consumable.consume(selection, "selection")) {
          return;
        }
        const viewRanges = [];
        for (const range of selection.getRanges()) {
          viewRanges.push(conversionApi.mapper.toViewRange(range));
        }
        conversionApi.writer.setSelection(viewRanges, {
          backward: selection.isBackward
        });
      };
    }
    function convertCollapsedSelection() {
      return (evt, data, conversionApi) => {
        const selection = data.selection;
        if (!selection.isCollapsed) {
          return;
        }
        if (!conversionApi.consumable.consume(selection, "selection")) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const modelPosition = selection.getFirstPosition();
        const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
        const brokenPosition = viewWriter.breakAttributes(viewPosition);
        viewWriter.setSelection(brokenPosition);
      };
    }
    function cleanSelection() {
      return (evt, data, conversionApi) => {
        const viewWriter = conversionApi.writer;
        const viewSelection = viewWriter.document.selection;
        for (const range of viewSelection.getRanges()) {
          if (range.isCollapsed) {
            if (range.end.parent.isAttached()) {
              conversionApi.writer.mergeAttributes(range.start);
            }
          }
        }
        viewWriter.setSelection(null);
      };
    }
    function wrap(elementCreator) {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const oldViewElement = elementCreator(data.attributeOldValue, conversionApi, data);
        const newViewElement = elementCreator(data.attributeNewValue, conversionApi, data);
        if (!oldViewElement && !newViewElement) {
          return;
        }
        conversionApi.consumable.consume(data.item, evt.name);
        const viewWriter = conversionApi.writer;
        const viewSelection = viewWriter.document.selection;
        if (data.item instanceof Selection || data.item instanceof DocumentSelection) {
          viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);
        } else {
          let viewRange = conversionApi.mapper.toViewRange(data.range);
          if (data.attributeOldValue !== null && oldViewElement) {
            viewRange = viewWriter.unwrap(viewRange, oldViewElement);
          }
          if (data.attributeNewValue !== null && newViewElement) {
            viewWriter.wrap(viewRange, newViewElement);
          }
        }
      };
    }
    function insertElement(elementCreator, consumer = defaultConsumer) {
      return (evt, data, conversionApi) => {
        if (!consumer(data.item, conversionApi.consumable, {
          preflight: true
        })) {
          return;
        }
        const viewElement = elementCreator(data.item, conversionApi, data);
        if (!viewElement) {
          return;
        }
        consumer(data.item, conversionApi.consumable);
        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        conversionApi.mapper.bindElements(data.item, viewElement);
        conversionApi.writer.insert(viewPosition, viewElement);
        conversionApi.convertAttributes(data.item);
        reinsertOrConvertNodes(viewElement, data.item.getChildren(), conversionApi, {
          reconversion: data.reconversion
        });
      };
    }
    function insertStructure(elementCreator, consumer) {
      return (evt, data, conversionApi) => {
        if (!consumer(data.item, conversionApi.consumable, {
          preflight: true
        })) {
          return;
        }
        const slotsMap = /* @__PURE__ */ new Map();
        conversionApi.writer._registerSlotFactory(createSlotFactory(data.item, slotsMap, conversionApi));
        const viewElement = elementCreator(data.item, conversionApi, data);
        conversionApi.writer._clearSlotFactory();
        if (!viewElement) {
          return;
        }
        validateSlotsChildren(data.item, slotsMap, conversionApi);
        consumer(data.item, conversionApi.consumable);
        const viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
        conversionApi.mapper.bindElements(data.item, viewElement);
        conversionApi.writer.insert(viewPosition, viewElement);
        conversionApi.convertAttributes(data.item);
        fillSlots(viewElement, slotsMap, conversionApi, {
          reconversion: data.reconversion
        });
      };
    }
    function insertUIElement(elementCreator) {
      return (evt, data, conversionApi) => {
        data.isOpening = true;
        const viewStartElement = elementCreator(data, conversionApi);
        data.isOpening = false;
        const viewEndElement = elementCreator(data, conversionApi);
        if (!viewStartElement || !viewEndElement) {
          return;
        }
        const markerRange = data.markerRange;
        if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {
          return;
        }
        for (const value of markerRange) {
          if (!conversionApi.consumable.consume(value.item, evt.name)) {
            return;
          }
        }
        const mapper = conversionApi.mapper;
        const viewWriter = conversionApi.writer;
        viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);
        conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName);
        if (!markerRange.isCollapsed) {
          viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);
          conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);
        }
        evt.stop();
      };
    }
    function removeUIElement() {
      return (evt, data, conversionApi) => {
        const elements = conversionApi.mapper.markerNameToElements(data.markerName);
        if (!elements) {
          return;
        }
        for (const element of elements) {
          conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
          conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
        }
        conversionApi.writer.clearClonedElementsGroup(data.markerName);
        evt.stop();
      };
    }
    function insertMarkerData(viewCreator) {
      return (evt, data, conversionApi) => {
        const viewMarkerData = viewCreator(data.markerName, conversionApi);
        if (!viewMarkerData) {
          return;
        }
        const markerRange = data.markerRange;
        if (!conversionApi.consumable.consume(markerRange, evt.name)) {
          return;
        }
        handleMarkerBoundary(markerRange, false, conversionApi, data, viewMarkerData);
        handleMarkerBoundary(markerRange, true, conversionApi, data, viewMarkerData);
        evt.stop();
      };
    }
    function handleMarkerBoundary(range, isStart, conversionApi, data, viewMarkerData) {
      const modelPosition = isStart ? range.start : range.end;
      const elementAfter = modelPosition.nodeAfter && modelPosition.nodeAfter.is("element") ? modelPosition.nodeAfter : null;
      const elementBefore = modelPosition.nodeBefore && modelPosition.nodeBefore.is("element") ? modelPosition.nodeBefore : null;
      if (elementAfter || elementBefore) {
        let modelElement;
        let isBefore;
        if (isStart && elementAfter || !isStart && !elementBefore) {
          modelElement = elementAfter;
          isBefore = true;
        } else {
          modelElement = elementBefore;
          isBefore = false;
        }
        const viewElement = conversionApi.mapper.toViewElement(modelElement);
        if (viewElement) {
          insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData);
          return;
        }
      }
      const viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
      insertMarkerAsElement(viewPosition, isStart, conversionApi, data, viewMarkerData);
    }
    function insertMarkerAsAttribute(viewElement, isStart, isBefore, conversionApi, data, viewMarkerData) {
      const attributeName = `data-${viewMarkerData.group}-${isStart ? "start" : "end"}-${isBefore ? "before" : "after"}`;
      const markerNames = viewElement.hasAttribute(attributeName) ? viewElement.getAttribute(attributeName).split(",") : [];
      markerNames.unshift(viewMarkerData.name);
      conversionApi.writer.setAttribute(attributeName, markerNames.join(","), viewElement);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
    function insertMarkerAsElement(position, isStart, conversionApi, data, viewMarkerData) {
      const viewElementName = `${viewMarkerData.group}-${isStart ? "start" : "end"}`;
      const attrs = viewMarkerData.name ? {
        "name": viewMarkerData.name
      } : null;
      const viewElement = conversionApi.writer.createUIElement(viewElementName, attrs);
      conversionApi.writer.insert(position, viewElement);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
    function removeMarkerData(viewCreator) {
      return (evt, data, conversionApi) => {
        const viewData = viewCreator(data.markerName, conversionApi);
        if (!viewData) {
          return;
        }
        const elements = conversionApi.mapper.markerNameToElements(data.markerName);
        if (!elements) {
          return;
        }
        for (const element of elements) {
          conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
          if (element.is("containerElement")) {
            removeMarkerFromAttribute(`data-${viewData.group}-start-before`, element);
            removeMarkerFromAttribute(`data-${viewData.group}-start-after`, element);
            removeMarkerFromAttribute(`data-${viewData.group}-end-before`, element);
            removeMarkerFromAttribute(`data-${viewData.group}-end-after`, element);
          } else {
            conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
          }
        }
        conversionApi.writer.clearClonedElementsGroup(data.markerName);
        evt.stop();
        function removeMarkerFromAttribute(attributeName, element) {
          if (element.hasAttribute(attributeName)) {
            const markerNames = new Set(element.getAttribute(attributeName).split(","));
            markerNames.delete(viewData.name);
            if (markerNames.size == 0) {
              conversionApi.writer.removeAttribute(attributeName, element);
            } else {
              conversionApi.writer.setAttribute(attributeName, Array.from(markerNames).join(","), element);
            }
          }
        }
      };
    }
    function changeAttribute(attributeCreator) {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const oldAttribute = attributeCreator(data.attributeOldValue, conversionApi, data);
        const newAttribute = attributeCreator(data.attributeNewValue, conversionApi, data);
        if (!oldAttribute && !newAttribute) {
          return;
        }
        conversionApi.consumable.consume(data.item, evt.name);
        const viewElement = conversionApi.mapper.toViewElement(data.item);
        const viewWriter = conversionApi.writer;
        if (!viewElement) {
          throw new CKEditorError("conversion-attribute-to-attribute-on-text", conversionApi.dispatcher, data);
        }
        if (data.attributeOldValue !== null && oldAttribute) {
          if (oldAttribute.key == "class") {
            const classes = typeof oldAttribute.value == "string" ? oldAttribute.value.split(/\s+/) : oldAttribute.value;
            for (const className of classes) {
              viewWriter.removeClass(className, viewElement);
            }
          } else if (oldAttribute.key == "style") {
            if (typeof oldAttribute.value == "string") {
              const styles = new StylesMap(viewWriter.document.stylesProcessor);
              styles.setTo(oldAttribute.value);
              for (const [key] of styles.getStylesEntries()) {
                viewWriter.removeStyle(key, viewElement);
              }
            } else {
              const keys2 = Object.keys(oldAttribute.value);
              for (const key of keys2) {
                viewWriter.removeStyle(key, viewElement);
              }
            }
          } else {
            viewWriter.removeAttribute(oldAttribute.key, viewElement);
          }
        }
        if (data.attributeNewValue !== null && newAttribute) {
          if (newAttribute.key == "class") {
            const classes = typeof newAttribute.value == "string" ? newAttribute.value.split(/\s+/) : newAttribute.value;
            for (const className of classes) {
              viewWriter.addClass(className, viewElement);
            }
          } else if (newAttribute.key == "style") {
            if (typeof newAttribute.value == "string") {
              const styles = new StylesMap(viewWriter.document.stylesProcessor);
              styles.setTo(newAttribute.value);
              for (const [key, value] of styles.getStylesEntries()) {
                viewWriter.setStyle(key, value, viewElement);
              }
            } else {
              const keys2 = Object.keys(newAttribute.value);
              for (const key of keys2) {
                viewWriter.setStyle(key, newAttribute.value[key], viewElement);
              }
            }
          } else {
            viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);
          }
        }
      };
    }
    function highlightText(highlightDescriptor) {
      return (evt, data, conversionApi) => {
        if (!data.item) {
          return;
        }
        if (!(data.item instanceof Selection || data.item instanceof DocumentSelection) && !data.item.is("$textProxy")) {
          return;
        }
        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
        if (!descriptor) {
          return;
        }
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);
        const viewSelection = viewWriter.document.selection;
        if (data.item instanceof Selection || data.item instanceof DocumentSelection) {
          viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
        } else {
          const viewRange = conversionApi.mapper.toViewRange(data.range);
          const rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);
          for (const element of rangeAfterWrap.getItems()) {
            if (element.is("attributeElement") && element.isSimilar(viewElement)) {
              conversionApi.mapper.bindElementToMarker(element, data.markerName);
              break;
            }
          }
        }
      };
    }
    function highlightElement(highlightDescriptor) {
      return (evt, data, conversionApi) => {
        if (!data.item) {
          return;
        }
        if (!(data.item instanceof Element)) {
          return;
        }
        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
        if (!descriptor) {
          return;
        }
        if (!conversionApi.consumable.test(data.item, evt.name)) {
          return;
        }
        const viewElement = conversionApi.mapper.toViewElement(data.item);
        if (viewElement && viewElement.getCustomProperty("addHighlight")) {
          conversionApi.consumable.consume(data.item, evt.name);
          for (const value of Range._createIn(data.item)) {
            conversionApi.consumable.consume(value.item, evt.name);
          }
          const addHighlightCallback = viewElement.getCustomProperty("addHighlight");
          addHighlightCallback(viewElement, descriptor, conversionApi.writer);
          conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
        }
      };
    }
    function removeHighlight$1(highlightDescriptor) {
      return (evt, data, conversionApi) => {
        if (data.markerRange.isCollapsed) {
          return;
        }
        const descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);
        if (!descriptor) {
          return;
        }
        const viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor);
        const elements = conversionApi.mapper.markerNameToElements(data.markerName);
        if (!elements) {
          return;
        }
        for (const element of elements) {
          conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
          if (element.is("attributeElement")) {
            conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);
          } else {
            const removeHighlightCallback = element.getCustomProperty("removeHighlight");
            removeHighlightCallback(element, descriptor.id, conversionApi.writer);
          }
        }
        conversionApi.writer.clearClonedElementsGroup(data.markerName);
        evt.stop();
      };
    }
    function downcastElementToElement(config) {
      const model = normalizeModelElementConfig(config.model);
      const view = normalizeToElementConfig(config.view, "container");
      if (model.attributes.length) {
        model.children = true;
      }
      return (dispatcher) => {
        dispatcher.on(`insert:${model.name}`, insertElement(view, createConsumer(model)), {
          priority: config.converterPriority || "normal"
        });
        if (model.children || model.attributes.length) {
          dispatcher.on("reduceChanges", createChangeReducer(model), {
            priority: "low"
          });
        }
      };
    }
    function downcastElementToStructure(config) {
      const model = normalizeModelElementConfig(config.model);
      const view = normalizeToElementConfig(config.view, "container");
      model.children = true;
      return (dispatcher) => {
        if (dispatcher._conversionApi.schema.checkChild(model.name, "$text")) {
          throw new CKEditorError("conversion-element-to-structure-disallowed-text", dispatcher, {
            elementName: model.name
          });
        }
        dispatcher.on(`insert:${model.name}`, insertStructure(view, createConsumer(model)), {
          priority: config.converterPriority || "normal"
        });
        dispatcher.on("reduceChanges", createChangeReducer(model), {
          priority: "low"
        });
      };
    }
    function downcastAttributeToElement(config) {
      config = cloneDeep(config);
      let model = config.model;
      if (typeof model == "string") {
        model = {
          key: model
        };
      }
      let eventName = `attribute:${model.key}`;
      if (model.name) {
        eventName += ":" + model.name;
      }
      if (model.values) {
        for (const modelValue of model.values) {
          config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], "attribute");
        }
      } else {
        config.view = normalizeToElementConfig(config.view, "attribute");
      }
      const elementCreator = getFromAttributeCreator(config);
      return (dispatcher) => {
        dispatcher.on(eventName, wrap(elementCreator), {
          priority: config.converterPriority || "normal"
        });
      };
    }
    function downcastAttributeToAttribute(config) {
      config = cloneDeep(config);
      let model = config.model;
      if (typeof model == "string") {
        model = {
          key: model
        };
      }
      let eventName = `attribute:${model.key}`;
      if (model.name) {
        eventName += ":" + model.name;
      }
      if (model.values) {
        for (const modelValue of model.values) {
          config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);
        }
      } else {
        config.view = normalizeToAttributeConfig(config.view);
      }
      const elementCreator = getFromAttributeCreator(config);
      return (dispatcher) => {
        dispatcher.on(eventName, changeAttribute(elementCreator), {
          priority: config.converterPriority || "normal"
        });
      };
    }
    function downcastMarkerToElement(config) {
      const view = normalizeToElementConfig(config.view, "ui");
      return (dispatcher) => {
        dispatcher.on(`addMarker:${config.model}`, insertUIElement(view), {
          priority: config.converterPriority || "normal"
        });
        dispatcher.on(`removeMarker:${config.model}`, removeUIElement(), {
          priority: config.converterPriority || "normal"
        });
      };
    }
    function downcastMarkerToData(config) {
      config = cloneDeep(config);
      const group = config.model;
      let view = config.view;
      if (!view) {
        view = (markerName) => ({
          group,
          name: markerName.substr(config.model.length + 1)
        });
      }
      return (dispatcher) => {
        dispatcher.on(`addMarker:${group}`, insertMarkerData(view), {
          priority: config.converterPriority || "normal"
        });
        dispatcher.on(`removeMarker:${group}`, removeMarkerData(view), {
          priority: config.converterPriority || "normal"
        });
      };
    }
    function downcastMarkerToHighlight(config) {
      return (dispatcher) => {
        dispatcher.on(`addMarker:${config.model}`, highlightText(config.view), {
          priority: config.converterPriority || "normal"
        });
        dispatcher.on(`addMarker:${config.model}`, highlightElement(config.view), {
          priority: config.converterPriority || "normal"
        });
        dispatcher.on(`removeMarker:${config.model}`, removeHighlight$1(config.view), {
          priority: config.converterPriority || "normal"
        });
      };
    }
    function normalizeModelElementConfig(model) {
      if (typeof model == "string") {
        model = {
          name: model
        };
      }
      return {
        name: model.name,
        attributes: model.attributes ? toArray$1(model.attributes) : [],
        children: !!model.children
      };
    }
    function normalizeToElementConfig(view, viewElementType) {
      if (typeof view == "function") {
        return view;
      }
      return (modelData, conversionApi) => createViewElementFromDefinition(view, conversionApi, viewElementType);
    }
    function createViewElementFromDefinition(viewElementDefinition, conversionApi, viewElementType) {
      if (typeof viewElementDefinition == "string") {
        viewElementDefinition = {
          name: viewElementDefinition
        };
      }
      let element;
      const viewWriter = conversionApi.writer;
      const attributes = Object.assign({}, viewElementDefinition.attributes);
      if (viewElementType == "container") {
        element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);
      } else if (viewElementType == "attribute") {
        const options = {
          priority: viewElementDefinition.priority || AttributeElement.DEFAULT_PRIORITY
        };
        element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);
      } else {
        element = viewWriter.createUIElement(viewElementDefinition.name, attributes);
      }
      if (viewElementDefinition.styles) {
        const keys2 = Object.keys(viewElementDefinition.styles);
        for (const key of keys2) {
          viewWriter.setStyle(key, viewElementDefinition.styles[key], element);
        }
      }
      if (viewElementDefinition.classes) {
        const classes = viewElementDefinition.classes;
        if (typeof classes == "string") {
          viewWriter.addClass(classes, element);
        } else {
          for (const className of classes) {
            viewWriter.addClass(className, element);
          }
        }
      }
      return element;
    }
    function getFromAttributeCreator(config) {
      if (config.model.values) {
        return (modelAttributeValue, conversionApi, data) => {
          const view = config.view[modelAttributeValue];
          if (view) {
            return view(modelAttributeValue, conversionApi, data);
          }
          return null;
        };
      } else {
        return config.view;
      }
    }
    function normalizeToAttributeConfig(view) {
      if (typeof view == "string") {
        return (modelAttributeValue) => ({
          key: view,
          value: modelAttributeValue
        });
      } else if (typeof view == "object") {
        if (view.value) {
          return () => view;
        } else {
          return (modelAttributeValue) => ({
            key: view.key,
            value: modelAttributeValue
          });
        }
      } else {
        return view;
      }
    }
    function prepareDescriptor(highlightDescriptor, data, conversionApi) {
      const descriptor = typeof highlightDescriptor == "function" ? highlightDescriptor(data, conversionApi) : highlightDescriptor;
      if (!descriptor) {
        return null;
      }
      if (!descriptor.priority) {
        descriptor.priority = 10;
      }
      if (!descriptor.id) {
        descriptor.id = data.markerName;
      }
      return descriptor;
    }
    function createChangeReducerCallback(model) {
      return (node, change) => {
        if (!node.is("element", model.name)) {
          return false;
        }
        if (change.type == "attribute") {
          if (model.attributes.includes(change.attributeKey)) {
            return true;
          }
        } else {
          /* istanbul ignore else: This is always true because otherwise it would not register a reducer callback. -- @preserve */
          if (model.children) {
            return true;
          }
        }
        return false;
      };
    }
    function createChangeReducer(model) {
      const shouldReplace = createChangeReducerCallback(model);
      return (evt, data) => {
        const reducedChanges = [];
        if (!data.reconvertedElements) {
          data.reconvertedElements = /* @__PURE__ */ new Set();
        }
        for (const change of data.changes) {
          const node = change.type == "attribute" ? change.range.start.nodeAfter : change.position.parent;
          if (!node || !shouldReplace(node, change)) {
            reducedChanges.push(change);
            continue;
          }
          if (!data.reconvertedElements.has(node)) {
            data.reconvertedElements.add(node);
            const position = Position._createBefore(node);
            let changeIndex = reducedChanges.length;
            for (let i = reducedChanges.length - 1; i >= 0; i--) {
              const change2 = reducedChanges[i];
              const changePosition = change2.type == "attribute" ? change2.range.start : change2.position;
              const positionRelation = changePosition.compareWith(position);
              if (positionRelation == "before" || change2.type == "remove" && positionRelation == "same") {
                break;
              }
              changeIndex = i;
            }
            reducedChanges.splice(changeIndex, 0, {
              type: "remove",
              name: node.name,
              position,
              length: 1
            }, {
              type: "reinsert",
              name: node.name,
              position,
              length: 1
            });
          }
        }
        data.changes = reducedChanges;
      };
    }
    function createConsumer(model) {
      return (node, consumable, options = {}) => {
        const events = [
          "insert"
        ];
        for (const attributeName of model.attributes) {
          if (node.hasAttribute(attributeName)) {
            events.push(`attribute:${attributeName}`);
          }
        }
        if (!events.every((event) => consumable.test(node, event))) {
          return false;
        }
        if (!options.preflight) {
          events.forEach((event) => consumable.consume(node, event));
        }
        return true;
      };
    }
    function createSlotFactory(element, slotsMap, conversionApi) {
      return (writer, modeOrFilter) => {
        const slot = writer.createContainerElement("$slot");
        let children = null;
        if (modeOrFilter === "children") {
          children = Array.from(element.getChildren());
        } else if (typeof modeOrFilter == "function") {
          children = Array.from(element.getChildren()).filter((element2) => modeOrFilter(element2));
        } else {
          throw new CKEditorError("conversion-slot-mode-unknown", conversionApi.dispatcher, {
            modeOrFilter
          });
        }
        slotsMap.set(slot, children);
        return slot;
      };
    }
    function validateSlotsChildren(element, slotsMap, conversionApi) {
      const childrenInSlots = Array.from(slotsMap.values()).flat();
      const uniqueChildrenInSlots = new Set(childrenInSlots);
      if (uniqueChildrenInSlots.size != childrenInSlots.length) {
        throw new CKEditorError("conversion-slot-filter-overlap", conversionApi.dispatcher, {
          element
        });
      }
      if (uniqueChildrenInSlots.size != element.childCount) {
        throw new CKEditorError("conversion-slot-filter-incomplete", conversionApi.dispatcher, {
          element
        });
      }
    }
    function fillSlots(viewElement, slotsMap, conversionApi, options) {
      conversionApi.mapper.on("modelToViewPosition", toViewPositionMapping, {
        priority: "highest"
      });
      let currentSlot = null;
      let currentSlotNodes = null;
      for ([currentSlot, currentSlotNodes] of slotsMap) {
        reinsertOrConvertNodes(viewElement, currentSlotNodes, conversionApi, options);
        conversionApi.writer.move(conversionApi.writer.createRangeIn(currentSlot), conversionApi.writer.createPositionBefore(currentSlot));
        conversionApi.writer.remove(currentSlot);
      }
      conversionApi.mapper.off("modelToViewPosition", toViewPositionMapping);
      function toViewPositionMapping(evt, data) {
        const element = data.modelPosition.nodeAfter;
        const index2 = currentSlotNodes.indexOf(element);
        if (index2 < 0) {
          return;
        }
        data.viewPosition = data.mapper.findPositionIn(currentSlot, index2);
      }
    }
    function reinsertOrConvertNodes(viewElement, modelNodes, conversionApi, options) {
      for (const modelChildNode of modelNodes) {
        if (!reinsertNode(viewElement.root, modelChildNode, conversionApi, options)) {
          conversionApi.convertItem(modelChildNode);
        }
      }
    }
    function reinsertNode(viewRoot, modelNode, conversionApi, options) {
      const { writer, mapper } = conversionApi;
      if (!options.reconversion) {
        return false;
      }
      const viewChildNode = mapper.toViewElement(modelNode);
      if (!viewChildNode || viewChildNode.root == viewRoot) {
        return false;
      }
      if (!conversionApi.canReuseView(viewChildNode)) {
        return false;
      }
      writer.move(writer.createRangeOn(viewChildNode), mapper.toViewPosition(Position._createBefore(modelNode)));
      return true;
    }
    function defaultConsumer(item, consumable, { preflight } = {}) {
      if (preflight) {
        return consumable.test(item, "insert");
      } else {
        return consumable.consume(item, "insert");
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function autoParagraphEmptyRoots(writer) {
      const { schema, document: document2 } = writer.model;
      for (const root2 of document2.getRoots()) {
        if (root2.isEmpty && !schema.checkChild(root2, "$text")) {
          if (schema.checkChild(root2, "paragraph")) {
            writer.insertElement("paragraph", root2);
            return true;
          }
        }
      }
      return false;
    }
    function isParagraphable(position, nodeOrType, schema) {
      const context = schema.createContext(position);
      if (!schema.checkChild(context, "paragraph")) {
        return false;
      }
      if (!schema.checkChild(context.push("paragraph"), nodeOrType)) {
        return false;
      }
      return true;
    }
    function wrapInParagraph(position, writer) {
      const paragraph2 = writer.createElement("paragraph");
      writer.insert(paragraph2, position);
      return writer.createPositionAt(paragraph2, 0);
    }
    class UpcastHelpers extends ConversionHelpers {
      /**
      * View element to model element conversion helper.
      *
      * This conversion results in creating a model element. For example,
      * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
      *
      * Keep in mind that the element will be inserted only if it is allowed
      * by {@link module:engine/model/schema~Schema schema} configuration.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: 'p',
      * 	model: 'paragraph'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: 'p',
      * 	model: 'paragraph',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: {
      * 		name: 'p',
      * 		classes: 'fancy'
      * 	},
      * 	model: 'fancyParagraph'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToElement( {
      * 	view: {
      * 		name: 'p',
      * 		classes: 'heading'
      * 	},
      * 	model: ( viewElement, conversionApi ) => {
      * 		const modelWriter = conversionApi.writer;
      *
      * 		return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Pattern matching all view elements which should be converted. If not set, the converter
      * will fire for every view element.
      * @param config.model Name of the model element, a model element instance or a function that takes a view element
      * and {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API}
      * and returns a model element. The model element will be inserted in the model.
      * @param config.converterPriority Converter priority.
      */
      elementToElement(config) {
        return this.add(upcastElementToElement(config));
      }
      /**
      * View element to model attribute conversion helper.
      *
      * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
      * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
      *
      * This helper is meant to set a model attribute on all the elements that are inside the converted element:
      *
      * ```
      * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
      * ```
      *
      * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
      * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
      * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
      *
      * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: 'strong',
      * 	model: 'bold'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: 'strong',
      * 	model: 'bold',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: {
      * 		name: 'span',
      * 		classes: 'bold'
      * 	},
      * 	model: 'bold'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: {
      * 		name: 'span',
      * 		classes: [ 'styled', 'styled-dark' ]
      * 	},
      * 	model: {
      * 		key: 'styled',
      * 		value: 'dark'
      * 	}
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToAttribute( {
      * 	view: {
      * 		name: 'span',
      * 		styles: {
      * 			'font-size': /[\s\S]+/
      * 		}
      * 	},
      * 	model: {
      * 		key: 'fontSize',
      * 		value: ( viewElement, conversionApi ) => {
      * 			const fontSize = viewElement.getStyle( 'font-size' );
      * 			const value = fontSize.substr( 0, fontSize.length - 2 );
      *
      * 			if ( value <= 10 ) {
      * 				return 'small';
      * 			} else if ( value > 12 ) {
      * 				return 'big';
      * 			}
      *
      * 			return null;
      * 		}
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Pattern matching all view elements which should be converted.
      * @param config.model Model attribute key or an object with `key` and `value` properties, describing
      * the model attribute. `value` property may be set as a function that takes a view element and
      * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
      * If `String` is given, the model attribute value will be set to `true`.
      * @param config.converterPriority Converter priority. Defaults to `low`.
      */
      elementToAttribute(config) {
        return this.add(upcastElementToAttribute(config));
      }
      /**
      * View attribute to model attribute conversion helper.
      *
      * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
      * `<imageBlock source="foo.jpg"></imageBlock>` in the model.
      *
      * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
      * is set only on the corresponding model node:
      *
      * ```
      * <div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
      * ```
      *
      * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrast to
      * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
      * all the children in the model:
      *
      * ```
      * <strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
      * ```
      *
      * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
      * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
      *
      * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: 'src',
      * 	model: 'source'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: { key: 'src' },
      * 	model: 'source'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: { key: 'src' },
      * 	model: 'source',
      * 	converterPriority: 'normal'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		key: 'data-style',
      * 		value: /[\s\S]+/
      * 	},
      * 	model: 'styled'
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		name: 'img',
      * 		key: 'class',
      * 		value: 'styled-dark'
      * 	},
      * 	model: {
      * 		key: 'styled',
      * 		value: 'dark'
      * 	}
      * } );
      *
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		key: 'class',
      * 		value: /styled-[\S]+/
      * 	},
      * 	model: {
      * 		key: 'styled'
      * 		value: ( viewElement, conversionApi ) => {
      * 			const regexp = /styled-([\S]+)/;
      * 			const match = viewElement.getAttribute( 'class' ).match( regexp );
      *
      * 			return match[ 1 ];
      * 		}
      * 	}
      * } );
      * ```
      *
      * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
      * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
      * callback that returns the desired value.
      *
      * ```ts
      * // Default conversion of font-weight style will result in setting bold attribute to true.
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		styles: {
      * 			'font-weight': 'bold'
      * 		}
      * 	},
      * 	model: 'bold'
      * } );
      *
      * // This converter will pass any style value to the `lineHeight` model attribute.
      * editor.conversion.for( 'upcast' ).attributeToAttribute( {
      * 	view: {
      * 		styles: {
      * 			'line-height': /[\s\S]+/
      * 		}
      * 	},
      * 	model: {
      * 		key: 'lineHeight',
      * 		value: ( viewElement, conversionApi ) => viewElement.getStyle( 'line-height' )
      * 	}
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Specifies which view attribute will be converted. If a `String` is passed,
      * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
      * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
      * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
      * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
      * @param config.model Model attribute key or an object with `key` and `value` properties, describing
      * the model attribute. `value` property may be set as a function that takes a view element and
      * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the value.
      * If `String` is given, the model attribute value will be same as view attribute value.
      * @param config.converterPriority Converter priority. Defaults to `low`.
      */
      attributeToAttribute(config) {
        return this.add(upcastAttributeToAttribute(config));
      }
      /**
      * View element to model marker conversion helper.
      *
      * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
      * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
      * after the conversion is done, the marker will be available in
      * {@link module:engine/model/model~Model#markers model document markers}.
      *
      * **Note**: When this helper is used in the data upcast in combination with
      * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} in the data downcast,
      * then invalid HTML code (e.g. a span between table cells) may be produced by the latter converter.
      *
      * In most of the cases, the {@link #dataToMarker} should be used instead.
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: 'marker-search',
      * 	model: 'search'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: 'marker-search',
      * 	model: 'search',
      * 	converterPriority: 'high'
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: 'marker-search',
      * 	model: ( viewElement, conversionApi ) => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
      * } );
      *
      * editor.conversion.for( 'upcast' ).elementToMarker( {
      * 	view: {
      * 		name: 'span',
      * 		attributes: {
      * 			'data-marker': 'search'
      * 		}
      * 	},
      * 	model: 'search'
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view Pattern matching all view elements which should be converted.
      * @param config.model Name of the model marker, or a function that takes a view element and returns
      * a model marker name.
      * @param config.converterPriority Converter priority.
      */
      elementToMarker(config) {
        return this.add(upcastElementToMarker(config));
      }
      /**
      * View-to-model marker conversion helper.
      *
      * Converts view data created by {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`}
      * back to a model marker.
      *
      * This converter looks for specific view elements and view attributes that mark marker boundaries. See
      * {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToData `#markerToData()`} to learn what view data
      * is expected by this converter.
      *
      * The `config.view` property is equal to the marker group name to convert.
      *
      * By default, this converter creates markers with the `group:name` name convention (to match the default `markerToData` conversion).
      *
      * The conversion configuration can take a function that will generate a marker name.
      * If such function is set as the `config.model` parameter, it is passed the `name` part from the view element or attribute and it is
      * expected to return a string with the marker name.
      *
      * Basic usage:
      *
      * ```ts
      * // Using the default conversion.
      * // In this case, all markers from the `comment` group will be converted.
      * // The conversion will look for `<comment-start>` and `<comment-end>` tags and
      * // `data-comment-start-before`, `data-comment-start-after`,
      * // `data-comment-end-before` and `data-comment-end-after` attributes.
      * editor.conversion.for( 'upcast' ).dataToMarker( {
      * 	view: 'comment'
      * } );
      * ```
      *
      * An example of a model that may be generated by this conversion:
      *
      * ```
      * // View:
      * <p>Foo<comment-start name="commentId:uid"></comment-start>bar</p>
      * <figure data-comment-end-after="commentId:uid" class="image"><img src="abc.jpg" /></figure>
      *
      * // Model:
      * <paragraph>Foo[bar</paragraph>
      * <imageBlock src="abc.jpg"></imageBlock>]
      * ```
      *
      * Where `[]` are boundaries of a marker that will receive the `comment:commentId:uid` name.
      *
      * Other examples of usage:
      *
      * ```ts
      * // Using a custom function which is the same as the default conversion:
      * editor.conversion.for( 'upcast' ).dataToMarker( {
      * 	view: 'comment',
      * 	model: ( name, conversionApi ) => 'comment:' + name,
      * } );
      *
      * // Using the converter priority:
      * editor.conversion.for( 'upcast' ).dataToMarker( {
      * 	view: 'comment',
      * 	model: ( name, conversionApi ) => 'comment:' + name,
      * 	converterPriority: 'high'
      * } );
      * ```
      *
      * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
      * to the conversion process.
      *
      * @param config Conversion configuration.
      * @param config.view The marker group name to convert.
      * @param config.model A function that takes the `name` part from the view element or attribute and
      * {@link module:engine/conversion/upcastdispatcher~UpcastConversionApi upcast conversion API} and returns the marker name.
      * @param config.converterPriority Converter priority.
      */
      dataToMarker(config) {
        return this.add(upcastDataToMarker(config));
      }
    }
    function convertToModelFragment$1() {
      return (evt, data, conversionApi) => {
        if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {
          name: true
        })) {
          const { modelRange, modelCursor } = conversionApi.convertChildren(data.viewItem, data.modelCursor);
          data.modelRange = modelRange;
          data.modelCursor = modelCursor;
        }
      };
    }
    function convertText() {
      return (evt, data, { schema, consumable, writer }) => {
        let position = data.modelCursor;
        if (!consumable.test(data.viewItem)) {
          return;
        }
        if (!schema.checkChild(position, "$text")) {
          if (!isParagraphable(position, "$text", schema)) {
            return;
          }
          if (data.viewItem.data.trim().length == 0) {
            return;
          }
          const nodeBefore = position.nodeBefore;
          position = wrapInParagraph(position, writer);
          if (nodeBefore && nodeBefore.is("element", "$marker")) {
            writer.move(writer.createRangeOn(nodeBefore), position);
            position = writer.createPositionAfter(nodeBefore);
          }
        }
        consumable.consume(data.viewItem);
        const text2 = writer.createText(data.viewItem.data);
        writer.insert(text2, position);
        data.modelRange = writer.createRange(position, position.getShiftedBy(text2.offsetSize));
        data.modelCursor = data.modelRange.end;
      };
    }
    function convertSelectionChange(model, mapper) {
      return (evt, data) => {
        const viewSelection = data.newSelection;
        const ranges = [];
        for (const viewRange of viewSelection.getRanges()) {
          ranges.push(mapper.toModelRange(viewRange));
        }
        const modelSelection = model.createSelection(ranges, {
          backward: viewSelection.isBackward
        });
        if (!modelSelection.isEqual(model.document.selection)) {
          model.change((writer) => {
            writer.setSelection(modelSelection);
          });
        }
      };
    }
    function upcastElementToElement(config) {
      config = cloneDeep(config);
      const converter = prepareToElementConverter(config);
      const elementName = getViewElementNameFromConfig(config.view);
      const eventName = elementName ? `element:${elementName}` : "element";
      return (dispatcher) => {
        dispatcher.on(eventName, converter, {
          priority: config.converterPriority || "normal"
        });
      };
    }
    function upcastElementToAttribute(config) {
      config = cloneDeep(config);
      normalizeModelAttributeConfig(config);
      const converter = prepareToAttributeConverter(config, false);
      const elementName = getViewElementNameFromConfig(config.view);
      const eventName = elementName ? `element:${elementName}` : "element";
      return (dispatcher) => {
        dispatcher.on(eventName, converter, {
          priority: config.converterPriority || "low"
        });
      };
    }
    function upcastAttributeToAttribute(config) {
      config = cloneDeep(config);
      let viewKey = null;
      if (typeof config.view == "string" || config.view.key) {
        viewKey = normalizeViewAttributeKeyValueConfig(config);
      }
      normalizeModelAttributeConfig(config, viewKey);
      const converter = prepareToAttributeConverter(config, true);
      return (dispatcher) => {
        dispatcher.on("element", converter, {
          priority: config.converterPriority || "low"
        });
      };
    }
    function upcastElementToMarker(config) {
      const model = normalizeElementToMarkerModelConfig(config.model);
      return upcastElementToElement({
        ...config,
        model
      });
    }
    function upcastDataToMarker(config) {
      config = cloneDeep(config);
      if (!config.model) {
        config.model = (name) => {
          return name ? config.view + ":" + name : config.view;
        };
      }
      const normalizedConfig = {
        view: config.view,
        model: config.model
      };
      const converterStart = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "start"));
      const converterEnd = prepareToElementConverter(normalizeDataToMarkerConfig(normalizedConfig, "end"));
      return (dispatcher) => {
        dispatcher.on(`element:${config.view}-start`, converterStart, {
          priority: config.converterPriority || "normal"
        });
        dispatcher.on(`element:${config.view}-end`, converterEnd, {
          priority: config.converterPriority || "normal"
        });
        const basePriority = priorities.low;
        const maxPriority = priorities.highest;
        const priorityFactor = priorities.get(config.converterPriority) / maxPriority;
        dispatcher.on("element", upcastAttributeToMarker(normalizedConfig), {
          priority: basePriority + priorityFactor
        });
      };
    }
    function upcastAttributeToMarker(config) {
      return (evt, data, conversionApi) => {
        const attrName = `data-${config.view}`;
        if (!conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-end-after"
        }) && !conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-start-after"
        }) && !conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-end-before"
        }) && !conversionApi.consumable.test(data.viewItem, {
          attributes: attrName + "-start-before"
        })) {
          return;
        }
        if (!data.modelRange) {
          Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-end-after"
        })) {
          addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-end-after").split(","));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-start-after"
        })) {
          addMarkerElements(data.modelRange.end, data.viewItem.getAttribute(attrName + "-start-after").split(","));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-end-before"
        })) {
          addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-end-before").split(","));
        }
        if (conversionApi.consumable.consume(data.viewItem, {
          attributes: attrName + "-start-before"
        })) {
          addMarkerElements(data.modelRange.start, data.viewItem.getAttribute(attrName + "-start-before").split(","));
        }
        function addMarkerElements(position, markerViewNames) {
          for (const markerViewName of markerViewNames) {
            const markerName = config.model(markerViewName, conversionApi);
            const element = conversionApi.writer.createElement("$marker", {
              "data-name": markerName
            });
            conversionApi.writer.insert(element, position);
            if (data.modelCursor.isEqual(position)) {
              data.modelCursor = data.modelCursor.getShiftedBy(1);
            } else {
              data.modelCursor = data.modelCursor._getTransformedByInsertion(position, 1);
            }
            data.modelRange = data.modelRange._getTransformedByInsertion(position, 1)[0];
          }
        }
      };
    }
    function getViewElementNameFromConfig(viewConfig) {
      if (typeof viewConfig == "string") {
        return viewConfig;
      }
      if (typeof viewConfig == "object" && typeof viewConfig.name == "string") {
        return viewConfig.name;
      }
      return null;
    }
    function prepareToElementConverter(config) {
      const matcher = new Matcher(config.view);
      return (evt, data, conversionApi) => {
        const matcherResult = matcher.match(data.viewItem);
        if (!matcherResult) {
          return;
        }
        const match = matcherResult.match;
        match.name = true;
        if (!conversionApi.consumable.test(data.viewItem, match)) {
          return;
        }
        const modelElement = getModelElement(config.model, data.viewItem, conversionApi);
        if (!modelElement) {
          return;
        }
        if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
          return;
        }
        conversionApi.consumable.consume(data.viewItem, match);
        conversionApi.convertChildren(data.viewItem, modelElement);
        conversionApi.updateConversionResult(modelElement, data);
      };
    }
    function getModelElement(model, input, conversionApi) {
      if (model instanceof Function) {
        return model(input, conversionApi);
      } else {
        return conversionApi.writer.createElement(model);
      }
    }
    function normalizeViewAttributeKeyValueConfig(config) {
      if (typeof config.view == "string") {
        config.view = {
          key: config.view
        };
      }
      const key = config.view.key;
      const value = typeof config.view.value == "undefined" ? /[\s\S]*/ : config.view.value;
      let normalized;
      if (key == "class" || key == "style") {
        const keyName = key == "class" ? "classes" : "styles";
        normalized = {
          [keyName]: value
        };
      } else {
        normalized = {
          attributes: {
            [key]: value
          }
        };
      }
      if (config.view.name) {
        normalized.name = config.view.name;
      }
      config.view = normalized;
      return key;
    }
    function normalizeModelAttributeConfig(config, viewAttributeKeyToCopy = null) {
      const defaultModelValue = viewAttributeKeyToCopy === null ? true : (viewElement) => viewElement.getAttribute(viewAttributeKeyToCopy);
      const key = typeof config.model != "object" ? config.model : config.model.key;
      const value = typeof config.model != "object" || typeof config.model.value == "undefined" ? defaultModelValue : config.model.value;
      config.model = {
        key,
        value
      };
    }
    function prepareToAttributeConverter(config, shallow) {
      const matcher = new Matcher(config.view);
      return (evt, data, conversionApi) => {
        if (!data.modelRange && shallow) {
          return;
        }
        const match = matcher.match(data.viewItem);
        if (!match) {
          return;
        }
        if (onlyViewNameIsDefined(config.view, data.viewItem)) {
          match.match.name = true;
        } else {
          delete match.match.name;
        }
        if (!conversionApi.consumable.test(data.viewItem, match.match)) {
          return;
        }
        const modelKey = config.model.key;
        const modelValue = typeof config.model.value == "function" ? config.model.value(data.viewItem, conversionApi) : config.model.value;
        if (modelValue === null) {
          return;
        }
        if (!data.modelRange) {
          Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
        }
        const attributeWasSet = setAttributeOn(data.modelRange, {
          key: modelKey,
          value: modelValue
        }, shallow, conversionApi);
        if (attributeWasSet) {
          if (conversionApi.consumable.test(data.viewItem, {
            name: true
          })) {
            match.match.name = true;
          }
          conversionApi.consumable.consume(data.viewItem, match.match);
        }
      };
    }
    function onlyViewNameIsDefined(viewConfig, viewItem) {
      const configToTest = typeof viewConfig == "function" ? viewConfig(viewItem) : viewConfig;
      if (typeof configToTest == "object" && !getViewElementNameFromConfig(configToTest)) {
        return false;
      }
      return !configToTest.classes && !configToTest.attributes && !configToTest.styles;
    }
    function setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {
      let result = false;
      for (const node of Array.from(modelRange.getItems({
        shallow
      }))) {
        if (!conversionApi.schema.checkAttribute(node, modelAttribute.key)) {
          continue;
        }
        result = true;
        if (node.hasAttribute(modelAttribute.key)) {
          continue;
        }
        conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);
      }
      return result;
    }
    function normalizeElementToMarkerModelConfig(model) {
      return (viewElement, conversionApi) => {
        const markerName = typeof model == "string" ? model : model(viewElement, conversionApi);
        return conversionApi.writer.createElement("$marker", {
          "data-name": markerName
        });
      };
    }
    function normalizeDataToMarkerConfig(config, type) {
      const elementCreatorFunction = (viewElement, conversionApi) => {
        const viewName = viewElement.getAttribute("name");
        const markerName = config.model(viewName, conversionApi);
        return conversionApi.writer.createElement("$marker", {
          "data-name": markerName
        });
      };
      return {
        // Upcast <markerGroup-start> and <markerGroup-end> elements.
        view: `${config.view}-${type}`,
        model: elementCreatorFunction
      };
    }
    function injectSelectionPostFixer(model) {
      model.document.registerPostFixer((writer) => selectionPostFixer(writer, model));
    }
    function selectionPostFixer(writer, model) {
      const selection = model.document.selection;
      const schema = model.schema;
      const ranges = [];
      let wasFixed = false;
      for (const modelRange of selection.getRanges()) {
        const correctedRange = tryFixingRange(modelRange, schema);
        if (correctedRange && !correctedRange.isEqual(modelRange)) {
          ranges.push(correctedRange);
          wasFixed = true;
        } else {
          ranges.push(modelRange);
        }
      }
      if (wasFixed) {
        writer.setSelection(mergeIntersectingRanges(ranges), {
          backward: selection.isBackward
        });
      }
      return false;
    }
    function tryFixingRange(range, schema) {
      if (range.isCollapsed) {
        return tryFixingCollapsedRange(range, schema);
      }
      return tryFixingNonCollapsedRage(range, schema);
    }
    function tryFixingCollapsedRange(range, schema) {
      const originalPosition = range.start;
      const nearestSelectionRange = schema.getNearestSelectionRange(originalPosition);
      if (!nearestSelectionRange) {
        const ancestorObject = originalPosition.getAncestors().reverse().find((item) => schema.isObject(item));
        if (ancestorObject) {
          return Range._createOn(ancestorObject);
        }
        return null;
      }
      if (!nearestSelectionRange.isCollapsed) {
        return nearestSelectionRange;
      }
      const fixedPosition = nearestSelectionRange.start;
      if (originalPosition.isEqual(fixedPosition)) {
        return null;
      }
      return new Range(fixedPosition);
    }
    function tryFixingNonCollapsedRage(range, schema) {
      const { start, end } = range;
      const isTextAllowedOnStart = schema.checkChild(start, "$text");
      const isTextAllowedOnEnd = schema.checkChild(end, "$text");
      const startLimitElement = schema.getLimitElement(start);
      const endLimitElement = schema.getLimitElement(end);
      if (startLimitElement === endLimitElement) {
        if (isTextAllowedOnStart && isTextAllowedOnEnd) {
          return null;
        }
        if (checkSelectionOnNonLimitElements(start, end, schema)) {
          const isStartBeforeSelectable = start.nodeAfter && schema.isSelectable(start.nodeAfter);
          const fixedStart = isStartBeforeSelectable ? null : schema.getNearestSelectionRange(start, "forward");
          const isEndAfterSelectable = end.nodeBefore && schema.isSelectable(end.nodeBefore);
          const fixedEnd = isEndAfterSelectable ? null : schema.getNearestSelectionRange(end, "backward");
          const rangeStart = fixedStart ? fixedStart.start : start;
          const rangeEnd = fixedEnd ? fixedEnd.end : end;
          return new Range(rangeStart, rangeEnd);
        }
      }
      const isStartInLimit = startLimitElement && !startLimitElement.is("rootElement");
      const isEndInLimit = endLimitElement && !endLimitElement.is("rootElement");
      if (isStartInLimit || isEndInLimit) {
        const bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;
        const expandStart = isStartInLimit && (!bothInSameParent || !isSelectable(start.nodeAfter, schema));
        const expandEnd = isEndInLimit && (!bothInSameParent || !isSelectable(end.nodeBefore, schema));
        let fixedStart = start;
        let fixedEnd = end;
        if (expandStart) {
          fixedStart = Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));
        }
        if (expandEnd) {
          fixedEnd = Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));
        }
        return new Range(fixedStart, fixedEnd);
      }
      return null;
    }
    function findOutermostLimitAncestor(startingNode, schema) {
      let isLimitNode = startingNode;
      let parent2 = isLimitNode;
      while (schema.isLimit(parent2) && parent2.parent) {
        isLimitNode = parent2;
        parent2 = parent2.parent;
      }
      return isLimitNode;
    }
    function checkSelectionOnNonLimitElements(start, end, schema) {
      const startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, "$text");
      const endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, "$text");
      return startIsOnBlock || endIsOnBlock;
    }
    function mergeIntersectingRanges(ranges) {
      const rangesToMerge = [
        ...ranges
      ];
      const rangeIndexesToRemove = /* @__PURE__ */ new Set();
      let currentRangeIndex = 1;
      while (currentRangeIndex < rangesToMerge.length) {
        const currentRange = rangesToMerge[currentRangeIndex];
        const previousRanges = rangesToMerge.slice(0, currentRangeIndex);
        for (const [previousRangeIndex, previousRange] of previousRanges.entries()) {
          if (rangeIndexesToRemove.has(previousRangeIndex)) {
            continue;
          }
          if (currentRange.isEqual(previousRange)) {
            rangeIndexesToRemove.add(previousRangeIndex);
          } else if (currentRange.isIntersecting(previousRange)) {
            rangeIndexesToRemove.add(previousRangeIndex);
            rangeIndexesToRemove.add(currentRangeIndex);
            const mergedRange = currentRange.getJoined(previousRange);
            rangesToMerge.push(mergedRange);
          }
        }
        currentRangeIndex++;
      }
      const nonIntersectingRanges = rangesToMerge.filter((_, index2) => !rangeIndexesToRemove.has(index2));
      return nonIntersectingRanges;
    }
    function isSelectable(node, schema) {
      return node && schema.isSelectable(node);
    }
    class EditingController extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates an editing controller instance.
      *
      * @param model Editing model.
      * @param stylesProcessor The styles processor instance.
      */
      constructor(model, stylesProcessor) {
        super();
        /**
        * Editor model.
        */
        __publicField(this, "model");
        /**
        * Editing view controller.
        */
        __publicField(this, "view");
        /**
        * A mapper that describes the model-view binding.
        */
        __publicField(this, "mapper");
        /**
        * Downcast dispatcher that converts changes from the model to the {@link #view editing view}.
        */
        __publicField(this, "downcastDispatcher");
        this.model = model;
        this.view = new View$1(stylesProcessor);
        this.mapper = new Mapper();
        this.downcastDispatcher = new DowncastDispatcher({
          mapper: this.mapper,
          schema: model.schema
        });
        const doc = this.model.document;
        const selection = doc.selection;
        const markers = this.model.markers;
        this.listenTo(this.model, "_beforeChanges", () => {
          this.view._disableRendering(true);
        }, {
          priority: "highest"
        });
        this.listenTo(this.model, "_afterChanges", () => {
          this.view._disableRendering(false);
        }, {
          priority: "lowest"
        });
        this.listenTo(doc, "change", () => {
          this.view.change((writer) => {
            this.downcastDispatcher.convertChanges(doc.differ, markers, writer);
            this.downcastDispatcher.convertSelection(selection, markers, writer);
          });
        }, {
          priority: "low"
        });
        this.listenTo(this.view.document, "selectionChange", convertSelectionChange(this.model, this.mapper));
        this.listenTo(this.view.document, "beforeinput", fixTargetRanges(this.mapper, this.model.schema, this.view), {
          priority: "high"
        });
        this.downcastDispatcher.on("insert:$text", insertText(), {
          priority: "lowest"
        });
        this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {
          priority: "lowest"
        });
        this.downcastDispatcher.on("remove", remove(), {
          priority: "low"
        });
        this.downcastDispatcher.on("cleanSelection", cleanSelection());
        this.downcastDispatcher.on("selection", convertRangeSelection(), {
          priority: "low"
        });
        this.downcastDispatcher.on("selection", convertCollapsedSelection(), {
          priority: "low"
        });
        this.view.document.roots.bindTo(this.model.document.roots).using((root2) => {
          if (root2.rootName == "$graveyard") {
            return null;
          }
          const viewRoot = new RootEditableElement(this.view.document, root2.name);
          viewRoot.rootName = root2.rootName;
          this.mapper.bindElements(root2, viewRoot);
          return viewRoot;
        });
      }
      /**
      * Removes all event listeners attached to the `EditingController`. Destroys all objects created
      * by `EditingController` that need to be destroyed.
      */
      destroy() {
        this.view.destroy();
        this.stopListening();
      }
      /**
      * Calling this method will refresh the marker by triggering the downcast conversion for it.
      *
      * Reconverting the marker is useful when you want to change its {@link module:engine/view/element~Element view element}
      * without changing any marker data. For instance:
      *
      * ```ts
      * let isCommentActive = false;
      *
      * model.conversion.markerToHighlight( {
      * 	model: 'comment',
      * 	view: data => {
      * 		const classes = [ 'comment-marker' ];
      *
      * 		if ( isCommentActive ) {
      * 			classes.push( 'comment-marker--active' );
      * 		}
      *
      * 		return { classes };
      * 	}
      * } );
      *
      * // ...
      *
      * // Change the property that indicates if marker is displayed as active or not.
      * isCommentActive = true;
      *
      * // Reconverting will downcast and synchronize the marker with the new isCommentActive state value.
      * editor.editing.reconvertMarker( 'comment' );
      * ```
      *
      * **Note**: If you want to reconvert a model item, use {@link #reconvertItem} instead.
      *
      * @param markerOrName Name of a marker to update, or a marker instance.
      */
      reconvertMarker(markerOrName) {
        const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
        const currentMarker = this.model.markers.get(markerName);
        if (!currentMarker) {
          throw new CKEditorError("editingcontroller-reconvertmarker-marker-not-exist", this, {
            markerName
          });
        }
        this.model.change(() => {
          this.model.markers._refresh(currentMarker);
        });
      }
      /**
      * Calling this method will downcast a model item on demand (by requesting a refresh in the {@link module:engine/model/differ~Differ}).
      *
      * You can use it if you want the view representation of a specific item updated as a response to external modifications. For instance,
      * when the view structure depends not only on the associated model data but also on some external state.
      *
      * **Note**: If you want to reconvert a model marker, use {@link #reconvertMarker} instead.
      *
      * @param item Item to refresh.
      */
      reconvertItem(item) {
        this.model.change(() => {
          this.model.document.differ._refreshItem(item);
        });
      }
    }
    function fixTargetRanges(mapper, schema, view) {
      return (evt, data) => {
        if (view.document.isComposing && !env.isAndroid) {
          return;
        }
        for (let i = 0; i < data.targetRanges.length; i++) {
          const viewRange = data.targetRanges[i];
          const modelRange = mapper.toModelRange(viewRange);
          const correctedRange = tryFixingRange(modelRange, schema);
          if (!correctedRange || correctedRange.isEqual(modelRange)) {
            continue;
          }
          data.targetRanges[i] = mapper.toViewRange(correctedRange);
        }
      };
    }
    class ViewConsumable {
      constructor() {
        /**
        * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,
        * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.
        * For {@link module:engine/view/text~Text text nodes} and
        * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.
        */
        __publicField(this, "_consumables", /* @__PURE__ */ new Map());
      }
      add(element, consumables) {
        let elementConsumables;
        if (element.is("$text") || element.is("documentFragment")) {
          this._consumables.set(element, true);
          return;
        }
        if (!this._consumables.has(element)) {
          elementConsumables = new ViewElementConsumables(element);
          this._consumables.set(element, elementConsumables);
        } else {
          elementConsumables = this._consumables.get(element);
        }
        elementConsumables.add(consumables);
      }
      /**
      * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
      * It returns `true` when all items included in method's call can be consumed. Returns `false` when
      * first already consumed item is found and `null` when first non-consumable item is found.
      *
      * ```ts
      * viewConsumable.test( p, { name: true } ); // Tests element's name.
      * viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
      * viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
      * viewConsumable.test( p, { styles: 'color' } ); // Tests style.
      * viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
      * viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
      * viewConsumable.test( textNode ); // Tests text node.
      * viewConsumable.test( docFragment ); // Tests document fragment.
      * ```
      *
      * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
      *
      * ```ts
      * viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
      * viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
      * ```
      *
      * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
      * @param consumables.name If set to true element's name will be included.
      * @param consumables.attributes Attribute name or array of attribute names.
      * @param consumables.classes Class name or array of class names.
      * @param consumables.styles Style name or array of style names.
      * @returns Returns `true` when all items included in method's call can be consumed. Returns `false`
      * when first already consumed item is found and `null` when first non-consumable item is found.
      */
      test(element, consumables) {
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables === void 0) {
          return null;
        }
        if (element.is("$text") || element.is("documentFragment")) {
          return elementConsumables;
        }
        return elementConsumables.test(consumables);
      }
      /**
      * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
      * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
      *
      * ```ts
      * viewConsumable.consume( p, { name: true } ); // Consumes element's name.
      * viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
      * viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
      * viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
      * viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
      * viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
      * viewConsumable.consume( textNode ); // Consumes text node.
      * viewConsumable.consume( docFragment ); // Consumes document fragment.
      * ```
      *
      * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
      *
      * ```ts
      * viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
      * viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
      * ```
      *
      * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
      * @param consumables.name If set to true element's name will be included.
      * @param consumables.attributes Attribute name or array of attribute names.
      * @param consumables.classes Class name or array of class names.
      * @param consumables.styles Style name or array of style names.
      * @returns Returns `true` when all items included in method's call can be consumed,
      * otherwise returns `false`.
      */
      consume(element, consumables) {
        if (this.test(element, consumables)) {
          if (element.is("$text") || element.is("documentFragment")) {
            this._consumables.set(element, false);
          } else {
            this._consumables.get(element).consume(consumables);
          }
          return true;
        }
        return false;
      }
      /**
      * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
      * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
      * Method does not revert items that were never previously added for consumption, even if they are included in
      * method's call.
      *
      * ```ts
      * viewConsumable.revert( p, { name: true } ); // Reverts element's name.
      * viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
      * viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
      * viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
      * viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
      * viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
      * viewConsumable.revert( textNode ); // Reverts text node.
      * viewConsumable.revert( docFragment ); // Reverts document fragment.
      * ```
      *
      * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
      * consumption.
      *
      * ```ts
      * viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
      * viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
      * ```
      *
      * @param consumables Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
      * @param consumables.name If set to true element's name will be included.
      * @param consumables.attributes Attribute name or array of attribute names.
      * @param consumables.classes Class name or array of class names.
      * @param consumables.styles Style name or array of style names.
      */
      revert(element, consumables) {
        const elementConsumables = this._consumables.get(element);
        if (elementConsumables !== void 0) {
          if (element.is("$text") || element.is("documentFragment")) {
            this._consumables.set(element, true);
          } else {
            elementConsumables.revert(consumables);
          }
        }
      }
      /**
      * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
      * element's name and all its attributes, classes and styles.
      */
      static consumablesFromElement(element) {
        const consumables = {
          element,
          name: true,
          attributes: [],
          classes: [],
          styles: []
        };
        const attributes = element.getAttributeKeys();
        for (const attribute of attributes) {
          if (attribute == "style" || attribute == "class") {
            continue;
          }
          consumables.attributes.push(attribute);
        }
        const classes = element.getClassNames();
        for (const className of classes) {
          consumables.classes.push(className);
        }
        const styles = element.getStyleNames();
        for (const style of styles) {
          consumables.styles.push(style);
        }
        return consumables;
      }
      /**
      * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
      * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
      * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
      *
      * @param from View node or document fragment from which `ViewConsumable` will be created.
      * @param instance If provided, given `ViewConsumable` instance will be used
      * to add all consumables. It will be returned instead of a new instance.
      */
      static createFrom(from, instance) {
        if (!instance) {
          instance = new ViewConsumable();
        }
        if (from.is("$text")) {
          instance.add(from);
          return instance;
        }
        if (from.is("element")) {
          instance.add(from, ViewConsumable.consumablesFromElement(from));
        }
        if (from.is("documentFragment")) {
          instance.add(from);
        }
        for (const child of from.getChildren()) {
          instance = ViewConsumable.createFrom(child, instance);
        }
        return instance;
      }
    }
    const CONSUMABLE_TYPES = [
      "attributes",
      "classes",
      "styles"
    ];
    class ViewElementConsumables {
      /**
      * Creates ViewElementConsumables instance.
      *
      * @param from View node or document fragment from which `ViewElementConsumables` is being created.
      */
      constructor(from) {
        __publicField(this, "element");
        /**
        * Flag indicating if name of the element can be consumed.
        */
        __publicField(this, "_canConsumeName");
        /**
        * Contains maps of element's consumables: attributes, classes and styles.
        */
        __publicField(this, "_consumables");
        this.element = from;
        this._canConsumeName = null;
        this._consumables = {
          attributes: /* @__PURE__ */ new Map(),
          styles: /* @__PURE__ */ new Map(),
          classes: /* @__PURE__ */ new Map()
        };
      }
      /**
      * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
      * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
      * styles still could be consumed):
      *
      * ```ts
      * consumables.add( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
      * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
      *
      * @param consumables Object describing which parts of the element can be consumed.
      * @param consumables.name If set to `true` element's name will be added as consumable.
      * @param consumables.attributes Attribute name or array of attribute names to add as consumable.
      * @param consumables.classes Class name or array of class names to add as consumable.
      * @param consumables.styles Style name or array of style names to add as consumable.
      */
      add(consumables) {
        if (consumables.name) {
          this._canConsumeName = true;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            this._add(type, consumables[type]);
          }
        }
      }
      /**
      * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
      *
      * Element's name can be tested:
      *
      * ```ts
      * consumables.test( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * @param consumables Object describing which parts of the element should be tested.
      * @param consumables.name If set to `true` element's name will be tested.
      * @param consumables.attributes Attribute name or array of attribute names to test.
      * @param consumables.classes Class name or array of class names to test.
      * @param consumables.styles Style name or array of style names to test.
      * @returns `true` when all tested items can be consumed, `null` when even one of the items
      * was never marked for consumption and `false` when even one of the items was already consumed.
      */
      test(consumables) {
        if (consumables.name && !this._canConsumeName) {
          return this._canConsumeName;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            const value = this._test(type, consumables[type]);
            if (value !== true) {
              return value;
            }
          }
        }
        return true;
      }
      /**
      * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
      * is already consumed - it consumes all consumable items provided.
      * Element's name can be consumed:
      *
      * ```ts
      * consumables.consume( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * @param consumables Object describing which parts of the element should be consumed.
      * @param consumables.name If set to `true` element's name will be consumed.
      * @param consumables.attributes Attribute name or array of attribute names to consume.
      * @param consumables.classes Class name or array of class names to consume.
      * @param consumables.styles Style name or array of style names to consume.
      */
      consume(consumables) {
        if (consumables.name) {
          this._canConsumeName = false;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            this._consume(type, consumables[type]);
          }
        }
      }
      /**
      * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
      * Element's name can be reverted:
      *
      * ```ts
      * consumables.revert( { name: true } );
      * ```
      *
      * Attributes classes and styles:
      *
      * ```ts
      * consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
      * consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
      * ```
      *
      * @param consumables Object describing which parts of the element should be reverted.
      * @param consumables.name If set to `true` element's name will be reverted.
      * @param consumables.attributes Attribute name or array of attribute names to revert.
      * @param consumables.classes Class name or array of class names to revert.
      * @param consumables.styles Style name or array of style names to revert.
      */
      revert(consumables) {
        if (consumables.name) {
          this._canConsumeName = true;
        }
        for (const type of CONSUMABLE_TYPES) {
          if (type in consumables) {
            this._revert(type, consumables[type]);
          }
        }
      }
      /**
      * Helper method that adds consumables of a given type: attribute, class or style.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
      * type is provided - it should be handled separately by providing actual style/class type.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
      * @param item Consumable item or array of items.
      */
      _add(type, item) {
        const items = toArray$1(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            throw new CKEditorError("viewconsumable-invalid-attribute", this);
          }
          consumables.set(name, true);
          if (type === "styles") {
            for (const alsoName of this.element.document.stylesProcessor.getRelatedStyles(name)) {
              consumables.set(alsoName, true);
            }
          }
        }
      }
      /**
      * Helper method that tests consumables of a given type: attribute, class or style.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
      * @param item Consumable item or array of items.
      * @returns Returns `true` if all items can be consumed, `null` when one of the items cannot be
      * consumed and `false` when one of the items is already consumed.
      */
      _test(type, item) {
        const items = toArray$1(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            const consumableName = name == "class" ? "classes" : "styles";
            const value = this._test(consumableName, [
              ...this._consumables[consumableName].keys()
            ]);
            if (value !== true) {
              return value;
            }
          } else {
            const value = consumables.get(name);
            if (value === void 0) {
              return null;
            }
            if (!value) {
              return false;
            }
          }
        }
        return true;
      }
      /**
      * Helper method that consumes items of a given type: attribute, class or style.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or `styles`.
      * @param item Consumable item or array of items.
      */
      _consume(type, item) {
        const items = toArray$1(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            const consumableName = name == "class" ? "classes" : "styles";
            this._consume(consumableName, [
              ...this._consumables[consumableName].keys()
            ]);
          } else {
            consumables.set(name, false);
            if (type == "styles") {
              for (const toConsume of this.element.document.stylesProcessor.getRelatedStyles(name)) {
                consumables.set(toConsume, false);
              }
            }
          }
        }
      }
      /**
      * Helper method that reverts items of a given type: attribute, class or style.
      *
      * @param type Type of the consumable item: `attributes`, `classes` or , `styles`.
      * @param item Consumable item or array of items.
      */
      _revert(type, item) {
        const items = toArray$1(item);
        const consumables = this._consumables[type];
        for (const name of items) {
          if (type === "attributes" && (name === "class" || name === "style")) {
            const consumableName = name == "class" ? "classes" : "styles";
            this._revert(consumableName, [
              ...this._consumables[consumableName].keys()
            ]);
          } else {
            const value = consumables.get(name);
            if (value === false) {
              consumables.set(name, true);
            }
          }
        }
      }
    }
    class Schema extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a schema instance.
      */
      constructor() {
        super();
        __publicField(this, "_sourceDefinitions", {});
        /**
        * A dictionary containing attribute properties.
        */
        __publicField(this, "_attributeProperties", {});
        __publicField(this, "_compiledDefinitions");
        this.decorate("checkChild");
        this.decorate("checkAttribute");
        this.on("checkAttribute", (evt, args) => {
          args[0] = new SchemaContext(args[0]);
        }, {
          priority: "highest"
        });
        this.on("checkChild", (evt, args) => {
          args[0] = new SchemaContext(args[0]);
          args[1] = this.getDefinition(args[1]);
        }, {
          priority: "highest"
        });
      }
      /**
      * Registers a schema item. Can only be called once for every item name.
      *
      * ```ts
      * schema.register( 'paragraph', {
      * 	inheritAllFrom: '$block'
      * } );
      * ```
      */
      register(itemName, definition) {
        if (this._sourceDefinitions[itemName]) {
          throw new CKEditorError("schema-cannot-register-item-twice", this, {
            itemName
          });
        }
        this._sourceDefinitions[itemName] = [
          Object.assign({}, definition)
        ];
        this._clearCache();
      }
      /**
      * Extends a {@link #register registered} item's definition.
      *
      * Extending properties such as `allowIn` will add more items to the existing properties,
      * while redefining properties such as `isBlock` will override the previously defined ones.
      *
      * ```ts
      * schema.register( 'foo', {
      * 	allowIn: '$root',
      * 	isBlock: true;
      * } );
      * schema.extend( 'foo', {
      * 	allowIn: 'blockQuote',
      * 	isBlock: false
      * } );
      *
      * schema.getDefinition( 'foo' );
      * //	{
      * //		allowIn: [ '$root', 'blockQuote' ],
      * // 		isBlock: false
      * //	}
      * ```
      */
      extend(itemName, definition) {
        if (!this._sourceDefinitions[itemName]) {
          throw new CKEditorError("schema-cannot-extend-missing-item", this, {
            itemName
          });
        }
        this._sourceDefinitions[itemName].push(Object.assign({}, definition));
        this._clearCache();
      }
      /**
      * Returns data of all registered items.
      *
      * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
      * checking a list of all block elements, etc).
      * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
      * in other cases.
      */
      getDefinitions() {
        if (!this._compiledDefinitions) {
          this._compile();
        }
        return this._compiledDefinitions;
      }
      /**
      * Returns a definition of the given item or `undefined` if an item is not registered.
      *
      * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
      * checking a list of all block elements, etc).
      * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
      * in other cases.
      */
      getDefinition(item) {
        let itemName;
        if (typeof item == "string") {
          itemName = item;
        } else if ("is" in item && (item.is("$text") || item.is("$textProxy"))) {
          itemName = "$text";
        } else {
          itemName = item.name;
        }
        return this.getDefinitions()[itemName];
      }
      /**
      * Returns `true` if the given item is registered in the schema.
      *
      * ```ts
      * schema.isRegistered( 'paragraph' ); // -> true
      * schema.isRegistered( editor.model.document.getRoot() ); // -> true
      * schema.isRegistered( 'foo' ); // -> false
      * ```
      */
      isRegistered(item) {
        return !!this.getDefinition(item);
      }
      /**
      * Returns `true` if the given item is defined to be
      * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
      *
      * ```ts
      * schema.isBlock( 'paragraph' ); // -> true
      * schema.isBlock( '$root' ); // -> false
      *
      * const paragraphElement = writer.createElement( 'paragraph' );
      * schema.isBlock( paragraphElement ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#block-elements Block elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isBlock(item) {
        const def = this.getDefinition(item);
        return !!(def && def.isBlock);
      }
      /**
      * Returns `true` if the given item should be treated as a limit element.
      *
      * It considers an item to be a limit element if its
      * {@link module:engine/model/schema~SchemaItemDefinition}'s
      * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
      * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
      * was set to `true`.
      *
      * ```ts
      * schema.isLimit( 'paragraph' ); // -> false
      * schema.isLimit( '$root' ); // -> true
      * schema.isLimit( editor.model.document.getRoot() ); // -> true
      * schema.isLimit( 'imageBlock' ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#limit-elements Limit elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isLimit(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isLimit || def.isObject);
      }
      /**
      * Returns `true` if the given item should be treated as an object element.
      *
      * It considers an item to be an object element if its
      * {@link module:engine/model/schema~SchemaItemDefinition}'s
      * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
      * was set to `true`.
      *
      * ```ts
      * schema.isObject( 'paragraph' ); // -> false
      * schema.isObject( 'imageBlock' ); // -> true
      *
      * const imageElement = writer.createElement( 'imageBlock' );
      * schema.isObject( imageElement ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#object-elements Object elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isObject(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isObject || def.isLimit && def.isSelectable && def.isContent);
      }
      /**
      * Returns `true` if the given item is defined to be
      * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
      *
      * ```ts
      * schema.isInline( 'paragraph' ); // -> false
      * schema.isInline( 'softBreak' ); // -> true
      *
      * const text = writer.createText( 'foo' );
      * schema.isInline( text ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#inline-elements Inline elements} section of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isInline(item) {
        const def = this.getDefinition(item);
        return !!(def && def.isInline);
      }
      /**
      * Returns `true` if the given item is defined to be
      * a selectable element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isSelectable` property.
      *
      * ```ts
      * schema.isSelectable( 'paragraph' ); // -> false
      * schema.isSelectable( 'heading1' ); // -> false
      * schema.isSelectable( 'imageBlock' ); // -> true
      * schema.isSelectable( 'tableCell' ); // -> true
      *
      * const text = writer.createText( 'foo' );
      * schema.isSelectable( text ); // -> false
      * ```
      *
      * See the {@glink framework/deep-dive/schema#selectable-elements Selectable elements section} of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isSelectable(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isSelectable || def.isObject);
      }
      /**
      * Returns `true` if the given item is defined to be
      * a content by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isContent` property.
      *
      * ```ts
      * schema.isContent( 'paragraph' ); // -> false
      * schema.isContent( 'heading1' ); // -> false
      * schema.isContent( 'imageBlock' ); // -> true
      * schema.isContent( 'horizontalLine' ); // -> true
      *
      * const text = writer.createText( 'foo' );
      * schema.isContent( text ); // -> true
      * ```
      *
      * See the {@glink framework/deep-dive/schema#content-elements Content elements section} of
      * the {@glink framework/deep-dive/schema Schema deep-dive} guide for more details.
      */
      isContent(item) {
        const def = this.getDefinition(item);
        if (!def) {
          return false;
        }
        return !!(def.isContent || def.isObject);
      }
      /**
      * Checks whether the given node (`child`) can be a child of the given context.
      *
      * ```ts
      * schema.checkChild( model.document.getRoot(), paragraph ); // -> false
      *
      * schema.register( 'paragraph', {
      * 	allowIn: '$root'
      * } );
      * schema.checkChild( model.document.getRoot(), paragraph ); // -> true
      * ```
      *
      * Note: When verifying whether the given node can be a child of the given context, the
      * schema also verifies the entire context &ndash; from its root to its last element. Therefore, it is possible
      * for `checkChild()` to return `false` even though the context's last element can contain the checked child.
      * It happens if one of the context's elements does not allow its child.
      *
      * @fires checkChild
      * @param context The context in which the child will be checked.
      * @param def The child to check.
      */
      checkChild(context, def) {
        if (!def) {
          return false;
        }
        return this._checkContextMatch(def, context);
      }
      /**
      * Checks whether the given attribute can be applied in the given context (on the last
      * item of the context).
      *
      * ```ts
      * schema.checkAttribute( textNode, 'bold' ); // -> false
      *
      * schema.extend( '$text', {
      * 	allowAttributes: 'bold'
      * } );
      * schema.checkAttribute( textNode, 'bold' ); // -> true
      * ```
      *
      * @fires checkAttribute
      * @param context The context in which the attribute will be checked.
      */
      checkAttribute(context, attributeName) {
        const def = this.getDefinition(context.last);
        if (!def) {
          return false;
        }
        return def.allowAttributes.includes(attributeName);
      }
      /**
      * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
      *
      * In other words &ndash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.
      *
      * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
      * will be valid.
      *
      * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
      * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
      *
      * @param positionOrBaseElement The position or base element to which the `elementToMerge` will be merged.
      * @param elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
      */
      checkMerge(positionOrBaseElement, elementToMerge) {
        if (positionOrBaseElement instanceof Position) {
          const nodeBefore = positionOrBaseElement.nodeBefore;
          const nodeAfter = positionOrBaseElement.nodeAfter;
          if (!(nodeBefore instanceof Element)) {
            throw new CKEditorError("schema-check-merge-no-element-before", this);
          }
          if (!(nodeAfter instanceof Element)) {
            throw new CKEditorError("schema-check-merge-no-element-after", this);
          }
          return this.checkMerge(nodeBefore, nodeAfter);
        }
        for (const child of elementToMerge.getChildren()) {
          if (!this.checkChild(positionOrBaseElement, child)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Allows registering a callback to the {@link #checkChild} method calls.
      *
      * Callbacks allow you to implement rules which are not otherwise possible to achieve
      * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
      * For example, by using this method you can disallow elements in specific contexts.
      *
      * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,
      * you can use that event instead.
      *
      * Example:
      *
      * ```ts
      * // Disallow heading1 directly inside a blockQuote.
      * schema.addChildCheck( ( context, childDefinition ) => {
      * 	if ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {
      * 		return false;
      * 	}
      * } );
      * ```
      *
      * Which translates to:
      *
      * ```ts
      * schema.on( 'checkChild', ( evt, args ) => {
      * 	const context = args[ 0 ];
      * 	const childDefinition = args[ 1 ];
      *
      * 	if ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {
      * 		// Prevent next listeners from being called.
      * 		evt.stop();
      * 		// Set the checkChild()'s return value.
      * 		evt.return = false;
      * 	}
      * }, { priority: 'high' } );
      * ```
      *
      * @param callback The callback to be called. It is called with two parameters:
      * {@link module:engine/model/schema~SchemaContext} (context) instance and
      * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).
      * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return
      * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.
      */
      addChildCheck(callback) {
        this.on("checkChild", (evt, [ctx, childDef]) => {
          if (!childDef) {
            return;
          }
          const retValue = callback(ctx, childDef);
          if (typeof retValue == "boolean") {
            evt.stop();
            evt.return = retValue;
          }
        }, {
          priority: "high"
        });
      }
      /**
      * Allows registering a callback to the {@link #checkAttribute} method calls.
      *
      * Callbacks allow you to implement rules which are not otherwise possible to achieve
      * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
      * For example, by using this method you can disallow attribute if node to which it is applied
      * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).
      *
      * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,
      * you can use that event instead.
      *
      * Example:
      *
      * ```ts
      * // Disallow bold on $text inside heading1.
      * schema.addAttributeCheck( ( context, attributeName ) => {
      * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
      * 		return false;
      * 	}
      * } );
      * ```
      *
      * Which translates to:
      *
      * ```ts
      * schema.on( 'checkAttribute', ( evt, args ) => {
      * 	const context = args[ 0 ];
      * 	const attributeName = args[ 1 ];
      *
      * 	if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
      * 		// Prevent next listeners from being called.
      * 		evt.stop();
      * 		// Set the checkAttribute()'s return value.
      * 		evt.return = false;
      * 	}
      * }, { priority: 'high' } );
      * ```
      *
      * @param callback The callback to be called. It is called with two parameters:
      * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.
      * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return
      * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.
      */
      addAttributeCheck(callback) {
        this.on("checkAttribute", (evt, [ctx, attributeName]) => {
          const retValue = callback(ctx, attributeName);
          if (typeof retValue == "boolean") {
            evt.stop();
            evt.return = retValue;
          }
        }, {
          priority: "high"
        });
      }
      /**
      * This method allows assigning additional metadata to the model attributes. For example,
      * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
      * used to mark formatting attributes (like `bold` or `italic`).
      *
      * ```ts
      * // Mark bold as a formatting attribute.
      * schema.setAttributeProperties( 'bold', {
      * 	isFormatting: true
      * } );
      *
      * // Override code not to be considered a formatting markup.
      * schema.setAttributeProperties( 'code', {
      * 	isFormatting: false
      * } );
      * ```
      *
      * Properties are not limited to members defined in the
      * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
      *
      * ```ts
      * schema.setAttributeProperties( 'blockQuote', {
      * 	customProperty: 'value'
      * } );
      * ```
      *
      * Subsequent calls with the same attribute will extend its custom properties:
      *
      * ```ts
      * schema.setAttributeProperties( 'blockQuote', {
      * 	one: 1
      * } );
      *
      * schema.setAttributeProperties( 'blockQuote', {
      * 	two: 2
      * } );
      *
      * console.log( schema.getAttributeProperties( 'blockQuote' ) );
      * // Logs: { one: 1, two: 2 }
      * ```
      *
      * @param attributeName A name of the attribute to receive the properties.
      * @param properties A dictionary of properties.
      */
      setAttributeProperties(attributeName, properties) {
        this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);
      }
      /**
      * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
      *
      * @param attributeName A name of the attribute.
      */
      getAttributeProperties(attributeName) {
        return this._attributeProperties[attributeName] || {};
      }
      /**
      * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
      * selection/range/position or the root otherwise.
      *
      * @param selectionOrRangeOrPosition The selection/range/position to check.
      * @returns The lowest limit element containing the entire `selectionOrRangeOrPosition`.
      */
      getLimitElement(selectionOrRangeOrPosition) {
        let element;
        if (selectionOrRangeOrPosition instanceof Position) {
          element = selectionOrRangeOrPosition.parent;
        } else {
          const ranges = selectionOrRangeOrPosition instanceof Range ? [
            selectionOrRangeOrPosition
          ] : Array.from(selectionOrRangeOrPosition.getRanges());
          element = ranges.reduce((element2, range) => {
            const rangeCommonAncestor = range.getCommonAncestor();
            if (!element2) {
              return rangeCommonAncestor;
            }
            return element2.getCommonAncestor(rangeCommonAncestor, {
              includeSelf: true
            });
          }, null);
        }
        while (!this.isLimit(element)) {
          if (element.parent) {
            element = element.parent;
          } else {
            break;
          }
        }
        return element;
      }
      /**
      * Checks whether the attribute is allowed in selection:
      *
      * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
      * * if the selection is collapsed, then checks if on the selection position there's a text with the
      * specified attribute allowed.
      *
      * @param selection Selection which will be checked.
      * @param attribute The name of the attribute to check.
      */
      checkAttributeInSelection(selection, attribute) {
        if (selection.isCollapsed) {
          const firstPosition = selection.getFirstPosition();
          const context = [
            ...firstPosition.getAncestors(),
            new Text("", selection.getAttributes())
          ];
          return this.checkAttribute(context, attribute);
        } else {
          const ranges = selection.getRanges();
          for (const range of ranges) {
            for (const value of range) {
              if (this.checkAttribute(value.item, attribute)) {
                return true;
              }
            }
          }
        }
        return false;
      }
      /**
      * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
      *
      * @param ranges Ranges to be validated.
      * @param attribute The name of the attribute to check.
      * @returns Ranges in which the attribute is allowed.
      */
      *getValidRanges(ranges, attribute) {
        ranges = convertToMinimalFlatRanges(ranges);
        for (const range of ranges) {
          yield* this._getValidRangesForRange(range, attribute);
        }
      }
      /**
      * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
      * nearest to that `position` and is a correct range for selection.
      *
      * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
      * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
      * the {@link module:engine/model/schema~Schema schema}.
      *
      * Direction of searching for the nearest correct selection range can be specified as:
      *
      * * `both` - searching will be performed in both ways,
      * * `forward` - searching will be performed only forward,
      * * `backward` - searching will be performed only backward.
      *
      * When valid selection range cannot be found, `null` is returned.
      *
      * @param position Reference position where new selection range should be looked for.
      * @param direction Search direction.
      * @returns Nearest selection range or `null` if one cannot be found.
      */
      getNearestSelectionRange(position, direction = "both") {
        if (position.root.rootName == "$graveyard") {
          return null;
        }
        if (this.checkChild(position, "$text")) {
          return new Range(position);
        }
        let backwardWalker, forwardWalker;
        const limitElement = position.getAncestors().reverse().find((item) => this.isLimit(item)) || position.root;
        if (direction == "both" || direction == "backward") {
          backwardWalker = new TreeWalker({
            boundaries: Range._createIn(limitElement),
            startPosition: position,
            direction: "backward"
          });
        }
        if (direction == "both" || direction == "forward") {
          forwardWalker = new TreeWalker({
            boundaries: Range._createIn(limitElement),
            startPosition: position
          });
        }
        for (const data of combineWalkers(backwardWalker, forwardWalker)) {
          const type = data.walker == backwardWalker ? "elementEnd" : "elementStart";
          const value = data.value;
          if (value.type == type && this.isObject(value.item)) {
            return Range._createOn(value.item);
          }
          if (this.checkChild(value.nextPosition, "$text")) {
            return new Range(value.nextPosition);
          }
        }
        return null;
      }
      /**
      * Tries to find position ancestors that allow to insert a given node.
      * It starts searching from the given position and goes node by node to the top of the model tree
      * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
      * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
      *
      * @param position The position that the search will start from.
      * @param node The node for which an allowed parent should be found or its name.
      * @returns Allowed parent or null if nothing was found.
      */
      findAllowedParent(position, node) {
        let parent2 = position.parent;
        while (parent2) {
          if (this.checkChild(parent2, node)) {
            return parent2;
          }
          if (this.isLimit(parent2)) {
            return null;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Sets attributes allowed by the schema on a given node.
      *
      * @param node A node to set attributes on.
      * @param attributes Attributes keys and values.
      * @param writer An instance of the model writer.
      */
      setAllowedAttributes(node, attributes, writer) {
        const model = writer.model;
        for (const [attributeName, attributeValue] of Object.entries(attributes)) {
          if (model.schema.checkAttribute(node, attributeName)) {
            writer.setAttribute(attributeName, attributeValue, node);
          }
        }
      }
      /**
      * Removes attributes disallowed by the schema.
      *
      * @param nodes Nodes that will be filtered.
      */
      removeDisallowedAttributes(nodes, writer) {
        for (const node of nodes) {
          if (node.is("$text")) {
            removeDisallowedAttributeFromNode(this, node, writer);
          } else {
            const rangeInNode = Range._createIn(node);
            const positionsInRange = rangeInNode.getPositions();
            for (const position of positionsInRange) {
              const item = position.nodeBefore || position.parent;
              removeDisallowedAttributeFromNode(this, item, writer);
            }
          }
        }
      }
      /**
      * Gets attributes of a node that have a given property.
      *
      * @param node Node to get attributes from.
      * @param propertyName Name of the property that attribute must have to return it.
      * @param propertyValue Desired value of the property that we want to check.
      * When `undefined` attributes will be returned if they have set a given property no matter what the value is. If specified it will
      * return attributes which given property's value is equal to this parameter.
      * @returns Object with attributes' names as key and attributes' values as value.
      */
      getAttributesWithProperty(node, propertyName, propertyValue) {
        const attributes = {};
        for (const [attributeName, attributeValue] of node.getAttributes()) {
          const attributeProperties = this.getAttributeProperties(attributeName);
          if (attributeProperties[propertyName] === void 0) {
            continue;
          }
          if (propertyValue === void 0 || propertyValue === attributeProperties[propertyName]) {
            attributes[attributeName] = attributeValue;
          }
        }
        return attributes;
      }
      /**
      * Creates an instance of the schema context.
      */
      createContext(context) {
        return new SchemaContext(context);
      }
      _clearCache() {
        this._compiledDefinitions = null;
      }
      _compile() {
        const definitions = {};
        const sourceRules = this._sourceDefinitions;
        const itemNames = Object.keys(sourceRules);
        for (const itemName of itemNames) {
          definitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);
        }
        const items = Object.values(definitions);
        for (const item of items) {
          propagateAllowIn(definitions, item);
          propagateAllowChildren(definitions, item);
          propagateDisallowIn(definitions, item);
          propagateDisallowChildren(definitions, item);
        }
        for (const item of items) {
          resolveDisallows(definitions, item);
        }
        for (const item of items) {
          compileAllowContentOf(definitions, item);
        }
        for (const item of items) {
          compileAllowWhere(definitions, item);
        }
        for (const item of items) {
          compileAllowAttributesOf(definitions, item);
        }
        for (const item of items) {
          compileInheritPropertiesFrom(definitions, item);
        }
        this._compiledDefinitions = compileDefinitions(definitions);
      }
      _checkContextMatch(def, context, contextItemIndex = context.length - 1) {
        const contextItem = context.getItem(contextItemIndex);
        if (def.allowIn.includes(contextItem.name)) {
          if (contextItemIndex == 0) {
            return true;
          } else {
            const parentRule = this.getDefinition(contextItem);
            return this._checkContextMatch(parentRule, context, contextItemIndex - 1);
          }
        } else {
          return false;
        }
      }
      /**
      * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
      * inside the given range on which the attribute can be applied.
      *
      * This is a helper function for {@link ~Schema#getValidRanges}.
      *
      * @param range The range to process.
      * @param attribute The name of the attribute to check.
      * @returns Ranges in which the attribute is allowed.
      */
      *_getValidRangesForRange(range, attribute) {
        let start = range.start;
        let end = range.start;
        for (const item of range.getItems({
          shallow: true
        })) {
          if (item.is("element")) {
            yield* this._getValidRangesForRange(Range._createIn(item), attribute);
          }
          if (!this.checkAttribute(item, attribute)) {
            if (!start.isEqual(end)) {
              yield new Range(start, end);
            }
            start = Position._createAfter(item);
          }
          end = Position._createAfter(item);
        }
        if (!start.isEqual(end)) {
          yield new Range(start, end);
        }
      }
      /**
      * Returns a model range which is optimal (in terms of UX) for inserting a widget block.
      *
      * For instance, if a selection is in the middle of a paragraph, the collapsed range before this paragraph
      * will be returned so that it is not split. If the selection is at the end of a paragraph,
      * the collapsed range after this paragraph will be returned.
      *
      * Note: If the selection is placed in an empty block, the range in that block will be returned. If that range
      * is then passed to {@link module:engine/model/model~Model#insertContent}, the block will be fully replaced
      * by the inserted widget block.
      *
      * @internal
      * @param selection The selection based on which the insertion position should be calculated.
      * @param place The place where to look for optimal insertion range.
      * The `auto` value will determine itself the best position for insertion.
      * The `before` value will try to find a position before selection.
      * The `after` value will try to find a position after selection.
      * @returns The optimal range.
      */
      findOptimalInsertionRange(selection, place) {
        const selectedElement = selection.getSelectedElement();
        if (selectedElement && this.isObject(selectedElement) && !this.isInline(selectedElement)) {
          if (place == "before" || place == "after") {
            return new Range(Position._createAt(selectedElement, place));
          }
          return Range._createOn(selectedElement);
        }
        const firstBlock = first(selection.getSelectedBlocks());
        if (!firstBlock) {
          return new Range(selection.focus);
        }
        if (firstBlock.isEmpty) {
          return new Range(Position._createAt(firstBlock, 0));
        }
        const positionAfter = Position._createAfter(firstBlock);
        if (selection.focus.isTouching(positionAfter)) {
          return new Range(positionAfter);
        }
        return new Range(Position._createBefore(firstBlock));
      }
    }
    class SchemaContext {
      /**
      * Creates an instance of the context.
      */
      constructor(context) {
        __publicField(this, "_items");
        if (context instanceof SchemaContext) {
          return context;
        }
        let items;
        if (typeof context == "string") {
          items = [
            context
          ];
        } else if (!Array.isArray(context)) {
          items = context.getAncestors({
            includeSelf: true
          });
        } else {
          items = context;
        }
        this._items = items.map(mapContextItem);
      }
      /**
      * The number of items.
      */
      get length() {
        return this._items.length;
      }
      /**
      * The last item (the lowest node).
      */
      get last() {
        return this._items[this._items.length - 1];
      }
      /**
      * Iterable interface.
      *
      * Iterates over all context items.
      */
      [Symbol.iterator]() {
        return this._items[Symbol.iterator]();
      }
      /**
      * Returns a new schema context instance with an additional item.
      *
      * Item can be added as:
      *
      * ```ts
      * const context = new SchemaContext( [ '$root' ] );
      *
      * // An element.
      * const fooElement = writer.createElement( 'fooElement' );
      * const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
      *
      * // A text node.
      * const text = writer.createText( 'foobar' );
      * const newContext = context.push( text ); // [ '$root', '$text' ]
      *
      * // A string (element name).
      * const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
      * ```
      *
      * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
      * (without ancestors).
      *
      * @param item An item that will be added to the current context.
      * @returns A new schema context instance with an additional item.
      */
      push(item) {
        const ctx = new SchemaContext([
          item
        ]);
        ctx._items = [
          ...this._items,
          ...ctx._items
        ];
        return ctx;
      }
      /**
      * Gets an item on the given index.
      */
      getItem(index2) {
        return this._items[index2];
      }
      /**
      * Returns the names of items.
      */
      *getNames() {
        yield* this._items.map((item) => item.name);
      }
      /**
      * Checks whether the context ends with the given nodes.
      *
      * ```ts
      * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
      *
      * ctx.endsWith( '$text' ); // -> true
      * ctx.endsWith( 'paragraph $text' ); // -> true
      * ctx.endsWith( '$root' ); // -> false
      * ctx.endsWith( 'paragraph' ); // -> false
      * ```
      */
      endsWith(query) {
        return Array.from(this.getNames()).join(" ").endsWith(query);
      }
      /**
      * Checks whether the context starts with the given nodes.
      *
      * ```ts
      * const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
      *
      * ctx.endsWith( '$root' ); // -> true
      * ctx.endsWith( '$root paragraph' ); // -> true
      * ctx.endsWith( '$text' ); // -> false
      * ctx.endsWith( 'paragraph' ); // -> false
      * ```
      */
      startsWith(query) {
        return Array.from(this.getNames()).join(" ").startsWith(query);
      }
    }
    function compileBaseItemRule(sourceItemRules, itemName) {
      const itemRule = {
        name: itemName,
        allowIn: /* @__PURE__ */ new Set(),
        allowChildren: /* @__PURE__ */ new Set(),
        disallowIn: /* @__PURE__ */ new Set(),
        disallowChildren: /* @__PURE__ */ new Set(),
        allowContentOf: /* @__PURE__ */ new Set(),
        allowWhere: /* @__PURE__ */ new Set(),
        allowAttributes: /* @__PURE__ */ new Set(),
        disallowAttributes: /* @__PURE__ */ new Set(),
        allowAttributesOf: /* @__PURE__ */ new Set(),
        inheritTypesFrom: /* @__PURE__ */ new Set()
      };
      copyTypes(sourceItemRules, itemRule);
      copyProperty(sourceItemRules, itemRule, "allowIn");
      copyProperty(sourceItemRules, itemRule, "allowChildren");
      copyProperty(sourceItemRules, itemRule, "disallowIn");
      copyProperty(sourceItemRules, itemRule, "disallowChildren");
      copyProperty(sourceItemRules, itemRule, "allowContentOf");
      copyProperty(sourceItemRules, itemRule, "allowWhere");
      copyProperty(sourceItemRules, itemRule, "allowAttributes");
      copyProperty(sourceItemRules, itemRule, "disallowAttributes");
      copyProperty(sourceItemRules, itemRule, "allowAttributesOf");
      copyProperty(sourceItemRules, itemRule, "inheritTypesFrom");
      resolveInheritAll(sourceItemRules, itemRule);
      return itemRule;
    }
    function propagateAllowIn(definitions, item) {
      for (const parentName of item.allowIn) {
        const parentItem = definitions[parentName];
        if (parentItem) {
          parentItem.allowChildren.add(item.name);
        } else {
          item.allowIn.delete(parentName);
        }
      }
    }
    function propagateAllowChildren(definitions, item) {
      for (const childName of item.allowChildren) {
        const childItem = definitions[childName];
        if (childItem) {
          childItem.allowIn.add(item.name);
        } else {
          item.allowChildren.delete(childName);
        }
      }
    }
    function propagateDisallowIn(definitions, item) {
      for (const parentName of item.disallowIn) {
        const parentItem = definitions[parentName];
        if (parentItem) {
          parentItem.disallowChildren.add(item.name);
        } else {
          item.disallowIn.delete(parentName);
        }
      }
    }
    function propagateDisallowChildren(definitions, item) {
      for (const childName of item.disallowChildren) {
        const childItem = definitions[childName];
        if (childItem) {
          childItem.disallowIn.add(item.name);
        } else {
          item.disallowChildren.delete(childName);
        }
      }
    }
    function resolveDisallows(definitions, item) {
      for (const childName of item.disallowChildren) {
        item.allowChildren.delete(childName);
      }
      for (const parentName of item.disallowIn) {
        item.allowIn.delete(parentName);
      }
      for (const attributeName of item.disallowAttributes) {
        item.allowAttributes.delete(attributeName);
      }
    }
    function compileAllowContentOf(definitions, item) {
      for (const allowContentOfItemName of item.allowContentOf) {
        const baseItem = definitions[allowContentOfItemName];
        if (!baseItem) {
          continue;
        }
        baseItem.disallowChildren.forEach((childName) => {
          if (item.allowChildren.has(childName)) {
            return;
          }
          item.disallowChildren.add(childName);
          definitions[childName].disallowIn.add(item.name);
        });
        baseItem.allowChildren.forEach((childName) => {
          if (item.disallowChildren.has(childName)) {
            return;
          }
          item.allowChildren.add(childName);
          definitions[childName].allowIn.add(item.name);
        });
      }
    }
    function compileAllowWhere(definitions, item) {
      for (const allowWhereItemName of item.allowWhere) {
        const baseItem = definitions[allowWhereItemName];
        if (!baseItem) {
          continue;
        }
        baseItem.disallowIn.forEach((parentName) => {
          if (item.allowIn.has(parentName)) {
            return;
          }
          item.disallowIn.add(parentName);
          definitions[parentName].disallowChildren.add(item.name);
        });
        baseItem.allowIn.forEach((parentName) => {
          if (item.disallowIn.has(parentName)) {
            return;
          }
          item.allowIn.add(parentName);
          definitions[parentName].allowChildren.add(item.name);
        });
      }
    }
    function compileDefinitions(definitions) {
      const finalDefinitions = {};
      for (const item of Object.values(definitions)) {
        finalDefinitions[item.name] = {
          name: item.name,
          // `is*` properties may not be set - convert `undefined` to `false`.
          isBlock: !!item.isBlock,
          isContent: !!item.isContent,
          isInline: !!item.isInline,
          isLimit: !!item.isLimit,
          isObject: !!item.isObject,
          isSelectable: !!item.isSelectable,
          // Filter out non-existing items.
          allowIn: Array.from(item.allowIn).filter((name) => !!definitions[name]),
          allowChildren: Array.from(item.allowChildren).filter((name) => !!definitions[name]),
          allowAttributes: Array.from(item.allowAttributes)
        };
      }
      return finalDefinitions;
    }
    function compileAllowAttributesOf(definitions, item) {
      for (const allowAttributeOfItemName of item.allowAttributesOf) {
        const baseItem = definitions[allowAttributeOfItemName];
        if (!baseItem) {
          return;
        }
        baseItem.allowAttributes.forEach((attributeName) => {
          if (item.disallowAttributes.has(attributeName)) {
            return;
          }
          item.allowAttributes.add(attributeName);
        });
      }
    }
    function compileInheritPropertiesFrom(definitions, item) {
      for (const inheritPropertiesOfItemName of item.inheritTypesFrom) {
        const inheritFrom = definitions[inheritPropertiesOfItemName];
        if (inheritFrom) {
          const typeNames = Object.keys(inheritFrom).filter((name) => name.startsWith("is"));
          for (const name of typeNames) {
            if (!(name in item)) {
              item[name] = inheritFrom[name];
            }
          }
        }
      }
    }
    function copyTypes(sourceItemRules, itemRule) {
      for (const sourceItemRule of sourceItemRules) {
        const typeNames = Object.keys(sourceItemRule).filter((name) => name.startsWith("is"));
        for (const name of typeNames) {
          itemRule[name] = !!sourceItemRule[name];
        }
      }
    }
    function copyProperty(sourceItemRules, itemRule, propertyName) {
      for (const sourceItemRule of sourceItemRules) {
        let value = sourceItemRule[propertyName];
        if (typeof value == "string") {
          value = [
            value
          ];
        }
        if (Array.isArray(value)) {
          value.forEach((singleValue) => itemRule[propertyName].add(singleValue));
        }
      }
    }
    function resolveInheritAll(sourceItemRules, itemRule) {
      for (const sourceItemRule of sourceItemRules) {
        const inheritFrom = sourceItemRule.inheritAllFrom;
        if (inheritFrom) {
          itemRule.allowContentOf.add(inheritFrom);
          itemRule.allowWhere.add(inheritFrom);
          itemRule.allowAttributesOf.add(inheritFrom);
          itemRule.inheritTypesFrom.add(inheritFrom);
        }
      }
    }
    function mapContextItem(ctxItem) {
      if (typeof ctxItem == "string" || ctxItem.is("documentFragment")) {
        return {
          name: typeof ctxItem == "string" ? ctxItem : "$documentFragment",
          *getAttributeKeys() {
          },
          getAttribute() {
          }
        };
      } else {
        return {
          // '$text' means text nodes and text proxies.
          name: ctxItem.is("element") ? ctxItem.name : "$text",
          *getAttributeKeys() {
            yield* ctxItem.getAttributeKeys();
          },
          getAttribute(key) {
            return ctxItem.getAttribute(key);
          }
        };
      }
    }
    function* combineWalkers(backward, forward) {
      let done = false;
      while (!done) {
        done = true;
        if (backward) {
          const step = backward.next();
          if (!step.done) {
            done = false;
            yield {
              walker: backward,
              value: step.value
            };
          }
        }
        if (forward) {
          const step = forward.next();
          if (!step.done) {
            done = false;
            yield {
              walker: forward,
              value: step.value
            };
          }
        }
      }
    }
    function* convertToMinimalFlatRanges(ranges) {
      for (const range of ranges) {
        yield* range.getMinimalFlatRanges();
      }
    }
    function removeDisallowedAttributeFromNode(schema, node, writer) {
      for (const attribute of node.getAttributeKeys()) {
        if (!schema.checkAttribute(node, attribute)) {
          writer.removeAttribute(attribute, node);
        }
      }
    }
    class UpcastDispatcher extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an upcast dispatcher that operates using the passed API.
      *
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
      * @param conversionApi Additional properties for an interface that will be passed to events fired
      * by the upcast dispatcher.
      */
      constructor(conversionApi) {
        super();
        /**
        * An interface passed by the dispatcher to the event callbacks.
        */
        __publicField(this, "conversionApi");
        /**
        * The list of elements that were created during splitting.
        *
        * After the conversion process, the list is cleared.
        */
        __publicField(this, "_splitParts", /* @__PURE__ */ new Map());
        /**
        * The list of cursor parent elements that were created during splitting.
        *
        * After the conversion process the list is cleared.
        */
        __publicField(this, "_cursorParents", /* @__PURE__ */ new Map());
        /**
        * The position in the temporary structure where the converted content is inserted. The structure reflects the context of
        * the target position where the content will be inserted. This property is built based on the context parameter of the
        * convert method.
        */
        __publicField(this, "_modelCursor", null);
        /**
        * The list of elements that were created during the splitting but should not get removed on conversion end even if they are empty.
        *
        * The list is cleared after the conversion process.
        */
        __publicField(this, "_emptyElementsToKeep", /* @__PURE__ */ new Set());
        this.conversionApi = {
          ...conversionApi,
          consumable: null,
          writer: null,
          store: null,
          convertItem: (viewItem, modelCursor) => this._convertItem(viewItem, modelCursor),
          convertChildren: (viewElement, positionOrElement) => this._convertChildren(viewElement, positionOrElement),
          safeInsert: (modelNode, position) => this._safeInsert(modelNode, position),
          updateConversionResult: (modelElement, data) => this._updateConversionResult(modelElement, data),
          // Advanced API - use only if custom position handling is needed.
          splitToAllowedParent: (modelNode, modelCursor) => this._splitToAllowedParent(modelNode, modelCursor),
          getSplitParts: (modelElement) => this._getSplitParts(modelElement),
          keepEmptyElement: (modelElement) => this._keepEmptyElement(modelElement)
        };
      }
      /**
      * Starts the conversion process. The entry point for the conversion.
      *
      * @fires element
      * @fires text
      * @fires documentFragment
      * @param viewElement The part of the view to be converted.
      * @param writer An instance of the model writer.
      * @param context Elements will be converted according to this context.
      * @returns Model data that is the result of the conversion process
      * wrapped in `DocumentFragment`. Converted marker elements will be set as the document fragment's
      * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
      */
      convert(viewElement, writer, context = [
        "$root"
      ]) {
        this.fire("viewCleanup", viewElement);
        this._modelCursor = createContextTree(context, writer);
        this.conversionApi.writer = writer;
        this.conversionApi.consumable = ViewConsumable.createFrom(viewElement);
        this.conversionApi.store = {};
        const { modelRange } = this._convertItem(viewElement, this._modelCursor);
        const documentFragment = writer.createDocumentFragment();
        if (modelRange) {
          this._removeEmptyElements();
          for (const item of Array.from(this._modelCursor.parent.getChildren())) {
            writer.append(item, documentFragment);
          }
          documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);
        }
        this._modelCursor = null;
        this._splitParts.clear();
        this._cursorParents.clear();
        this._emptyElementsToKeep.clear();
        this.conversionApi.writer = null;
        this.conversionApi.store = null;
        return documentFragment;
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
      */
      _convertItem(viewItem, modelCursor) {
        const data = {
          viewItem,
          modelCursor,
          modelRange: null
        };
        if (viewItem.is("element")) {
          this.fire(`element:${viewItem.name}`, data, this.conversionApi);
        } else if (viewItem.is("$text")) {
          this.fire("text", data, this.conversionApi);
        } else {
          this.fire("documentFragment", data, this.conversionApi);
        }
        if (data.modelRange && !(data.modelRange instanceof Range)) {
          throw new CKEditorError("view-conversion-dispatcher-incorrect-result", this);
        }
        return {
          modelRange: data.modelRange,
          modelCursor: data.modelCursor
        };
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
      */
      _convertChildren(viewItem, elementOrModelCursor) {
        let nextModelCursor = elementOrModelCursor.is("position") ? elementOrModelCursor : Position._createAt(elementOrModelCursor, 0);
        const modelRange = new Range(nextModelCursor);
        for (const viewChild of Array.from(viewItem.getChildren())) {
          const result = this._convertItem(viewChild, nextModelCursor);
          if (result.modelRange instanceof Range) {
            modelRange.end = result.modelRange.end;
            nextModelCursor = result.modelCursor;
          }
        }
        return {
          modelRange,
          modelCursor: nextModelCursor
        };
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#safeInsert
      */
      _safeInsert(modelNode, position) {
        const splitResult = this._splitToAllowedParent(modelNode, position);
        if (!splitResult) {
          return false;
        }
        this.conversionApi.writer.insert(modelNode, splitResult.position);
        return true;
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#updateConversionResult
      */
      _updateConversionResult(modelElement, data) {
        const parts = this._getSplitParts(modelElement);
        const writer = this.conversionApi.writer;
        if (!data.modelRange) {
          data.modelRange = writer.createRange(writer.createPositionBefore(modelElement), writer.createPositionAfter(parts[parts.length - 1]));
        }
        const savedCursorParent = this._cursorParents.get(modelElement);
        if (savedCursorParent) {
          data.modelCursor = writer.createPositionAt(savedCursorParent, 0);
        } else {
          data.modelCursor = data.modelRange.end;
        }
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
      */
      _splitToAllowedParent(node, modelCursor) {
        const { schema, writer } = this.conversionApi;
        let allowedParent = schema.findAllowedParent(modelCursor, node);
        if (allowedParent) {
          if (allowedParent === modelCursor.parent) {
            return {
              position: modelCursor
            };
          }
          if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {
            allowedParent = null;
          }
        }
        if (!allowedParent) {
          if (!isParagraphable(modelCursor, node, schema)) {
            return null;
          }
          return {
            position: wrapInParagraph(modelCursor, writer)
          };
        }
        const splitResult = this.conversionApi.writer.split(modelCursor, allowedParent);
        const stack = [];
        for (const treeWalkerValue of splitResult.range.getWalker()) {
          if (treeWalkerValue.type == "elementEnd") {
            stack.push(treeWalkerValue.item);
          } else {
            const originalPart = stack.pop();
            const splitPart = treeWalkerValue.item;
            this._registerSplitPair(originalPart, splitPart);
          }
        }
        const cursorParent = splitResult.range.end.parent;
        this._cursorParents.set(node, cursorParent);
        return {
          position: splitResult.position,
          cursorParent
        };
      }
      /**
      * Registers that a `splitPart` element is a split part of the `originalPart` element.
      *
      * The data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
      */
      _registerSplitPair(originalPart, splitPart) {
        if (!this._splitParts.has(originalPart)) {
          this._splitParts.set(originalPart, [
            originalPart
          ]);
        }
        const list = this._splitParts.get(originalPart);
        this._splitParts.set(splitPart, list);
        list.push(splitPart);
      }
      /**
      * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
      */
      _getSplitParts(element) {
        let parts;
        if (!this._splitParts.has(element)) {
          parts = [
            element
          ];
        } else {
          parts = this._splitParts.get(element);
        }
        return parts;
      }
      /**
      * Mark an element that were created during the splitting to not get removed on conversion end even if it is empty.
      */
      _keepEmptyElement(element) {
        this._emptyElementsToKeep.add(element);
      }
      /**
      * Checks if there are any empty elements created while splitting and removes them.
      *
      * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
      * as some elements might have become empty after other empty elements were removed from them.
      */
      _removeEmptyElements() {
        let anyRemoved = false;
        for (const element of this._splitParts.keys()) {
          if (element.isEmpty && !this._emptyElementsToKeep.has(element)) {
            this.conversionApi.writer.remove(element);
            this._splitParts.delete(element);
            anyRemoved = true;
          }
        }
        if (anyRemoved) {
          this._removeEmptyElements();
        }
      }
    }
    function extractMarkersFromModelFragment(modelItem, writer) {
      const markerElements = /* @__PURE__ */ new Set();
      const markers = /* @__PURE__ */ new Map();
      const range = Range._createIn(modelItem).getItems();
      for (const item of range) {
        if (item.is("element", "$marker")) {
          markerElements.add(item);
        }
      }
      for (const markerElement of markerElements) {
        const markerName = markerElement.getAttribute("data-name");
        const currentPosition = writer.createPositionBefore(markerElement);
        if (!markers.has(markerName)) {
          markers.set(markerName, new Range(currentPosition.clone()));
        } else {
          markers.get(markerName).end = currentPosition.clone();
        }
        writer.remove(markerElement);
      }
      return markers;
    }
    function createContextTree(contextDefinition, writer) {
      let position;
      for (const item of new SchemaContext(contextDefinition)) {
        const attributes = {};
        for (const key of item.getAttributeKeys()) {
          attributes[key] = item.getAttribute(key);
        }
        const current = writer.createElement(item.name, attributes);
        if (position) {
          writer.insert(current, position);
        }
        position = Position._createAt(current, 0);
      }
      return position;
    }
    class BasicHtmlWriter {
      /**
      * Returns an HTML string created from the document fragment.
      */
      getHtml(fragment) {
        const doc = global$1.document.implementation.createHTMLDocument("");
        const container = doc.createElement("div");
        container.appendChild(fragment);
        return container.innerHTML;
      }
    }
    class HtmlDataProcessor {
      /**
      * Creates a new instance of the HTML data processor class.
      *
      * @param document The view document instance.
      */
      constructor(document2) {
        /**
        * A DOM parser instance used to parse an HTML string to an HTML document.
        */
        __publicField(this, "domParser");
        /**
        * A DOM converter used to convert DOM elements to view elements.
        */
        __publicField(this, "domConverter");
        /**
        * A basic HTML writer instance used to convert DOM elements to an HTML string.
        */
        __publicField(this, "htmlWriter");
        __publicField(this, "skipComments", true);
        this.domParser = new DOMParser();
        this.domConverter = new DomConverter(document2, {
          renderingMode: "data"
        });
        this.htmlWriter = new BasicHtmlWriter();
      }
      /**
      * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
      * to data format &ndash; in this case to an HTML string.
      *
      * @returns HTML string.
      */
      toData(viewFragment) {
        const domFragment = this.domConverter.viewToDom(viewFragment);
        return this.htmlWriter.getHtml(domFragment);
      }
      /**
      * Converts the provided HTML string to a view tree.
      *
      * @param data An HTML string.
      * @returns A converted view element.
      */
      toView(data) {
        const domFragment = this._toDom(data);
        return this.domConverter.domToView(domFragment, {
          skipComments: this.skipComments
        });
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} for view elements whose content should be treated as raw data
      * and not processed during the conversion from the DOM to the view elements.
      *
      * The raw data can be later accessed by a
      * {@link module:engine/view/element~Element#getCustomProperty custom property of a view element} called `"$rawContent"`.
      *
      * @param pattern Pattern matching all view elements whose content should be treated as raw data.
      */
      registerRawContentMatcher(pattern) {
        this.domConverter.registerRawContentMatcher(pattern);
      }
      /**
      * If the processor is set to use marked fillers, it will insert `&nbsp;` fillers wrapped in `<span>` elements
      * (`<span data-cke-filler="true">&nbsp;</span>`) instead of regular `&nbsp;` characters.
      *
      * This mode allows for a more precise handling of the block fillers (so they do not leak into the editor content) but
      * bloats the editor data with additional markup.
      *
      * This mode may be required by some features and will be turned on by them automatically.
      *
      * @param type Whether to use the default or the marked `&nbsp;` block fillers.
      */
      useFillerType(type) {
        this.domConverter.blockFillerMode = type == "marked" ? "markedNbsp" : "nbsp";
      }
      /**
      * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
      * the provided data.
      */
      _toDom(data) {
        if (!data.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i)) {
          data = `<body>${data}</body>`;
        }
        const document2 = this.domParser.parseFromString(data, "text/html");
        const fragment = document2.createDocumentFragment();
        const bodyChildNodes = document2.body.childNodes;
        while (bodyChildNodes.length > 0) {
          fragment.appendChild(bodyChildNodes[0]);
        }
        return fragment;
      }
    }
    class DataController extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates a data controller instance.
      *
      * @param model Data model.
      * @param stylesProcessor The styles processor instance.
      */
      constructor(model, stylesProcessor) {
        super();
        /**
        * Data model.
        */
        __publicField(this, "model");
        /**
        * Mapper used for the conversion. It has no permanent bindings, because these are created while getting data and
        * are cleared directly after the data are converted. However, the mapper is defined as a class property, because
        * it needs to be passed to the `DowncastDispatcher` as a conversion API.
        */
        __publicField(this, "mapper");
        /**
        * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.
        */
        __publicField(this, "downcastDispatcher");
        /**
        * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.
        */
        __publicField(this, "upcastDispatcher");
        /**
        * The view document used by the data controller.
        */
        __publicField(this, "viewDocument");
        /**
        * Styles processor used during the conversion.
        */
        __publicField(this, "stylesProcessor");
        /**
        * Data processor used specifically for HTML conversion.
        */
        __publicField(this, "htmlProcessor");
        /**
        * Data processor used during the conversion.
        * Same instance as {@link #htmlProcessor} by default. Can be replaced at run time to handle different format, e.g. XML or Markdown.
        */
        __publicField(this, "processor");
        /**
        * The view downcast writer just for data conversion purposes, i.e. to modify
        * the {@link #viewDocument}.
        */
        __publicField(this, "_viewWriter");
        this.model = model;
        this.mapper = new Mapper();
        this.downcastDispatcher = new DowncastDispatcher({
          mapper: this.mapper,
          schema: model.schema
        });
        this.downcastDispatcher.on("insert:$text", insertText(), {
          priority: "lowest"
        });
        this.downcastDispatcher.on("insert", insertAttributesAndChildren(), {
          priority: "lowest"
        });
        this.upcastDispatcher = new UpcastDispatcher({
          schema: model.schema
        });
        this.viewDocument = new Document$1(stylesProcessor);
        this.stylesProcessor = stylesProcessor;
        this.htmlProcessor = new HtmlDataProcessor(this.viewDocument);
        this.processor = this.htmlProcessor;
        this._viewWriter = new DowncastWriter(this.viewDocument);
        this.upcastDispatcher.on("text", convertText(), {
          priority: "lowest"
        });
        this.upcastDispatcher.on("element", convertToModelFragment$1(), {
          priority: "lowest"
        });
        this.upcastDispatcher.on("documentFragment", convertToModelFragment$1(), {
          priority: "lowest"
        });
        ObservableMixin().prototype.decorate.call(this, "init");
        ObservableMixin().prototype.decorate.call(this, "set");
        ObservableMixin().prototype.decorate.call(this, "get");
        ObservableMixin().prototype.decorate.call(this, "toView");
        ObservableMixin().prototype.decorate.call(this, "toModel");
        this.on("init", () => {
          this.fire("ready");
        }, {
          priority: "lowest"
        });
        this.on("ready", () => {
          this.model.enqueueChange({
            isUndoable: false
          }, autoParagraphEmptyRoots);
        }, {
          priority: "lowest"
        });
      }
      /**
      * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
      * formatted by the {@link #processor data processor}.
      *
      * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
      * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
      *
      * @fires get
      * @param options Additional configuration for the retrieved data. `DataController` provides two optional
      * properties: `rootName` and `trim`. Other properties of this object are specified by various editor features.
      * @param options.rootName Root name. Default 'main'.
      * @param options.trim Whether returned data should be trimmed. This option is set to `empty` by default,
      * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
      * use `'none'`. In such cases the exact content will be returned (for example a `<p>&nbsp;</p>` for an empty editor).
      * @returns Output data.
      */
      get(options = {}) {
        const { rootName = "main", trim = "empty" } = options;
        if (!this._checkIfRootsExists([
          rootName
        ])) {
          throw new CKEditorError("datacontroller-get-non-existent-root", this);
        }
        const root2 = this.model.document.getRoot(rootName);
        if (!root2.isAttached()) {
          logWarning("datacontroller-get-detached-root", this);
        }
        if (trim === "empty" && !this.model.hasContent(root2, {
          ignoreWhitespaces: true
        })) {
          return "";
        }
        return this.stringify(root2, options);
      }
      /**
      * Returns the content of the given {@link module:engine/model/element~Element model's element} or
      * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
      * attached to the {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
      *
      * @param modelElementOrFragment The element whose content will be stringified.
      * @param options Additional configuration passed to the conversion process.
      * @returns Output data.
      */
      stringify(modelElementOrFragment, options = {}) {
        const viewDocumentFragment = this.toView(modelElementOrFragment, options);
        return this.processor.toData(viewDocumentFragment);
      }
      /**
      * Returns the content of the given {@link module:engine/model/element~Element model element} or
      * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
      * converters attached to {@link #downcastDispatcher} into a
      * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
      *
      * @fires toView
      * @param modelElementOrFragment Element or document fragment whose content will be converted.
      * @param options Additional configuration that will be available through the
      * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi#options} during the conversion process.
      * @returns Output view DocumentFragment.
      */
      toView(modelElementOrFragment, options = {}) {
        const viewDocument = this.viewDocument;
        const viewWriter = this._viewWriter;
        this.mapper.clearBindings();
        const modelRange = Range._createIn(modelElementOrFragment);
        const viewDocumentFragment = new DocumentFragment$1(viewDocument);
        this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment);
        const markers = modelElementOrFragment.is("documentFragment") ? modelElementOrFragment.markers : _getMarkersRelativeToElement(modelElementOrFragment);
        this.downcastDispatcher.convert(modelRange, markers, viewWriter, options);
        return viewDocumentFragment;
      }
      /**
      * Sets the initial input data parsed by the {@link #processor data processor} and
      * converted by the {@link #upcastDispatcher view-to-model converters}.
      * Initial data can be only set to a document whose {@link module:engine/model/document~Document#version} is equal 0.
      *
      * **Note** This method is {@link module:utils/observablemixin~Observable#decorate decorated} which is
      * used by e.g. collaborative editing plugin that syncs remote data on init.
      *
      * When data is passed as a string, it is initialized on the default `main` root:
      *
      * ```ts
      * dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root only, as no other is specified.
      * ```
      *
      * To initialize data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
      *
      * ```ts
      * dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on both the `main` and `title` roots.
      * ```
      *
      * @fires init
      * @param data Input data as a string or an object containing the `rootName` - `data`
      * pairs to initialize data on multiple roots at once.
      * @returns Promise that is resolved after the data is set on the editor.
      */
      init(data) {
        if (this.model.document.version) {
          throw new CKEditorError("datacontroller-init-document-not-empty", this);
        }
        let initialData = {};
        if (typeof data === "string") {
          initialData.main = data;
        } else {
          initialData = data;
        }
        if (!this._checkIfRootsExists(Object.keys(initialData))) {
          throw new CKEditorError("datacontroller-init-non-existent-root", this);
        }
        this.model.enqueueChange({
          isUndoable: false
        }, (writer) => {
          for (const rootName of Object.keys(initialData)) {
            const modelRoot = this.model.document.getRoot(rootName);
            writer.insert(this.parse(initialData[rootName], modelRoot), modelRoot, 0);
          }
        });
        return Promise.resolve();
      }
      /**
      * Sets the input data parsed by the {@link #processor data processor} and
      * converted by the {@link #upcastDispatcher view-to-model converters}.
      * This method can be used any time to replace existing editor data with the new one without clearing the
      * {@link module:engine/model/document~Document#history document history}.
      *
      * This method also creates a batch with all the changes applied. If all you need is to parse data, use
      * the {@link #parse} method.
      *
      * When data is passed as a string it is set on the default `main` root:
      *
      * ```ts
      * dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root, as no other is specified.
      * ```
      *
      * To set data on a different root or multiple roots at once, an object containing `rootName` - `data` pairs should be passed:
      *
      * ```ts
      * dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots as specified.
      * ```
      *
      * To set the data with a preserved undo stack and add the change to the undo stack, set `{ isUndoable: true }` as a `batchType` option.
      *
      * ```ts
      * dataController.set( '<p>Foo</p>', { batchType: { isUndoable: true } } );
      * ```
      *
      * @fires set
      * @param data Input data as a string or an object containing the `rootName` - `data`
      * pairs to set data on multiple roots at once.
      * @param options Options for setting data.
      * @param options.batchType The batch type that will be used to create a batch for the changes applied by this method.
      * By default, the batch will be set as {@link module:engine/model/batch~Batch#isUndoable not undoable} and the undo stack will be
      * cleared after the new data is applied (all undo steps will be removed). If the batch type `isUndoable` flag is be set to `true`,
      * the undo stack will be preserved instead and not cleared when new data is applied.
      */
      set(data, options = {}) {
        let newData = {};
        if (typeof data === "string") {
          newData.main = data;
        } else {
          newData = data;
        }
        if (!this._checkIfRootsExists(Object.keys(newData))) {
          throw new CKEditorError("datacontroller-set-non-existent-root", this);
        }
        this.model.enqueueChange(options.batchType || {}, (writer) => {
          writer.setSelection(null);
          writer.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
          for (const rootName of Object.keys(newData)) {
            const modelRoot = this.model.document.getRoot(rootName);
            writer.remove(writer.createRangeIn(modelRoot));
            writer.insert(this.parse(newData[rootName], modelRoot), modelRoot, 0);
          }
        });
      }
      /**
      * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
      * attached to the {@link #upcastDispatcher}.
      *
      * @see #set
      * @param data Data to parse.
      * @param context Base context in which the view will be converted to the model.
      * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
      * @returns Parsed data.
      */
      parse(data, context = "$root") {
        const viewDocumentFragment = this.processor.toView(data);
        return this.toModel(viewDocumentFragment, context);
      }
      /**
      * Returns the result of the given {@link module:engine/view/element~Element view element} or
      * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
      * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
      *
      * When marker elements were converted during the conversion process, it will be set as a document fragment's
      * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
      *
      * @fires toModel
      * @param viewElementOrFragment The element or document fragment whose content will be converted.
      * @param context Base context in which the view will be converted to the model.
      * See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
      * @returns Output document fragment.
      */
      toModel(viewElementOrFragment, context = "$root") {
        return this.model.change((writer) => {
          return this.upcastDispatcher.convert(viewElementOrFragment, writer, context);
        });
      }
      /**
      * Adds the style processor normalization rules.
      *
      * You can implement your own rules as well as use one of the available processor rules:
      *
      * * background: {@link module:engine/view/styles/background~addBackgroundRules}
      * * border: {@link module:engine/view/styles/border~addBorderRules}
      * * margin: {@link module:engine/view/styles/margin~addMarginRules}
      * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
      */
      addStyleProcessorRules(callback) {
        callback(this.stylesProcessor);
      }
      /**
      * Registers a {@link module:engine/view/matcher~MatcherPattern} on an {@link #htmlProcessor htmlProcessor}
      * and a {@link #processor processor} for view elements whose content should be treated as raw data
      * and not processed during the conversion from DOM to view elements.
      *
      * The raw data can be later accessed by the {@link module:engine/view/element~Element#getCustomProperty view element custom property}
      * `"$rawContent"`.
      *
      * @param pattern Pattern matching all view elements whose content should be treated as a raw data.
      */
      registerRawContentMatcher(pattern) {
        if (this.processor && this.processor !== this.htmlProcessor) {
          this.processor.registerRawContentMatcher(pattern);
        }
        this.htmlProcessor.registerRawContentMatcher(pattern);
      }
      /**
      * Removes all event listeners set by the DataController.
      */
      destroy() {
        this.stopListening();
      }
      /**
      * Checks whether all provided root names are actually existing editor roots.
      *
      * @param rootNames Root names to check.
      * @returns Whether all provided root names are existing editor roots.
      */
      _checkIfRootsExists(rootNames) {
        for (const rootName of rootNames) {
          if (!this.model.document.getRoot(rootName)) {
            return false;
          }
        }
        return true;
      }
    }
    function _getMarkersRelativeToElement(element) {
      const result = [];
      const doc = element.root.document;
      if (!doc) {
        return /* @__PURE__ */ new Map();
      }
      const elementRange = Range._createIn(element);
      for (const marker of doc.model.markers) {
        const markerRange = marker.getRange();
        const isMarkerCollapsed = markerRange.isCollapsed;
        const isMarkerAtElementBoundary = markerRange.start.isEqual(elementRange.start) || markerRange.end.isEqual(elementRange.end);
        if (isMarkerCollapsed && isMarkerAtElementBoundary) {
          result.push([
            marker.name,
            markerRange
          ]);
        } else {
          const updatedMarkerRange = elementRange.getIntersection(markerRange);
          if (updatedMarkerRange) {
            result.push([
              marker.name,
              updatedMarkerRange
            ]);
          }
        }
      }
      result.sort(([n1, r1], [n2, r2]) => {
        if (r1.end.compareWith(r2.start) !== "after") {
          return 1;
        } else if (r1.start.compareWith(r2.end) !== "before") {
          return -1;
        } else {
          switch (r1.start.compareWith(r2.start)) {
            case "before":
              return 1;
            case "after":
              return -1;
            default:
              switch (r1.end.compareWith(r2.end)) {
                case "before":
                  return 1;
                case "after":
                  return -1;
                default:
                  return n2.localeCompare(n1);
              }
          }
        }
      });
      return new Map(result);
    }
    class Conversion {
      /**
      * Creates a new conversion instance.
      */
      constructor(downcastDispatchers, upcastDispatchers) {
        /**
        * Maps dispatchers group name to ConversionHelpers instances.
        */
        __publicField(this, "_helpers", /* @__PURE__ */ new Map());
        __publicField(this, "_downcast");
        __publicField(this, "_upcast");
        this._downcast = toArray$1(downcastDispatchers);
        this._createConversionHelpers({
          name: "downcast",
          dispatchers: this._downcast,
          isDowncast: true
        });
        this._upcast = toArray$1(upcastDispatchers);
        this._createConversionHelpers({
          name: "upcast",
          dispatchers: this._upcast,
          isDowncast: false
        });
      }
      /**
      * Define an alias for registered dispatcher.
      *
      * ```ts
      * const conversion = new Conversion(
      * 	[ dataDowncastDispatcher, editingDowncastDispatcher ],
      * 	upcastDispatcher
      * );
      *
      * conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
      * ```
      *
      * @param alias An alias of a dispatcher.
      * @param dispatcher Dispatcher which should have an alias.
      */
      addAlias(alias, dispatcher) {
        const isDowncast = this._downcast.includes(dispatcher);
        const isUpcast = this._upcast.includes(dispatcher);
        if (!isUpcast && !isDowncast) {
          throw new CKEditorError("conversion-add-alias-dispatcher-not-registered", this);
        }
        this._createConversionHelpers({
          name: alias,
          dispatchers: [
            dispatcher
          ],
          isDowncast
        });
      }
      /**
      * Provides a chainable API to assign converters to a conversion dispatchers group.
      *
      * If the given group name has not been registered, the
      * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
      *
      * You can use conversion helpers available directly in the `for()` chain or your custom ones via
      * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
      *
      * # Using built-in conversion helpers
      *
      * The `for()` chain comes with a set of conversion helpers which you can use like this:
      *
      * ```ts
      * editor.conversion.for( 'downcast' )
      * 	.elementToElement( config1 )        // Adds an element-to-element downcast converter.
      * 	.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
      *
      * editor.conversion.for( 'upcast' )
      * 	.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
      * ```
      *
      * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
      *
      * * downcast (model-to-view) conversion helpers:
      *
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
      *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
      *
      * * upcast (view-to-model) conversion helpers:
      *
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
      *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
      *
      * # Using custom conversion helpers
      *
      * If you need to implement an atypical converter, you can do so by calling:
      *
      * ```ts
      * editor.conversion.for( direction ).add( customHelper );
      * ```
      *
      * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
      * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
      *
      * Example:
      *
      * ```ts
      * editor.conversion.for( 'upcast' ).add( dispatcher => {
      * 	dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
      * 		// Do something with a view <a> element.
      * 	} );
      * } );
      * ```
      *
      * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
      * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
      * custom converters.
      *
      * @param groupName The name of dispatchers group to add the converters to.
      */
      for(groupName) {
        if (!this._helpers.has(groupName)) {
          throw new CKEditorError("conversion-for-unknown-group", this);
        }
        return this._helpers.get(groupName);
      }
      /**
      * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
      * For example, the model `<paragraph>Foo</paragraph>` is turned into `<p>Foo</p>` in the view.
      *
      * ```ts
      * // A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
      * editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
      *
      * // Override other converters by specifying a converter definition with a higher priority.
      * editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
      *
      * // View specified as an object instead of a string.
      * editor.conversion.elementToElement( {
      * 	model: 'fancyParagraph',
      * 	view: {
      * 		name: 'p',
      * 		classes: 'fancy'
      * 	}
      * } );
      *
      * // Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
      * editor.conversion.elementToElement( {
      * 	model: 'paragraph',
      * 	view: 'p',
      * 	upcastAlso: [
      * 		'div',
      * 		{
      * 			// Any element with the `display: block` style.
      * 			styles: {
      * 				display: 'block'
      * 			}
      * 		}
      * 	]
      * } );
      *
      * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
      * editor.conversion.elementToElement( {
      * 	model: 'heading',
      * 	view: 'h2',
      * 	// Convert "heading-like" paragraphs to headings.
      * 	upcastAlso: viewElement => {
      * 		const fontSize = viewElement.getStyle( 'font-size' );
      *
      * 		if ( !fontSize ) {
      * 			return null;
      * 		}
      *
      * 		const match = fontSize.match( /(\d+)\s*px/ );
      *
      * 		if ( !match ) {
      * 			return null;
      * 		}
      *
      * 		const size = Number( match[ 1 ] );
      *
      * 		if ( size > 26 ) {
      * 			// Returned value can be an object with the matched properties.
      * 			// These properties will be "consumed" during the conversion.
      * 			// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 			return { name: true, styles: [ 'font-size' ] };
      * 		}
      *
      * 		return null;
      * 	}
      * } );
      * ```
      *
      * `definition.model` is a `String` with a model element name to convert from or to.
      *
      * @param definition The converter definition.
      */
      elementToElement(definition) {
        this.for("downcast").elementToElement(definition);
        for (const { model, view } of _getAllUpcastDefinitions(definition)) {
          this.for("upcast").elementToElement({
            model,
            view,
            converterPriority: definition.converterPriority
          });
        }
      }
      /**
      * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
      * For example, a model text node with `"Foo"` as data and the `bold` attribute will be turned to `<strong>Foo</strong>` in the view.
      *
      * ```ts
      * // A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
      * editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
      *
      * // Override other converters by specifying a converter definition with a higher priority.
      * editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
      *
      * // View specified as an object instead of a string.
      * editor.conversion.attributeToElement( {
      * 	model: 'bold',
      * 	view: {
      * 		name: 'span',
      * 		classes: 'bold'
      * 	}
      * } );
      *
      * // Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
      * // The same attribute on different elements may then be handled by a different converter.
      * editor.conversion.attributeToElement( {
      * 	model: {
      * 		key: 'textDecoration',
      * 		values: [ 'underline', 'lineThrough' ],
      * 		name: '$text'
      * 	},
      * 	view: {
      * 		underline: {
      * 			name: 'span',
      * 			styles: {
      * 				'text-decoration': 'underline'
      * 			}
      * 		},
      * 		lineThrough: {
      * 			name: 'span',
      * 			styles: {
      * 				'text-decoration': 'line-through'
      * 			}
      * 		}
      * 	}
      * } );
      *
      * // Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
      * editor.conversion.attributeToElement( {
      * 	model: 'bold',
      * 	view: 'strong',
      * 	upcastAlso: [
      * 		'b',
      * 		{
      * 			name: 'span',
      * 			classes: 'bold'
      * 		},
      * 		{
      * 			name: 'span',
      * 			styles: {
      * 				'font-weight': 'bold'
      * 			}
      * 		},
      * 		viewElement => {
      * 			const fontWeight = viewElement.getStyle( 'font-weight' );
      *
      * 			if ( viewElement.is( 'element', 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
      * 				// Returned value can be an object with the matched properties.
      * 				// These properties will be "consumed" during the conversion.
      * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 				return {
      * 					name: true,
      * 					styles: [ 'font-weight' ]
      * 				};
      * 			}
      * 		}
      * 	]
      * } );
      *
      * // Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
      * // `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
      * editor.conversion.attributeToElement( {
      * 	model: {
      * 		key: 'fontSize',
      * 		values: [ 'big', 'small' ]
      * 	},
      * 	view: {
      * 		big: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '1.2em'
      * 			}
      * 		},
      * 		small: {
      * 			name: 'span',
      * 			styles: {
      * 				'font-size': '0.8em'
      * 			}
      * 		}
      * 	},
      * 	upcastAlso: {
      * 		big: viewElement => {
      * 			const fontSize = viewElement.getStyle( 'font-size' );
      *
      * 			if ( !fontSize ) {
      * 				return null;
      * 			}
      *
      * 			const match = fontSize.match( /(\d+)\s*px/ );
      *
      * 			if ( !match ) {
      * 				return null;
      * 			}
      *
      * 			const size = Number( match[ 1 ] );
      *
      * 			if ( viewElement.is( 'element', 'span' ) && size > 10 ) {
      * 				// Returned value can be an object with the matched properties.
      * 				// These properties will be "consumed" during the conversion.
      * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 				return { name: true, styles: [ 'font-size' ] };
      * 			}
      *
      * 			return null;
      * 		},
      * 		small: viewElement => {
      * 			const fontSize = viewElement.getStyle( 'font-size' );
      *
      * 			if ( !fontSize ) {
      * 				return null;
      * 			}
      *
      * 			const match = fontSize.match( /(\d+)\s*px/ );
      *
      * 			if ( !match ) {
      * 				return null;
      * 			}
      *
      * 			const size = Number( match[ 1 ] );
      *
      * 			if ( viewElement.is( 'element', 'span' ) && size < 10 ) {
      * 				// Returned value can be an object with the matched properties.
      * 				// These properties will be "consumed" during the conversion.
      * 				// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
      *
      * 				return { name: true, styles: [ 'font-size' ] };
      * 			}
      *
      * 			return null;
      * 		}
      * 	}
      * } );
      * ```
      *
      * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
      * describing the attribute key and value to convert or a `String` specifying just the attribute key (in such a case
      * `value` is set to `true`).
      *
      * @param definition The converter definition.
      */
      attributeToElement(definition) {
        this.for("downcast").attributeToElement(definition);
        for (const { model, view } of _getAllUpcastDefinitions(definition)) {
          this.for("upcast").elementToAttribute({
            view,
            model,
            converterPriority: definition.converterPriority
          });
        }
      }
      /**
      * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa). For example,
      * `<imageBlock src='foo.jpg'></imageBlock>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
      * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
      * To convert the text attributes,
      * the {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}should be set up.
      *
      * ```ts
      * // A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
      * editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
      *
      * // Attribute values are strictly specified.
      * editor.conversion.attributeToAttribute( {
      * 	model: {
      * 		name: 'imageInline',
      * 		key: 'aside',
      * 		values: [ 'aside' ]
      * 	},
      * 	view: {
      * 		aside: {
      * 			name: 'img',
      * 			key: 'class',
      * 			value: [ 'aside', 'half-size' ]
      * 		}
      * 	}
      * } );
      *
      * // Set the style attribute.
      * editor.conversion.attributeToAttribute( {
      * 	model: {
      * 		name: 'imageInline',
      * 		key: 'aside',
      * 		values: [ 'aside' ]
      * 	},
      * 	view: {
      * 		aside: {
      * 			name: 'img',
      * 			key: 'style',
      * 			value: {
      * 				float: 'right',
      * 				width: '50%',
      * 				margin: '5px'
      * 			}
      * 		}
      * 	}
      * } );
      *
      * // Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
      * // Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
      * editor.conversion.attributeToAttribute( {
      * 	model: {
      * 		key: 'align',
      * 		values: [ 'right', 'center' ]
      * 	},
      * 	view: {
      * 		right: {
      * 			key: 'class',
      * 			value: 'align-right'
      * 		},
      * 		center: {
      * 			key: 'class',
      * 			value: 'align-center'
      * 		}
      * 	},
      * 	upcastAlso: {
      * 		right: {
      * 			styles: {
      * 				'text-align': 'right'
      * 			}
      * 		},
      * 		center: {
      * 			styles: {
      * 				'text-align': 'center'
      * 			}
      * 		}
      * 	}
      * } );
      * ```
      *
      * The `definition.model` parameter specifies which model attribute should be converted from and to.
      * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
      * The `key` property is the model attribute key to convert from and to.
      * The `values` are the possible model attribute values. If the `values` parameter is not set, the model attribute value
      * will be the same as the view attribute value.
      * If `name` is set, the conversion will be set up only for model elements with the given name.
      *
      * The `definition.view` parameter specifies which view attribute should be converted from and to.
      * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
      * The `key` property is the view attribute key to convert from and to.
      * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
      * the same as the model attribute value.
      * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
      * If `key` is `'style'`, `value` is an object with key-value pairs.
      * In other cases, `value` is a `String`.
      * If `name` is set, the conversion will be set up only for model elements with the given name.
      * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
      * to `{ key, value, [ name ] }` objects.
      *
      * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
      * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
      * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
      *
      * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
      * be given in both parameters.
      *
      * @param definition The converter definition.
      * @param definition.model The model attribute to convert from and to.
      * @param definition.view The view attribute to convert from and to.
      * @param definition.upcastAlso Any view element matching `definition.upcastAlso` will also be converted to the given model attribute.
      * `definition.upcastAlso` is used only if `config.model.values` is specified.
      */
      attributeToAttribute(definition) {
        this.for("downcast").attributeToAttribute(definition);
        for (const { model, view } of _getAllUpcastDefinitions(definition)) {
          this.for("upcast").attributeToAttribute({
            view,
            model
          });
        }
      }
      /**
      * Creates and caches conversion helpers for given dispatchers group.
      *
      * @param options.name Group name.
      */
      _createConversionHelpers({ name, dispatchers, isDowncast }) {
        if (this._helpers.has(name)) {
          throw new CKEditorError("conversion-group-exists", this);
        }
        const helpers = isDowncast ? new DowncastHelpers(dispatchers) : new UpcastHelpers(dispatchers);
        this._helpers.set(name, helpers);
      }
    }
    function* _getAllUpcastDefinitions(definition) {
      if (definition.model.values) {
        for (const value of definition.model.values) {
          const model = {
            key: definition.model.key,
            value
          };
          const view = definition.view[value];
          const upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : void 0;
          yield* _getUpcastDefinition(model, view, upcastAlso);
        }
      } else {
        yield* _getUpcastDefinition(definition.model, definition.view, definition.upcastAlso);
      }
    }
    function* _getUpcastDefinition(model, view, upcastAlso) {
      yield {
        model,
        view
      };
      if (upcastAlso) {
        for (const upcastAlsoItem of toArray$1(upcastAlso)) {
          yield {
            model,
            view: upcastAlsoItem
          };
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Operation {
      /**
      * Base operation constructor.
      *
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(baseVersion) {
        /**
        * {@link module:engine/model/document~Document#version} on which operation can be applied. If you try to
        * {@link module:engine/model/model~Model#applyOperation apply} operation with different base version than the
        * {@link module:engine/model/document~Document#version document version} the
        * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
        */
        __publicField(this, "baseVersion");
        /**
        * Defines whether operation is executed on attached or detached {@link module:engine/model/item~Item items}.
        */
        __publicField(this, "isDocumentOperation");
        /**
        * {@link module:engine/model/batch~Batch Batch} to which the operation is added or `null` if the operation is not
        * added to any batch yet.
        */
        __publicField(this, "batch");
        this.baseVersion = baseVersion;
        this.isDocumentOperation = this.baseVersion !== null;
        this.batch = null;
      }
      /**
      * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
      * an error if operation is not valid.
      *
      * @internal
      */
      _validate() {
      }
      /**
      * Custom toJSON method to solve child-parent circular dependencies.
      *
      * @returns Clone of this object with the operation property replaced with string.
      */
      toJSON() {
        const json = Object.assign({}, this);
        json.__className = this.constructor.className;
        delete json.batch;
        delete json.isDocumentOperation;
        return json;
      }
      /**
      * Name of the operation class used for serialization.
      */
      static get className() {
        return "Operation";
      }
      /**
      * Creates `Operation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param doc Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new this(json.baseVersion);
      }
    }
    function _insert(position, nodes) {
      const normalizedNodes = _normalizeNodes(nodes);
      const offset = normalizedNodes.reduce((sum, node) => sum + node.offsetSize, 0);
      const parent2 = position.parent;
      _splitNodeAtPosition(position);
      const index2 = position.index;
      parent2._insertChild(index2, normalizedNodes);
      _mergeNodesAtIndex(parent2, index2 + normalizedNodes.length);
      _mergeNodesAtIndex(parent2, index2);
      return new Range(position, position.getShiftedBy(offset));
    }
    function _remove(range) {
      if (!range.isFlat) {
        throw new CKEditorError("operation-utils-remove-range-not-flat", this);
      }
      const parent2 = range.start.parent;
      _splitNodeAtPosition(range.start);
      _splitNodeAtPosition(range.end);
      const removed = parent2._removeChildren(range.start.index, range.end.index - range.start.index);
      _mergeNodesAtIndex(parent2, range.start.index);
      return removed;
    }
    function _move(sourceRange, targetPosition) {
      if (!sourceRange.isFlat) {
        throw new CKEditorError("operation-utils-move-range-not-flat", this);
      }
      const nodes = _remove(sourceRange);
      targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);
      return _insert(targetPosition, nodes);
    }
    function _setAttribute(range, key, value) {
      _splitNodeAtPosition(range.start);
      _splitNodeAtPosition(range.end);
      for (const item of range.getItems({
        shallow: true
      })) {
        const node = item.is("$textProxy") ? item.textNode : item;
        if (value !== null) {
          node._setAttribute(key, value);
        } else {
          node._removeAttribute(key);
        }
        _mergeNodesAtIndex(node.parent, node.index);
      }
      _mergeNodesAtIndex(range.end.parent, range.end.index);
    }
    function _normalizeNodes(nodes) {
      const normalized = [];
      function convert2(nodes2) {
        if (typeof nodes2 == "string") {
          normalized.push(new Text(nodes2));
        } else if (nodes2 instanceof TextProxy) {
          normalized.push(new Text(nodes2.data, nodes2.getAttributes()));
        } else if (nodes2 instanceof Node$1) {
          normalized.push(nodes2);
        } else if (isIterable(nodes2)) {
          for (const node of nodes2) {
            convert2(node);
          }
        } else ;
      }
      convert2(nodes);
      for (let i = 1; i < normalized.length; i++) {
        const node = normalized[i];
        const prev = normalized[i - 1];
        if (node instanceof Text && prev instanceof Text && _haveSameAttributes(node, prev)) {
          normalized.splice(i - 1, 2, new Text(prev.data + node.data, prev.getAttributes()));
          i--;
        }
      }
      return normalized;
    }
    function _mergeNodesAtIndex(element, index2) {
      const nodeBefore = element.getChild(index2 - 1);
      const nodeAfter = element.getChild(index2);
      if (nodeBefore && nodeAfter && nodeBefore.is("$text") && nodeAfter.is("$text") && _haveSameAttributes(nodeBefore, nodeAfter)) {
        const mergedNode = new Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes());
        element._removeChildren(index2 - 1, 2);
        element._insertChild(index2 - 1, mergedNode);
      }
    }
    function _splitNodeAtPosition(position) {
      const textNode = position.textNode;
      const element = position.parent;
      if (textNode) {
        const offsetDiff = position.offset - textNode.startOffset;
        const index2 = textNode.index;
        element._removeChildren(index2, 1);
        const firstPart = new Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
        const secondPart = new Text(textNode.data.substr(offsetDiff), textNode.getAttributes());
        element._insertChild(index2, [
          firstPart,
          secondPart
        ]);
      }
    }
    function _haveSameAttributes(nodeA, nodeB) {
      const iteratorA = nodeA.getAttributes();
      const iteratorB = nodeB.getAttributes();
      for (const attr of iteratorA) {
        if (attr[1] !== nodeB.getAttribute(attr[0])) {
          return false;
        }
        iteratorB.next();
      }
      return iteratorB.next().done;
    }
    class MoveOperation extends Operation {
      /**
      * Creates a move operation.
      *
      * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
      * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
      * `sourcePosition` with offset shifted by `howMany`.
      * @param targetPosition Position at which moved nodes will be inserted.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(sourcePosition, howMany, targetPosition, baseVersion) {
        super(baseVersion);
        /**
        * Position before the first {@link module:engine/model/item~Item model item} to move.
        */
        __publicField(this, "sourcePosition");
        /**
        * Offset size of moved range.
        */
        __publicField(this, "howMany");
        /**
        * Position at which moved nodes will be inserted.
        */
        __publicField(this, "targetPosition");
        this.sourcePosition = sourcePosition.clone();
        this.sourcePosition.stickiness = "toNext";
        this.howMany = howMany;
        this.targetPosition = targetPosition.clone();
        this.targetPosition.stickiness = "toNone";
      }
      /**
      * @inheritDoc
      */
      get type() {
        if (this.targetPosition.root.rootName == "$graveyard") {
          return "remove";
        } else if (this.sourcePosition.root.rootName == "$graveyard") {
          return "reinsert";
        }
        return "move";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return [
          Range._createFromPositionAndShift(this.sourcePosition, this.howMany),
          Range._createFromPositionAndShift(this.targetPosition, 0)
        ];
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new MoveOperation(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
      }
      /**
      * Returns the start position of the moved range after it got moved. This may be different than
      * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
      * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
      * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
      *
      * ```
      *  vv              vv
      * abcdefg ===> adefbcg
      *      ^          ^
      *      targetPos  movedRangeStart
      *      offset 6   offset 4
      *```
      */
      getMovedRangeStart() {
        return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
        return new MoveOperation(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const sourceElement = this.sourcePosition.parent;
        const targetElement = this.targetPosition.parent;
        const sourceOffset = this.sourcePosition.offset;
        const targetOffset = this.targetPosition.offset;
        if (sourceOffset + this.howMany > sourceElement.maxOffset) {
          throw new CKEditorError("move-operation-nodes-do-not-exist", this);
        } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
          throw new CKEditorError("move-operation-range-into-itself", this);
        } else if (this.sourcePosition.root == this.targetPosition.root) {
          if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == "prefix") {
            const i = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
              throw new CKEditorError("move-operation-node-into-itself", this);
            }
          }
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        _move(Range._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.sourcePosition = this.sourcePosition.toJSON();
        json.targetPosition = this.targetPosition.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "MoveOperation";
      }
      /**
      * Creates `MoveOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const sourcePosition = Position.fromJSON(json.sourcePosition, document2);
        const targetPosition = Position.fromJSON(json.targetPosition, document2);
        return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);
      }
    }
    class InsertOperation extends Operation {
      /**
      * Creates an insert operation.
      *
      * @param position Position of insertion.
      * @param nodes The list of nodes to be inserted.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(position, nodes, baseVersion) {
        super(baseVersion);
        /**
        * Position of insertion.
        *
        * @readonly
        */
        __publicField(this, "position");
        /**
        * List of nodes to insert.
        *
        * @readonly
        */
        __publicField(this, "nodes");
        /**
        * Flag deciding how the operation should be transformed. If set to `true`, nodes might get additional attributes
        * during operational transformation. This happens when the operation insertion position is inside of a range
        * where attributes have changed.
        */
        __publicField(this, "shouldReceiveAttributes");
        this.position = position.clone();
        this.position.stickiness = "toNone";
        this.nodes = new NodeList(_normalizeNodes(nodes));
        this.shouldReceiveAttributes = false;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "insert";
      }
      /**
      * Total offset size of inserted nodes.
      */
      get howMany() {
        return this.nodes.maxOffset;
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.position.clone();
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        const nodes = new NodeList([
          ...this.nodes
        ].map((node) => node._clone(true)));
        const insert = new InsertOperation(this.position, nodes, this.baseVersion);
        insert.shouldReceiveAttributes = this.shouldReceiveAttributes;
        return insert;
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const graveyard = this.position.root.document.graveyard;
        const gyPosition = new Position(graveyard, [
          0
        ]);
        return new MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const targetElement = this.position.parent;
        if (!targetElement || targetElement.maxOffset < this.position.offset) {
          throw new CKEditorError("insert-operation-position-invalid", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const originalNodes = this.nodes;
        this.nodes = new NodeList([
          ...originalNodes
        ].map((node) => node._clone(true)));
        _insert(this.position, originalNodes);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.position = this.position.toJSON();
        json.nodes = this.nodes.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "InsertOperation";
      }
      /**
      * Creates `InsertOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const children = [];
        for (const child of json.nodes) {
          if (child.name) {
            children.push(Element.fromJSON(child));
          } else {
            children.push(Text.fromJSON(child));
          }
        }
        const insert = new InsertOperation(Position.fromJSON(json.position, document2), children, json.baseVersion);
        insert.shouldReceiveAttributes = json.shouldReceiveAttributes;
        return insert;
      }
    }
    class SplitOperation extends Operation {
      /**
      * Creates a split operation.
      *
      * @param splitPosition Position at which an element should be split.
      * @param howMany Total offset size of elements that are in the split element after `position`.
      * @param insertionPosition Position at which the clone of split element (or element from graveyard) will be inserted.
      * @param graveyardPosition Position in the graveyard root before the element which
      * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(splitPosition, howMany, insertionPosition, graveyardPosition, baseVersion) {
        super(baseVersion);
        /**
        * Position at which an element should be split.
        */
        __publicField(this, "splitPosition");
        /**
        * Total offset size of elements that are in the split element after `position`.
        */
        __publicField(this, "howMany");
        /**
        * Position at which the clone of split element (or element from graveyard) will be inserted.
        */
        __publicField(this, "insertionPosition");
        /**
        * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.
        * If it is not set, a copy of the the `position` parent will be used.
        *
        * The default behavior is to clone the split element. Element from graveyard is used during undo.
        */
        __publicField(this, "graveyardPosition");
        this.splitPosition = splitPosition.clone();
        this.splitPosition.stickiness = "toNext";
        this.howMany = howMany;
        this.insertionPosition = insertionPosition;
        this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;
        if (this.graveyardPosition) {
          this.graveyardPosition.stickiness = "toNext";
        }
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "split";
      }
      /**
      * Position inside the new clone of a split element.
      *
      * This is a position where nodes that are after the split position will be moved to.
      */
      get moveTargetPosition() {
        const path = this.insertionPosition.path.slice();
        path.push(0);
        return new Position(this.insertionPosition.root, path);
      }
      /**
      * Artificial range that contains all the nodes from the split element that will be moved to the new element.
      * The range starts at {@link #splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
      */
      get movedRange() {
        const end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new Range(this.splitPosition, end);
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        const ranges = [
          Range._createFromPositionAndShift(this.splitPosition, 0),
          Range._createFromPositionAndShift(this.insertionPosition, 0)
        ];
        if (this.graveyardPosition) {
          ranges.push(Range._createFromPositionAndShift(this.graveyardPosition, 0));
        }
        return ranges;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      *
      * @returns Clone of this operation.
      */
      clone() {
        return new SplitOperation(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const graveyard = this.splitPosition.root.document.graveyard;
        const graveyardPosition = new Position(graveyard, [
          0
        ]);
        return new MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const element = this.splitPosition.parent;
        const offset = this.splitPosition.offset;
        if (!element || element.maxOffset < offset) {
          throw new CKEditorError("split-operation-position-invalid", this);
        } else if (!element.parent) {
          throw new CKEditorError("split-operation-split-in-root", this);
        } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {
          throw new CKEditorError("split-operation-how-many-invalid", this);
        } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
          throw new CKEditorError("split-operation-graveyard-position-invalid", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const splitElement = this.splitPosition.parent;
        if (this.graveyardPosition) {
          _move(Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
        } else {
          const newElement = splitElement._clone();
          _insert(this.insertionPosition, newElement);
        }
        const sourceRange = new Range(Position._createAt(splitElement, this.splitPosition.offset), Position._createAt(splitElement, splitElement.maxOffset));
        _move(sourceRange, this.moveTargetPosition);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.splitPosition = this.splitPosition.toJSON();
        json.insertionPosition = this.insertionPosition.toJSON();
        if (this.graveyardPosition) {
          json.graveyardPosition = this.graveyardPosition.toJSON();
        }
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "SplitOperation";
      }
      /**
      * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
      * position is after the split element.
      */
      static getInsertionPosition(splitPosition) {
        const path = splitPosition.path.slice(0, -1);
        path[path.length - 1]++;
        return new Position(splitPosition.root, path, "toPrevious");
      }
      /**
      * Creates `SplitOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const splitPosition = Position.fromJSON(json.splitPosition, document2);
        const insertionPosition = Position.fromJSON(json.insertionPosition, document2);
        const graveyardPosition = json.graveyardPosition ? Position.fromJSON(json.graveyardPosition, document2) : null;
        return new this(splitPosition, json.howMany, insertionPosition, graveyardPosition, json.baseVersion);
      }
    }
    class MergeOperation extends Operation {
      /**
      * Creates a merge operation.
      *
      * @param sourcePosition Position inside the merged element. All nodes from that
      * element after that position will be moved to {@link #targetPosition}.
      * @param howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
      * @param targetPosition Position which the nodes from the merged elements will be moved to.
      * @param graveyardPosition Position in graveyard to which the merged element will be moved.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {
        super(baseVersion);
        /**
        * Position inside the merged element. All nodes from that element after that position will be moved to {@link #targetPosition}.
        */
        __publicField(this, "sourcePosition");
        /**
        * Summary offset size of nodes which will be moved from the merged element to the new parent.
        */
        __publicField(this, "howMany");
        /**
        * Position which the nodes from the merged elements will be moved to.
        */
        __publicField(this, "targetPosition");
        /**
        * Position in graveyard to which the merged element will be moved.
        */
        __publicField(this, "graveyardPosition");
        this.sourcePosition = sourcePosition.clone();
        this.sourcePosition.stickiness = "toPrevious";
        this.howMany = howMany;
        this.targetPosition = targetPosition.clone();
        this.targetPosition.stickiness = "toNext";
        this.graveyardPosition = graveyardPosition.clone();
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "merge";
      }
      /**
      * Position before the merged element (which will be deleted).
      */
      get deletionPosition() {
        return new Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
      }
      /**
      * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
      * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
      */
      get movedRange() {
        const end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
        return new Range(this.sourcePosition, end);
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        const mergedElement = this.sourcePosition.parent;
        return [
          Range._createOn(mergedElement),
          // These could be positions but `Selectable` type only supports `Iterable<Range>`.
          Range._createFromPositionAndShift(this.targetPosition, 0),
          Range._createFromPositionAndShift(this.graveyardPosition, 0)
        ];
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new MergeOperation(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        const targetPosition = this.targetPosition._getTransformedByMergeOperation(this);
        const path = this.sourcePosition.path.slice(0, -1);
        const insertionPosition = new Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);
        return new SplitOperation(targetPosition, this.howMany, insertionPosition, this.graveyardPosition, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const sourceElement = this.sourcePosition.parent;
        const targetElement = this.targetPosition.parent;
        if (!sourceElement.parent) {
          throw new CKEditorError("merge-operation-source-position-invalid", this);
        } else if (!targetElement.parent) {
          throw new CKEditorError("merge-operation-target-position-invalid", this);
        } else if (this.howMany != sourceElement.maxOffset) {
          throw new CKEditorError("merge-operation-how-many-invalid", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const mergedElement = this.sourcePosition.parent;
        const sourceRange = Range._createIn(mergedElement);
        _move(sourceRange, this.targetPosition);
        _move(Range._createOn(mergedElement), this.graveyardPosition);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.sourcePosition = json.sourcePosition.toJSON();
        json.targetPosition = json.targetPosition.toJSON();
        json.graveyardPosition = json.graveyardPosition.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "MergeOperation";
      }
      /**
      * Creates `MergeOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        const sourcePosition = Position.fromJSON(json.sourcePosition, document2);
        const targetPosition = Position.fromJSON(json.targetPosition, document2);
        const graveyardPosition = Position.fromJSON(json.graveyardPosition, document2);
        return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);
      }
    }
    class MarkerOperation extends Operation {
      /**
      * @param name Marker name.
      * @param oldRange Marker range before the change.
      * @param newRange Marker range after the change.
      * @param markers Marker collection on which change should be executed.
      * @param affectsData Specifies whether the marker operation affects the data produced by the data pipeline
      * (is persisted in the editor's data).
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(name, oldRange, newRange, markers, affectsData, baseVersion) {
        super(baseVersion);
        /**
        * Marker name.
        *
        * @readonly
        */
        __publicField(this, "name");
        /**
        * Marker range before the change.
        *
        * @readonly
        */
        __publicField(this, "oldRange");
        /**
        * Marker range after the change.
        *
        * @readonly
        */
        __publicField(this, "newRange");
        /**
        * Specifies whether the marker operation affects the data produced by the data pipeline
        * (is persisted in the editor's data).
        *
        * @readonly
        */
        __publicField(this, "affectsData");
        /**
        * Marker collection on which change should be executed.
        */
        __publicField(this, "_markers");
        this.name = name;
        this.oldRange = oldRange ? oldRange.clone() : null;
        this.newRange = newRange ? newRange.clone() : null;
        this.affectsData = affectsData;
        this._markers = markers;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "marker";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        const ranges = [];
        if (this.oldRange) {
          ranges.push(this.oldRange.clone());
        }
        if (this.newRange) {
          if (this.oldRange) {
            ranges.push(...this.newRange.getDifference(this.oldRange));
          } else {
            ranges.push(this.newRange.clone());
          }
        }
        return ranges;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new MarkerOperation(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new MarkerOperation(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        if (this.newRange) {
          this._markers._set(this.name, this.newRange, true, this.affectsData);
        } else {
          this._markers._remove(this.name);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      toJSON() {
        const json = super.toJSON();
        if (this.oldRange) {
          json.oldRange = this.oldRange.toJSON();
        }
        if (this.newRange) {
          json.newRange = this.newRange.toJSON();
        }
        delete json._markers;
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "MarkerOperation";
      }
      /**
      * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new MarkerOperation(json.name, json.oldRange ? Range.fromJSON(json.oldRange, document2) : null, json.newRange ? Range.fromJSON(json.newRange, document2) : null, document2.model.markers, json.affectsData, json.baseVersion);
      }
    }
    class AttributeOperation extends Operation {
      /**
      * Creates an operation that changes, removes or adds attributes.
      *
      * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
      * have an attribute with the same key as the added attribute.
      *
      * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
      * must have an attribute with that key added.
      *
      * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
      * operation's ranges must already have an attribute with given key and `oldValue` as value
      *
      * @param range Range on which the operation should be applied. Must be a flat range.
      * @param key Key of an attribute to change or remove.
      * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
      * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(range, key, oldValue, newValue, baseVersion) {
        super(baseVersion);
        /**
        * Range on which operation should be applied.
        *
        * @readonly
        */
        __publicField(this, "range");
        /**
        * Key of an attribute to change or remove.
        *
        * @readonly
        */
        __publicField(this, "key");
        /**
        * Old value of the attribute with given key or `null`, if attribute was not set before.
        *
        * @readonly
        */
        __publicField(this, "oldValue");
        /**
        * New value of the attribute with given key or `null`, if operation should remove attribute.
        *
        * @readonly
        */
        __publicField(this, "newValue");
        this.range = range.clone();
        this.key = key;
        this.oldValue = oldValue === void 0 ? null : oldValue;
        this.newValue = newValue === void 0 ? null : newValue;
      }
      /**
      * @inheritDoc
      */
      get type() {
        if (this.oldValue === null) {
          return "addAttribute";
        } else if (this.newValue === null) {
          return "removeAttribute";
        } else {
          return "changeAttribute";
        }
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.range.clone();
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.range = this.range.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        if (!this.range.isFlat) {
          throw new CKEditorError("attribute-operation-range-not-flat", this);
        }
        for (const item of this.range.getItems({
          shallow: true
        })) {
          if (this.oldValue !== null && !isEqual(item.getAttribute(this.key), this.oldValue)) {
            throw new CKEditorError("attribute-operation-wrong-old-value", this, {
              item,
              key: this.key,
              value: this.oldValue
            });
          }
          if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
            throw new CKEditorError("attribute-operation-attribute-exists", this, {
              node: item,
              key: this.key
            });
          }
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        if (!isEqual(this.oldValue, this.newValue)) {
          _setAttribute(this.range, this.key, this.newValue);
        }
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "AttributeOperation";
      }
      /**
      * Creates `AttributeOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new AttributeOperation(Range.fromJSON(json.range, document2), json.key, json.oldValue, json.newValue, json.baseVersion);
      }
    }
    class NoOperation extends Operation {
      get type() {
        return "noop";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return null;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      */
      clone() {
        return new NoOperation(this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new NoOperation(this.baseVersion + 1);
      }
      /** @internal */
      _execute() {
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "NoOperation";
      }
    }
    class RenameOperation extends Operation {
      /**
      * Creates an operation that changes element's name.
      *
      * @param position Position before an element to change.
      * @param oldName Current name of the element.
      * @param newName New name for the element.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(position, oldName, newName, baseVersion) {
        super(baseVersion);
        /**
        * Position before an element to change.
        */
        __publicField(this, "position");
        /**
        * Current name of the element.
        */
        __publicField(this, "oldName");
        /**
        * New name for the element.
        */
        __publicField(this, "newName");
        this.position = position;
        this.position.stickiness = "toNext";
        this.oldName = oldName;
        this.newName = newName;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "rename";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.position.nodeAfter;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      *
      * @returns Clone of this operation.
      */
      clone() {
        return new RenameOperation(this.position.clone(), this.oldName, this.newName, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new RenameOperation(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        const element = this.position.nodeAfter;
        if (!(element instanceof Element)) {
          throw new CKEditorError("rename-operation-wrong-position", this);
        } else if (element.name !== this.oldName) {
          throw new CKEditorError("rename-operation-wrong-name", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        const element = this.position.nodeAfter;
        element.name = this.newName;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.position = this.position.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "RenameOperation";
      }
      /**
      * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new RenameOperation(Position.fromJSON(json.position, document2), json.oldName, json.newName, json.baseVersion);
      }
    }
    class RootAttributeOperation extends Operation {
      /**
      * Creates an operation that changes, removes or adds attributes on root element.
      *
      * @see module:engine/model/operation/attributeoperation~AttributeOperation
      * @param root Root element to change.
      * @param key Key of an attribute to change or remove.
      * @param oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
      * @param newValue New value of the attribute with given key or `null`, if operation should remove attribute.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation
      * can be applied or `null` if the operation operates on detached (non-document) tree.
      */
      constructor(root2, key, oldValue, newValue, baseVersion) {
        super(baseVersion);
        /**
        * Root element to change.
        */
        __publicField(this, "root");
        /**
        * Key of an attribute to change or remove.
        */
        __publicField(this, "key");
        /**
        * Old value of the attribute with given key or `null`, if attribute was not set before.
        *
        * @readonly
        */
        __publicField(this, "oldValue");
        /**
        * New value of the attribute with given key or `null`, if operation should remove attribute.
        *
        * @readonly
        */
        __publicField(this, "newValue");
        this.root = root2;
        this.key = key;
        this.oldValue = oldValue === void 0 ? null : oldValue;
        this.newValue = newValue === void 0 ? null : newValue;
      }
      /**
      * @inheritDoc
      */
      get type() {
        if (this.oldValue === null) {
          return "addRootAttribute";
        } else if (this.newValue === null) {
          return "removeRootAttribute";
        } else {
          return "changeRootAttribute";
        }
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this.root;
      }
      /**
      * Creates and returns an operation that has the same parameters as this operation.
      *
      * @returns Clone of this operation.
      */
      clone() {
        return new RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
      }
      /**
      * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
      */
      getReversed() {
        return new RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        if (this.root != this.root.root || this.root.is("documentFragment")) {
          throw new CKEditorError("rootattribute-operation-not-a-root", this, {
            root: this.root,
            key: this.key
          });
        }
        if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
          throw new CKEditorError("rootattribute-operation-wrong-old-value", this, {
            root: this.root,
            key: this.key
          });
        }
        if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
          throw new CKEditorError("rootattribute-operation-attribute-exists", this, {
            root: this.root,
            key: this.key
          });
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        if (this.newValue !== null) {
          this.root._setAttribute(this.key, this.newValue);
        } else {
          this.root._removeAttribute(this.key);
        }
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.root = this.root.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "RootAttributeOperation";
      }
      /**
      * Creates `RootAttributeOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        if (!document2.getRoot(json.root)) {
          throw new CKEditorError("rootattribute-operation-fromjson-no-root", this, {
            rootName: json.root
          });
        }
        return new RootAttributeOperation(document2.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
      }
    }
    class RootOperation extends Operation {
      /**
      * Creates an operation that creates or removes a root element.
      *
      * @param rootName Root name to create or detach.
      * @param elementName Root element name.
      * @param isAdd Specifies whether the operation adds (`true`) or detaches the root (`false`).
      * @param document Document which owns the root.
      * @param baseVersion Document {@link module:engine/model/document~Document#version} on which operation can be applied.
      */
      constructor(rootName, elementName, isAdd, document2, baseVersion) {
        super(baseVersion);
        /**
        * Root name to create or detach.
        */
        __publicField(this, "rootName");
        /**
        * Root element name.
        */
        __publicField(this, "elementName");
        /**
        * Specifies whether the operation adds (`true`) or detaches the root (`false`).
        */
        __publicField(this, "isAdd");
        /**
        * Document which owns the root.
        */
        __publicField(this, "_document");
        this.rootName = rootName;
        this.elementName = elementName;
        this.isAdd = isAdd;
        this._document = document2;
        if (!this._document.getRoot(this.rootName)) {
          const root2 = this._document.createRoot(this.elementName, this.rootName);
          root2._isAttached = false;
        }
      }
      /**
      * @inheritDoc
      */
      get type() {
        return this.isAdd ? "addRoot" : "detachRoot";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return this._document.getRoot(this.rootName);
      }
      /**
      * @inheritDoc
      */
      clone() {
        return new RootOperation(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
      }
      /**
      * @inheritDoc
      */
      getReversed() {
        return new RootOperation(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
      }
      /**
      * @inheritDoc
      */
      _execute() {
        this._document.getRoot(this.rootName)._isAttached = this.isAdd;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        delete json._document;
        return json;
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "RootOperation";
      }
      /**
      * Creates `RootOperation` object from deserialized object, i.e. from parsed JSON string.
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return new RootOperation(json.rootName, json.elementName, json.isAdd, document2, json.baseVersion);
      }
    }
    const operations = {};
    operations[AttributeOperation.className] = AttributeOperation;
    operations[InsertOperation.className] = InsertOperation;
    operations[MarkerOperation.className] = MarkerOperation;
    operations[MoveOperation.className] = MoveOperation;
    operations[NoOperation.className] = NoOperation;
    operations[Operation.className] = Operation;
    operations[RenameOperation.className] = RenameOperation;
    operations[RootAttributeOperation.className] = RootAttributeOperation;
    operations[RootOperation.className] = RootOperation;
    operations[SplitOperation.className] = SplitOperation;
    operations[MergeOperation.className] = MergeOperation;
    class OperationFactory {
      /**
      * Creates an operation instance from a JSON object (parsed JSON string).
      *
      * @param json Deserialized JSON object.
      * @param document Document on which this operation will be applied.
      */
      static fromJSON(json, document2) {
        return operations[json.__className].fromJSON(json, document2);
      }
    }
    const transformations = /* @__PURE__ */ new Map();
    function setTransformation(OperationA, OperationB, transformationFunction) {
      let aGroup = transformations.get(OperationA);
      if (!aGroup) {
        aGroup = /* @__PURE__ */ new Map();
        transformations.set(OperationA, aGroup);
      }
      aGroup.set(OperationB, transformationFunction);
    }
    function getTransformation(OperationA, OperationB) {
      const aGroup = transformations.get(OperationA);
      if (aGroup && aGroup.has(OperationB)) {
        return aGroup.get(OperationB);
      }
      return noUpdateTransformation;
    }
    function noUpdateTransformation(a) {
      return [
        a
      ];
    }
    function transform$1(a, b, context = {}) {
      const transformationFunction = getTransformation(a.constructor, b.constructor);
      try {
        a = a.clone();
        return transformationFunction(a, b, context);
      } catch (e) {
        throw e;
      }
    }
    function transformSets(operationsA, operationsB, options) {
      operationsA = operationsA.slice();
      operationsB = operationsB.slice();
      const contextFactory = new ContextFactory(options.document, options.useRelations, options.forceWeakRemove);
      contextFactory.setOriginalOperations(operationsA);
      contextFactory.setOriginalOperations(operationsB);
      const originalOperations = contextFactory.originalOperations;
      if (operationsA.length == 0 || operationsB.length == 0) {
        return {
          operationsA,
          operationsB,
          originalOperations
        };
      }
      const nextTransformIndex = /* @__PURE__ */ new WeakMap();
      for (const op of operationsA) {
        nextTransformIndex.set(op, 0);
      }
      const data = {
        nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,
        nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,
        originalOperationsACount: operationsA.length,
        originalOperationsBCount: operationsB.length
      };
      let i = 0;
      while (i < operationsA.length) {
        const opA = operationsA[i];
        const indexB = nextTransformIndex.get(opA);
        if (indexB == operationsB.length) {
          i++;
          continue;
        }
        const opB = operationsB[indexB];
        const newOpsA = transform$1(opA, opB, contextFactory.getContext(opA, opB, true));
        const newOpsB = transform$1(opB, opA, contextFactory.getContext(opB, opA, false));
        contextFactory.updateRelation(opA, opB);
        contextFactory.setOriginalOperations(newOpsA, opA);
        contextFactory.setOriginalOperations(newOpsB, opB);
        for (const newOpA of newOpsA) {
          nextTransformIndex.set(newOpA, indexB + newOpsB.length);
        }
        operationsA.splice(i, 1, ...newOpsA);
        operationsB.splice(indexB, 1, ...newOpsB);
      }
      updateBaseVersions(operationsA, data.nextBaseVersionB);
      updateBaseVersions(operationsB, data.nextBaseVersionA);
      return {
        operationsA,
        operationsB,
        originalOperations
      };
    }
    class ContextFactory {
      /**
      * Creates `ContextFactory` instance.
      *
      * @param document Document which the operations change.
      * @param useRelations Whether during transformation relations should be used (used during undo for
      * better conflict resolution).
      * @param forceWeakRemove If set to `false`, remove operation will be always stronger than move operation,
      * so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
      */
      constructor(document2, useRelations, forceWeakRemove = false) {
        __publicField(this, "originalOperations");
        __publicField(this, "_history");
        __publicField(this, "_useRelations");
        __publicField(this, "_forceWeakRemove");
        __publicField(this, "_relations");
        this.originalOperations = /* @__PURE__ */ new Map();
        this._history = document2.history;
        this._useRelations = useRelations;
        this._forceWeakRemove = !!forceWeakRemove;
        this._relations = /* @__PURE__ */ new Map();
      }
      /**
      * Sets "original operation" for given operations.
      *
      * During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
      * or multiple operations. When gathering additional data it is important that all operations can be somehow linked
      * so a cloned and transformed "version" still kept track of the data assigned earlier to it.
      *
      * The original operation object will be used as such an universal linking id. Throughout the transformation process
      * all cloned operations will refer to "the original operation" when storing and reading additional data.
      *
      * If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
      * This should be used as an initialization step.
      *
      * If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
      * for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
      * `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
      */
      setOriginalOperations(operations2, takeFrom = null) {
        const originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;
        for (const operation of operations2) {
          this.originalOperations.set(operation, originalOperation || operation);
        }
      }
      /**
      * Saves a relation between operations `opA` and `opB`.
      *
      * Relations are then later used to help solve conflicts when operations are transformed.
      */
      updateRelation(opA, opB) {
        if (opA instanceof MoveOperation) {
          if (opB instanceof MergeOperation) {
            if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {
              this._setRelation(opA, opB, "insertAtSource");
            } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {
              this._setRelation(opA, opB, "insertBetween");
            } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {
              this._setRelation(opA, opB, "moveTargetAfter");
            }
          } else if (opB instanceof MoveOperation) {
            if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {
              this._setRelation(opA, opB, "insertBefore");
            } else {
              this._setRelation(opA, opB, "insertAfter");
            }
          }
        } else if (opA instanceof SplitOperation) {
          if (opB instanceof MergeOperation) {
            if (opA.splitPosition.isBefore(opB.sourcePosition)) {
              this._setRelation(opA, opB, "splitBefore");
            }
          } else if (opB instanceof MoveOperation) {
            if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {
              this._setRelation(opA, opB, "splitBefore");
            } else {
              const range = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
              if (opA.splitPosition.hasSameParentAs(opB.sourcePosition) && range.containsPosition(opA.splitPosition)) {
                const howMany = range.end.offset - opA.splitPosition.offset;
                const offset = opA.splitPosition.offset - range.start.offset;
                this._setRelation(opA, opB, {
                  howMany,
                  offset
                });
              }
            }
          }
        } else if (opA instanceof MergeOperation) {
          if (opB instanceof MergeOperation) {
            if (!opA.targetPosition.isEqual(opB.sourcePosition)) {
              this._setRelation(opA, opB, "mergeTargetNotMoved");
            }
            if (opA.sourcePosition.isEqual(opB.targetPosition)) {
              this._setRelation(opA, opB, "mergeSourceNotMoved");
            }
            if (opA.sourcePosition.isEqual(opB.sourcePosition)) {
              this._setRelation(opA, opB, "mergeSameElement");
            }
          } else if (opB instanceof SplitOperation) {
            if (opA.sourcePosition.isEqual(opB.splitPosition)) {
              this._setRelation(opA, opB, "splitAtSource");
            }
          } else if (opB instanceof MoveOperation && opB.howMany > 0) {
            if (opA.sourcePosition.isEqual(opB.sourcePosition.getShiftedBy(opB.howMany))) {
              this._setRelation(opA, opB, "mergeSourceAffected");
            }
            if (opA.targetPosition.isEqual(opB.sourcePosition)) {
              this._setRelation(opA, opB, "mergeTargetWasBefore");
            }
          }
        } else if (opA instanceof MarkerOperation) {
          const markerRange = opA.newRange;
          if (!markerRange) {
            return;
          }
          if (opB instanceof MoveOperation) {
            const movedRange = Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);
            const affectedLeft = movedRange.containsPosition(markerRange.start) || movedRange.start.isEqual(markerRange.start);
            const affectedRight = movedRange.containsPosition(markerRange.end) || movedRange.end.isEqual(markerRange.end);
            if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {
              this._setRelation(opA, opB, {
                side: affectedLeft ? "left" : "right",
                path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()
              });
            }
          } else if (opB instanceof MergeOperation) {
            const wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);
            const wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);
            const wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);
            const wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);
            if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {
              this._setRelation(opA, opB, {
                wasInLeftElement,
                wasStartBeforeMergedElement,
                wasEndBeforeMergedElement,
                wasInRightElement
              });
            }
          }
        }
      }
      /**
      * Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
      */
      getContext(opA, opB, aIsStrong) {
        return {
          aIsStrong,
          aWasUndone: this._wasUndone(opA),
          bWasUndone: this._wasUndone(opB),
          abRelation: this._useRelations ? this._getRelation(opA, opB) : null,
          baRelation: this._useRelations ? this._getRelation(opB, opA) : null,
          forceWeakRemove: this._forceWeakRemove
        };
      }
      /**
      * Returns whether given operation `op` has already been undone.
      *
      * Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
      */
      _wasUndone(op) {
        const originalOp = this.originalOperations.get(op);
        return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);
      }
      /**
      * Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
      * was set earlier or `null` if there was no relation between those operations.
      *
      * This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
      *
      * When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
      * undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
      * we look forward in the future and ask if in that future `opB` was undone.
      *
      * Relations is a backward process to `wasUndone()`.
      *
      * Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
      * operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
      * a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
      * between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
      * a better decision when resolving a conflict between two operations, because we know more about the context of
      * those two operations.
      *
      * This is why this function does not return a relation directly between `opA` and `opB` because we need to look
      * back to search for a meaningful contextual information.
      */
      _getRelation(opA, opB) {
        const origB = this.originalOperations.get(opB);
        const undoneB = this._history.getUndoneOperation(origB);
        if (!undoneB) {
          return null;
        }
        const origA = this.originalOperations.get(opA);
        const relationsA = this._relations.get(origA);
        if (relationsA) {
          return relationsA.get(undoneB) || null;
        }
        return null;
      }
      /**
      * Helper function for `ContextFactory#updateRelations`.
      */
      _setRelation(opA, opB, relation) {
        const origA = this.originalOperations.get(opA);
        const origB = this.originalOperations.get(opB);
        let relationsA = this._relations.get(origA);
        if (!relationsA) {
          relationsA = /* @__PURE__ */ new Map();
          this._relations.set(origA, relationsA);
        }
        relationsA.set(origB, relation);
      }
    }
    function updateBaseVersions(operations2, baseVersion) {
      for (const operation of operations2) {
        operation.baseVersion = baseVersion++;
      }
    }
    setTransformation(AttributeOperation, AttributeOperation, (a, b, context) => {
      if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {
        const operations2 = a.range.getDifference(b.range).map((range) => {
          return new AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);
        });
        const common = a.range.getIntersection(b.range);
        if (common) {
          if (context.aIsStrong) {
            operations2.push(new AttributeOperation(common, b.key, b.newValue, a.newValue, 0));
          }
        }
        if (operations2.length == 0) {
          return [
            new NoOperation(0)
          ];
        }
        return operations2;
      } else {
        return [
          a
        ];
      }
    });
    setTransformation(AttributeOperation, InsertOperation, (a, b) => {
      if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {
        const range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);
        const result = range.map((r) => {
          return new AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);
        });
        if (b.shouldReceiveAttributes) {
          const op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);
          if (op) {
            result.unshift(op);
          }
        }
        return result;
      }
      a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];
      return [
        a
      ];
    });
    function _getComplementaryAttributeOperations(insertOperation, key, newValue) {
      const nodes = insertOperation.nodes;
      const insertValue = nodes.getNode(0).getAttribute(key);
      if (insertValue == newValue) {
        return null;
      }
      const range = new Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));
      return new AttributeOperation(range, key, insertValue, newValue, 0);
    }
    setTransformation(AttributeOperation, MergeOperation, (a, b) => {
      const ranges = [];
      if (a.range.start.hasSameParentAs(b.deletionPosition)) {
        if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {
          ranges.push(Range._createFromPositionAndShift(b.graveyardPosition, 1));
        }
      }
      const range = a.range._getTransformedByMergeOperation(b);
      if (!range.isCollapsed) {
        ranges.push(range);
      }
      return ranges.map((range2) => {
        return new AttributeOperation(range2, a.key, a.oldValue, a.newValue, a.baseVersion);
      });
    });
    setTransformation(AttributeOperation, MoveOperation, (a, b) => {
      const ranges = _breakRangeByMoveOperation(a.range, b);
      return ranges.map((range) => new AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion));
    });
    function _breakRangeByMoveOperation(range, moveOp) {
      const moveRange = Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany);
      let common = null;
      let difference = [];
      if (moveRange.containsRange(range, true)) {
        common = range;
      } else if (range.start.hasSameParentAs(moveRange.start)) {
        difference = range.getDifference(moveRange);
        common = range.getIntersection(moveRange);
      } else {
        difference = [
          range
        ];
      }
      const result = [];
      for (let diff2 of difference) {
        diff2 = diff2._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany);
        const targetPosition = moveOp.getMovedRangeStart();
        const spread = diff2.start.hasSameParentAs(targetPosition);
        const diffs = diff2._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);
        result.push(...diffs);
      }
      if (common) {
        result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);
      }
      return result;
    }
    setTransformation(AttributeOperation, SplitOperation, (a, b) => {
      if (a.range.end.isEqual(b.insertionPosition)) {
        if (!b.graveyardPosition) {
          a.range.end.offset++;
        }
        return [
          a
        ];
      }
      if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {
        const secondPart = a.clone();
        secondPart.range = new Range(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));
        a.range.end = b.splitPosition.clone();
        a.range.end.stickiness = "toPrevious";
        return [
          a,
          secondPart
        ];
      }
      a.range = a.range._getTransformedBySplitOperation(b);
      return [
        a
      ];
    });
    setTransformation(InsertOperation, AttributeOperation, (a, b) => {
      const result = [
        a
      ];
      if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {
        const op = _getComplementaryAttributeOperations(a, b.key, b.newValue);
        if (op) {
          result.push(op);
        }
      }
      return result;
    });
    setTransformation(InsertOperation, InsertOperation, (a, b, context) => {
      if (a.position.isEqual(b.position) && context.aIsStrong) {
        return [
          a
        ];
      }
      a.position = a.position._getTransformedByInsertOperation(b);
      return [
        a
      ];
    });
    setTransformation(InsertOperation, MoveOperation, (a, b) => {
      a.position = a.position._getTransformedByMoveOperation(b);
      return [
        a
      ];
    });
    setTransformation(InsertOperation, SplitOperation, (a, b) => {
      a.position = a.position._getTransformedBySplitOperation(b);
      return [
        a
      ];
    });
    setTransformation(InsertOperation, MergeOperation, (a, b) => {
      a.position = a.position._getTransformedByMergeOperation(b);
      return [
        a
      ];
    });
    setTransformation(MarkerOperation, InsertOperation, (a, b) => {
      if (a.oldRange) {
        a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];
      }
      if (a.newRange) {
        a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];
      }
      return [
        a
      ];
    });
    setTransformation(MarkerOperation, MarkerOperation, (a, b, context) => {
      if (a.name == b.name) {
        if (context.aIsStrong) {
          a.oldRange = b.newRange ? b.newRange.clone() : null;
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      return [
        a
      ];
    });
    setTransformation(MarkerOperation, MergeOperation, (a, b) => {
      if (a.oldRange) {
        a.oldRange = a.oldRange._getTransformedByMergeOperation(b);
      }
      if (a.newRange) {
        a.newRange = a.newRange._getTransformedByMergeOperation(b);
      }
      return [
        a
      ];
    });
    setTransformation(MarkerOperation, MoveOperation, (a, b, context) => {
      if (a.oldRange) {
        a.oldRange = Range._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));
      }
      if (a.newRange) {
        if (context.abRelation) {
          const aNewRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));
          if (context.abRelation.side == "left" && b.targetPosition.isEqual(a.newRange.start)) {
            a.newRange.end = aNewRange.end;
            a.newRange.start.path = context.abRelation.path;
            return [
              a
            ];
          } else if (context.abRelation.side == "right" && b.targetPosition.isEqual(a.newRange.end)) {
            a.newRange.start = aNewRange.start;
            a.newRange.end.path = context.abRelation.path;
            return [
              a
            ];
          }
        }
        a.newRange = Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));
      }
      return [
        a
      ];
    });
    setTransformation(MarkerOperation, SplitOperation, (a, b, context) => {
      if (a.oldRange) {
        a.oldRange = a.oldRange._getTransformedBySplitOperation(b);
      }
      if (a.newRange) {
        if (context.abRelation) {
          const aNewRange = a.newRange._getTransformedBySplitOperation(b);
          if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {
            a.newRange.start = Position._createAt(b.insertionPosition);
          } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {
            a.newRange.start = Position._createAt(b.moveTargetPosition);
          }
          if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {
            a.newRange.end = Position._createAt(b.moveTargetPosition);
          } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {
            a.newRange.end = Position._createAt(b.insertionPosition);
          } else {
            a.newRange.end = aNewRange.end;
          }
          return [
            a
          ];
        }
        a.newRange = a.newRange._getTransformedBySplitOperation(b);
      }
      return [
        a
      ];
    });
    setTransformation(MergeOperation, InsertOperation, (a, b) => {
      if (a.sourcePosition.hasSameParentAs(b.position)) {
        a.howMany += b.howMany;
      }
      a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);
      a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
      return [
        a
      ];
    });
    setTransformation(MergeOperation, MergeOperation, (a, b, context) => {
      if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {
        if (!context.bWasUndone) {
          return [
            new NoOperation(0)
          ];
        } else {
          const path = b.graveyardPosition.path.slice();
          path.push(0);
          a.sourcePosition = new Position(b.graveyardPosition.root, path);
          a.howMany = 0;
          return [
            a
          ];
        }
      }
      if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != "splitAtSource") {
        const aToGraveyard = a.targetPosition.root.rootName == "$graveyard";
        const bToGraveyard = b.targetPosition.root.rootName == "$graveyard";
        const aIsWeak = aToGraveyard && !bToGraveyard;
        const bIsWeak = bToGraveyard && !aToGraveyard;
        const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
        if (forceMove) {
          const sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);
          const targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
          return [
            new MoveOperation(sourcePosition, a.howMany, targetPosition, 0)
          ];
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
        a.howMany += b.howMany;
      }
      a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);
      a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
      if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {
        a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
      }
      return [
        a
      ];
    });
    setTransformation(MergeOperation, MoveOperation, (a, b, context) => {
      const removedRange = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);
      if (b.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
        if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {
          return [
            new NoOperation(0)
          ];
        }
      }
      if (b.sourcePosition.getShiftedBy(b.howMany).isEqual(a.sourcePosition)) {
        a.sourcePosition.stickiness = "toNone";
      } else if (b.targetPosition.isEqual(a.sourcePosition) && context.abRelation == "mergeSourceAffected") {
        a.sourcePosition.stickiness = "toNext";
      } else if (b.sourcePosition.isEqual(a.targetPosition)) {
        a.targetPosition.stickiness = "toNone";
        a.howMany -= b.howMany;
      } else if (b.targetPosition.isEqual(a.targetPosition) && context.abRelation == "mergeTargetWasBefore") {
        a.targetPosition.stickiness = "toPrevious";
        a.howMany += b.howMany;
      } else {
        if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
          a.howMany += b.howMany;
        }
        if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {
          a.howMany -= b.howMany;
        }
      }
      a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);
      a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b);
      a.sourcePosition.stickiness = "toPrevious";
      a.targetPosition.stickiness = "toNext";
      if (!a.graveyardPosition.isEqual(b.targetPosition)) {
        a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
      }
      return [
        a
      ];
    });
    setTransformation(MergeOperation, SplitOperation, (a, b, context) => {
      if (b.graveyardPosition) {
        a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1);
        if (a.deletionPosition.isEqual(b.graveyardPosition)) {
          a.howMany = b.howMany;
        }
      }
      if (a.targetPosition.isEqual(b.splitPosition)) {
        const mergeInside = b.howMany != 0;
        const mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);
        if (mergeInside || mergeSplittingElement || context.abRelation == "mergeTargetNotMoved") {
          a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
          return [
            a
          ];
        }
      }
      if (a.sourcePosition.isEqual(b.splitPosition)) {
        if (context.abRelation == "mergeSourceNotMoved") {
          a.howMany = 0;
          a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
          return [
            a
          ];
        }
        if (context.abRelation == "mergeSameElement" || a.sourcePosition.offset > 0) {
          a.sourcePosition = b.moveTargetPosition.clone();
          a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
          return [
            a
          ];
        }
      }
      if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {
        a.howMany = b.splitPosition.offset;
      }
      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [
        a
      ];
    });
    setTransformation(MoveOperation, InsertOperation, (a, b) => {
      const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);
      const transformed = moveRange._getTransformedByInsertOperation(b, false)[0];
      a.sourcePosition = transformed.start;
      a.howMany = transformed.end.offset - transformed.start.offset;
      if (!a.targetPosition.isEqual(b.position)) {
        a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
      }
      return [
        a
      ];
    });
    setTransformation(MoveOperation, MoveOperation, (a, b, context) => {
      const rangeA = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);
      const rangeB = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);
      let aIsStrong = context.aIsStrong;
      let insertBefore = !context.aIsStrong;
      if (context.abRelation == "insertBefore" || context.baRelation == "insertAfter") {
        insertBefore = true;
      } else if (context.abRelation == "insertAfter" || context.baRelation == "insertBefore") {
        insertBefore = false;
      }
      let newTargetPosition;
      if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {
        newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
      } else {
        newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
      }
      if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {
        return [
          b.getReversed()
        ];
      }
      const bTargetsToA = rangeA.containsPosition(b.targetPosition);
      if (bTargetsToA && rangeA.containsRange(rangeB, true)) {
        rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
        rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
        return _makeMoveOperationsFromRanges([
          rangeA
        ], newTargetPosition);
      }
      const aTargetsToB = rangeB.containsPosition(a.targetPosition);
      if (aTargetsToB && rangeB.containsRange(rangeA, true)) {
        rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
        rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
        return _makeMoveOperationsFromRanges([
          rangeA
        ], newTargetPosition);
      }
      const aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());
      if (aCompB == "prefix" || aCompB == "extension") {
        rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
        rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
        return _makeMoveOperationsFromRanges([
          rangeA
        ], newTargetPosition);
      }
      if (a.type == "remove" && b.type != "remove" && !context.aWasUndone && !context.forceWeakRemove) {
        aIsStrong = true;
      } else if (a.type != "remove" && b.type == "remove" && !context.bWasUndone && !context.forceWeakRemove) {
        aIsStrong = false;
      }
      const ranges = [];
      const difference = rangeA.getDifference(rangeB);
      for (const range of difference) {
        range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);
        range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany);
        const shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == "same";
        const newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);
        ranges.push(...newRanges);
      }
      const common = rangeA.getIntersection(rangeB);
      if (common !== null && aIsStrong) {
        common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
        common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
        if (ranges.length === 0) {
          ranges.push(common);
        } else if (ranges.length == 1) {
          if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {
            ranges.unshift(common);
          } else {
            ranges.push(common);
          }
        } else {
          ranges.splice(1, 0, common);
        }
      }
      if (ranges.length === 0) {
        return [
          new NoOperation(a.baseVersion)
        ];
      }
      return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
    });
    setTransformation(MoveOperation, SplitOperation, (a, b, context) => {
      let newTargetPosition = a.targetPosition.clone();
      if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == "moveTargetAfter") {
        newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      }
      const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);
      if (moveRange.end.isEqual(b.insertionPosition)) {
        if (!b.graveyardPosition) {
          a.howMany++;
        }
        a.targetPosition = newTargetPosition;
        return [
          a
        ];
      }
      if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {
        let rightRange = new Range(b.splitPosition, moveRange.end);
        rightRange = rightRange._getTransformedBySplitOperation(b);
        const ranges2 = [
          new Range(moveRange.start, b.splitPosition),
          rightRange
        ];
        return _makeMoveOperationsFromRanges(ranges2, newTargetPosition);
      }
      if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == "insertAtSource") {
        newTargetPosition = b.moveTargetPosition;
      }
      if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == "insertBetween") {
        newTargetPosition = a.targetPosition;
      }
      const transformed = moveRange._getTransformedBySplitOperation(b);
      const ranges = [
        transformed
      ];
      if (b.graveyardPosition) {
        const movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);
        if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {
          ranges.push(Range._createFromPositionAndShift(b.insertionPosition, 1));
        }
      }
      return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
    });
    setTransformation(MoveOperation, MergeOperation, (a, b, context) => {
      const movedRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);
      if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {
        if (a.type == "remove" && !context.forceWeakRemove) {
          if (!context.aWasUndone) {
            const results = [];
            let gyMoveSource = b.graveyardPosition.clone();
            let splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);
            if (a.howMany > 1) {
              results.push(new MoveOperation(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));
              gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);
              splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);
            }
            const gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);
            const gyMove = new MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);
            const splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();
            splitNodesMoveTargetPath.push(0);
            const splitNodesMoveTarget = new Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);
            splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);
            const splitNodesMove = new MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);
            results.push(gyMove);
            results.push(splitNodesMove);
            return results;
          }
        } else {
          if (a.howMany == 1) {
            if (!context.bWasUndone) {
              return [
                new NoOperation(0)
              ];
            } else {
              a.sourcePosition = b.graveyardPosition.clone();
              a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
              return [
                a
              ];
            }
          }
        }
      }
      const moveRange = Range._createFromPositionAndShift(a.sourcePosition, a.howMany);
      const transformed = moveRange._getTransformedByMergeOperation(b);
      a.sourcePosition = transformed.start;
      a.howMany = transformed.end.offset - transformed.start.offset;
      a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
      return [
        a
      ];
    });
    setTransformation(RenameOperation, InsertOperation, (a, b) => {
      a.position = a.position._getTransformedByInsertOperation(b);
      return [
        a
      ];
    });
    setTransformation(RenameOperation, MergeOperation, (a, b) => {
      if (a.position.isEqual(b.deletionPosition)) {
        a.position = b.graveyardPosition.clone();
        a.position.stickiness = "toNext";
        return [
          a
        ];
      }
      a.position = a.position._getTransformedByMergeOperation(b);
      return [
        a
      ];
    });
    setTransformation(RenameOperation, MoveOperation, (a, b) => {
      a.position = a.position._getTransformedByMoveOperation(b);
      return [
        a
      ];
    });
    setTransformation(RenameOperation, RenameOperation, (a, b, context) => {
      if (a.position.isEqual(b.position)) {
        if (context.aIsStrong) {
          a.oldName = b.newName;
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      return [
        a
      ];
    });
    setTransformation(RenameOperation, SplitOperation, (a, b) => {
      const renamePath = a.position.path;
      const splitPath = b.splitPosition.getParentPath();
      if (compareArrays(renamePath, splitPath) == "same" && !b.graveyardPosition) {
        const extraRename = new RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);
        return [
          a,
          extraRename
        ];
      }
      a.position = a.position._getTransformedBySplitOperation(b);
      return [
        a
      ];
    });
    setTransformation(RootAttributeOperation, RootAttributeOperation, (a, b, context) => {
      if (a.root === b.root && a.key === b.key) {
        if (!context.aIsStrong || a.newValue === b.newValue) {
          return [
            new NoOperation(0)
          ];
        } else {
          a.oldValue = b.newValue;
        }
      }
      return [
        a
      ];
    });
    setTransformation(RootOperation, RootOperation, (a, b) => {
      if (a.rootName === b.rootName && a.isAdd === b.isAdd) {
        return [
          new NoOperation(0)
        ];
      }
      return [
        a
      ];
    });
    setTransformation(SplitOperation, InsertOperation, (a, b) => {
      if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {
        a.howMany += b.howMany;
      }
      a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);
      a.insertionPosition = a.insertionPosition._getTransformedByInsertOperation(b);
      return [
        a
      ];
    });
    setTransformation(SplitOperation, MergeOperation, (a, b, context) => {
      if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {
        const splitPath = b.graveyardPosition.path.slice();
        splitPath.push(0);
        const splitPosition = new Position(b.graveyardPosition.root, splitPath);
        const insertionPosition = SplitOperation.getInsertionPosition(new Position(b.graveyardPosition.root, splitPath));
        const additionalSplit = new SplitOperation(splitPosition, 0, insertionPosition, null, 0);
        a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
        a.graveyardPosition = additionalSplit.insertionPosition.clone();
        a.graveyardPosition.stickiness = "toNext";
        return [
          additionalSplit,
          a
        ];
      }
      if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {
        a.howMany--;
      }
      if (a.splitPosition.hasSameParentAs(b.targetPosition)) {
        a.howMany += b.howMany;
      }
      a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
      a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
      if (a.graveyardPosition) {
        a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
      }
      return [
        a
      ];
    });
    setTransformation(SplitOperation, MoveOperation, (a, b, context) => {
      const rangeToMove = Range._createFromPositionAndShift(b.sourcePosition, b.howMany);
      if (a.graveyardPosition) {
        const gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);
        if (!context.bWasUndone && gyElementMoved) {
          const sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);
          const newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
          const newTargetPath = newParentPosition.path.slice();
          newTargetPath.push(0);
          const newTargetPosition = new Position(newParentPosition.root, newTargetPath);
          const moveOp = new MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);
          return [
            moveOp
          ];
        }
        a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
      }
      const splitAtTarget = a.splitPosition.isEqual(b.targetPosition);
      if (splitAtTarget && (context.baRelation == "insertAtSource" || context.abRelation == "splitBefore")) {
        a.howMany += b.howMany;
        a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
        return [
          a
        ];
      }
      if (splitAtTarget && context.abRelation && context.abRelation.howMany) {
        const { howMany, offset } = context.abRelation;
        a.howMany += howMany;
        a.splitPosition = a.splitPosition.getShiftedBy(offset);
        return [
          a
        ];
      }
      if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {
        const howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);
        a.howMany -= howManyRemoved;
        if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
          a.howMany += b.howMany;
        }
        a.splitPosition = b.sourcePosition.clone();
        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
        return [
          a
        ];
      }
      if (!b.sourcePosition.isEqual(b.targetPosition)) {
        if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {
          a.howMany -= b.howMany;
        }
        if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
          a.howMany += b.howMany;
        }
      }
      a.splitPosition.stickiness = "toNone";
      a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);
      a.splitPosition.stickiness = "toNext";
      if (a.graveyardPosition) {
        a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);
      } else {
        a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
      }
      return [
        a
      ];
    });
    setTransformation(SplitOperation, SplitOperation, (a, b, context) => {
      if (a.splitPosition.isEqual(b.splitPosition)) {
        if (!a.graveyardPosition && !b.graveyardPosition) {
          return [
            new NoOperation(0)
          ];
        }
        if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
          return [
            new NoOperation(0)
          ];
        }
        if (context.abRelation == "splitBefore") {
          a.howMany = 0;
          a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
          return [
            a
          ];
        }
      }
      if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
        const aInGraveyard = a.splitPosition.root.rootName == "$graveyard";
        const bInGraveyard = b.splitPosition.root.rootName == "$graveyard";
        const aIsWeak = aInGraveyard && !bInGraveyard;
        const bIsWeak = bInGraveyard && !aInGraveyard;
        const forceMove = bIsWeak || !aIsWeak && context.aIsStrong;
        if (forceMove) {
          const result = [];
          if (b.howMany) {
            result.push(new MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));
          }
          if (a.howMany) {
            result.push(new MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));
          }
          return result;
        } else {
          return [
            new NoOperation(0)
          ];
        }
      }
      if (a.graveyardPosition) {
        a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
      }
      if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == "splitBefore") {
        a.howMany++;
        return [
          a
        ];
      }
      if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == "splitBefore") {
        const newPositionPath = b.insertionPosition.path.slice();
        newPositionPath.push(0);
        const newPosition = new Position(b.insertionPosition.root, newPositionPath);
        const moveOp = new MoveOperation(a.insertionPosition, 1, newPosition, 0);
        return [
          a,
          moveOp
        ];
      }
      if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {
        a.howMany -= b.howMany;
      }
      a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);
      a.insertionPosition = SplitOperation.getInsertionPosition(a.splitPosition);
      return [
        a
      ];
    });
    function _moveTargetIntoMovedRange(a, b) {
      return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
    }
    function _makeMoveOperationsFromRanges(ranges, targetPosition) {
      const operations2 = [];
      for (let i = 0; i < ranges.length; i++) {
        const range = ranges[i];
        const op = new MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);
        operations2.push(op);
        for (let j = i + 1; j < ranges.length; j++) {
          ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];
        }
        targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);
      }
      return operations2;
    }
    class LivePosition extends (/* @__PURE__ */ EmitterMixin(Position)) {
      /**
      * Creates a live position.
      *
      * @see module:engine/model/position~Position
      */
      constructor(root2, path, stickiness = "toNone") {
        super(root2, path, stickiness);
        if (!this.root.is("rootElement")) {
          throw new CKEditorError("model-liveposition-root-not-rootelement", root2);
        }
        bindWithDocument.call(this);
      }
      /**
      * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
      * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
      * referring to it).
      */
      detach() {
        this.stopListening();
      }
      /**
      * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
      */
      toPosition() {
        return new Position(this.root, this.path.slice(), this.stickiness);
      }
      /**
      * Creates a `LivePosition` instance that is equal to position.
      */
      static fromPosition(position, stickiness) {
        return new this(position.root, position.path.slice(), stickiness ? stickiness : position.stickiness);
      }
    }
    LivePosition.prototype.is = function(type) {
      return type === "livePosition" || type === "model:livePosition" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type == "position" || type === "model:position";
    };
    function bindWithDocument() {
      this.listenTo(this.root.document.model, "applyOperation", (event, args) => {
        const operation = args[0];
        if (!operation.isDocumentOperation) {
          return;
        }
        transform.call(this, operation);
      }, {
        priority: "low"
      });
    }
    function transform(operation) {
      const result = this.getTransformedByOperation(operation);
      if (!this.isEqual(result)) {
        const oldPosition = this.toPosition();
        this.path = result.path;
        this.root = result.root;
        this.fire("change", oldPosition);
      }
    }
    class Batch {
      /**
      * Creates a batch instance.
      *
      * @see module:engine/model/model~Model#enqueueChange
      * @see module:engine/model/model~Model#change
      * @param type A set of flags that specify the type of the batch. Batch type can alter how some of the features work
      * when encountering a given `Batch` instance (for example, when a feature listens to applied operations).
      */
      constructor(type = {}) {
        /**
        * An array of operations that compose this batch.
        */
        __publicField(this, "operations");
        /**
        * Whether the batch can be undone through the undo feature.
        */
        __publicField(this, "isUndoable");
        /**
        * Whether the batch includes operations created locally (`true`) or operations created on other, remote editors (`false`).
        */
        __publicField(this, "isLocal");
        /**
        * Whether the batch was created by the undo feature and undoes other operations.
        */
        __publicField(this, "isUndo");
        /**
        * Whether the batch includes operations connected with typing.
        */
        __publicField(this, "isTyping");
        if (typeof type === "string") {
          type = type === "transparent" ? {
            isUndoable: false
          } : {};
          logWarning("batch-constructor-deprecated-string-type");
        }
        const { isUndoable = true, isLocal = true, isUndo = false, isTyping = false } = type;
        this.operations = [];
        this.isUndoable = isUndoable;
        this.isLocal = isLocal;
        this.isUndo = isUndo;
        this.isTyping = isTyping;
      }
      /**
      * The type of the batch.
      *
      * **This property has been deprecated and is always set to the `'default'` value.**
      *
      * It can be one of the following values:
      * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
      * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
      * changes.
      *
      * @deprecated
      */
      get type() {
        logWarning("batch-type-deprecated");
        return "default";
      }
      /**
      * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
      * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
      */
      get baseVersion() {
        for (const op of this.operations) {
          if (op.baseVersion !== null) {
            return op.baseVersion;
          }
        }
        return null;
      }
      /**
      * Adds an operation to the batch instance.
      *
      * @param operation An operation to add.
      * @returns The added operation.
      */
      addOperation(operation) {
        operation.batch = this;
        this.operations.push(operation);
        return operation;
      }
    }
    const _Differ = class _Differ {
      /**
      * Creates a `Differ` instance.
      *
      * @param markerCollection Model's marker collection.
      */
      constructor(markerCollection) {
        /**
        * Reference to the model's marker collection.
        */
        __publicField(this, "_markerCollection");
        /**
        * A map that stores changes that happened in a given element.
        *
        * The keys of the map are references to the model elements.
        * The values of the map are arrays with changes that were done on this element.
        */
        __publicField(this, "_changesInElement", /* @__PURE__ */ new Map());
        /**
        * Stores a snapshot for these model nodes that might have changed.
        *
        * This complements {@link ~Differ#_elementChildrenSnapshots `_elementChildrenSnapshots`}.
        *
        * See also {@link ~DifferSnapshot}.
        */
        __publicField(this, "_elementsSnapshots", /* @__PURE__ */ new Map());
        /**
        * For each element or document fragment inside which there was a change, it stores a snapshot of the child nodes list (an array
        * of children snapshots that represent the state in the element / fragment before any change has happened).
        *
        * This complements {@link ~Differ#_elementsSnapshots `_elementsSnapshots`}.
        *
        * See also {@link ~DifferSnapshot}.
        */
        __publicField(this, "_elementChildrenSnapshots", /* @__PURE__ */ new Map());
        /**
        * Keeps the state for a given element, describing how the element was changed so far. It is used to evaluate the `action` property
        * of diff items returned by {@link ~Differ#getChanges}.
        *
        * Possible values, in the order from the lowest priority to the highest priority:
        *
        * * `'refresh'` - element was refreshed,
        * * `'rename'` - element was renamed,
        * * `'move'` - element was moved (or, usually, removed, that is moved to the graveyard).
        *
        * Element that was refreshed, may change its state to `'rename'` if it was later renamed, or to `'move'` if it was removed.
        * But the element cannot change its state from `'move'` to `'rename'`, or from `'rename'` to `'refresh'`.
        *
        * Only already existing elements are registered in `_elementState`. If a new element was inserted as a result of a buffered operation,
        * it is not be registered in `_elementState`.
        */
        __publicField(this, "_elementState", /* @__PURE__ */ new Map());
        /**
        * A map that stores all changed markers.
        *
        * The keys of the map are marker names.
        *
        * The values of the map are objects with the following properties:
        *
        * * `oldMarkerData`,
        * * `newMarkerData`.
        */
        __publicField(this, "_changedMarkers", /* @__PURE__ */ new Map());
        /**
        * A map that stores all roots that have been changed.
        *
        * The keys are the names of the roots while value represents the changes.
        */
        __publicField(this, "_changedRoots", /* @__PURE__ */ new Map());
        /**
        * Stores the number of changes that were processed. Used to order the changes chronologically. It is important
        * when changes are sorted.
        */
        __publicField(this, "_changeCount", 0);
        /**
        * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.
        * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
        * return the cached value instead of calculating it again.
        *
        * This property stores those changes that did not take place in graveyard root.
        */
        __publicField(this, "_cachedChanges", null);
        /**
        * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.
        * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
        * return the cached value instead of calculating it again.
        *
        * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.
        */
        __publicField(this, "_cachedChangesWithGraveyard", null);
        /**
        * Set of model items that were marked to get refreshed in {@link #_refreshItem}.
        */
        __publicField(this, "_refreshedItems", /* @__PURE__ */ new Set());
        this._markerCollection = markerCollection;
      }
      /**
      * Informs whether there are any changes buffered in `Differ`.
      */
      get isEmpty() {
        return this._changesInElement.size == 0 && this._changedMarkers.size == 0 && this._changedRoots.size == 0;
      }
      /**
      * Buffers the given operation. **An operation has to be buffered before it is executed.**
      *
      * @param operationToBuffer An operation to buffer.
      */
      bufferOperation(operationToBuffer) {
        const operation = operationToBuffer;
        switch (operation.type) {
          case "insert": {
            if (this._isInInsertedElement(operation.position.parent)) {
              return;
            }
            this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);
            break;
          }
          case "addAttribute":
          case "removeAttribute":
          case "changeAttribute": {
            for (const item of operation.range.getItems({
              shallow: true
            })) {
              if (this._isInInsertedElement(item.parent)) {
                continue;
              }
              this._markAttribute(item);
            }
            break;
          }
          case "remove":
          case "move":
          case "reinsert": {
            if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {
              return;
            }
            const sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);
            const targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);
            if (!sourceParentInserted) {
              this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);
            }
            if (!targetParentInserted) {
              this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);
            }
            const range = Range._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
            for (const node of range.getItems({
              shallow: true
            })) {
              this._setElementState(node, "move");
            }
            break;
          }
          case "rename": {
            if (this._isInInsertedElement(operation.position.parent)) {
              return;
            }
            this._markRemove(operation.position.parent, operation.position.offset, 1);
            this._markInsert(operation.position.parent, operation.position.offset, 1);
            const range = Range._createFromPositionAndShift(operation.position, 1);
            for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {
              const markerData = marker.getData();
              this.bufferMarkerChange(marker.name, markerData, markerData);
            }
            this._setElementState(operation.position.nodeAfter, "rename");
            break;
          }
          case "split": {
            const splitElement = operation.splitPosition.parent;
            if (!this._isInInsertedElement(splitElement)) {
              this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);
              const range = Range._createFromPositionAndShift(operation.splitPosition, operation.howMany);
              for (const node of range.getItems({
                shallow: true
              })) {
                this._setElementState(node, "move");
              }
            }
            if (!this._isInInsertedElement(operation.insertionPosition.parent)) {
              this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);
            }
            if (operation.graveyardPosition) {
              this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);
              this._setElementState(operation.graveyardPosition.nodeAfter, "move");
            }
            break;
          }
          case "merge": {
            const mergedElement = operation.sourcePosition.parent;
            if (!this._isInInsertedElement(mergedElement.parent)) {
              this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);
            }
            const graveyardParent = operation.graveyardPosition.parent;
            this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1);
            this._setElementState(mergedElement, "move");
            const mergedIntoElement = operation.targetPosition.parent;
            if (!this._isInInsertedElement(mergedIntoElement)) {
              this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);
              const range = Range._createFromPositionAndShift(operation.sourcePosition, operation.howMany);
              for (const node of range.getItems({
                shallow: true
              })) {
                this._setElementState(node, "move");
              }
            }
            break;
          }
          case "detachRoot":
          case "addRoot": {
            const root2 = operation.affectedSelectable;
            if (!root2._isLoaded) {
              return;
            }
            if (root2.isAttached() == operation.isAdd) {
              return;
            }
            this._bufferRootStateChange(operation.rootName, operation.isAdd);
            break;
          }
          case "addRootAttribute":
          case "removeRootAttribute":
          case "changeRootAttribute": {
            if (!operation.root._isLoaded) {
              return;
            }
            const rootName = operation.root.rootName;
            this._bufferRootAttributeChange(rootName, operation.key, operation.oldValue, operation.newValue);
            break;
          }
        }
        this._cachedChanges = null;
      }
      /**
      * Buffers a marker change.
      *
      * @param markerName The name of the marker that changed.
      * @param oldMarkerData Marker data before the change.
      * @param newMarkerData Marker data after the change.
      */
      bufferMarkerChange(markerName, oldMarkerData, newMarkerData) {
        if (oldMarkerData.range && oldMarkerData.range.root.is("rootElement") && !oldMarkerData.range.root._isLoaded) {
          oldMarkerData.range = null;
        }
        if (newMarkerData.range && newMarkerData.range.root.is("rootElement") && !newMarkerData.range.root._isLoaded) {
          newMarkerData.range = null;
        }
        let buffered = this._changedMarkers.get(markerName);
        if (!buffered) {
          buffered = {
            newMarkerData,
            oldMarkerData
          };
          this._changedMarkers.set(markerName, buffered);
        } else {
          buffered.newMarkerData = newMarkerData;
        }
        if (buffered.oldMarkerData.range == null && newMarkerData.range == null) {
          this._changedMarkers.delete(markerName);
        }
      }
      /**
      * Returns all markers that should be removed as a result of buffered changes.
      *
      * @returns Markers to remove. Each array item is an object containing the `name` and `range` properties.
      */
      getMarkersToRemove() {
        const result = [];
        for (const [name, change] of this._changedMarkers) {
          if (change.oldMarkerData.range != null) {
            result.push({
              name,
              range: change.oldMarkerData.range
            });
          }
        }
        return result;
      }
      /**
      * Returns all markers which should be added as a result of buffered changes.
      *
      * @returns Markers to add. Each array item is an object containing the `name` and `range` properties.
      */
      getMarkersToAdd() {
        const result = [];
        for (const [name, change] of this._changedMarkers) {
          if (change.newMarkerData.range != null) {
            result.push({
              name,
              range: change.newMarkerData.range
            });
          }
        }
        return result;
      }
      /**
      * Returns all markers which changed.
      */
      getChangedMarkers() {
        return Array.from(this._changedMarkers).map(([name, change]) => ({
          name,
          data: {
            oldRange: change.oldMarkerData.range,
            newRange: change.newMarkerData.range
          }
        }));
      }
      /**
      * Checks whether some of the buffered changes affect the editor data.
      *
      * Types of changes which affect the editor data:
      *
      * * model structure changes,
      * * attribute changes,
      * * a root is added or detached,
      * * changes of markers which were defined as `affectsData`,
      * * changes of markers' `affectsData` property.
      */
      hasDataChanges() {
        if (this.getChanges().length) {
          return true;
        }
        if (this._changedRoots.size > 0) {
          return true;
        }
        for (const { newMarkerData, oldMarkerData } of this._changedMarkers.values()) {
          if (newMarkerData.affectsData !== oldMarkerData.affectsData) {
            return true;
          }
          if (newMarkerData.affectsData) {
            const markerAdded = newMarkerData.range && !oldMarkerData.range;
            const markerRemoved = !newMarkerData.range && oldMarkerData.range;
            const markerChanged = newMarkerData.range && oldMarkerData.range && !newMarkerData.range.isEqual(oldMarkerData.range);
            if (markerAdded || markerRemoved || markerChanged) {
              return true;
            }
          }
        }
        return false;
      }
      /**
      * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
      * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
      *
      * The diff set is returned as an array of {@link module:engine/model/differ~DiffItem diff items}, each describing a change done
      * on the model. The items are sorted by the position on which the change happened. If a position
      * {@link module:engine/model/position~Position#isBefore is before} another one, it will be on an earlier index in the diff set.
      *
      * **Note**: Elements inside inserted element will not have a separate diff item, only the top most element change will be reported.
      *
      * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
      * previous {@link #getChanges} call, the next call will return the cached value.
      *
      * @param options Additional options.
      * @param options.includeChangesInGraveyard If set to `true`, also changes that happened
      * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
      * @returns Diff between the old and the new model tree state.
      */
      getChanges(options = {}) {
        if (this._cachedChanges) {
          if (options.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard.slice();
          } else {
            return this._cachedChanges.slice();
          }
        }
        let diffSet = [];
        for (const element of this._changesInElement.keys()) {
          const changes = this._changesInElement.get(element).sort((a, b) => {
            if (a.offset === b.offset) {
              if (a.type != b.type) {
                return a.type == "remove" ? -1 : 1;
              }
              return 0;
            }
            return a.offset < b.offset ? -1 : 1;
          });
          const childrenBefore = this._elementChildrenSnapshots.get(element);
          const childrenAfter = _getChildrenSnapshots(element.getChildren());
          const diffInstructions = _generateDiffInstructionsFromChanges(childrenBefore.length, changes);
          let i = 0;
          let j = 0;
          for (const instruction of diffInstructions) {
            if (instruction === "i") {
              const action = this._getDiffActionForNode(childrenAfter[i].node, "insert");
              const childSnapshotBefore = this._elementsSnapshots.get(childrenAfter[i].node);
              const diffItem = this._getInsertDiff(element, i, action, childrenAfter[i], childSnapshotBefore);
              diffSet.push(diffItem);
              i++;
            } else if (instruction === "r") {
              const action = this._getDiffActionForNode(childrenBefore[j].node, "remove");
              const diffItem = this._getRemoveDiff(element, i, action, childrenBefore[j]);
              diffSet.push(diffItem);
              j++;
            } else if (instruction === "a") {
              const beforeAttributes = childrenBefore[j].attributes;
              const afterAttributes = childrenAfter[i].attributes;
              let range;
              if (childrenAfter[i].name == "$text") {
                range = new Range(Position._createAt(element, i), Position._createAt(element, i + 1));
              } else {
                const index2 = element.offsetToIndex(i);
                range = new Range(Position._createAt(element, i), Position._createAt(element.getChild(index2), 0));
              }
              const diffItems = this._getAttributesDiff(range, beforeAttributes, afterAttributes);
              diffSet.push(...diffItems);
              i++;
              j++;
            } else {
              i++;
              j++;
            }
          }
        }
        diffSet.sort((a, b) => {
          if (a.position.root != b.position.root) {
            return a.position.root.rootName < b.position.root.rootName ? -1 : 1;
          }
          if (a.position.isEqual(b.position)) {
            return a.changeCount - b.changeCount;
          }
          return a.position.isBefore(b.position) ? -1 : 1;
        });
        for (let i = 1, prevIndex = 0; i < diffSet.length; i++) {
          const prevDiff = diffSet[prevIndex];
          const thisDiff = diffSet[i];
          const isConsecutiveTextRemove = prevDiff.type == "remove" && thisDiff.type == "remove" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.isEqual(thisDiff.position);
          const isConsecutiveTextAdd = prevDiff.type == "insert" && thisDiff.type == "insert" && prevDiff.name == "$text" && thisDiff.name == "$text" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset;
          const isConsecutiveAttributeChange = prevDiff.type == "attribute" && thisDiff.type == "attribute" && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;
          if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {
            prevDiff.length++;
            if (isConsecutiveAttributeChange) {
              prevDiff.range.end = prevDiff.range.end.getShiftedBy(1);
            }
            diffSet[i] = null;
          } else {
            prevIndex = i;
          }
        }
        diffSet = diffSet.filter((v) => v);
        for (const item of diffSet) {
          delete item.changeCount;
          if (item.type == "attribute") {
            delete item.position;
            delete item.length;
          }
        }
        this._changeCount = 0;
        this._cachedChangesWithGraveyard = diffSet;
        this._cachedChanges = diffSet.filter(_changesInGraveyardFilter);
        if (options.includeChangesInGraveyard) {
          return this._cachedChangesWithGraveyard.slice();
        } else {
          return this._cachedChanges.slice();
        }
      }
      /**
      * Returns all roots that have changed (either were attached, or detached, or their attributes changed).
      *
      * @returns Diff between the old and the new roots state.
      */
      getChangedRoots() {
        return Array.from(this._changedRoots.values()).map((diffItem) => {
          const entry = {
            ...diffItem
          };
          if (entry.state !== void 0) {
            delete entry.attributes;
          }
          return entry;
        });
      }
      /**
      * Returns a set of model items that were marked to get refreshed.
      */
      getRefreshedItems() {
        return new Set(this._refreshedItems);
      }
      /**
      * Resets `Differ`. Removes all buffered changes.
      */
      reset() {
        this._changesInElement.clear();
        this._elementChildrenSnapshots.clear();
        this._elementsSnapshots.clear();
        this._elementState.clear();
        this._changedMarkers.clear();
        this._changedRoots.clear();
        this._refreshedItems.clear();
        this._cachedChanges = null;
      }
      /**
      * Marks the given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted
      * in the differ changes set, so it will be effectively re-converted when the differ changes are handled by a dispatcher.
      *
      * @internal
      * @param item Item to refresh.
      */
      _refreshItem(item) {
        if (this._isInInsertedElement(item.parent)) {
          return;
        }
        this._markRemove(item.parent, item.startOffset, item.offsetSize);
        this._markInsert(item.parent, item.startOffset, item.offsetSize);
        this._refreshedItems.add(item);
        this._setElementState(item, "refresh");
        const range = Range._createOn(item);
        for (const marker of this._markerCollection.getMarkersIntersectingRange(range)) {
          const markerData = marker.getData();
          this.bufferMarkerChange(marker.name, markerData, markerData);
        }
        this._cachedChanges = null;
      }
      /**
      * Buffers all the data related to given root like it was all just added to the editor.
      *
      * Following changes are buffered:
      *
      * * root is attached,
      * * all root content is inserted,
      * * all root attributes are added,
      * * all markers inside the root are added.
      *
      * @internal
      */
      _bufferRootLoad(root2) {
        if (!root2.isAttached()) {
          return;
        }
        this._bufferRootStateChange(root2.rootName, true);
        this._markInsert(root2, 0, root2.maxOffset);
        for (const key of root2.getAttributeKeys()) {
          this._bufferRootAttributeChange(root2.rootName, key, null, root2.getAttribute(key));
        }
        for (const marker of this._markerCollection) {
          if (marker.getRange().root == root2) {
            const markerData = marker.getData();
            this.bufferMarkerChange(marker.name, {
              ...markerData,
              range: null
            }, markerData);
          }
        }
      }
      /**
      * Buffers the root state change after the root was attached or detached
      */
      _bufferRootStateChange(rootName, isAttached) {
        if (!this._changedRoots.has(rootName)) {
          this._changedRoots.set(rootName, {
            name: rootName,
            state: isAttached ? "attached" : "detached"
          });
          return;
        }
        const diffItem = this._changedRoots.get(rootName);
        if (diffItem.state !== void 0) {
          delete diffItem.state;
          if (diffItem.attributes === void 0) {
            this._changedRoots.delete(rootName);
          }
        } else {
          diffItem.state = isAttached ? "attached" : "detached";
        }
      }
      /**
      * Buffers a root attribute change.
      */
      _bufferRootAttributeChange(rootName, key, oldValue, newValue) {
        const diffItem = this._changedRoots.get(rootName) || {
          name: rootName
        };
        const attrs = diffItem.attributes || {};
        if (attrs[key]) {
          const attrEntry = attrs[key];
          if (newValue === attrEntry.oldValue) {
            delete attrs[key];
          } else {
            attrEntry.newValue = newValue;
          }
        } else {
          attrs[key] = {
            oldValue,
            newValue
          };
        }
        if (Object.entries(attrs).length === 0) {
          delete diffItem.attributes;
          if (diffItem.state === void 0) {
            this._changedRoots.delete(rootName);
          }
        } else {
          diffItem.attributes = attrs;
          this._changedRoots.set(rootName, diffItem);
        }
      }
      /**
      * Saves and handles an insert change.
      */
      _markInsert(parent2, offset, howMany) {
        if (parent2.root.is("rootElement") && !parent2.root._isLoaded) {
          return;
        }
        const changeItem = {
          type: "insert",
          offset,
          howMany,
          count: this._changeCount++
        };
        this._markChange(parent2, changeItem);
      }
      /**
      * Saves and handles a remove change.
      */
      _markRemove(parent2, offset, howMany) {
        if (parent2.root.is("rootElement") && !parent2.root._isLoaded) {
          return;
        }
        const changeItem = {
          type: "remove",
          offset,
          howMany,
          count: this._changeCount++
        };
        this._markChange(parent2, changeItem);
        this._removeAllNestedChanges(parent2, offset, howMany);
      }
      /**
      * Saves and handles an attribute change.
      */
      _markAttribute(item) {
        if (item.root.is("rootElement") && !item.root._isLoaded) {
          return;
        }
        const changeItem = {
          type: "attribute",
          offset: item.startOffset,
          howMany: item.offsetSize,
          count: this._changeCount++
        };
        this._markChange(item.parent, changeItem);
      }
      /**
      * Saves and handles a model change.
      */
      _markChange(parent2, changeItem) {
        this._makeSnapshots(parent2);
        const changes = this._getChangesForElement(parent2);
        this._handleChange(changeItem, changes);
        changes.push(changeItem);
        for (let i = 0; i < changes.length; i++) {
          if (changes[i].howMany < 1) {
            changes.splice(i, 1);
            i--;
          }
        }
      }
      /**
      * Tries to set given state for given item.
      *
      * This method does simple validation (it sets the state only for model elements, not for text proxy nodes). It also follows state
      * setting rules, that is, `'refresh'` cannot overwrite `'rename'`, and `'rename'` cannot overwrite `'move'`.
      */
      _setElementState(node, state) {
        if (!node.is("element")) {
          return;
        }
        const currentStatePriority = _Differ._statesPriority.indexOf(this._elementState.get(node));
        const newStatePriority = _Differ._statesPriority.indexOf(state);
        if (newStatePriority > currentStatePriority) {
          this._elementState.set(node, state);
        }
      }
      /**
      * Returns a value for {@link ~DifferItemAction `action`} property for diff items returned by {@link ~Differ#getChanges}.
      * This method aims to return `'rename'` or `'refresh'` when it should, and `diffItemType` ("default action") in all other cases.
      *
      * It bases on a few factors:
      *
      * * for text nodes, the method always returns `diffItemType`,
      * * for newly inserted element, the method returns `diffItemType`,
      * * if {@link ~Differ#_elementState element state} was not recorded, the method returns `diffItemType`,
      * * if state was recorded, and it was `'move'` (default action), the method returns `diffItemType`,
      * * finally, if state was `'refresh'` or `'rename'`, the method returns the state value.
      */
      _getDiffActionForNode(node, diffItemType) {
        if (!node.is("element")) {
          return diffItemType;
        }
        if (!this._elementsSnapshots.has(node)) {
          return diffItemType;
        }
        const state = this._elementState.get(node);
        if (!state || state == "move") {
          return diffItemType;
        }
        return state;
      }
      /**
      * Gets an array of changes that have already been saved for a given element.
      */
      _getChangesForElement(element) {
        let changes;
        if (this._changesInElement.has(element)) {
          changes = this._changesInElement.get(element);
        } else {
          changes = [];
          this._changesInElement.set(element, changes);
        }
        return changes;
      }
      /**
      * Creates and saves a snapshot for all children of the given element.
      */
      _makeSnapshots(element) {
        if (this._elementChildrenSnapshots.has(element)) {
          return;
        }
        const childrenSnapshots = _getChildrenSnapshots(element.getChildren());
        this._elementChildrenSnapshots.set(element, childrenSnapshots);
        for (const snapshot of childrenSnapshots) {
          this._elementsSnapshots.set(snapshot.node, snapshot);
        }
      }
      /**
      * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
      * change and/or the old change.
      *
      * @param inc Incoming (new) change.
      * @param changes An array containing all the changes done on that element.
      */
      _handleChange(inc, changes) {
        inc.nodesToHandle = inc.howMany;
        for (const old of changes) {
          const incEnd = inc.offset + inc.howMany;
          const oldEnd = old.offset + old.howMany;
          if (inc.type == "insert") {
            if (old.type == "insert") {
              if (inc.offset <= old.offset) {
                old.offset += inc.howMany;
              } else if (inc.offset < oldEnd) {
                old.howMany += inc.nodesToHandle;
                inc.nodesToHandle = 0;
              }
            }
            if (old.type == "remove") {
              if (inc.offset < old.offset) {
                old.offset += inc.howMany;
              }
            }
            if (old.type == "attribute") {
              if (inc.offset <= old.offset) {
                old.offset += inc.howMany;
              } else if (inc.offset < oldEnd) {
                const howMany = old.howMany;
                old.howMany = inc.offset - old.offset;
                changes.unshift({
                  type: "attribute",
                  offset: incEnd,
                  howMany: howMany - old.howMany,
                  count: this._changeCount++
                });
              }
            }
          }
          if (inc.type == "remove") {
            if (old.type == "insert") {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (incEnd <= oldEnd) {
                if (inc.offset < old.offset) {
                  const intersectionLength = incEnd - old.offset;
                  old.offset = inc.offset;
                  old.howMany -= intersectionLength;
                  inc.nodesToHandle -= intersectionLength;
                } else {
                  old.howMany -= inc.nodesToHandle;
                  inc.nodesToHandle = 0;
                }
              } else {
                if (inc.offset <= old.offset) {
                  inc.nodesToHandle -= old.howMany;
                  old.howMany = 0;
                } else if (inc.offset < oldEnd) {
                  const intersectionLength = oldEnd - inc.offset;
                  old.howMany -= intersectionLength;
                  inc.nodesToHandle -= intersectionLength;
                }
              }
            }
            if (old.type == "remove") {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (inc.offset < old.offset) {
                inc.nodesToHandle += old.howMany;
                old.howMany = 0;
              }
            }
            if (old.type == "attribute") {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (inc.offset < old.offset) {
                const intersectionLength = incEnd - old.offset;
                old.offset = inc.offset;
                old.howMany -= intersectionLength;
              } else if (inc.offset < oldEnd) {
                if (incEnd <= oldEnd) {
                  const howMany = old.howMany;
                  old.howMany = inc.offset - old.offset;
                  const howManyAfter = howMany - old.howMany - inc.nodesToHandle;
                  changes.unshift({
                    type: "attribute",
                    offset: inc.offset,
                    howMany: howManyAfter,
                    count: this._changeCount++
                  });
                } else {
                  old.howMany -= oldEnd - inc.offset;
                }
              }
            }
          }
          if (inc.type == "attribute") {
            if (old.type == "insert") {
              if (inc.offset < old.offset && incEnd > old.offset) {
                if (incEnd > oldEnd) {
                  const attributePart = {
                    type: "attribute",
                    offset: oldEnd,
                    howMany: incEnd - oldEnd,
                    count: this._changeCount++
                  };
                  this._handleChange(attributePart, changes);
                  changes.push(attributePart);
                }
                inc.nodesToHandle = old.offset - inc.offset;
                inc.howMany = inc.nodesToHandle;
              } else if (inc.offset >= old.offset && inc.offset < oldEnd) {
                if (incEnd > oldEnd) {
                  inc.nodesToHandle = incEnd - oldEnd;
                  inc.offset = oldEnd;
                } else {
                  inc.nodesToHandle = 0;
                }
              }
            }
            if (old.type == "remove") {
              if (inc.offset < old.offset && incEnd > old.offset) {
                const attributePart = {
                  type: "attribute",
                  offset: old.offset,
                  howMany: incEnd - old.offset,
                  count: this._changeCount++
                };
                this._handleChange(attributePart, changes);
                changes.push(attributePart);
                inc.nodesToHandle = old.offset - inc.offset;
                inc.howMany = inc.nodesToHandle;
              }
            }
            if (old.type == "attribute") {
              if (inc.offset >= old.offset && incEnd <= oldEnd) {
                inc.nodesToHandle = 0;
                inc.howMany = 0;
                inc.offset = 0;
              } else if (inc.offset <= old.offset && incEnd >= oldEnd) {
                old.howMany = 0;
              }
            }
          }
        }
        inc.howMany = inc.nodesToHandle;
        delete inc.nodesToHandle;
      }
      /**
      * Returns an object with a single insert change description.
      *
      * @param parent The element in which the change happened.
      * @param offset The offset at which change happened.
      * @param action Further specifies what kind of action led to generating this change.
      * @param elementSnapshot Snapshot of the inserted node after changes.
      * @param elementSnapshotBefore Snapshot of the inserted node before changes.
      * @returns The diff item.
      */
      _getInsertDiff(parent2, offset, action, elementSnapshot, elementSnapshotBefore) {
        const diffItem = {
          type: "insert",
          position: Position._createAt(parent2, offset),
          name: elementSnapshot.name,
          attributes: new Map(elementSnapshot.attributes),
          length: 1,
          changeCount: this._changeCount++,
          action
        };
        if (action != "insert" && elementSnapshotBefore) {
          diffItem.before = {
            name: elementSnapshotBefore.name,
            attributes: new Map(elementSnapshotBefore.attributes)
          };
        }
        return diffItem;
      }
      /**
      * Returns an object with a single remove change description.
      *
      * @param parent The element in which change happened.
      * @param offset The offset at which change happened.
      * @param action Further specifies what kind of action led to generating this change.
      * @param elementSnapshot The snapshot of the removed node before changes.
      * @returns The diff item.
      */
      _getRemoveDiff(parent2, offset, action, elementSnapshot) {
        return {
          type: "remove",
          action,
          position: Position._createAt(parent2, offset),
          name: elementSnapshot.name,
          attributes: new Map(elementSnapshot.attributes),
          length: 1,
          changeCount: this._changeCount++
        };
      }
      /**
      * Returns an array of objects where each one is a single attribute change description.
      *
      * @param range The range where the change happened.
      * @param oldAttributes A map, map iterator or compatible object that contains attributes before the change.
      * @param newAttributes A map, map iterator or compatible object that contains attributes after the change.
      * @returns An array containing one or more diff items.
      */
      _getAttributesDiff(range, oldAttributes, newAttributes) {
        const diffs = [];
        newAttributes = new Map(newAttributes);
        for (const [key, oldValue] of oldAttributes) {
          const newValue = newAttributes.has(key) ? newAttributes.get(key) : null;
          if (newValue !== oldValue) {
            diffs.push({
              type: "attribute",
              position: range.start,
              range: range.clone(),
              length: 1,
              attributeKey: key,
              attributeOldValue: oldValue,
              attributeNewValue: newValue,
              changeCount: this._changeCount++
            });
          }
          newAttributes.delete(key);
        }
        for (const [key, newValue] of newAttributes) {
          diffs.push({
            type: "attribute",
            position: range.start,
            range: range.clone(),
            length: 1,
            attributeKey: key,
            attributeOldValue: null,
            attributeNewValue: newValue,
            changeCount: this._changeCount++
          });
        }
        return diffs;
      }
      /**
      * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
      */
      _isInInsertedElement(element) {
        const parent2 = element.parent;
        if (!parent2) {
          return false;
        }
        const changes = this._changesInElement.get(parent2);
        const offset = element.startOffset;
        if (changes) {
          for (const change of changes) {
            if (change.type == "insert" && offset >= change.offset && offset < change.offset + change.howMany) {
              return true;
            }
          }
        }
        return this._isInInsertedElement(parent2);
      }
      /**
      * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
      * and `howMany`.
      */
      _removeAllNestedChanges(parent2, offset, howMany) {
        const range = new Range(Position._createAt(parent2, offset), Position._createAt(parent2, offset + howMany));
        for (const item of range.getItems({
          shallow: true
        })) {
          if (item.is("element")) {
            this._changesInElement.delete(item);
            this._removeAllNestedChanges(item, 0, item.maxOffset);
          }
        }
      }
    };
    /**
    * Priority of the {@link ~Differ#_elementState element states}. States on higher indexes of the array can overwrite states on the lower
    * indexes.
    */
    __publicField(_Differ, "_statesPriority", [
      void 0,
      "refresh",
      "rename",
      "move"
    ]);
    let Differ = _Differ;
    function _getSingleNodeSnapshot(node) {
      return {
        node,
        name: node.is("$text") ? "$text" : node.name,
        attributes: new Map(node.getAttributes())
      };
    }
    function _getChildrenSnapshots(children) {
      const snapshots = [];
      for (const child of children) {
        if (child.is("$text")) {
          for (let i = 0; i < child.data.length; ++i) {
            snapshots.push(_getSingleNodeSnapshot(child));
          }
        } else {
          snapshots.push(_getSingleNodeSnapshot(child));
        }
      }
      return snapshots;
    }
    function _generateDiffInstructionsFromChanges(oldChildrenLength, changes) {
      const diff2 = [];
      let offset = 0;
      let oldChildrenHandled = 0;
      for (const change of changes) {
        if (change.offset > offset) {
          for (let i = 0; i < change.offset - offset; i++) {
            diff2.push("e");
          }
          oldChildrenHandled += change.offset - offset;
        }
        if (change.type == "insert") {
          for (let i = 0; i < change.howMany; i++) {
            diff2.push("i");
          }
          offset = change.offset + change.howMany;
        } else if (change.type == "remove") {
          for (let i = 0; i < change.howMany; i++) {
            diff2.push("r");
          }
          offset = change.offset;
          oldChildrenHandled += change.howMany;
        } else {
          diff2.push(..."a".repeat(change.howMany).split(""));
          offset = change.offset + change.howMany;
          oldChildrenHandled += change.howMany;
        }
      }
      if (oldChildrenHandled < oldChildrenLength) {
        for (let i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {
          diff2.push("e");
        }
      }
      return diff2;
    }
    function _changesInGraveyardFilter(entry) {
      const posInGy = "position" in entry && entry.position.root.rootName == "$graveyard";
      const rangeInGy = "range" in entry && entry.range.root.rootName == "$graveyard";
      return !posInGy && !rangeInGy;
    }
    class History {
      constructor() {
        /**
        * Operations added to the history.
        */
        __publicField(this, "_operations", []);
        /**
        * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which
        * {@link module:engine/model/operation/operation~Operation operation}.
        *
        * Keys of the map are "undoing operations", that is operations that undone some other operations. For each key, the
        * value is an operation that has been undone by the "undoing operation".
        */
        __publicField(this, "_undoPairs", /* @__PURE__ */ new Map());
        /**
        * Holds all undone operations.
        */
        __publicField(this, "_undoneOperations", /* @__PURE__ */ new Set());
        /**
        * A map that allows retrieving the operations fast based on the given base version.
        */
        __publicField(this, "_baseVersionToOperationIndex", /* @__PURE__ */ new Map());
        /**
        * The history version.
        */
        __publicField(this, "_version", 0);
        /**
        * The gap pairs kept in the <from,to> format.
        *
        * Anytime the `history.version` is set to a version larger than `history.version + 1`,
        * a new <lastHistoryVersion, newHistoryVersion> entry is added to the map.
        */
        __publicField(this, "_gaps", /* @__PURE__ */ new Map());
      }
      /**
      * The version of the last operation in the history.
      *
      * The history version is incremented automatically when a new operation is added to the history.
      * Setting the version manually should be done only in rare circumstances when a gap is planned
      * between history versions. When doing so, a gap will be created and the history will accept adding
      * an operation with base version equal to the new history version.
      */
      get version() {
        return this._version;
      }
      set version(version2) {
        if (this._operations.length && version2 > this._version + 1) {
          this._gaps.set(this._version, version2);
        }
        this._version = version2;
      }
      /**
      * The last history operation.
      */
      get lastOperation() {
        return this._operations[this._operations.length - 1];
      }
      /**
      * Adds an operation to the history and increments the history version.
      *
      * The operation's base version should be equal to the history version. Otherwise an error is thrown.
      */
      addOperation(operation) {
        if (operation.baseVersion !== this.version) {
          throw new CKEditorError("model-document-history-addoperation-incorrect-version", this, {
            operation,
            historyVersion: this.version
          });
        }
        this._operations.push(operation);
        this._version++;
        this._baseVersionToOperationIndex.set(operation.baseVersion, this._operations.length - 1);
      }
      /**
      * Returns operations from the given range of operation base versions that were added to the history.
      *
      * Note that there may be gaps in operations base versions.
      *
      * @param fromBaseVersion Base version from which operations should be returned (inclusive).
      * @param toBaseVersion Base version up to which operations should be returned (exclusive).
         * @returns History operations for the given range, in chronological order.
      */
      getOperations(fromBaseVersion, toBaseVersion = this.version) {
        if (!this._operations.length) {
          return [];
        }
        const firstOperation = this._operations[0];
        if (fromBaseVersion === void 0) {
          fromBaseVersion = firstOperation.baseVersion;
        }
        let inclusiveTo = toBaseVersion - 1;
        for (const [gapFrom, gapTo] of this._gaps) {
          if (fromBaseVersion > gapFrom && fromBaseVersion < gapTo) {
            fromBaseVersion = gapTo;
          }
          if (inclusiveTo > gapFrom && inclusiveTo < gapTo) {
            inclusiveTo = gapFrom - 1;
          }
        }
        if (inclusiveTo < firstOperation.baseVersion || fromBaseVersion > this.lastOperation.baseVersion) {
          return [];
        }
        let fromIndex = this._baseVersionToOperationIndex.get(fromBaseVersion);
        if (fromIndex === void 0) {
          fromIndex = 0;
        }
        let toIndex = this._baseVersionToOperationIndex.get(inclusiveTo);
        if (toIndex === void 0) {
          toIndex = this._operations.length - 1;
        }
        return this._operations.slice(
          fromIndex,
          // The `toIndex` should be included in the returned operations, so add `1`.
          toIndex + 1
        );
      }
      /**
      * Returns operation from the history that bases on given `baseVersion`.
      *
      * @param baseVersion Base version of the operation to get.
      * @returns Operation with given base version or `undefined` if there is no such operation in history.
      */
      getOperation(baseVersion) {
        const operationIndex = this._baseVersionToOperationIndex.get(baseVersion);
        if (operationIndex === void 0) {
          return;
        }
        return this._operations[operationIndex];
      }
      /**
      * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
      * history is keeping more context information about operations, which helps in operational transformation.
      *
      * @param undoneOperation Operation which is undone by `undoingOperation`.
      * @param undoingOperation Operation which undoes `undoneOperation`.
      */
      setOperationAsUndone(undoneOperation, undoingOperation) {
        this._undoPairs.set(undoingOperation, undoneOperation);
        this._undoneOperations.add(undoneOperation);
      }
      /**
      * Checks whether given `operation` is undoing any other operation.
      *
      * @param operation Operation to check.
      * @returns `true` if given `operation` is undoing any other operation, `false` otherwise.
      */
      isUndoingOperation(operation) {
        return this._undoPairs.has(operation);
      }
      /**
      * Checks whether given `operation` has been undone by any other operation.
      *
      * @param operation Operation to check.
      * @returns `true` if given `operation` has been undone any other operation, `false` otherwise.
      */
      isUndoneOperation(operation) {
        return this._undoneOperations.has(operation);
      }
      /**
      * For given `undoingOperation`, returns the operation which has been undone by it.
      *
      * @returns Operation that has been undone by given `undoingOperation` or `undefined`
      * if given `undoingOperation` is not undoing any other operation.
      */
      getUndoneOperation(undoingOperation) {
        return this._undoPairs.get(undoingOperation);
      }
      /**
      * Resets the history of operations.
      */
      reset() {
        this._version = 0;
        this._undoPairs = /* @__PURE__ */ new Map();
        this._operations = [];
        this._undoneOperations = /* @__PURE__ */ new Set();
        this._gaps = /* @__PURE__ */ new Map();
        this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
      }
    }
    class RootElement extends Element {
      /**
      * Creates root element.
      *
      * @param document Document that is an owner of this root.
      * @param name Node name.
      * @param rootName Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
      */
      constructor(document2, name, rootName = "main") {
        super(name);
        /**
        * Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
        */
        __publicField(this, "rootName");
        /**
        * Document that is an owner of this root.
        */
        __publicField(this, "_document");
        /**
        * @internal
        */
        __publicField(this, "_isAttached", true);
        /**
        * Informs if the root element is loaded (default).
        *
        * @internal
        */
        __publicField(this, "_isLoaded", true);
        this._document = document2;
        this.rootName = rootName;
      }
      /**
      * {@link module:engine/model/document~Document Document} that owns this root element.
      */
      get document() {
        return this._document;
      }
      /**
      * Informs if the root element is currently attached to the document, or not.
      *
      * A detached root is equivalent to being removed and cannot contain any children or markers.
      *
      * By default, a newly added root is attached. It can be detached using
      * {@link module:engine/model/writer~Writer#detachRoot `Writer#detachRoot`}. A detached root can be re-attached again using
      * {@link module:engine/model/writer~Writer#addRoot `Writer#addRoot`}.
      */
      isAttached() {
        return this._isAttached;
      }
      /**
      * Converts `RootElement` instance to `string` containing its name.
      *
      * @returns `RootElement` instance converted to `string`.
      */
      toJSON() {
        return this.rootName;
      }
    }
    RootElement.prototype.is = function(type, name) {
      if (!name) {
        return type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === "element" || type === "model:element" || type === "node" || type === "model:node";
      }
      return name === this.name && (type === "rootElement" || type === "model:rootElement" || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === "element" || type === "model:element");
    };
    const graveyardName = "$graveyard";
    class Document extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an empty document instance with no {@link #roots} (other than
      * the {@link #graveyard graveyard root}).
      */
      constructor(model) {
        super();
        /**
        * The {@link module:engine/model/model~Model model} that the document is a part of.
        */
        __publicField(this, "model");
        /**
        * The document's history.
        */
        __publicField(this, "history");
        /**
        * The selection in this document.
        */
        __publicField(this, "selection");
        /**
        * A list of roots that are owned and managed by this document. Use {@link #createRoot}, {@link #getRoot} and
        * {@link #getRootNames} to manipulate it.
        */
        __publicField(this, "roots");
        /**
        * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.
        */
        __publicField(this, "differ");
        /**
        * Defines whether the document is in a read-only mode.
        *
        * The user should not be able to change the data of a document that is read-only.
        *
        * @readonly
        */
        __publicField(this, "isReadOnly");
        /**
        * Post-fixer callbacks registered to the model document.
        */
        __publicField(this, "_postFixers");
        /**
        * A flag that indicates whether the selection has changed since last change block.
        */
        __publicField(this, "_hasSelectionChangedFromTheLastChangeBlock");
        this.model = model;
        this.history = new History();
        this.selection = new DocumentSelection(this);
        this.roots = new Collection({
          idProperty: "rootName"
        });
        this.differ = new Differ(model.markers);
        this.isReadOnly = false;
        this._postFixers = /* @__PURE__ */ new Set();
        this._hasSelectionChangedFromTheLastChangeBlock = false;
        this.createRoot("$root", graveyardName);
        this.listenTo(model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (operation.isDocumentOperation) {
            this.differ.bufferOperation(operation);
          }
        }, {
          priority: "high"
        });
        this.listenTo(model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (operation.isDocumentOperation) {
            this.history.addOperation(operation);
          }
        }, {
          priority: "low"
        });
        this.listenTo(this.selection, "change", () => {
          this._hasSelectionChangedFromTheLastChangeBlock = true;
        });
        this.listenTo(model.markers, "update", (evt, marker, oldRange, newRange, oldMarkerData) => {
          const newMarkerData = {
            ...marker.getData(),
            range: newRange
          };
          this.differ.bufferMarkerChange(marker.name, oldMarkerData, newMarkerData);
          if (oldRange === null) {
            marker.on("change", (evt2, oldRange2) => {
              const markerData = marker.getData();
              this.differ.bufferMarkerChange(marker.name, {
                ...markerData,
                range: oldRange2
              }, markerData);
            });
          }
        });
        this.registerPostFixer((writer) => {
          let result = false;
          for (const root2 of this.roots) {
            if (!root2.isAttached() && !root2.isEmpty) {
              writer.remove(writer.createRangeIn(root2));
              result = true;
            }
          }
          for (const marker of this.model.markers) {
            if (!marker.getRange().root.isAttached()) {
              writer.removeMarker(marker);
              result = true;
            }
          }
          return result;
        });
      }
      /**
      * The document version. Every applied operation increases the version number. It is used to
      * ensure that operations are applied on a proper document version.
      *
      * This property is equal to {@link module:engine/model/history~History#version `model.Document#history#version`}.
      *
      * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
      * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyoperation-wrong-version} error is thrown.
      */
      get version() {
        return this.history.version;
      }
      set version(version2) {
        this.history.version = version2;
      }
      /**
      * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
      */
      get graveyard() {
        return this.getRoot(graveyardName);
      }
      /**
      * Creates a new root.
      *
      * **Note:** do not use this method after the editor has been initialized! If you want to dynamically add a root, use
      * {@link module:engine/model/writer~Writer#addRoot `model.Writer#addRoot`} instead.
      *
      * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
      * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
      * @param rootName A unique root name.
      * @returns The created root.
      */
      createRoot(elementName = "$root", rootName = "main") {
        if (this.roots.get(rootName)) {
          throw new CKEditorError("model-document-createroot-name-exists", this, {
            name: rootName
          });
        }
        const root2 = new RootElement(this, elementName, rootName);
        this.roots.add(root2);
        return root2;
      }
      /**
      * Removes all event listeners set by the document instance.
      */
      destroy() {
        this.selection.destroy();
        this.stopListening();
      }
      /**
      * Returns a root by its name.
      *
      * Detached roots are returned by this method. This is to be able to operate on the detached root (for example, to be able to create
      * a position inside such a root for undo feature purposes).
      *
      * @param name The root name of the root to return.
      * @returns The root registered under a given name or `null` when there is no root with the given name.
      */
      getRoot(name = "main") {
        return this.roots.get(name);
      }
      /**
      * Returns an array with names of all roots added to the document (except the {@link #graveyard graveyard root}).
      *
      * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
      * on the document data know which roots are still a part of the document and should be processed.
      *
      * @param includeDetached Specified whether detached roots should be returned as well.
      */
      getRootNames(includeDetached = false) {
        return this.getRoots(includeDetached).map((root2) => root2.rootName);
      }
      /**
      * Returns an array with all roots added to the document (except the {@link #graveyard graveyard root}).
      *
      * Detached roots **are not** returned by this method by default. This is to make sure that all features or algorithms that operate
      * on the document data know which roots are still a part of the document and should be processed.
      *
      * @param includeDetached Specified whether detached roots should be returned as well.
      */
      getRoots(includeDetached = false) {
        return this.roots.filter((root2) => root2 != this.graveyard && (includeDetached || root2.isAttached()) && root2._isLoaded);
      }
      /**
      * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
      * will operate on a correct model state.
      *
      * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
      * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
      * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
      * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
      * not be fixed in the new document tree state.
      *
      * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
      * executed changes block. Thanks to that, all changes done by the callback will be added to the same
      * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
      * for the user.
      *
      * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
      * callback should add an empty paragraph so that the editor is never empty:
      *
      * ```ts
      * document.registerPostFixer( writer => {
      * 	const changes = document.differ.getChanges();
      *
      * 	// Check if the changes lead to an empty root in the editor.
      * 	for ( const entry of changes ) {
      * 		if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
      * 			writer.insertElement( 'paragraph', entry.position.root, 0 );
      *
      * 			// It is fine to return early, even if multiple roots would need to be fixed.
      * 			// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
      * 			return true;
      * 		}
      * 	}
      *
      * 	return false;
      * } );
      * ```
      */
      registerPostFixer(postFixer) {
        this._postFixers.add(postFixer);
      }
      /**
      * A custom `toJSON()` method to solve child-parent circular dependencies.
      *
      * @returns A clone of this object with the document property changed to a string.
      */
      toJSON() {
        const json = clone$1(this);
        json.selection = "[engine.model.DocumentSelection]";
        json.model = "[engine.model.Model]";
        return json;
      }
      /**
      * Check if there were any changes done on document, and if so, call post-fixers,
      * fire `change` event for features and conversion and then reset the differ.
      * Fire `change:data` event when at least one operation or buffered marker changes the data.
      *
      * @internal
      * @fires change
      * @fires change:data
      * @param writer The writer on which post-fixers will be called.
      */
      _handleChangeBlock(writer) {
        if (this._hasDocumentChangedFromTheLastChangeBlock()) {
          this._callPostFixers(writer);
          this.selection.refresh();
          if (this.differ.hasDataChanges()) {
            this.fire("change:data", writer.batch);
          } else {
            this.fire("change", writer.batch);
          }
          this.selection.refresh();
          this.differ.reset();
        }
        this._hasSelectionChangedFromTheLastChangeBlock = false;
      }
      /**
      * Returns whether there is a buffered change or if the selection has changed from the last
      * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
      * or {@link module:engine/model/model~Model#change `change()` block}.
      *
      * @returns Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
      */
      _hasDocumentChangedFromTheLastChangeBlock() {
        return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
      }
      /**
      * Returns the default root for this document which is either the first root that was added to the document using
      * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
      *
      * @returns The default root for this document.
      */
      _getDefaultRoot() {
        const roots = this.getRoots();
        return roots.length ? roots[0] : this.graveyard;
      }
      /**
      * Returns the default range for this selection. The default range is a collapsed range that starts and ends
      * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
      *
      * @internal
      */
      _getDefaultRange() {
        const defaultRoot = this._getDefaultRoot();
        const model = this.model;
        const schema = model.schema;
        const position = model.createPositionFromPath(defaultRoot, [
          0
        ]);
        const nearestRange = schema.getNearestSelectionRange(position);
        return nearestRange || model.createRange(position);
      }
      /**
      * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
      * the {@link #selection document's selection}.
      *
      * @internal
      * @param range A range to check.
      * @returns `true` if `range` is valid, `false` otherwise.
      */
      _validateSelectionRange(range) {
        return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);
      }
      /**
      * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
      *
      * @param writer The writer on which post-fixer callbacks will be called.
      */
      _callPostFixers(writer) {
        let wasFixed = false;
        do {
          for (const callback of this._postFixers) {
            this.selection.refresh();
            wasFixed = callback(writer);
            if (wasFixed) {
              break;
            }
          }
        } while (wasFixed);
      }
    }
    function validateTextNodePosition(rangeBoundary) {
      const textNode = rangeBoundary.textNode;
      if (textNode) {
        const data = textNode.data;
        const offset = rangeBoundary.offset - textNode.startOffset;
        return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);
      }
      return true;
    }
    class MarkerCollection extends (/* @__PURE__ */ EmitterMixin()) {
      constructor() {
        super(...arguments);
        /**
        * Stores {@link ~Marker markers} added to the collection.
        */
        __publicField(this, "_markers", /* @__PURE__ */ new Map());
      }
      /**
      * Iterable interface.
      *
      * Iterates over all {@link ~Marker markers} added to the collection.
      */
      [Symbol.iterator]() {
        return this._markers.values();
      }
      /**
      * Checks if given {@link ~Marker marker} or marker name is in the collection.
      *
      * @param markerOrName Name of marker or marker instance to check.
      * @returns `true` if marker is in the collection, `false` otherwise.
      */
      has(markerOrName) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        return this._markers.has(markerName);
      }
      /**
      * Returns {@link ~Marker marker} with given `markerName`.
      *
      * @param markerName Name of marker to get.
      * @returns Marker with given name or `null` if such marker was
      * not added to the collection.
      */
      get(markerName) {
        return this._markers.get(markerName) || null;
      }
      /**
      * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
      * {@link module:engine/model/range~Range range}.
      *
      * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
      * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
      * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
      * flag has changed.
      *
      * @internal
      * @fires update
      * @param markerOrName Name of marker to set or marker instance to update.
      * @param range Marker range.
      * @param managedUsingOperations Specifies whether the marker is managed using operations.
      * @param affectsData Specifies whether the marker affects the data produced by the data pipeline
      * (is persisted in the editor's data).
      * @returns `Marker` instance which was added or updated.
      */
      _set(markerOrName, range, managedUsingOperations = false, affectsData = false) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        if (markerName.includes(",")) {
          throw new CKEditorError("markercollection-incorrect-marker-name", this);
        }
        const oldMarker = this._markers.get(markerName);
        if (oldMarker) {
          const oldMarkerData = oldMarker.getData();
          const oldRange = oldMarker.getRange();
          let hasChanged = false;
          if (!oldRange.isEqual(range)) {
            oldMarker._attachLiveRange(LiveRange.fromRange(range));
            hasChanged = true;
          }
          if (managedUsingOperations != oldMarker.managedUsingOperations) {
            oldMarker._managedUsingOperations = managedUsingOperations;
            hasChanged = true;
          }
          if (typeof affectsData === "boolean" && affectsData != oldMarker.affectsData) {
            oldMarker._affectsData = affectsData;
            hasChanged = true;
          }
          if (hasChanged) {
            this.fire(`update:${markerName}`, oldMarker, oldRange, range, oldMarkerData);
          }
          return oldMarker;
        }
        const liveRange = LiveRange.fromRange(range);
        const marker = new Marker(markerName, liveRange, managedUsingOperations, affectsData);
        this._markers.set(markerName, marker);
        this.fire(`update:${markerName}`, marker, null, range, {
          ...marker.getData(),
          range: null
        });
        return marker;
      }
      /**
      * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
      *
      * @internal
      * @fires update
      * @param markerOrName Marker or name of a marker to remove.
      * @returns `true` if marker was found and removed, `false` otherwise.
      */
      _remove(markerOrName) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        const oldMarker = this._markers.get(markerName);
        if (oldMarker) {
          this._markers.delete(markerName);
          this.fire(`update:${markerName}`, oldMarker, oldMarker.getRange(), null, oldMarker.getData());
          this._destroyMarker(oldMarker);
          return true;
        }
        return false;
      }
      /**
      * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
      * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
      * conversion} for the marker.
      *
      * @internal
      * @fires update
      * @param markerOrName Marker or name of a marker to refresh.
      */
      _refresh(markerOrName) {
        const markerName = markerOrName instanceof Marker ? markerOrName.name : markerOrName;
        const marker = this._markers.get(markerName);
        if (!marker) {
          throw new CKEditorError("markercollection-refresh-marker-not-exists", this);
        }
        const range = marker.getRange();
        this.fire(`update:${markerName}`, marker, range, range, marker.getData());
      }
      /**
      * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
      */
      *getMarkersAtPosition(position) {
        for (const marker of this) {
          if (marker.getRange().containsPosition(position)) {
            yield marker;
          }
        }
      }
      /**
      * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
      */
      *getMarkersIntersectingRange(range) {
        for (const marker of this) {
          if (marker.getRange().getIntersection(range) !== null) {
            yield marker;
          }
        }
      }
      /**
      * Destroys marker collection and all markers inside it.
      */
      destroy() {
        for (const marker of this._markers.values()) {
          this._destroyMarker(marker);
        }
        this._markers = null;
        this.stopListening();
      }
      /**
      * Iterates over all markers that starts with given `prefix`.
      *
      * ```ts
      * const markerFooA = markersCollection._set( 'foo:a', rangeFooA );
      * const markerFooB = markersCollection._set( 'foo:b', rangeFooB );
      * const markerBarA = markersCollection._set( 'bar:a', rangeBarA );
      * const markerFooBarA = markersCollection._set( 'foobar:a', rangeFooBarA );
      * Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
      * Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
      * ```
      */
      *getMarkersGroup(prefix) {
        for (const marker of this._markers.values()) {
          if (marker.name.startsWith(prefix + ":")) {
            yield marker;
          }
        }
      }
      /**
      * Destroys the marker.
      */
      _destroyMarker(marker) {
        marker.stopListening();
        marker._detachLiveRange();
      }
    }
    class Marker extends (/* @__PURE__ */ EmitterMixin(TypeCheckable)) {
      /**
      * Creates a marker instance.
      *
      * @param name Marker name.
      * @param liveRange Range marked by the marker.
      * @param managedUsingOperations Specifies whether the marker is managed using operations.
      * @param affectsData Specifies whether the marker affects the data produced by the data pipeline (is persisted in the editor's data).
      */
      constructor(name, liveRange, managedUsingOperations, affectsData) {
        super();
        /**
        * Marker's name.
        */
        __publicField(this, "name");
        /**
        * Flag indicates if the marker is managed using operations or not.
        *
        * @internal
        */
        __publicField(this, "_managedUsingOperations");
        /**
        * Specifies whether the marker affects the data produced by the data pipeline
        * (is persisted in the editor's data).
        *
        * @internal
        */
        __publicField(this, "_affectsData");
        /**
        * Range marked by the marker.
        */
        __publicField(this, "_liveRange");
        this.name = name;
        this._liveRange = this._attachLiveRange(liveRange);
        this._managedUsingOperations = managedUsingOperations;
        this._affectsData = affectsData;
      }
      /**
      * A value indicating if the marker is managed using operations.
      * See {@link ~Marker marker class description} to learn more about marker types.
      * See {@link module:engine/model/writer~Writer#addMarker}.
      */
      get managedUsingOperations() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._managedUsingOperations;
      }
      /**
      * A value indicating if the marker changes the data.
      */
      get affectsData() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._affectsData;
      }
      /**
      * Returns the marker data (properties defining the marker).
      */
      getData() {
        return {
          range: this.getRange(),
          affectsData: this.affectsData,
          managedUsingOperations: this.managedUsingOperations
        };
      }
      /**
      * Returns current marker start position.
      */
      getStart() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._liveRange.start.clone();
      }
      /**
      * Returns current marker end position.
      */
      getEnd() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._liveRange.end.clone();
      }
      /**
      * Returns a range that represents the current state of the marker.
      *
      * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
      * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
      * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
      * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
      * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
      * that it's data is up-to-date.
      */
      getRange() {
        if (!this._liveRange) {
          throw new CKEditorError("marker-destroyed", this);
        }
        return this._liveRange.toRange();
      }
      /**
      * Binds new live range to the marker and detach the old one if is attached.
      *
      * @internal
      * @param liveRange Live range to attach
      * @returns Attached live range.
      */
      _attachLiveRange(liveRange) {
        if (this._liveRange) {
          this._detachLiveRange();
        }
        liveRange.delegate("change:range").to(this);
        liveRange.delegate("change:content").to(this);
        this._liveRange = liveRange;
        return liveRange;
      }
      /**
      * Unbinds and destroys currently attached live range.
      *
      * @internal
      */
      _detachLiveRange() {
        this._liveRange.stopDelegating("change:range", this);
        this._liveRange.stopDelegating("change:content", this);
        this._liveRange.detach();
        this._liveRange = null;
      }
    }
    Marker.prototype.is = function(type) {
      return type === "marker" || type === "model:marker";
    };
    class DetachOperation extends Operation {
      /**
      * Creates an insert operation.
      *
      * @param sourcePosition Position before the first {@link module:engine/model/item~Item model item} to move.
      * @param howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
      * `sourcePosition` with offset shifted by `howMany`.
      */
      constructor(sourcePosition, howMany) {
        super(null);
        /**
        * Position before the first {@link module:engine/model/item~Item model item} to detach.
        */
        __publicField(this, "sourcePosition");
        /**
        * Offset size of moved range.
        */
        __publicField(this, "howMany");
        this.sourcePosition = sourcePosition.clone();
        this.howMany = howMany;
      }
      /**
      * @inheritDoc
      */
      get type() {
        return "detach";
      }
      /**
      * @inheritDoc
      */
      get affectedSelectable() {
        return null;
      }
      /**
      * @inheritDoc
      */
      toJSON() {
        const json = super.toJSON();
        json.sourcePosition = this.sourcePosition.toJSON();
        return json;
      }
      /**
      * @inheritDoc
      * @internal
      */
      _validate() {
        if (this.sourcePosition.root.document) {
          throw new CKEditorError("detach-operation-on-document-node", this);
        }
      }
      /**
      * @inheritDoc
      * @internal
      */
      _execute() {
        _remove(Range._createFromPositionAndShift(this.sourcePosition, this.howMany));
      }
      /**
      * @inheritDoc
      */
      static get className() {
        return "DetachOperation";
      }
    }
    class DocumentFragment extends TypeCheckable {
      /**
      * Creates an empty `DocumentFragment`.
      *
      * **Note:** Constructor of this class shouldn't be used directly in the code.
      * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
      *
      * @internal
      * @param children Nodes to be contained inside the `DocumentFragment`.
      */
      constructor(children) {
        super();
        /**
        * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}
        * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}
        * when DocumentFragment will be inserted to the document.
        */
        __publicField(this, "markers", /* @__PURE__ */ new Map());
        /**
        * List of nodes contained inside the document fragment.
        */
        __publicField(this, "_children", new NodeList());
        if (children) {
          this._insertChild(0, children);
        }
      }
      /**
      * Returns an iterator that iterates over all nodes contained inside this document fragment.
      */
      [Symbol.iterator]() {
        return this.getChildren();
      }
      /**
      * Number of this document fragment's children.
      */
      get childCount() {
        return this._children.length;
      }
      /**
      * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
      */
      get maxOffset() {
        return this._children.maxOffset;
      }
      /**
      * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
      */
      get isEmpty() {
        return this.childCount === 0;
      }
      /**
      * Artificial next sibling. Returns `null`. Added for compatibility reasons.
      */
      get nextSibling() {
        return null;
      }
      /**
      * Artificial previous sibling. Returns `null`. Added for compatibility reasons.
      */
      get previousSibling() {
        return null;
      }
      /**
      * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
      */
      get root() {
        return this;
      }
      /**
      * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
      */
      get parent() {
        return null;
      }
      /**
      * Artificial owner of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
      */
      get document() {
        return null;
      }
      /**
      * Returns `false` as `DocumentFragment` by definition is not attached to a document. Added for compatibility reasons.
      */
      isAttached() {
        return false;
      }
      /**
      * Returns empty array. Added for compatibility reasons.
      */
      getAncestors() {
        return [];
      }
      /**
      * Gets the child at the given index. Returns `null` if incorrect index was passed.
      *
      * @param index Index of child.
      * @returns Child node.
      */
      getChild(index2) {
        return this._children.getNode(index2);
      }
      /**
      * Returns an iterator that iterates over all of this document fragment's children.
      */
      getChildren() {
        return this._children[Symbol.iterator]();
      }
      /**
      * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
      *
      * @param node Child node to look for.
      * @returns Child node's index.
      */
      getChildIndex(node) {
        return this._children.getNodeIndex(node);
      }
      /**
      * Returns the starting offset of given child. Starting offset is equal to the sum of
      * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
      * given node is not a child of this document fragment.
      *
      * @param node Child node to look for.
      * @returns Child node's starting offset.
      */
      getChildStartOffset(node) {
        return this._children.getNodeStartOffset(node);
      }
      /**
      * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
      */
      getPath() {
        return [];
      }
      /**
      * Returns a descendant node by its path relative to this element.
      *
      * ```ts
      * // <this>a<b>c</b></this>
      * this.getNodeByPath( [ 0 ] );     // -> "a"
      * this.getNodeByPath( [ 1 ] );     // -> <b>
      * this.getNodeByPath( [ 1, 0 ] );  // -> "c"
      * ```
      *
      * @param relativePath Path of the node to find, relative to this element.
      */
      getNodeByPath(relativePath) {
        let node = this;
        for (const index2 of relativePath) {
          node = node.getChild(node.offsetToIndex(index2));
        }
        return node;
      }
      /**
      * Converts offset "position" to index "position".
      *
      * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
      * too high, returns index after last child.
      *
      * ```ts
      * const textNode = new Text( 'foo' );
      * const pElement = new Element( 'p' );
      * const docFrag = new DocumentFragment( [ textNode, pElement ] );
      * docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
      * docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
      * docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
      * docFrag.offsetToIndex( 2 ); // Returns 0.
      * docFrag.offsetToIndex( 3 ); // Returns 1.
      * docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
      * ```
      *
      * @param offset Offset to look for.
      * @returns Index of a node that occupies given offset.
      */
      offsetToIndex(offset) {
        return this._children.offsetToIndex(offset);
      }
      /**
      * Converts `DocumentFragment` instance to plain object and returns it.
      * Takes care of converting all of this document fragment's children.
      *
      * @returns `DocumentFragment` instance converted to plain object.
      */
      toJSON() {
        const json = [];
        for (const node of this._children) {
          json.push(node.toJSON());
        }
        return json;
      }
      /**
      * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
      * Converts `DocumentFragment` children to proper nodes.
      *
      * @param json Plain object to be converted to `DocumentFragment`.
      * @returns `DocumentFragment` instance created using given plain object.
      */
      static fromJSON(json) {
        const children = [];
        for (const child of json) {
          if (child.name) {
            children.push(Element.fromJSON(child));
          } else {
            children.push(Text.fromJSON(child));
          }
        }
        return new DocumentFragment(children);
      }
      /**
      * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
      *
      * @internal
      * @param items Items to be inserted.
      */
      _appendChild(items) {
        this._insertChild(this.childCount, items);
      }
      /**
      * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
      * to this document fragment.
      *
      * @internal
      * @param index Index at which nodes should be inserted.
      * @param items Items to be inserted.
      */
      _insertChild(index2, items) {
        const nodes = normalize$4(items);
        for (const node of nodes) {
          if (node.parent !== null) {
            node._remove();
          }
          node.parent = this;
        }
        this._children._insertNodes(index2, nodes);
      }
      /**
      * Removes one or more nodes starting at the given index
      * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
      *
      * @internal
      * @param index Index of the first node to remove.
      * @param howMany Number of nodes to remove.
      * @returns Array containing removed nodes.
      */
      _removeChildren(index2, howMany = 1) {
        const nodes = this._children._removeNodes(index2, howMany);
        for (const node of nodes) {
          node.parent = null;
        }
        return nodes;
      }
    }
    DocumentFragment.prototype.is = function(type) {
      return type === "documentFragment" || type === "model:documentFragment";
    };
    function normalize$4(nodes) {
      if (typeof nodes == "string") {
        return [
          new Text(nodes)
        ];
      }
      if (!isIterable(nodes)) {
        nodes = [
          nodes
        ];
      }
      return Array.from(nodes).map((node) => {
        if (typeof node == "string") {
          return new Text(node);
        }
        if (node instanceof TextProxy) {
          return new Text(node.data, node.getAttributes());
        }
        return node;
      });
    }
    class Writer {
      /**
      * Creates a writer instance.
      *
      * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
      * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
      *
      * @internal
      */
      constructor(model, batch) {
        /**
        * Instance of the model on which this writer operates.
        */
        __publicField(this, "model");
        /**
        * The batch to which this writer will add changes.
        */
        __publicField(this, "batch");
        this.model = model;
        this.batch = batch;
      }
      /**
      * Creates a new {@link module:engine/model/text~Text text node}.
      *
      * ```ts
      * writer.createText( 'foo' );
      * writer.createText( 'foo', { bold: true } );
      * ```
      *
      * @param data Text data.
      * @param attributes Text attributes.
      * @returns {module:engine/model/text~Text} Created text node.
      */
      createText(data, attributes) {
        return new Text(data, attributes);
      }
      /**
      * Creates a new {@link module:engine/model/element~Element element}.
      *
      * ```ts
      * writer.createElement( 'paragraph' );
      * writer.createElement( 'paragraph', { alignment: 'center' } );
      * ```
      *
      * @param name Name of the element.
      * @param attributes Elements attributes.
      * @returns Created element.
      */
      createElement(name, attributes) {
        return new Element(name, attributes);
      }
      /**
      * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
      *
      * @returns Created document fragment.
      */
      createDocumentFragment() {
        return new DocumentFragment();
      }
      /**
      * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
      * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
      *
      * @param element The element to clone.
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any child.
      */
      cloneElement(element, deep = true) {
        return element._clone(deep);
      }
      /**
      * Inserts item on given position.
      *
      * ```ts
      * const paragraph = writer.createElement( 'paragraph' );
      * writer.insert( paragraph, position );
      * ```
      *
      * Instead of using position you can use parent and offset:
      *
      * ```ts
      * const text = writer.createText( 'foo' );
      * writer.insert( text, paragraph, 5 );
      * ```
      *
      * You can also use `end` instead of the offset to insert at the end:
      *
      * ```ts
      * const text = writer.createText( 'foo' );
      * writer.insert( text, paragraph, 'end' );
      * ```
      *
      * Or insert before or after another element:
      *
      * ```ts
      * const paragraph = writer.createElement( 'paragraph' );
      * writer.insert( paragraph, anotherParagraph, 'after' );
      * ```
      *
      * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
      *
      * Note that if the item already has parent it will be removed from the previous parent.
      *
      * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
      * `model-writer-insert-forbidden-move` is thrown.
      *
      * If you want to move {@link module:engine/model/range~Range range} instead of an
      * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
      *
      * **Note:** For a paste-like content insertion mechanism see
      * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
      *
      * @param item Item or document fragment to insert.
      * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
      */
      insert(item, itemOrPosition, offset = 0) {
        this._assertWriterUsedCorrectly();
        if (item instanceof Text && item.data == "") {
          return;
        }
        const position = Position._createAt(itemOrPosition, offset);
        if (item.parent) {
          if (isSameTree(item.root, position.root)) {
            this.move(Range._createOn(item), position);
            return;
          } else {
            if (item.root.document) {
              throw new CKEditorError("model-writer-insert-forbidden-move", this);
            } else {
              this.remove(item);
            }
          }
        }
        const version2 = position.root.document ? position.root.document.version : null;
        const insert = new InsertOperation(position, item, version2);
        if (item instanceof Text) {
          insert.shouldReceiveAttributes = true;
        }
        this.batch.addOperation(insert);
        this.model.applyOperation(insert);
        if (item instanceof DocumentFragment) {
          for (const [markerName, markerRange] of item.markers) {
            const rangeRootPosition = Position._createAt(markerRange.root, 0);
            const range = new Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));
            const options = {
              range,
              usingOperation: true,
              affectsData: true
            };
            if (this.model.markers.has(markerName)) {
              this.updateMarker(markerName, options);
            } else {
              this.addMarker(markerName, options);
            }
          }
        }
      }
      insertText(text2, attributes, itemOrPosition, offset) {
        if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {
          this.insert(this.createText(text2), attributes, itemOrPosition);
        } else {
          this.insert(this.createText(text2, attributes), itemOrPosition, offset);
        }
      }
      insertElement(name, attributes, itemOrPositionOrOffset, offset) {
        if (attributes instanceof DocumentFragment || attributes instanceof Element || attributes instanceof Position) {
          this.insert(this.createElement(name), attributes, itemOrPositionOrOffset);
        } else {
          this.insert(this.createElement(name, attributes), itemOrPositionOrOffset, offset);
        }
      }
      /**
      * Inserts item at the end of the given parent.
      *
      * ```ts
      * const paragraph = writer.createElement( 'paragraph' );
      * writer.append( paragraph, root );
      * ```
      *
      * Note that if the item already has parent it will be removed from the previous parent.
      *
      * If you want to move {@link module:engine/model/range~Range range} instead of an
      * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
      *
      * @param item Item or document fragment to insert.
      */
      append(item, parent2) {
        this.insert(item, parent2, "end");
      }
      appendText(text2, attributes, parent2) {
        if (attributes instanceof DocumentFragment || attributes instanceof Element) {
          this.insert(this.createText(text2), attributes, "end");
        } else {
          this.insert(this.createText(text2, attributes), parent2, "end");
        }
      }
      appendElement(name, attributes, parent2) {
        if (attributes instanceof DocumentFragment || attributes instanceof Element) {
          this.insert(this.createElement(name), attributes, "end");
        } else {
          this.insert(this.createElement(name, attributes), parent2, "end");
        }
      }
      /**
      * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
      * or on a {@link module:engine/model/range~Range range}.
      *
      * @param key Attribute key.
      * @param value Attribute new value.
      * @param itemOrRange Model item or range on which the attribute will be set.
      */
      setAttribute(key, value, itemOrRange) {
        this._assertWriterUsedCorrectly();
        if (itemOrRange instanceof Range) {
          const ranges = itemOrRange.getMinimalFlatRanges();
          for (const range of ranges) {
            setAttributeOnRange(this, key, value, range);
          }
        } else {
          setAttributeOnItem(this, key, value, itemOrRange);
        }
      }
      /**
      * Sets values of attributes on a {@link module:engine/model/item~Item model item}
      * or on a {@link module:engine/model/range~Range range}.
      *
      * ```ts
      * writer.setAttributes( {
      * 	bold: true,
      * 	italic: true
      * }, range );
      * ```
      *
      * @param attributes Attributes keys and values.
      * @param itemOrRange Model item or range on which the attributes will be set.
      */
      setAttributes(attributes, itemOrRange) {
        for (const [key, val] of toMap(attributes)) {
          this.setAttribute(key, val, itemOrRange);
        }
      }
      /**
      * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
      * or from a {@link module:engine/model/range~Range range}.
      *
      * @param key Attribute key.
      * @param itemOrRange Model item or range from which the attribute will be removed.
      */
      removeAttribute(key, itemOrRange) {
        this._assertWriterUsedCorrectly();
        if (itemOrRange instanceof Range) {
          const ranges = itemOrRange.getMinimalFlatRanges();
          for (const range of ranges) {
            setAttributeOnRange(this, key, null, range);
          }
        } else {
          setAttributeOnItem(this, key, null, itemOrRange);
        }
      }
      /**
      * Removes all attributes from all elements in the range or from the given item.
      *
      * @param itemOrRange Model item or range from which all attributes will be removed.
      */
      clearAttributes(itemOrRange) {
        this._assertWriterUsedCorrectly();
        const removeAttributesFromItem = (item) => {
          for (const attribute of item.getAttributeKeys()) {
            this.removeAttribute(attribute, item);
          }
        };
        if (!(itemOrRange instanceof Range)) {
          removeAttributesFromItem(itemOrRange);
        } else {
          for (const item of itemOrRange.getItems()) {
            removeAttributesFromItem(item);
          }
        }
      }
      /**
      * Moves all items in the source range to the target position.
      *
      * ```ts
      * writer.move( sourceRange, targetPosition );
      * ```
      *
      * Instead of the target position you can use parent and offset or define that range should be moved to the end
      * or before or after chosen item:
      *
      * ```ts
      * // Moves all items in the range to the paragraph at offset 5:
      * writer.move( sourceRange, paragraph, 5 );
      * // Moves all items in the range to the end of a blockquote:
      * writer.move( sourceRange, blockquote, 'end' );
      * // Moves all items in the range to a position after an image:
      * writer.move( sourceRange, image, 'after' );
      * ```
      *
      * These parameters work the same way as {@link #createPositionAt `writer.createPositionAt()`}.
      *
      * Note that items can be moved only within the same tree. It means that you can move items within the same root
      * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
      * but you can not move items from document fragment to the document or from one detached element to another. Use
      * {@link module:engine/model/writer~Writer#insert} in such cases.
      *
      * @param range Source range.
      * @param offset Offset or one of the flags. Used only when second parameter is a {@link module:engine/model/item~Item model item}.
      */
      move(range, itemOrPosition, offset) {
        this._assertWriterUsedCorrectly();
        if (!(range instanceof Range)) {
          throw new CKEditorError("writer-move-invalid-range", this);
        }
        if (!range.isFlat) {
          throw new CKEditorError("writer-move-range-not-flat", this);
        }
        const position = Position._createAt(itemOrPosition, offset);
        if (position.isEqual(range.start)) {
          return;
        }
        this._addOperationForAffectedMarkers("move", range);
        if (!isSameTree(range.root, position.root)) {
          throw new CKEditorError("writer-move-different-document", this);
        }
        const version2 = range.root.document ? range.root.document.version : null;
        const operation = new MoveOperation(range.start, range.end.offset - range.start.offset, position, version2);
        this.batch.addOperation(operation);
        this.model.applyOperation(operation);
      }
      /**
      * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
      *
      * @param itemOrRange Model item or range to remove.
      */
      remove(itemOrRange) {
        this._assertWriterUsedCorrectly();
        const rangeToRemove = itemOrRange instanceof Range ? itemOrRange : Range._createOn(itemOrRange);
        const ranges = rangeToRemove.getMinimalFlatRanges().reverse();
        for (const flat of ranges) {
          this._addOperationForAffectedMarkers("move", flat);
          applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);
        }
      }
      /**
      * Merges two siblings at the given position.
      *
      * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
      * `writer-merge-no-element-after` error will be thrown.
      *
      * @param position Position between merged elements.
      */
      merge(position) {
        this._assertWriterUsedCorrectly();
        const nodeBefore = position.nodeBefore;
        const nodeAfter = position.nodeAfter;
        this._addOperationForAffectedMarkers("merge", position);
        if (!(nodeBefore instanceof Element)) {
          throw new CKEditorError("writer-merge-no-element-before", this);
        }
        if (!(nodeAfter instanceof Element)) {
          throw new CKEditorError("writer-merge-no-element-after", this);
        }
        if (!position.root.document) {
          this._mergeDetached(position);
        } else {
          this._merge(position);
        }
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
      *
      * @param root Root of the position.
      * @param path Position path. See {@link module:engine/model/position~Position#path}.
      * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
      */
      createPositionFromPath(root2, path, stickiness) {
        return this.model.createPositionFromPath(root2, path, stickiness);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
      *
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      createPositionAt(itemOrPosition, offset) {
        return this.model.createPositionAt(itemOrPosition, offset);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
      *
      * @param item Item after which the position should be placed.
      */
      createPositionAfter(item) {
        return this.model.createPositionAfter(item);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
      *
      * @param item Item after which the position should be placed.
      */
      createPositionBefore(item) {
        return this.model.createPositionBefore(item);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start, end) {
        return this.model.createRange(start, end);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return this.model.createRangeIn(element);
      }
      /**
      * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeOn(element) {
        return this.model.createRangeOn(element);
      }
      createSelection(...args) {
        return this.model.createSelection(...args);
      }
      /**
      * Performs merge action in a detached tree.
      *
      * @param position Position between merged elements.
      */
      _mergeDetached(position) {
        const nodeBefore = position.nodeBefore;
        const nodeAfter = position.nodeAfter;
        this.move(Range._createIn(nodeAfter), Position._createAt(nodeBefore, "end"));
        this.remove(nodeAfter);
      }
      /**
      * Performs merge action in a non-detached tree.
      *
      * @param position Position between merged elements.
      */
      _merge(position) {
        const targetPosition = Position._createAt(position.nodeBefore, "end");
        const sourcePosition = Position._createAt(position.nodeAfter, 0);
        const graveyard = position.root.document.graveyard;
        const graveyardPosition = new Position(graveyard, [
          0
        ]);
        const version2 = position.root.document.version;
        const merge2 = new MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version2);
        this.batch.addOperation(merge2);
        this.model.applyOperation(merge2);
      }
      /**
      * Renames the given element.
      *
      * @param element The element to rename.
      * @param newName New element name.
      */
      rename(element, newName) {
        this._assertWriterUsedCorrectly();
        if (!(element instanceof Element)) {
          throw new CKEditorError("writer-rename-not-element-instance", this);
        }
        const version2 = element.root.document ? element.root.document.version : null;
        const renameOperation = new RenameOperation(Position._createBefore(element), element.name, newName, version2);
        this.batch.addOperation(renameOperation);
        this.model.applyOperation(renameOperation);
      }
      /**
      * Splits elements starting from the given position and going to the top of the model tree as long as given
      * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
      *
      * The element needs to have a parent. It cannot be a root element nor a document fragment.
      * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
      *
      * @param position Position of split.
      * @param limitElement Stop splitting when this element will be reached.
      * @returns Split result with properties:
      * * `position` - Position between split elements.
      * * `range` - Range that stars from the end of the first split element and ends at the beginning of the first copy element.
      */
      split(position, limitElement) {
        this._assertWriterUsedCorrectly();
        let splitElement = position.parent;
        if (!splitElement.parent) {
          throw new CKEditorError("writer-split-element-no-parent", this);
        }
        if (!limitElement) {
          limitElement = splitElement.parent;
        }
        if (!position.parent.getAncestors({
          includeSelf: true
        }).includes(limitElement)) {
          throw new CKEditorError("writer-split-invalid-limit-element", this);
        }
        let firstSplitElement;
        let firstCopyElement;
        do {
          const version2 = splitElement.root.document ? splitElement.root.document.version : null;
          const howMany = splitElement.maxOffset - position.offset;
          const insertionPosition = SplitOperation.getInsertionPosition(position);
          const split = new SplitOperation(position, howMany, insertionPosition, null, version2);
          this.batch.addOperation(split);
          this.model.applyOperation(split);
          if (!firstSplitElement && !firstCopyElement) {
            firstSplitElement = splitElement;
            firstCopyElement = position.parent.nextSibling;
          }
          position = this.createPositionAfter(position.parent);
          splitElement = position.parent;
        } while (splitElement !== limitElement);
        return {
          position,
          range: new Range(Position._createAt(firstSplitElement, "end"), Position._createAt(firstCopyElement, 0))
        };
      }
      /**
      * Wraps the given range with the given element or with a new element (if a string was passed).
      *
      * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
      * If not, an error will be thrown.
      *
      * @param range Range to wrap.
      * @param elementOrString Element or name of element to wrap the range with.
      */
      wrap(range, elementOrString) {
        this._assertWriterUsedCorrectly();
        if (!range.isFlat) {
          throw new CKEditorError("writer-wrap-range-not-flat", this);
        }
        const element = elementOrString instanceof Element ? elementOrString : new Element(elementOrString);
        if (element.childCount > 0) {
          throw new CKEditorError("writer-wrap-element-not-empty", this);
        }
        if (element.parent !== null) {
          throw new CKEditorError("writer-wrap-element-attached", this);
        }
        this.insert(element, range.start);
        const shiftedRange = new Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));
        this.move(shiftedRange, Position._createAt(element, 0));
      }
      /**
      * Unwraps children of the given element – all its children are moved before it and then the element is removed.
      * Throws error if you try to unwrap an element which does not have a parent.
      *
      * @param element Element to unwrap.
      */
      unwrap(element) {
        this._assertWriterUsedCorrectly();
        if (element.parent === null) {
          throw new CKEditorError("writer-unwrap-element-no-parent", this);
        }
        this.move(Range._createIn(element), this.createPositionAfter(element));
        this.remove(element);
      }
      /**
      * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
      * changes in the document and updates its range automatically, when model tree changes.
      *
      * As the first parameter you can set marker name.
      *
      * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
      * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
      * markers managed by operations and not-managed by operations.
      *
      * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
      * `true` when the marker change changes the data returned by the
      * {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
      * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
      * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
      *
      * Create marker directly base on marker's name:
      *
      * ```ts
      * addMarker( markerName, { range, usingOperation: false } );
      * ```
      *
      * Create marker using operation:
      *
      * ```ts
      * addMarker( markerName, { range, usingOperation: true } );
      * ```
      *
      * Create marker that affects the editor data:
      *
      * ```ts
      * addMarker( markerName, { range, usingOperation: false, affectsData: true } );
      * ```
      *
      * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
      *
      * @see module:engine/model/markercollection~Marker
      * @param name Name of a marker to create - must be unique.
      * @param options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
      * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
      * @param options.range Marker range.
      * @param options.affectsData Flag indicating that the marker changes the editor data.
      * @returns Marker that was set.
      */
      addMarker(name, options) {
        this._assertWriterUsedCorrectly();
        if (!options || typeof options.usingOperation != "boolean") {
          throw new CKEditorError("writer-addmarker-no-usingoperation", this);
        }
        const usingOperation = options.usingOperation;
        const range = options.range;
        const affectsData = options.affectsData === void 0 ? false : options.affectsData;
        if (this.model.markers.has(name)) {
          throw new CKEditorError("writer-addmarker-marker-exists", this);
        }
        if (!range) {
          throw new CKEditorError("writer-addmarker-no-range", this);
        }
        if (!usingOperation) {
          return this.model.markers._set(name, range, usingOperation, affectsData);
        }
        applyMarkerOperation(this, name, null, range, affectsData);
        return this.model.markers.get(name);
      }
      /**
      * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
      * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
      * marker's range directly using this method.
      *
      * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
      * name is created and returned.
      *
      * **Note**: If you want to change the {@link module:engine/view/element~Element view element} of the marker while its data in the model
      * remains the same, use the dedicated {@link module:engine/controller/editingcontroller~EditingController#reconvertMarker} method.
      *
      * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
      * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
      * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
      *
      * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
      * `true` when the marker change changes the data returned by
      * the {@link module:core/editor/editor~Editor#getData `editor.getData()`} method.
      * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
      * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
      *
      * Update marker directly base on marker's name:
      *
      * ```ts
      * updateMarker( markerName, { range } );
      * ```
      *
      * Update marker using operation:
      *
      * ```ts
      * updateMarker( marker, { range, usingOperation: true } );
      * updateMarker( markerName, { range, usingOperation: true } );
      * ```
      *
      * Change marker's option (start using operations to manage it):
      *
      * ```ts
      * updateMarker( marker, { usingOperation: true } );
      * ```
      *
      * Change marker's option (inform the engine, that the marker does not affect the data anymore):
      *
      * ```ts
      * updateMarker( markerName, { affectsData: false } );
      * ```
      *
      * @see module:engine/model/markercollection~Marker
      * @param markerOrName Name of a marker to update, or a marker instance.
      * @param options If options object is not defined then marker will be refreshed by triggering
      * downcast conversion for this marker with the same data.
      * @param options.range Marker range to update.
      * @param options.usingOperation Flag indicated whether the marker should be added by MarkerOperation.
      * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
      * @param options.affectsData Flag indicating that the marker changes the editor data.
      */
      updateMarker(markerOrName, options) {
        this._assertWriterUsedCorrectly();
        const markerName = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
        const currentMarker = this.model.markers.get(markerName);
        if (!currentMarker) {
          throw new CKEditorError("writer-updatemarker-marker-not-exists", this);
        }
        if (!options) {
          logWarning("writer-updatemarker-reconvert-using-editingcontroller", {
            markerName
          });
          this.model.markers._refresh(currentMarker);
          return;
        }
        const hasUsingOperationDefined = typeof options.usingOperation == "boolean";
        const affectsDataDefined = typeof options.affectsData == "boolean";
        const affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;
        if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {
          throw new CKEditorError("writer-updatemarker-wrong-options", this);
        }
        const currentRange = currentMarker.getRange();
        const updatedRange = options.range ? options.range : currentRange;
        if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {
          if (options.usingOperation) {
            applyMarkerOperation(this, markerName, null, updatedRange, affectsData);
          } else {
            applyMarkerOperation(this, markerName, currentRange, null, affectsData);
            this.model.markers._set(markerName, updatedRange, void 0, affectsData);
          }
          return;
        }
        if (currentMarker.managedUsingOperations) {
          applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);
        } else {
          this.model.markers._set(markerName, updatedRange, void 0, affectsData);
        }
      }
      /**
      * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
      * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
      * it will be destroyed using operation.
      *
      * @param markerOrName Marker or marker name to remove.
      */
      removeMarker(markerOrName) {
        this._assertWriterUsedCorrectly();
        const name = typeof markerOrName == "string" ? markerOrName : markerOrName.name;
        if (!this.model.markers.has(name)) {
          throw new CKEditorError("writer-removemarker-no-marker", this);
        }
        const marker = this.model.markers.get(name);
        if (!marker.managedUsingOperations) {
          this.model.markers._remove(name);
          return;
        }
        const oldRange = marker.getRange();
        applyMarkerOperation(this, name, oldRange, null, marker.affectsData);
      }
      /**
      * Adds a new root to the document (or re-attaches a {@link #detachRoot detached root}).
      *
      * Throws an error, if trying to add a root that is already added and attached.
      *
      * @param rootName Name of the added root.
      * @param elementName The element name. Defaults to `'$root'` which also has some basic schema defined
      * (e.g. `$block` elements are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
      * @returns The added root element.
      */
      addRoot(rootName, elementName = "$root") {
        this._assertWriterUsedCorrectly();
        const root2 = this.model.document.getRoot(rootName);
        if (root2 && root2.isAttached()) {
          throw new CKEditorError("writer-addroot-root-exists", this);
        }
        const document2 = this.model.document;
        const operation = new RootOperation(rootName, elementName, true, document2, document2.version);
        this.batch.addOperation(operation);
        this.model.applyOperation(operation);
        return this.model.document.getRoot(rootName);
      }
      /**
      * Detaches the root from the document.
      *
      * All content and markers are removed from the root upon detaching. New content and new markers cannot be added to the root, as long
      * as it is detached.
      *
      * A root cannot be fully removed from the document, it can be only detached. A root is permanently removed only after you
      * re-initialize the editor and do not specify the root in the initial data.
      *
      * A detached root can be re-attached using {@link #addRoot}.
      *
      * Throws an error if the root does not exist or the root is already detached.
      *
      * @param rootOrName Name of the detached root.
      */
      detachRoot(rootOrName) {
        this._assertWriterUsedCorrectly();
        const root2 = typeof rootOrName == "string" ? this.model.document.getRoot(rootOrName) : rootOrName;
        if (!root2 || !root2.isAttached()) {
          throw new CKEditorError("writer-detachroot-no-root", this);
        }
        for (const marker of this.model.markers) {
          if (marker.getRange().root === root2) {
            this.removeMarker(marker);
          }
        }
        for (const key of root2.getAttributeKeys()) {
          this.removeAttribute(key, root2);
        }
        this.remove(this.createRangeIn(root2));
        const document2 = this.model.document;
        const operation = new RootOperation(root2.rootName, root2.name, false, document2, document2.version);
        this.batch.addOperation(operation);
        this.model.applyOperation(operation);
      }
      setSelection(...args) {
        this._assertWriterUsedCorrectly();
        this.model.document.selection._setTo(...args);
      }
      /**
      * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
      *
      * The location can be specified in the same form as
      * {@link #createPositionAt `writer.createPositionAt()`} parameters.
      *
      * @param itemOrPosition
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      setSelectionFocus(itemOrPosition, offset) {
        this._assertWriterUsedCorrectly();
        this.model.document.selection._setFocus(itemOrPosition, offset);
      }
      setSelectionAttribute(keyOrObjectOrIterable, value) {
        this._assertWriterUsedCorrectly();
        if (typeof keyOrObjectOrIterable === "string") {
          this._setSelectionAttribute(keyOrObjectOrIterable, value);
        } else {
          for (const [key, value2] of toMap(keyOrObjectOrIterable)) {
            this._setSelectionAttribute(key, value2);
          }
        }
      }
      /**
      * Removes attribute(s) with given key(s) from the selection.
      *
      * Remove one attribute:
      *
      * ```ts
      * writer.removeSelectionAttribute( 'italic' );
      * ```
      *
      * Remove multiple attributes:
      *
      * ```ts
      * writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
      * ```
      *
      * @param keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
      */
      removeSelectionAttribute(keyOrIterableOfKeys) {
        this._assertWriterUsedCorrectly();
        if (typeof keyOrIterableOfKeys === "string") {
          this._removeSelectionAttribute(keyOrIterableOfKeys);
        } else {
          for (const key of keyOrIterableOfKeys) {
            this._removeSelectionAttribute(key);
          }
        }
      }
      /**
      * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
      * of the selection from left to right.
      *
      * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
      * then the selection (after being moved by the user) inherits attributes from its left-hand side.
      * This method allows to temporarily override this behavior by forcing the gravity to the right.
      *
      * For the following model fragment:
      *
      * ```xml
      * <$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
      * ```
      *
      * * Default gravity: selection will have the `bold` and `linkHref` attributes.
      * * Overridden gravity: selection will have `bold` attribute.
      *
      * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
      * of the process.
      *
      * @returns The unique id which allows restoring the gravity.
      */
      overrideSelectionGravity() {
        return this.model.document.selection._overrideGravity();
      }
      /**
      * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
      *
      * Restoring the gravity is only possible using the unique identifier returned by
      * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
      * the same number of times it was overridden.
      *
      * @param uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
      */
      restoreSelectionGravity(uid2) {
        this.model.document.selection._restoreGravity(uid2);
      }
      /**
      * @param key Key of the attribute to remove.
      * @param value Attribute value.
      */
      _setSelectionAttribute(key, value) {
        const selection = this.model.document.selection;
        if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
          const storeKey = DocumentSelection._getStoreAttributeKey(key);
          this.setAttribute(storeKey, value, selection.anchor.parent);
        }
        selection._setAttribute(key, value);
      }
      /**
      * @param key Key of the attribute to remove.
      */
      _removeSelectionAttribute(key) {
        const selection = this.model.document.selection;
        if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
          const storeKey = DocumentSelection._getStoreAttributeKey(key);
          this.removeAttribute(storeKey, selection.anchor.parent);
        }
        selection._removeAttribute(key);
      }
      /**
      * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
      */
      _assertWriterUsedCorrectly() {
        if (this.model._currentWriter !== this) {
          throw new CKEditorError("writer-incorrect-use", this);
        }
      }
      /**
      * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
      * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
      * can be later correctly processed during undo.
      *
      * @param type Writer action type.
      * @param positionOrRange Position or range where the writer action happens.
      */
      _addOperationForAffectedMarkers(type, positionOrRange) {
        for (const marker of this.model.markers) {
          if (!marker.managedUsingOperations) {
            continue;
          }
          const markerRange = marker.getRange();
          let isAffected = false;
          if (type === "move") {
            const range = positionOrRange;
            isAffected = range.containsPosition(markerRange.start) || range.start.isEqual(markerRange.start) || range.containsPosition(markerRange.end) || range.end.isEqual(markerRange.end);
          } else {
            const position = positionOrRange;
            const elementBefore = position.nodeBefore;
            const elementAfter = position.nodeAfter;
            const affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd;
            const affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0;
            const affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter;
            const affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;
            isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;
          }
          if (isAffected) {
            this.updateMarker(marker.name, {
              range: markerRange
            });
          }
        }
      }
    }
    function setAttributeOnRange(writer, key, value, range) {
      const model = writer.model;
      const doc = model.document;
      let lastSplitPosition = range.start;
      let position;
      let valueBefore;
      let valueAfter;
      for (const val of range.getWalker({
        shallow: true
      })) {
        valueAfter = val.item.getAttribute(key);
        if (position && valueBefore != valueAfter) {
          if (valueBefore != value) {
            addOperation();
          }
          lastSplitPosition = position;
        }
        position = val.nextPosition;
        valueBefore = valueAfter;
      }
      if (position instanceof Position && position != lastSplitPosition && valueBefore != value) {
        addOperation();
      }
      function addOperation() {
        const range2 = new Range(lastSplitPosition, position);
        const version2 = range2.root.document ? doc.version : null;
        const operation = new AttributeOperation(range2, key, valueBefore, value, version2);
        writer.batch.addOperation(operation);
        model.applyOperation(operation);
      }
    }
    function setAttributeOnItem(writer, key, value, item) {
      const model = writer.model;
      const doc = model.document;
      const previousValue = item.getAttribute(key);
      let range, operation;
      if (previousValue != value) {
        const isRootChanged = item.root === item;
        if (isRootChanged) {
          const version2 = item.document ? doc.version : null;
          operation = new RootAttributeOperation(item, key, previousValue, value, version2);
        } else {
          range = new Range(Position._createBefore(item), writer.createPositionAfter(item));
          const version2 = range.root.document ? doc.version : null;
          operation = new AttributeOperation(range, key, previousValue, value, version2);
        }
        writer.batch.addOperation(operation);
        model.applyOperation(operation);
      }
    }
    function applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {
      const model = writer.model;
      const doc = model.document;
      const operation = new MarkerOperation(name, oldRange, newRange, model.markers, !!affectsData, doc.version);
      writer.batch.addOperation(operation);
      model.applyOperation(operation);
    }
    function applyRemoveOperation(position, howMany, batch, model) {
      let operation;
      if (position.root.document) {
        const doc = model.document;
        const graveyardPosition = new Position(doc.graveyard, [
          0
        ]);
        operation = new MoveOperation(position, howMany, graveyardPosition, doc.version);
      } else {
        operation = new DetachOperation(position, howMany);
      }
      batch.addOperation(operation);
      model.applyOperation(operation);
    }
    function isSameTree(rootA, rootB) {
      if (rootA === rootB) {
        return true;
      }
      if (rootA instanceof RootElement && rootB instanceof RootElement) {
        return true;
      }
      return false;
    }
    function deleteContent(model, selection, options = {}) {
      if (selection.isCollapsed) {
        return;
      }
      const selRange = selection.getFirstRange();
      if (selRange.root.rootName == "$graveyard") {
        return;
      }
      const schema = model.schema;
      model.change((writer) => {
        if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {
          replaceEntireContentWithParagraph(writer, selection);
          return;
        }
        const attributesForAutoparagraph = {};
        if (!options.doNotAutoparagraph) {
          const selectedElement = selection.getSelectedElement();
          if (selectedElement) {
            Object.assign(attributesForAutoparagraph, schema.getAttributesWithProperty(selectedElement, "copyOnReplace", true));
          }
        }
        const [startPosition, endPosition] = getLivePositionsForSelectedBlocks(selRange);
        if (!startPosition.isTouching(endPosition)) {
          writer.remove(writer.createRange(startPosition, endPosition));
        }
        if (!options.leaveUnmerged) {
          mergeBranches(writer, startPosition, endPosition);
          schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);
        }
        collapseSelectionAt(writer, selection, startPosition);
        if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {
          insertParagraph(writer, startPosition, selection, attributesForAutoparagraph);
        }
        startPosition.detach();
        endPosition.detach();
      });
    }
    function getLivePositionsForSelectedBlocks(range) {
      const model = range.root.document.model;
      const startPosition = range.start;
      let endPosition = range.end;
      if (model.hasContent(range, {
        ignoreMarkers: true
      })) {
        const endBlock = getParentBlock(endPosition);
        if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {
          const selection = model.createSelection(range);
          model.modifySelection(selection, {
            direction: "backward"
          });
          const newEndPosition = selection.getLastPosition();
          const skippedRange = model.createRange(newEndPosition, endPosition);
          if (!model.hasContent(skippedRange, {
            ignoreMarkers: true
          })) {
            endPosition = newEndPosition;
          }
        }
      }
      return [
        LivePosition.fromPosition(startPosition, "toPrevious"),
        LivePosition.fromPosition(endPosition, "toNext")
      ];
    }
    function getParentBlock(position) {
      const element = position.parent;
      const schema = element.root.document.model.schema;
      const ancestors = element.getAncestors({
        parentFirst: true,
        includeSelf: true
      });
      for (const element2 of ancestors) {
        if (schema.isLimit(element2)) {
          return null;
        }
        if (schema.isBlock(element2)) {
          return element2;
        }
      }
    }
    function mergeBranches(writer, startPosition, endPosition) {
      const model = writer.model;
      if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
        return;
      }
      const [startAncestor, endAncestor] = getAncestorsJustBelowCommonAncestor(startPosition, endPosition);
      if (!startAncestor || !endAncestor) {
        return;
      }
      if (!model.hasContent(startAncestor, {
        ignoreMarkers: true
      }) && model.hasContent(endAncestor, {
        ignoreMarkers: true
      })) {
        mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);
      } else {
        mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);
      }
    }
    function mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {
      const startElement = startPosition.parent;
      const endElement = endPosition.parent;
      if (startElement == commonAncestor || endElement == commonAncestor) {
        return;
      }
      startPosition = writer.createPositionAfter(startElement);
      endPosition = writer.createPositionBefore(endElement);
      if (!endPosition.isEqual(startPosition)) {
        writer.insert(endElement, startPosition);
      }
      writer.merge(startPosition);
      while (endPosition.parent.isEmpty) {
        const parentToRemove = endPosition.parent;
        endPosition = writer.createPositionBefore(parentToRemove);
        writer.remove(parentToRemove);
      }
      if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
        return;
      }
      mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);
    }
    function mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {
      const startElement = startPosition.parent;
      const endElement = endPosition.parent;
      if (startElement == commonAncestor || endElement == commonAncestor) {
        return;
      }
      startPosition = writer.createPositionAfter(startElement);
      endPosition = writer.createPositionBefore(endElement);
      if (!endPosition.isEqual(startPosition)) {
        writer.insert(startElement, endPosition);
      }
      while (startPosition.parent.isEmpty) {
        const parentToRemove = startPosition.parent;
        startPosition = writer.createPositionBefore(parentToRemove);
        writer.remove(parentToRemove);
      }
      endPosition = writer.createPositionBefore(endElement);
      mergeRight(writer, endPosition);
      if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
        return;
      }
      mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);
    }
    function mergeRight(writer, position) {
      const startElement = position.nodeBefore;
      const endElement = position.nodeAfter;
      if (startElement.name != endElement.name) {
        writer.rename(startElement, endElement.name);
      }
      writer.clearAttributes(startElement);
      writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);
      writer.merge(position);
    }
    function checkShouldMerge(schema, startPosition, endPosition) {
      const startElement = startPosition.parent;
      const endElement = endPosition.parent;
      if (startElement == endElement) {
        return false;
      }
      if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
        return false;
      }
      return isCrossingLimitElement(startPosition, endPosition, schema);
    }
    function getAncestorsJustBelowCommonAncestor(positionA, positionB) {
      const ancestorsA = positionA.getAncestors();
      const ancestorsB = positionB.getAncestors();
      let i = 0;
      while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {
        i++;
      }
      return [
        ancestorsA[i],
        ancestorsB[i]
      ];
    }
    function shouldAutoparagraph(schema, position) {
      const isTextAllowed = schema.checkChild(position, "$text");
      const isParagraphAllowed = schema.checkChild(position, "paragraph");
      return !isTextAllowed && isParagraphAllowed;
    }
    function isCrossingLimitElement(leftPos, rightPos, schema) {
      const rangeToCheck = new Range(leftPos, rightPos);
      for (const value of rangeToCheck.getWalker()) {
        if (schema.isLimit(value.item)) {
          return false;
        }
      }
      return true;
    }
    function insertParagraph(writer, position, selection, attributes = {}) {
      const paragraph2 = writer.createElement("paragraph");
      writer.model.schema.setAllowedAttributes(paragraph2, attributes, writer);
      writer.insert(paragraph2, position);
      collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph2, 0));
    }
    function replaceEntireContentWithParagraph(writer, selection) {
      const limitElement = writer.model.schema.getLimitElement(selection);
      writer.remove(writer.createRangeIn(limitElement));
      insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);
    }
    function shouldEntireContentBeReplacedWithParagraph(schema, selection) {
      const limitElement = schema.getLimitElement(selection);
      if (!selection.containsEntireContent(limitElement)) {
        return false;
      }
      const range = selection.getFirstRange();
      if (range.start.parent == range.end.parent) {
        return false;
      }
      return schema.checkChild(limitElement, "paragraph");
    }
    function collapseSelectionAt(writer, selection, positionOrRange) {
      if (selection instanceof DocumentSelection) {
        writer.setSelection(positionOrRange);
      } else {
        selection.setTo(positionOrRange);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getSelectedContent(model, selection) {
      return model.change((writer) => {
        const frag = writer.createDocumentFragment();
        const range = selection.getFirstRange();
        if (!range || range.isCollapsed) {
          return frag;
        }
        const root2 = range.start.root;
        const commonPath = range.start.getCommonPath(range.end);
        const commonParent = root2.getNodeByPath(commonPath);
        let flatSubtreeRange;
        if (range.start.parent == range.end.parent) {
          flatSubtreeRange = range;
        } else {
          flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));
        }
        const howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset;
        for (const item of flatSubtreeRange.getItems({
          shallow: true
        })) {
          if (item.is("$textProxy")) {
            writer.appendText(item.data, item.getAttributes(), frag);
          } else {
            writer.append(writer.cloneElement(item, true), frag);
          }
        }
        if (flatSubtreeRange != range) {
          const newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];
          const leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);
          const rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, "end"));
          removeRangeContent(rightExcessRange, writer);
          removeRangeContent(leftExcessRange, writer);
        }
        return frag;
      });
    }
    function removeRangeContent(range, writer) {
      const parentsToCheck = [];
      Array.from(range.getItems({
        direction: "backward"
      })).map((item) => writer.createRangeOn(item)).filter((itemRange) => {
        const contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));
        return contained;
      }).forEach((itemRange) => {
        parentsToCheck.push(itemRange.start.parent);
        writer.remove(itemRange);
      });
      parentsToCheck.forEach((parentToCheck) => {
        let parent2 = parentToCheck;
        while (parent2.parent && parent2.isEmpty) {
          const removeRange = writer.createRangeOn(parent2);
          parent2 = parent2.parent;
          writer.remove(removeRange);
        }
      });
    }
    function insertContent(model, content, selectable) {
      return model.change((writer) => {
        const selection = selectable ? selectable : model.document.selection;
        if (!selection.isCollapsed) {
          model.deleteContent(selection, {
            doNotAutoparagraph: true
          });
        }
        const insertion = new Insertion(model, writer, selection.anchor);
        const fakeMarkerElements = [];
        let nodesToInsert;
        if (content.is("documentFragment")) {
          if (content.markers.size) {
            const markersPosition = [];
            for (const [name, range] of content.markers) {
              const { start, end } = range;
              const isCollapsed = start.isEqual(end);
              markersPosition.push({
                position: start,
                name,
                isCollapsed
              }, {
                position: end,
                name,
                isCollapsed
              });
            }
            markersPosition.sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
            for (const { position, name, isCollapsed } of markersPosition) {
              let fakeElement = null;
              let collapsed = null;
              const isAtBeginning = position.parent === content && position.isAtStart;
              const isAtEnd = position.parent === content && position.isAtEnd;
              if (!isAtBeginning && !isAtEnd) {
                fakeElement = writer.createElement("$marker");
                writer.insert(fakeElement, position);
              } else if (isCollapsed) {
                collapsed = isAtBeginning ? "start" : "end";
              }
              fakeMarkerElements.push({
                name,
                element: fakeElement,
                collapsed
              });
            }
          }
          nodesToInsert = content.getChildren();
        } else {
          nodesToInsert = [
            content
          ];
        }
        insertion.handleNodes(nodesToInsert);
        let newRange = insertion.getSelectionRange();
        if (content.is("documentFragment") && fakeMarkerElements.length) {
          const selectionLiveRange = newRange ? LiveRange.fromRange(newRange) : null;
          const markersData = {};
          for (let i = fakeMarkerElements.length - 1; i >= 0; i--) {
            const { name, element, collapsed } = fakeMarkerElements[i];
            const isStartBoundary = !markersData[name];
            if (isStartBoundary) {
              markersData[name] = [];
            }
            if (element) {
              const elementPosition = writer.createPositionAt(element, "before");
              markersData[name].push(elementPosition);
              writer.remove(element);
            } else {
              const rangeOnInsertion = insertion.getAffectedRange();
              if (!rangeOnInsertion) {
                if (collapsed) {
                  markersData[name].push(insertion.position);
                }
                continue;
              }
              if (collapsed) {
                markersData[name].push(rangeOnInsertion[collapsed]);
              } else {
                markersData[name].push(isStartBoundary ? rangeOnInsertion.start : rangeOnInsertion.end);
              }
            }
          }
          for (const [name, [start, end]] of Object.entries(markersData)) {
            if (start && end && start.root === end.root && start.root.document && !writer.model.markers.has(name)) {
              writer.addMarker(name, {
                usingOperation: true,
                affectsData: true,
                range: new Range(start, end)
              });
            }
          }
          if (selectionLiveRange) {
            newRange = selectionLiveRange.toRange();
            selectionLiveRange.detach();
          }
        }
        /* istanbul ignore else -- @preserve */
        if (newRange) {
          if (selection instanceof DocumentSelection) {
            writer.setSelection(newRange);
          } else {
            selection.setTo(newRange);
          }
        }
        const affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);
        insertion.destroy();
        return affectedRange;
      });
    }
    class Insertion {
      constructor(model, writer, position) {
        /**
        * The model in context of which the insertion should be performed.
        */
        __publicField(this, "model");
        /**
        * Batch to which operations will be added.
        */
        __publicField(this, "writer");
        /**
        * The position at which (or near which) the next node will be inserted.
        */
        __publicField(this, "position");
        /**
        * Elements with which the inserted elements can be merged.
        *
        * ```html
        * <p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)
        * <p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)
        * <p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,
        * 						so both its pieces will be added to this set)
        * ```
        */
        __publicField(this, "canMergeWith");
        /**
        * Schema of the model.
        */
        __publicField(this, "schema");
        /**
        * The temporary DocumentFragment used for grouping multiple nodes for single insert operation.
        */
        __publicField(this, "_documentFragment");
        /**
        * The current position in the temporary DocumentFragment.
        */
        __publicField(this, "_documentFragmentPosition");
        /**
        * The reference to the first inserted node.
        */
        __publicField(this, "_firstNode", null);
        /**
        * The reference to the last inserted node.
        */
        __publicField(this, "_lastNode", null);
        /**
        * The reference to the last auto paragraph node.
        */
        __publicField(this, "_lastAutoParagraph", null);
        /**
        * The array of nodes that should be cleaned of not allowed attributes.
        */
        __publicField(this, "_filterAttributesOf", []);
        /**
        * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
        */
        __publicField(this, "_affectedStart", null);
        /**
        * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
        */
        __publicField(this, "_affectedEnd", null);
        __publicField(this, "_nodeToSelect", null);
        this.model = model;
        this.writer = writer;
        this.position = position;
        this.canMergeWith = /* @__PURE__ */ new Set([
          this.position.parent
        ]);
        this.schema = model.schema;
        this._documentFragment = writer.createDocumentFragment();
        this._documentFragmentPosition = writer.createPositionAt(this._documentFragment, 0);
      }
      /**
      * Handles insertion of a set of nodes.
      *
      * @param nodes Nodes to insert.
      */
      handleNodes(nodes) {
        for (const node of Array.from(nodes)) {
          this._handleNode(node);
        }
        this._insertPartialFragment();
        if (this._lastAutoParagraph) {
          this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph);
        }
        this._mergeOnRight();
        this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
        this._filterAttributesOf = [];
      }
      /**
      * Updates the last node after the auto paragraphing.
      *
      * @param node The last auto paragraphing node.
      */
      _updateLastNodeFromAutoParagraph(node) {
        const positionAfterLastNode = this.writer.createPositionAfter(this._lastNode);
        const positionAfterNode = this.writer.createPositionAfter(node);
        if (positionAfterNode.isAfter(positionAfterLastNode)) {
          this._lastNode = node;
          /* istanbul ignore if -- @preserve */
          if (this.position.parent != node || !this.position.isAtEnd) {
            throw new CKEditorError("insertcontent-invalid-insertion-position", this);
          }
          this.position = positionAfterNode;
          this._setAffectedBoundaries(this.position);
        }
      }
      /**
      * Returns range to be selected after insertion.
      * Returns `null` if there is no valid range to select after insertion.
      */
      getSelectionRange() {
        if (this._nodeToSelect) {
          return Range._createOn(this._nodeToSelect);
        }
        return this.model.schema.getNearestSelectionRange(this.position);
      }
      /**
      * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
      * before the insertion. Returns `null` if no changes were done.
      */
      getAffectedRange() {
        if (!this._affectedStart) {
          return null;
        }
        return new Range(this._affectedStart, this._affectedEnd);
      }
      /**
      * Destroys `Insertion` instance.
      */
      destroy() {
        if (this._affectedStart) {
          this._affectedStart.detach();
        }
        if (this._affectedEnd) {
          this._affectedEnd.detach();
        }
      }
      /**
      * Handles insertion of a single node.
      */
      _handleNode(node) {
        if (this.schema.isObject(node)) {
          this._handleObject(node);
          return;
        }
        let isAllowed = this._checkAndAutoParagraphToAllowedPosition(node);
        if (!isAllowed) {
          isAllowed = this._checkAndSplitToAllowedPosition(node);
          if (!isAllowed) {
            this._handleDisallowedNode(node);
            return;
          }
        }
        this._appendToFragment(node);
        if (!this._firstNode) {
          this._firstNode = node;
        }
        this._lastNode = node;
      }
      /**
      * Inserts the temporary DocumentFragment into the model.
      */
      _insertPartialFragment() {
        if (this._documentFragment.isEmpty) {
          return;
        }
        const livePosition = LivePosition.fromPosition(this.position, "toNext");
        this._setAffectedBoundaries(this.position);
        if (this._documentFragment.getChild(0) == this._firstNode) {
          this.writer.insert(this._firstNode, this.position);
          this._mergeOnLeft();
          this.position = livePosition.toPosition();
        }
        if (!this._documentFragment.isEmpty) {
          this.writer.insert(this._documentFragment, this.position);
        }
        this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0);
        this.position = livePosition.toPosition();
        livePosition.detach();
      }
      /**
      * @param node The object element.
      */
      _handleObject(node) {
        if (this._checkAndSplitToAllowedPosition(node)) {
          this._appendToFragment(node);
        } else {
          this._tryAutoparagraphing(node);
        }
      }
      /**
      * @param node The disallowed node which needs to be handled.
      */
      _handleDisallowedNode(node) {
        if (node.is("element")) {
          this.handleNodes(node.getChildren());
        } else {
          this._tryAutoparagraphing(node);
        }
      }
      /**
      * Append a node to the temporary DocumentFragment.
      *
      * @param node The node to insert.
      */
      _appendToFragment(node) {
        /* istanbul ignore if -- @preserve */
        if (!this.schema.checkChild(this.position, node)) {
          throw new CKEditorError("insertcontent-wrong-position", this, {
            node,
            position: this.position
          });
        }
        this.writer.insert(node, this._documentFragmentPosition);
        this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(node.offsetSize);
        if (this.schema.isObject(node) && !this.schema.checkChild(this.position, "$text")) {
          this._nodeToSelect = node;
        } else {
          this._nodeToSelect = null;
        }
        this._filterAttributesOf.push(node);
      }
      /**
      * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
      * mark the affected range.
      *
      * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
      * during merging, but the logic there is more complicated so it is left out of this function.
      */
      _setAffectedBoundaries(position) {
        if (!this._affectedStart) {
          this._affectedStart = LivePosition.fromPosition(position, "toPrevious");
        }
        if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
          this._affectedEnd = LivePosition.fromPosition(position, "toNext");
        }
      }
      /**
      * Merges the previous sibling of the first node if it should be merged.
      *
      * After the content was inserted we may try to merge it with its siblings.
      * This should happen only if the selection was in those elements initially.
      */
      _mergeOnLeft() {
        const node = this._firstNode;
        if (!(node instanceof Element)) {
          return;
        }
        if (!this._canMergeLeft(node)) {
          return;
        }
        const mergePosLeft = LivePosition._createBefore(node);
        mergePosLeft.stickiness = "toNext";
        const livePosition = LivePosition.fromPosition(this.position, "toNext");
        if (this._affectedStart.isEqual(mergePosLeft)) {
          this._affectedStart.detach();
          this._affectedStart = LivePosition._createAt(mergePosLeft.nodeBefore, "end", "toPrevious");
        }
        if (this._firstNode === this._lastNode) {
          this._firstNode = mergePosLeft.nodeBefore;
          this._lastNode = mergePosLeft.nodeBefore;
        }
        this.writer.merge(mergePosLeft);
        if (mergePosLeft.isEqual(this._affectedEnd) && this._firstNode === this._lastNode) {
          this._affectedEnd.detach();
          this._affectedEnd = LivePosition._createAt(mergePosLeft.nodeBefore, "end", "toNext");
        }
        this.position = livePosition.toPosition();
        livePosition.detach();
        this._filterAttributesOf.push(this.position.parent);
        mergePosLeft.detach();
      }
      /**
      * Merges the next sibling of the last node if it should be merged.
      *
      * After the content was inserted we may try to merge it with its siblings.
      * This should happen only if the selection was in those elements initially.
      */
      _mergeOnRight() {
        const node = this._lastNode;
        if (!(node instanceof Element)) {
          return;
        }
        if (!this._canMergeRight(node)) {
          return;
        }
        const mergePosRight = LivePosition._createAfter(node);
        mergePosRight.stickiness = "toNext";
        /* istanbul ignore if -- @preserve */
        if (!this.position.isEqual(mergePosRight)) {
          throw new CKEditorError("insertcontent-invalid-insertion-position", this);
        }
        this.position = Position._createAt(mergePosRight.nodeBefore, "end");
        const livePosition = LivePosition.fromPosition(this.position, "toPrevious");
        if (this._affectedEnd.isEqual(mergePosRight)) {
          this._affectedEnd.detach();
          this._affectedEnd = LivePosition._createAt(mergePosRight.nodeBefore, "end", "toNext");
        }
        if (this._firstNode === this._lastNode) {
          this._firstNode = mergePosRight.nodeBefore;
          this._lastNode = mergePosRight.nodeBefore;
        }
        this.writer.merge(mergePosRight);
        if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode) {
          this._affectedStart.detach();
          this._affectedStart = LivePosition._createAt(mergePosRight.nodeBefore, 0, "toPrevious");
        }
        this.position = livePosition.toPosition();
        livePosition.detach();
        this._filterAttributesOf.push(this.position.parent);
        mergePosRight.detach();
      }
      /**
      * Checks whether specified node can be merged with previous sibling element.
      *
      * @param node The node which could potentially be merged.
      */
      _canMergeLeft(node) {
        const previousSibling = node.previousSibling;
        return previousSibling instanceof Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);
      }
      /**
      * Checks whether specified node can be merged with next sibling element.
      *
      * @param node The node which could potentially be merged.
      */
      _canMergeRight(node) {
        const nextSibling = node.nextSibling;
        return nextSibling instanceof Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);
      }
      /**
      * Tries wrapping the node in a new paragraph and inserting it this way.
      *
      * @param node The node which needs to be autoparagraphed.
      */
      _tryAutoparagraphing(node) {
        const paragraph2 = this.writer.createElement("paragraph");
        if (this._getAllowedIn(this.position.parent, paragraph2) && this.schema.checkChild(paragraph2, node)) {
          paragraph2._appendChild(node);
          this._handleNode(paragraph2);
        }
      }
      /**
      * Checks if a node can be inserted in the given position or it would be accepted if a paragraph would be inserted.
      * It also handles inserting the paragraph.
      *
      * @returns Whether an allowed position was found.
      * `false` is returned if the node isn't allowed at the current position or in auto paragraph, `true` if was.
      */
      _checkAndAutoParagraphToAllowedPosition(node) {
        if (this.schema.checkChild(this.position.parent, node)) {
          return true;
        }
        if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", node)) {
          return false;
        }
        this._insertPartialFragment();
        const paragraph2 = this.writer.createElement("paragraph");
        this.writer.insert(paragraph2, this.position);
        this._setAffectedBoundaries(this.position);
        this._lastAutoParagraph = paragraph2;
        this.position = this.writer.createPositionAt(paragraph2, 0);
        return true;
      }
      /**
      * @returns Whether an allowed position was found.
      * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
      */
      _checkAndSplitToAllowedPosition(node) {
        const allowedIn = this._getAllowedIn(this.position.parent, node);
        if (!allowedIn) {
          return false;
        }
        if (allowedIn != this.position.parent) {
          this._insertPartialFragment();
        }
        while (allowedIn != this.position.parent) {
          if (this.position.isAtStart) {
            const parent2 = this.position.parent;
            this.position = this.writer.createPositionBefore(parent2);
            if (parent2.isEmpty && parent2.parent === allowedIn) {
              this.writer.remove(parent2);
            }
          } else if (this.position.isAtEnd) {
            this.position = this.writer.createPositionAfter(this.position.parent);
          } else {
            const tempPos = this.writer.createPositionAfter(this.position.parent);
            this._setAffectedBoundaries(this.position);
            this.writer.split(this.position);
            this.position = tempPos;
            this.canMergeWith.add(this.position.nodeAfter);
          }
        }
        return true;
      }
      /**
      * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
      *
      * @param contextElement The element in which context the node should be checked.
      * @param childNode The node to check.
      */
      _getAllowedIn(contextElement, childNode) {
        if (this.schema.checkChild(contextElement, childNode)) {
          return contextElement;
        }
        if (this.schema.isLimit(contextElement)) {
          return null;
        }
        return this._getAllowedIn(contextElement.parent, childNode);
      }
    }
    function insertObject(model, object, selectable, options = {}) {
      if (!model.schema.isObject(object)) {
        throw new CKEditorError("insertobject-element-not-an-object", model, {
          object
        });
      }
      const originalSelection = selectable ? selectable : model.document.selection;
      let insertionSelection = originalSelection;
      if (options.findOptimalPosition && model.schema.isBlock(object)) {
        insertionSelection = model.createSelection(model.schema.findOptimalInsertionRange(originalSelection, options.findOptimalPosition));
      }
      const firstSelectedBlock = first(originalSelection.getSelectedBlocks());
      const attributesToCopy = {};
      if (firstSelectedBlock) {
        Object.assign(attributesToCopy, model.schema.getAttributesWithProperty(firstSelectedBlock, "copyOnReplace", true));
      }
      return model.change((writer) => {
        if (!insertionSelection.isCollapsed) {
          model.deleteContent(insertionSelection, {
            doNotAutoparagraph: true
          });
        }
        let elementToInsert = object;
        const insertionPositionParent = insertionSelection.anchor.parent;
        if (!model.schema.checkChild(insertionPositionParent, object) && model.schema.checkChild(insertionPositionParent, "paragraph") && model.schema.checkChild("paragraph", object)) {
          elementToInsert = writer.createElement("paragraph");
          writer.insert(object, elementToInsert);
        }
        model.schema.setAllowedAttributes(elementToInsert, attributesToCopy, writer);
        const affectedRange = model.insertContent(elementToInsert, insertionSelection);
        if (affectedRange.isCollapsed) {
          return affectedRange;
        }
        if (options.setSelection) {
          updateSelection(writer, object, options.setSelection, attributesToCopy);
        }
        return affectedRange;
      });
    }
    function updateSelection(writer, contextElement, place, paragraphAttributes) {
      const model = writer.model;
      if (place == "on") {
        writer.setSelection(contextElement, "on");
        return;
      }
      if (place != "after") {
        throw new CKEditorError("insertobject-invalid-place-parameter-value", model);
      }
      let nextElement = contextElement.nextSibling;
      if (model.schema.isInline(contextElement)) {
        writer.setSelection(contextElement, "after");
        return;
      }
      const canSetSelection = nextElement && model.schema.checkChild(nextElement, "$text");
      if (!canSetSelection && model.schema.checkChild(contextElement.parent, "paragraph")) {
        nextElement = writer.createElement("paragraph");
        model.schema.setAllowedAttributes(nextElement, paragraphAttributes, writer);
        model.insertContent(nextElement, writer.createPositionAfter(contextElement));
      }
      if (nextElement) {
        writer.setSelection(nextElement, 0);
      }
    }
    const wordBoundaryCharacters = ' ,.?!:;"-()';
    function modifySelection(model, selection, options = {}) {
      const schema = model.schema;
      const isForward = options.direction != "backward";
      const unit = options.unit ? options.unit : "character";
      const treatEmojiAsSingleUnit = !!options.treatEmojiAsSingleUnit;
      const focus = selection.focus;
      const walker = new TreeWalker({
        boundaries: getSearchRange(focus, isForward),
        singleCharacters: true,
        direction: isForward ? "forward" : "backward"
      });
      const data = {
        walker,
        schema,
        isForward,
        unit,
        treatEmojiAsSingleUnit
      };
      let next;
      while (next = walker.next()) {
        if (next.done) {
          return;
        }
        const position = tryExtendingTo(data, next.value);
        if (position) {
          if (selection instanceof DocumentSelection) {
            model.change((writer) => {
              writer.setSelectionFocus(position);
            });
          } else {
            selection.setFocus(position);
          }
          return;
        }
      }
    }
    function tryExtendingTo(data, value) {
      const { isForward, walker, unit, schema, treatEmojiAsSingleUnit } = data;
      const { type, item, nextPosition } = value;
      if (type == "text") {
        if (data.unit === "word") {
          return getCorrectWordBreakPosition(walker, isForward);
        }
        return getCorrectPosition(walker, unit, treatEmojiAsSingleUnit);
      }
      if (type == (isForward ? "elementStart" : "elementEnd")) {
        if (schema.isSelectable(item)) {
          return Position._createAt(item, isForward ? "after" : "before");
        }
        if (schema.checkChild(nextPosition, "$text")) {
          return nextPosition;
        }
      } else {
        if (schema.isLimit(item)) {
          walker.skip(() => true);
          return;
        }
        if (schema.checkChild(nextPosition, "$text")) {
          return nextPosition;
        }
      }
    }
    function getCorrectPosition(walker, unit, treatEmojiAsSingleUnit) {
      const textNode = walker.position.textNode;
      if (textNode) {
        const data = textNode.data;
        let offset = walker.position.offset - textNode.startOffset;
        while (isInsideSurrogatePair(data, offset) || unit == "character" && isInsideCombinedSymbol(data, offset) || treatEmojiAsSingleUnit && isInsideEmojiSequence(data, offset)) {
          walker.next();
          offset = walker.position.offset - textNode.startOffset;
        }
      }
      return walker.position;
    }
    function getCorrectWordBreakPosition(walker, isForward) {
      let textNode = walker.position.textNode;
      if (!textNode) {
        textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
      }
      while (textNode && textNode.is("$text")) {
        const offset = walker.position.offset - textNode.startOffset;
        if (isAtNodeBoundary(textNode, offset, isForward)) {
          textNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore;
        } else if (isAtWordBoundary(textNode.data, offset, isForward)) {
          break;
        } else {
          walker.next();
        }
      }
      return walker.position;
    }
    function getSearchRange(start, isForward) {
      const root2 = start.root;
      const searchEnd = Position._createAt(root2, isForward ? "end" : 0);
      if (isForward) {
        return new Range(start, searchEnd);
      } else {
        return new Range(searchEnd, start);
      }
    }
    function isAtWordBoundary(data, offset, isForward) {
      const offsetToCheck = offset + (isForward ? 0 : -1);
      return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));
    }
    function isAtNodeBoundary(textNode, offset, isForward) {
      return offset === (isForward ? textNode.offsetSize : 0);
    }
    let Model$1 = class Model extends (/* @__PURE__ */ ObservableMixin()) {
      // @if CK_DEBUG_ENGINE // private _operationLogs: Array<string>;
      // @if CK_DEBUG_ENGINE // private _appliedOperations: Array<Operation>;
      constructor() {
        super();
        /**
        * Model's marker collection.
        */
        __publicField(this, "markers");
        /**
        * Model's document.
        */
        __publicField(this, "document");
        /**
        * Model's schema.
        */
        __publicField(this, "schema");
        /**
        * All callbacks added by {@link module:engine/model/model~Model#change} or
        * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.
        */
        __publicField(this, "_pendingChanges");
        /**
        * The last created and currently used writer instance.
        */
        __publicField(this, "_currentWriter");
        this.markers = new MarkerCollection();
        this.document = new Document(this);
        this.schema = new Schema();
        this._pendingChanges = [];
        this._currentWriter = null;
        [
          "deleteContent",
          "modifySelection",
          "getSelectedContent",
          "applyOperation"
        ].forEach((methodName) => this.decorate(methodName));
        this.on("applyOperation", (evt, args) => {
          const operation = args[0];
          operation._validate();
        }, {
          priority: "highest"
        });
        this.schema.register("$root", {
          isLimit: true
        });
        this.schema.register("$container", {
          allowIn: [
            "$root",
            "$container"
          ]
        });
        this.schema.register("$block", {
          allowIn: [
            "$root",
            "$container"
          ],
          isBlock: true
        });
        this.schema.register("$blockObject", {
          allowWhere: "$block",
          isBlock: true,
          isObject: true
        });
        this.schema.register("$inlineObject", {
          allowWhere: "$text",
          allowAttributesOf: "$text",
          isInline: true,
          isObject: true
        });
        this.schema.register("$text", {
          allowIn: "$block",
          isInline: true,
          isContent: true
        });
        this.schema.register("$clipboardHolder", {
          allowContentOf: "$root",
          allowChildren: "$text",
          isLimit: true
        });
        this.schema.register("$documentFragment", {
          allowContentOf: "$root",
          allowChildren: "$text",
          isLimit: true
        });
        this.schema.register("$marker");
        this.schema.addChildCheck((context, childDefinition) => {
          if (childDefinition.name === "$marker") {
            return true;
          }
        });
        injectSelectionPostFixer(this);
        this.document.registerPostFixer(autoParagraphEmptyRoots);
        this.on("insertContent", (evt, [content, selectable]) => {
          evt.return = insertContent(this, content, selectable);
        });
        this.on("insertObject", (evt, [element, selection, options]) => {
          evt.return = insertObject(this, element, selection, options);
        });
        this.on("canEditAt", (evt) => {
          const canEditAt = !this.document.isReadOnly;
          evt.return = canEditAt;
          if (!canEditAt) {
            evt.stop();
          }
        });
      }
      /**
      * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
      * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
      * the {@link module:engine/model/document~Document#selection document's selection}, and
      * {@link module:engine/model/model~Model#markers model markers}.
      *
      * ```ts
      * model.change( writer => {
      * 	writer.insertText( 'foo', paragraph, 'end' );
      * } );
      * ```
      *
      * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
      * into a single undo step.
      *
      * ```ts
      * model.change( writer => {
      * 	writer.insertText( 'foo', paragraph, 'end' ); // foo.
      *
      * 	model.change( writer => {
      * 		writer.insertText( 'bar', paragraph, 'end' ); // foobar.
      * 	} );
      *
      * 	writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
      * } );
      * ```
      *
      * The callback of the `change()` block is executed synchronously.
      *
      * You can also return a value from the change block.
      *
      * ```ts
      * const img = model.change( writer => {
      * 	return writer.createElement( 'img' );
      * } );
      * ```
      *
      * @see #enqueueChange
      * @typeParam TReturn The return type of the provided callback.
      * @param callback Callback function which may modify the model.
      */
      change(callback) {
        try {
          if (this._pendingChanges.length === 0) {
            this._pendingChanges.push({
              batch: new Batch(),
              callback
            });
            return this._runPendingChanges()[0];
          } else {
            return callback(this._currentWriter);
          }
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      enqueueChange(batchOrType, callback) {
        try {
          if (!batchOrType) {
            batchOrType = new Batch();
          } else if (typeof batchOrType === "function") {
            callback = batchOrType;
            batchOrType = new Batch();
          } else if (!(batchOrType instanceof Batch)) {
            batchOrType = new Batch(batchOrType);
          }
          this._pendingChanges.push({
            batch: batchOrType,
            callback
          });
          if (this._pendingChanges.length == 1) {
            this._runPendingChanges();
          }
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      /**
      * {@link module:utils/observablemixin~Observable#decorate Decorated} function for applying
      * {@link module:engine/model/operation/operation~Operation operations} to the model.
      *
      * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
      * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
      * See also {@glink framework/architecture/editing-engine#changing-the-model Changing the model} section
      * of the {@glink framework/architecture/editing-engine Editing architecture} guide.
      *
      * @param operation The operation to apply.
      */
      applyOperation(operation) {
        operation._execute();
      }
      // @if CK_DEBUG_ENGINE // public getAppliedOperation(): string {
      // @if CK_DEBUG_ENGINE // 	if ( !this._appliedOperations ) {
      // @if CK_DEBUG_ENGINE // 		return '';
      // @if CK_DEBUG_ENGINE // 	}
      // @if CK_DEBUG_ENGINE // 	return this._appliedOperations.map( operation => JSON.stringify( operation ) ).join( '-------' );
      // @if CK_DEBUG_ENGINE // }
      // @if CK_DEBUG_ENGINE // public createReplayer( stringifiedOperations: string ): typeof OperationReplayer {
      // @if CK_DEBUG_ENGINE // 	return new OperationReplayer( this, '-------', stringifiedOperations );
      // @if CK_DEBUG_ENGINE // }
      /**
      * Inserts content at the position in the editor specified by the selection, as one would expect the paste
      * functionality to work.
      *
      * **Note**: If you want to insert an {@glink framework/deep-dive/schema#object-elements object element}
      * (e.g. a {@link module:widget/utils~toWidget widget}), see {@link #insertObject} instead.
      *
      * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
      * the content, clears the given selection's content before inserting nodes and moves the selection
      * to its target position at the end of the process.
      * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &ndash; just like the
      * pasting feature should do.
      *
      * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
      *
      * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
      * inside a {@link #change `change()` block}.
      *
      * # Conversion and schema
      *
      * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
      * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
      * is only adding nodes to the model. Additionally, you need to define
      * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
      * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
      *
      * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
      * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
      * unless converters are defined for all elements and attributes in that HTML.
      *
      * # Examples
      *
      * Using `insertContent()` with a manually created model structure:
      *
      * ```ts
      * // Let's create a document fragment containing such content as:
      * //
      * // <paragraph>foo</paragraph>
      * // <blockQuote>
      * //    <paragraph>bar</paragraph>
      * // </blockQuote>
      * const docFrag = editor.model.change( writer => {
      * 	const p1 = writer.createElement( 'paragraph' );
      * 	const p2 = writer.createElement( 'paragraph' );
      * 	const blockQuote = writer.createElement( 'blockQuote' );
      * 	const docFrag = writer.createDocumentFragment();
      *
      * 	writer.append( p1, docFrag );
      * 	writer.append( blockQuote, docFrag );
      * 	writer.append( p2, blockQuote );
      * 	writer.insertText( 'foo', p1 );
      * 	writer.insertText( 'bar', p2 );
      *
      * 	return docFrag;
      * } );
      *
      * // insertContent() does not have to be used in a change() block. It can, though,
      * // so this code could be moved to the callback defined above.
      * editor.model.insertContent( docFrag );
      * ```
      *
      * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
      *
      * ```ts
      * // You can create your own HtmlDataProcessor instance or use editor.data.processor
      * // if you have not overridden the default one (which is the HtmlDataProcessor instance).
      * const htmlDP = new HtmlDataProcessor( viewDocument );
      *
      * // Convert an HTML string to a view document fragment:
      * const viewFragment = htmlDP.toView( htmlString );
      *
      * // Convert the view document fragment to a model document fragment
      * // in the context of $root. This conversion takes the schema into
      * // account so if, for example, the view document fragment contained a bare text node,
      * // this text node cannot be a child of $root, so it will be automatically
      * // wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
      * // and e.g. convert the content like it would happen in a <paragraph>.
      * // Note: The clipboard feature uses a custom context called $clipboardHolder
      * // which has a loosened schema.
      * const modelFragment = editor.data.toModel( viewFragment );
      *
      * editor.model.insertContent( modelFragment );
      * ```
      *
      * By default this method will use the document selection but it can also be used with a position, range or selection instance.
      *
      * ```ts
      * // Insert text at the current document selection position.
      * editor.model.change( writer => {
      * 	editor.model.insertContent( writer.createText( 'x' ) );
      * } );
      *
      * // Insert text at a given position - the document selection will not be modified.
      * editor.model.change( writer => {
      * 	editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
      *
      * 	// Which is a shorthand for:
      * 	editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
      * } );
      * ```
      *
      * If you want the document selection to be moved to the inserted content, use the
      * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
      * the content:
      *
      * ```ts
      * editor.model.change( writer => {
      * 	const paragraph = writer.createElement( 'paragraph' );
      *
      * 	// Insert an empty paragraph at the beginning of the root.
      * 	editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
      *
      * 	// Move the document selection to the inserted paragraph.
      * 	writer.setSelection( paragraph, 'in' );
      * } );
      * ```
      *
      * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
      * the new content will be inserted at the passed selection (instead of document selection):
      *
      * ```ts
      * editor.model.change( writer => {
      * 	// Create a selection in a paragraph that will be used as a place of insertion.
      * 	const selection = writer.createSelection( paragraph, 'in' );
      *
      * 	// Insert the new text at the created selection.
      * 	editor.model.insertContent( writer.createText( 'x' ), selection );
      *
      * 	// insertContent() modifies the passed selection instance so it can be used to set the document selection.
      * 	// Note: This is not necessary when you passed the document selection to insertContent().
      * 	writer.setSelection( selection );
      * } );
      * ```
      *
      * @fires insertContent
      * @param content The content to insert.
      * @param selectable The selection into which the content should be inserted.
      * If not provided the current model document selection will be used.
      * @param placeOrOffset To be used when a model item was passed as `selectable`.
      * This param defines a position in relation to that item.
      * at the insertion position.
      */
      insertContent(content, selectable, placeOrOffset, ...rest) {
        const selection = normalizeSelectable(selectable, placeOrOffset);
        return this.fire("insertContent", [
          content,
          selection,
          placeOrOffset,
          ...rest
        ]);
      }
      /**
      * Inserts an {@glink framework/deep-dive/schema#object-elements object element} at a specific position in the editor content.
      *
      * This is a high-level API:
      * * It takes the {@link #schema schema} into consideration,
      * * It clears the content of passed `selectable` before inserting,
      * * It can move the selection at the end of the process,
      * * It will copy the selected block's attributes to preserve them upon insertion,
      * * It can split elements or wrap inline objects with paragraphs if they are not allowed in target position,
      * * etc.
      *
      * # Notes
      *
      * * If you want to insert a non-object content, see {@link #insertContent} instead.
      * * For lower-level API, see {@link module:engine/model/writer~Writer `Writer`}.
      * * Unlike {@link module:engine/model/writer~Writer `Writer`}, this method does not have to be used inside
      * a {@link #change `change()` block}.
      * * Inserting object into the model is not enough to make CKEditor 5 render that content to the user.
      * CKEditor 5 implements a model-view-controller architecture and what `model.insertObject()` does
      * is only adding nodes to the model. Additionally, you need to define
      * {@glink framework/architecture/editing-engine#conversion converters} between the model and view
      * and define those nodes in the {@glink framework/architecture/editing-engine#schema schema}.
      *
      * # Examples
      *
      * Use the following code to insert an object at the current selection and keep the selection on the inserted element:
      *
      * ```ts
      * const rawHtmlEmbedElement = writer.createElement( 'rawHtml' );
      *
      * model.insertObject( rawHtmlEmbedElement, null, null, {
      * 	setSelection: 'on'
      * } );
      * ```
      *
      * Use the following code to insert an object at the current selection and nudge the selection after the inserted object:
      *
      * ```ts
      * const pageBreakElement = writer.createElement( 'pageBreak' );
       *
      * model.insertObject( pageBreakElement, null, null, {
      * 	setSelection: 'after'
      * } );
      * ```
      *
      * Use the following code to insert an object at the current selection and avoid splitting the content (non-destructive insertion):
      *
      * ```ts
      * const tableElement = writer.createElement( 'table' );
       *
      * model.insertObject( tableElement, null, null, {
      * 	findOptimalPosition: 'auto'
      * } );
      * ```
      *
      * Use the following code to insert an object at the specific range (also: replace the content of the range):
      *
      * ```ts
      * const tableElement = writer.createElement( 'table' );
      * const range = model.createRangeOn( model.document.getRoot().getChild( 1 ) );
       *
      * model.insertObject( tableElement, range );
      * ```
      *
      * @param element An object to be inserted into the model document.
      * @param selectable A selectable where the content should be inserted. If not specified, the current
      * {@link module:engine/model/document~Document#selection document selection} will be used instead.
      * @param placeOrOffset Specifies the exact place or offset for the insertion to take place, relative to `selectable`.
      * @param options Additional options.
      * @param options.findOptimalPosition An option that, when set, adjusts the insertion position (relative to
      * `selectable` and `placeOrOffset`) so that the content of `selectable` is not split upon insertion (a.k.a. non-destructive insertion).
      * * When `'auto'`, the algorithm will decide whether to insert the object before or after `selectable` to avoid content splitting.
      * * When `'before'`, the closest position before `selectable` will be used that will not result in content splitting.
      * * When `'after'`, the closest position after `selectable` will be used that will not result in content splitting.
      *
      * Note that this option only works for block objects. Inline objects are inserted into text and do not split blocks.
      * @param options.setSelection An option that, when set, moves the
      * {@link module:engine/model/document~Document#selection document selection} after inserting the object.
      * * When `'on'`, the document selection will be set on the inserted object.
      * * When `'after'`, the document selection will move to the closest text node after the inserted object. If there is no
      * such text node, a paragraph will be created and the document selection will be moved inside it.
      * at the insertion position.
      */
      insertObject(element, selectable, placeOrOffset, options, ...rest) {
        const selection = normalizeSelectable(selectable, placeOrOffset);
        return this.fire("insertObject", [
          element,
          selection,
          options,
          options,
          ...rest
        ]);
      }
      /**
      * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
      *
      * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
      * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
      * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
      * then that behavior should be implemented in the view's listener. At the same time, the table feature
      * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
      * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
      * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
      *
      * @fires deleteContent
      * @param selection Selection of which the content should be deleted.
      * @param options.leaveUnmerged Whether to merge elements after removing the content of the selection.
      *
      * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
      *
      * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
      * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
      *
      * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
      * elements will not be merged.
      *
      * @param options.doNotResetEntireContent Whether to skip replacing the entire content with a
      * paragraph when the entire content was selected.
      *
      * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
      *
      * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
      * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
      *
      * @param options.doNotAutoparagraph Whether to create a paragraph if after content deletion selection is moved
      * to a place where text cannot be inserted.
      *
      * For example `<paragraph>x</paragraph>[<imageBlock src="foo.jpg"></imageBlock>]` will become:
      *
      * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
      * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
      *
      * **Note:** if there is no valid position for the selection, the paragraph will always be created:
      *
      * `[<imageBlock src="foo.jpg"></imageBlock>]` -> `<paragraph>[]</paragraph>`.
      *
      * @param options.direction The direction in which the content is being consumed.
      * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
      * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
      */
      deleteContent(selection, options) {
        deleteContent(this, selection, options);
      }
      /**
      * Modifies the selection. Currently, the supported modifications are:
      *
      * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
      * Possible values for `unit` are:
      *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
      *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
      *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
      *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
      *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
      *  why `'character'` value is most natural and common method of modifying selection.
      *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
      *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
      *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
      *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
      *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
      *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
      *  extension will include whole "surrogate pair".
      *  * `'word'` - moves selection by a whole word.
      *
      * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
      *
      * @fires modifySelection
      * @param selection The selection to modify.
      * @param options.direction The direction in which the selection should be modified.
      * @param options.unit The unit by which selection should be modified.
      * @param options.treatEmojiAsSingleUnit Whether multi-characer emoji sequences should be handled as single unit.
      */
      modifySelection(selection, options) {
        modifySelection(this, selection, options);
      }
      /**
      * Gets a clone of the selected content.
      *
      * For example, for the following selection:
      *
      * ```html
      * <paragraph>x</paragraph>
      * <blockQuote>
      * 	<paragraph>y</paragraph>
      * 	<heading1>fir[st</heading1>
      * </blockQuote>
      * <paragraph>se]cond</paragraph>
      * <paragraph>z</paragraph>
      * ```
      *
      * It will return a document fragment with such a content:
      *
      * ```html
      * <blockQuote>
      * 	<heading1>st</heading1>
      * </blockQuote>
      * <paragraph>se</paragraph>
      * ```
      *
      * @fires getSelectedContent
      * @param selection The selection of which content will be returned.
      */
      getSelectedContent(selection) {
        return getSelectedContent(this, selection);
      }
      /**
      * Checks whether the given {@link module:engine/model/range~Range range} or
      * {@link module:engine/model/element~Element element} has any meaningful content.
      *
      * Meaningful content is:
      *
      * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
      * any non-whitespace characters),
      * * or any {@link module:engine/model/schema~Schema#isContent content element},
      * * or any {@link module:engine/model/markercollection~Marker marker} which
      * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
      *
      * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
      * However, a range containing an `<imageBlock></imageBlock>` (which would normally be marked in the schema as an object element)
      * is considered non-empty.
      *
      * @param rangeOrElement Range or element to check.
      * @param options.ignoreWhitespaces Whether text node with whitespaces only should be considered empty.
      * @param options.ignoreMarkers Whether markers should be ignored.
      */
      hasContent(rangeOrElement, options = {}) {
        const range = rangeOrElement instanceof Range ? rangeOrElement : Range._createIn(rangeOrElement);
        if (range.isCollapsed) {
          return false;
        }
        const { ignoreWhitespaces = false, ignoreMarkers = false } = options;
        if (!ignoreMarkers) {
          for (const intersectingMarker of this.markers.getMarkersIntersectingRange(range)) {
            if (intersectingMarker.affectsData) {
              return true;
            }
          }
        }
        for (const item of range.getItems()) {
          if (this.schema.isContent(item)) {
            if (item.is("$textProxy")) {
              if (!ignoreWhitespaces) {
                return true;
              } else if (item.data.search(/\S/) !== -1) {
                return true;
              }
            } else {
              return true;
            }
          }
        }
        return false;
      }
      /**
      * Check whether given selectable is at a place in the model where it can be edited (returns `true`) or not (returns `false`).
      *
      * Should be used instead of {@link module:core/editor/editor~Editor#isReadOnly} to check whether a user action can happen at
      * given selectable. It may be decorated and used differently in different environment (e.g. multi-root editor can disable
      * a particular root).
      *
      * This method is decorated. Although this method accepts any parameter of `Selectable` type, the
      * {@link ~Model#event:canEditAt `canEditAt` event} is fired with `selectable` normalized to an instance of
      * {@link module:engine/model/selection~Selection} or {@link module:engine/model/documentselection~DocumentSelection}
      *
      * @fires canEditAt
      */
      canEditAt(selectable) {
        const selection = normalizeSelectable(selectable);
        return this.fire("canEditAt", [
          selection
        ]);
      }
      /**
      * Creates a position from the given root and path in that root.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
      *
      * @param root Root of the position.
      * @param path Position path. See {@link module:engine/model/position~Position#path}.
      * @param stickiness Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
      */
      createPositionFromPath(root2, path, stickiness) {
        return new Position(root2, path, stickiness);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/model/position~Position position},
      * * a parent element and offset in that element,
      * * a parent element and `'end'` (the position will be set at the end of that element),
      * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
      * (the position will be set before or after the given model item).
      *
      * This method is a shortcut to other factory methods such as:
      *
      * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
      * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
      *
      * @param itemOrPosition
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/model/item~Item model item}.
      */
      createPositionAt(itemOrPosition, offset) {
        return Position._createAt(itemOrPosition, offset);
      }
      /**
      * Creates a new position after the given {@link module:engine/model/item~Item model item}.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
      *
      * @param item Item after which the position should be placed.
      */
      createPositionAfter(item) {
        return Position._createAfter(item);
      }
      /**
      * Creates a new position before the given {@link module:engine/model/item~Item model item}.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
      *
      * @param item Item before which the position should be placed.
      */
      createPositionBefore(item) {
        return Position._createBefore(item);
      }
      /**
      * Creates a range spanning from the `start` position to the `end` position.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
      *
      * ```ts
      * model.change( writer => {
      * 	const range = writer.createRange( start, end );
      * } );
      * ```
      *
      * @param start Start position.
      * @param end End position. If not set, the range will be collapsed to the `start` position.
      */
      createRange(start, end) {
        return new Range(start, end);
      }
      /**
      * Creates a range inside the given element which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * Note: This method is also available as
      * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
      *
      * ```ts
      * model.change( writer => {
      * 	const range = writer.createRangeIn( paragraph );
      * } );
      * ```
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range._createIn(element);
      }
      /**
      * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
      *
      * Note: This method is also available on `writer` instance as
      * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
      *
      * ```ts
      * model.change( writer => {
      * 	const range = writer.createRangeOn( paragraph );
      * } );
      * ```
      *
      * @param item
      */
      createRangeOn(item) {
        return Range._createOn(item);
      }
      createSelection(...args) {
        return new Selection(...args);
      }
      /**
      * Creates a {@link module:engine/model/batch~Batch} instance.
      *
      * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
      *
      * * {@link #change `change()`},
      * * {@link #enqueueChange `enqueueChange()`}.
      *
      * @param type {@link module:engine/model/batch~Batch#constructor The type} of the batch.
      */
      createBatch(type) {
        return new Batch(type);
      }
      /**
      * Creates an operation instance from a JSON object (parsed JSON string).
      *
      * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
      *
      * @param json Deserialized JSON object.
      */
      createOperationFromJSON(json) {
        return OperationFactory.fromJSON(json, this.document);
      }
      /**
      * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
      */
      destroy() {
        this.document.destroy();
        this.stopListening();
      }
      /**
      * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
      * which calls callbacks and returns array of values returned by these callbacks.
      */
      _runPendingChanges() {
        const ret = [];
        this.fire("_beforeChanges");
        try {
          while (this._pendingChanges.length) {
            const currentBatch = this._pendingChanges[0].batch;
            this._currentWriter = new Writer(this, currentBatch);
            const callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);
            ret.push(callbackReturnValue);
            this.document._handleChangeBlock(this._currentWriter);
            this._pendingChanges.shift();
            this._currentWriter = null;
          }
        } finally {
          this._pendingChanges.length = 0;
          this._currentWriter = null;
          this.fire("_afterChanges");
        }
        return ret;
      }
    };
    function normalizeSelectable(selectable, placeOrOffset) {
      if (!selectable) {
        return;
      }
      if (selectable instanceof Selection || selectable instanceof DocumentSelection) {
        return selectable;
      }
      if (selectable instanceof Node$1) {
        if (placeOrOffset || placeOrOffset === 0) {
          return new Selection(selectable, placeOrOffset);
        } else if (selectable.is("rootElement")) {
          return new Selection(selectable, "in");
        } else {
          return new Selection(selectable, "on");
        }
      }
      return new Selection(selectable);
    }
    class ClickObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", "click");
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
    }
    class MouseObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        /**
        * @inheritDoc
        */
        __publicField(this, "domEventType", [
          "mousedown",
          "mouseup",
          "mouseover",
          "mouseout"
        ]);
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
    }
    class UpcastWriter {
      /**
      * @param document The view document instance in which this upcast writer operates.
      */
      constructor(document2) {
        /**
        * The view document instance in which this upcast writer operates.
        */
        __publicField(this, "document");
        this.document = document2;
      }
      /**
      * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
      *
      * @param children A list of nodes to be inserted into the created document fragment.
      * @returns The created document fragment.
      */
      createDocumentFragment(children) {
        return new DocumentFragment$1(this.document, children);
      }
      /**
      * Creates a new {@link module:engine/view/element~Element} instance.
      *
      * Attributes can be passed in various formats:
      *
      * ```ts
      * upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
      * upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
      * upcastWriter.createElement( 'div', mapOfAttributes ); // map
      * ```
      *
      * @param name Node name.
      * @param attrs Collection of attributes.
      * @param children A list of nodes to be inserted into created element.
      * @returns Created element.
      */
      createElement(name, attrs, children) {
        return new Element$1(this.document, name, attrs, children);
      }
      /**
      * Creates a new {@link module:engine/view/text~Text} instance.
      *
      * @param data The text's data.
      * @returns The created text node.
      */
      createText(data) {
        return new Text$1(this.document, data);
      }
      /**
      * Clones the provided element.
      *
      * @see module:engine/view/element~Element#_clone
      * @param element Element to be cloned.
      * @param deep If set to `true` clones element and all its children recursively. When set to `false`,
      * element will be cloned without any children.
      * @returns Clone of this element.
      */
      clone(element, deep = false) {
        return element._clone(deep);
      }
      /**
      * Appends a child node or a list of child nodes at the end of this node
      * and sets the parent of these nodes to this element.
      *
      * @see module:engine/view/element~Element#_appendChild
      * @param items Items to be inserted.
      * @param element Element to which items will be appended.
      * @returns Number of appended nodes.
      */
      appendChild(items, element) {
        return element._appendChild(items);
      }
      /**
      * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
      * this element.
      *
      * @see module:engine/view/element~Element#_insertChild
      * @param index Offset at which nodes should be inserted.
      * @param items Items to be inserted.
      * @param element Element to which items will be inserted.
      * @returns Number of inserted nodes.
      */
      insertChild(index2, items, element) {
        return element._insertChild(index2, items);
      }
      /**
      * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
      *
      * @see module:engine/view/element~Element#_removeChildren
      * @param index Offset from which nodes will be removed.
      * @param howMany Number of nodes to remove.
      * @param element Element which children will be removed.
      * @returns The array containing removed nodes.
      */
      removeChildren(index2, howMany, element) {
        return element._removeChildren(index2, howMany);
      }
      /**
      * Removes given element from the view structure. Will not have effect on detached elements.
      *
      * @param element Element which will be removed.
      * @returns The array containing removed nodes.
      */
      remove(element) {
        const parent2 = element.parent;
        if (parent2) {
          return this.removeChildren(parent2.getChildIndex(element), 1, parent2);
        }
        return [];
      }
      /**
      * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
      *
      * @param oldElement Element which will be replaced.
      * @param newElement Element which will be inserted in the place of the old element.
      * @returns Whether old element was successfully replaced.
      */
      replace(oldElement, newElement) {
        const parent2 = oldElement.parent;
        if (parent2) {
          const index2 = parent2.getChildIndex(oldElement);
          this.removeChildren(index2, 1, parent2);
          this.insertChild(index2, newElement, parent2);
          return true;
        }
        return false;
      }
      /**
      * Removes given element from view structure and places its children in its position.
      * It does nothing if element has no parent.
      *
      * @param element Element to unwrap.
      */
      unwrapElement(element) {
        const parent2 = element.parent;
        if (parent2) {
          const index2 = parent2.getChildIndex(element);
          this.remove(element);
          this.insertChild(index2, element.getChildren(), parent2);
        }
      }
      /**
      * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
      * old element to the new one.
      *
      * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
      *
      * @param newName New element name.
      * @param  element Element to be renamed.
      * @returns New element or null if the old element was not replaced (happens for detached elements).
      */
      rename(newName, element) {
        const newElement = new Element$1(this.document, newName, element.getAttributes(), element.getChildren());
        return this.replace(element, newElement) ? newElement : null;
      }
      /**
      * Adds or overwrites element's attribute with a specified key and value.
      *
      * ```ts
      * writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
      * ```
      *
      * @see module:engine/view/element~Element#_setAttribute
      * @param key Attribute key.
      * @param value Attribute value.
      * @param element Element for which attribute will be set.
      */
      setAttribute(key, value, element) {
        element._setAttribute(key, value);
      }
      /**
      * Removes attribute from the element.
      *
      * ```ts
      * writer.removeAttribute( 'href', linkElement );
      * ```
      *
      * @see module:engine/view/element~Element#_removeAttribute
      * @param key Attribute key.
      * @param element Element from which attribute will be removed.
      */
      removeAttribute(key, element) {
        element._removeAttribute(key);
      }
      /**
      * Adds specified class to the element.
      *
      * ```ts
      * writer.addClass( 'foo', linkElement );
      * writer.addClass( [ 'foo', 'bar' ], linkElement );
      * ```
      *
      * @see module:engine/view/element~Element#_addClass
      * @param className Single class name or array of class names which will be added.
      * @param element Element for which class will be added.
      */
      addClass(className, element) {
        element._addClass(className);
      }
      /**
      * Removes specified class from the element.
      *
      * ```ts
      * writer.removeClass( 'foo', linkElement );
      * writer.removeClass( [ 'foo', 'bar' ], linkElement );
      * ```
      *
      * @see module:engine/view/element~Element#_removeClass
      * @param className Single class name or array of class names which will be removed.
      * @param element Element from which class will be removed.
      */
      removeClass(className, element) {
        element._removeClass(className);
      }
      setStyle(property2, valueOrElement, element) {
        if (isPlainObject(property2) && element === void 0) {
          valueOrElement._setStyle(property2);
        } else {
          element._setStyle(property2, valueOrElement);
        }
      }
      /**
      * Removes specified style from the element.
      *
      * ```ts
      * writer.removeStyle( 'color', element );  // Removes 'color' style.
      * writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
      * ```
      *
      * **Note**: This method can work with normalized style names if
      * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
      * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
      *
      * @see module:engine/view/element~Element#_removeStyle
      * @param property Style property name or names to be removed.
      * @param element Element from which style will be removed.
      */
      removeStyle(property2, element) {
        element._removeStyle(property2);
      }
      /**
      * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
      * so they can be used to add special data to elements.
      *
      * @see module:engine/view/element~Element#_setCustomProperty
      * @param key Custom property name/key.
      * @param value Custom property value to be stored.
      * @param element Element for which custom property will be set.
      */
      setCustomProperty(key, value, element) {
        element._setCustomProperty(key, value);
      }
      /**
      * Removes a custom property stored under the given key.
      *
      * @see module:engine/view/element~Element#_removeCustomProperty
      * @param key Name/key of the custom property to be removed.
      * @param element Element from which the custom property will be removed.
      * @returns Returns true if property was removed.
      */
      removeCustomProperty(key, element) {
        return element._removeCustomProperty(key);
      }
      /**
      * Creates position at the given location. The location can be specified as:
      *
      * * a {@link module:engine/view/position~Position position},
      * * parent element and offset (offset defaults to `0`),
      * * parent element and `'end'` (sets position at the end of that element),
      * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
      *
      * This method is a shortcut to other constructors such as:
      *
      * * {@link #createPositionBefore},
      * * {@link #createPositionAfter},
      *
      * @param offset Offset or one of the flags. Used only when first parameter is a {@link module:engine/view/item~Item view item}.
      */
      createPositionAt(itemOrPosition, offset) {
        return Position$1._createAt(itemOrPosition, offset);
      }
      /**
      * Creates a new position after given view item.
      *
      * @param item View item after which the position should be located.
      */
      createPositionAfter(item) {
        return Position$1._createAfter(item);
      }
      /**
      * Creates a new position before given view item.
      *
      * @param item View item before which the position should be located.
      */
      createPositionBefore(item) {
        return Position$1._createBefore(item);
      }
      /**
      * Creates a range spanning from `start` position to `end` position.
      *
      * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
      *
      * @param start Start position.
      * @param end End position. If not set, range will be collapsed at `start` position.
      */
      createRange(start, end) {
        return new Range$1(start, end);
      }
      /**
      * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
      */
      createRangeOn(item) {
        return Range$1._createOn(item);
      }
      /**
      * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
      * that element and ends after the last child of that element.
      *
      * @param element Element which is a parent for the range.
      */
      createRangeIn(element) {
        return Range$1._createIn(element);
      }
      createSelection(...args) {
        return new Selection$1(...args);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const HEX_COLOR_REGEXP = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
    const RGB_COLOR_REGEXP = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i;
    const RGBA_COLOR_REGEXP = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
    const HSL_COLOR_REGEXP = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i;
    const HSLA_COLOR_REGEXP = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i;
    const CSS_SHORTHAND_VALUE_REGEXP = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi;
    const COLOR_NAMES = /* @__PURE__ */ new Set([
      // CSS Level 1
      "black",
      "silver",
      "gray",
      "white",
      "maroon",
      "red",
      "purple",
      "fuchsia",
      "green",
      "lime",
      "olive",
      "yellow",
      "navy",
      "blue",
      "teal",
      "aqua",
      // CSS Level 2 (Revision 1)
      "orange",
      // CSS Color Module Level 3
      "aliceblue",
      "antiquewhite",
      "aquamarine",
      "azure",
      "beige",
      "bisque",
      "blanchedalmond",
      "blueviolet",
      "brown",
      "burlywood",
      "cadetblue",
      "chartreuse",
      "chocolate",
      "coral",
      "cornflowerblue",
      "cornsilk",
      "crimson",
      "cyan",
      "darkblue",
      "darkcyan",
      "darkgoldenrod",
      "darkgray",
      "darkgreen",
      "darkgrey",
      "darkkhaki",
      "darkmagenta",
      "darkolivegreen",
      "darkorange",
      "darkorchid",
      "darkred",
      "darksalmon",
      "darkseagreen",
      "darkslateblue",
      "darkslategray",
      "darkslategrey",
      "darkturquoise",
      "darkviolet",
      "deeppink",
      "deepskyblue",
      "dimgray",
      "dimgrey",
      "dodgerblue",
      "firebrick",
      "floralwhite",
      "forestgreen",
      "gainsboro",
      "ghostwhite",
      "gold",
      "goldenrod",
      "greenyellow",
      "grey",
      "honeydew",
      "hotpink",
      "indianred",
      "indigo",
      "ivory",
      "khaki",
      "lavender",
      "lavenderblush",
      "lawngreen",
      "lemonchiffon",
      "lightblue",
      "lightcoral",
      "lightcyan",
      "lightgoldenrodyellow",
      "lightgray",
      "lightgreen",
      "lightgrey",
      "lightpink",
      "lightsalmon",
      "lightseagreen",
      "lightskyblue",
      "lightslategray",
      "lightslategrey",
      "lightsteelblue",
      "lightyellow",
      "limegreen",
      "linen",
      "magenta",
      "mediumaquamarine",
      "mediumblue",
      "mediumorchid",
      "mediumpurple",
      "mediumseagreen",
      "mediumslateblue",
      "mediumspringgreen",
      "mediumturquoise",
      "mediumvioletred",
      "midnightblue",
      "mintcream",
      "mistyrose",
      "moccasin",
      "navajowhite",
      "oldlace",
      "olivedrab",
      "orangered",
      "orchid",
      "palegoldenrod",
      "palegreen",
      "paleturquoise",
      "palevioletred",
      "papayawhip",
      "peachpuff",
      "peru",
      "pink",
      "plum",
      "powderblue",
      "rosybrown",
      "royalblue",
      "saddlebrown",
      "salmon",
      "sandybrown",
      "seagreen",
      "seashell",
      "sienna",
      "skyblue",
      "slateblue",
      "slategray",
      "slategrey",
      "snow",
      "springgreen",
      "steelblue",
      "tan",
      "thistle",
      "tomato",
      "turquoise",
      "violet",
      "wheat",
      "whitesmoke",
      "yellowgreen",
      // CSS Color Module Level 3 (System Colors)
      "activeborder",
      "activecaption",
      "appworkspace",
      "background",
      "buttonface",
      "buttonhighlight",
      "buttonshadow",
      "buttontext",
      "captiontext",
      "graytext",
      "highlight",
      "highlighttext",
      "inactiveborder",
      "inactivecaption",
      "inactivecaptiontext",
      "infobackground",
      "infotext",
      "menu",
      "menutext",
      "scrollbar",
      "threeddarkshadow",
      "threedface",
      "threedhighlight",
      "threedlightshadow",
      "threedshadow",
      "window",
      "windowframe",
      "windowtext",
      // CSS Color Module Level 4
      "rebeccapurple",
      // Keywords
      "currentcolor",
      "transparent"
    ]);
    function isColor(string) {
      if (string.startsWith("#")) {
        return HEX_COLOR_REGEXP.test(string);
      }
      if (string.startsWith("rgb")) {
        return RGB_COLOR_REGEXP.test(string) || RGBA_COLOR_REGEXP.test(string);
      }
      if (string.startsWith("hsl")) {
        return HSL_COLOR_REGEXP.test(string) || HSLA_COLOR_REGEXP.test(string);
      }
      return COLOR_NAMES.has(string.toLowerCase());
    }
    const lineStyleValues = [
      "none",
      "hidden",
      "dotted",
      "dashed",
      "solid",
      "double",
      "groove",
      "ridge",
      "inset",
      "outset"
    ];
    function isLineStyle(string) {
      return lineStyleValues.includes(string);
    }
    const lengthRegExp = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
    function isLength(string) {
      return lengthRegExp.test(string);
    }
    const PERCENTAGE_VALUE_REGEXP = /^[+-]?[0-9]*([.][0-9]+)?%$/;
    function isPercentage(string) {
      return PERCENTAGE_VALUE_REGEXP.test(string);
    }
    const repeatValues = [
      "repeat-x",
      "repeat-y",
      "repeat",
      "space",
      "round",
      "no-repeat"
    ];
    function isRepeat(string) {
      return repeatValues.includes(string);
    }
    const positionValues = [
      "center",
      "top",
      "bottom",
      "left",
      "right"
    ];
    function isPosition(string) {
      return positionValues.includes(string);
    }
    const attachmentValues = [
      "fixed",
      "scroll",
      "local"
    ];
    function isAttachment(string) {
      return attachmentValues.includes(string);
    }
    const urlRegExp = /^url\(/;
    function isURL(string) {
      return urlRegExp.test(string);
    }
    function getBoxSidesValues(value = "") {
      if (value === "") {
        return {
          top: void 0,
          right: void 0,
          bottom: void 0,
          left: void 0
        };
      }
      const values = getShorthandValues(value);
      const top = values[0];
      const bottom = values[2] || top;
      const right = values[1] || top;
      const left = values[3] || right;
      return {
        top,
        bottom,
        right,
        left
      };
    }
    function getBoxSidesValueReducer(styleShorthand) {
      return (value) => {
        const { top, right, bottom, left } = value;
        const reduced = [];
        if (![
          top,
          right,
          left,
          bottom
        ].every((value2) => !!value2)) {
          if (top) {
            reduced.push([
              styleShorthand + "-top",
              top
            ]);
          }
          if (right) {
            reduced.push([
              styleShorthand + "-right",
              right
            ]);
          }
          if (bottom) {
            reduced.push([
              styleShorthand + "-bottom",
              bottom
            ]);
          }
          if (left) {
            reduced.push([
              styleShorthand + "-left",
              left
            ]);
          }
        } else {
          reduced.push([
            styleShorthand,
            getBoxSidesShorthandValue(value)
          ]);
        }
        return reduced;
      };
    }
    function getBoxSidesShorthandValue({ top, right, bottom, left }) {
      const out = [];
      if (left !== right) {
        out.push(top, right, bottom, left);
      } else if (bottom !== top) {
        out.push(top, right, bottom);
      } else if (right !== top) {
        out.push(top, right);
      } else {
        out.push(top);
      }
      return out.join(" ");
    }
    function getPositionShorthandNormalizer(shorthand) {
      return (value) => {
        return {
          path: shorthand,
          value: getBoxSidesValues(value)
        };
      };
    }
    function getShorthandValues(string) {
      const matches = string.matchAll(CSS_SHORTHAND_VALUE_REGEXP);
      return Array.from(matches).map((i) => i[0]);
    }
    function addBackgroundRules(stylesProcessor) {
      stylesProcessor.setNormalizer("background", getBackgroundNormalizer());
      stylesProcessor.setNormalizer("background-color", getBackgroundColorNormalizer());
      stylesProcessor.setReducer("background", getBackgroundReducer());
      stylesProcessor.setStyleRelation("background", [
        "background-color"
      ]);
    }
    function getBackgroundNormalizer() {
      return (value) => {
        const background = {};
        const parts = getShorthandValues(value);
        for (const part of parts) {
          if (isRepeat(part)) {
            background.repeat = background.repeat || [];
            background.repeat.push(part);
          } else if (isPosition(part)) {
            background.position = background.position || [];
            background.position.push(part);
          } else if (isAttachment(part)) {
            background.attachment = part;
          } else if (isColor(part)) {
            background.color = part;
          } else if (isURL(part)) {
            background.image = part;
          }
        }
        return {
          path: "background",
          value: background
        };
      };
    }
    function getBackgroundColorNormalizer() {
      return (value) => ({
        path: "background.color",
        value
      });
    }
    function getBackgroundReducer() {
      return (value) => {
        const ret = [];
        ret.push([
          "background-color",
          value.color
        ]);
        return ret;
      };
    }
    function addBorderRules(stylesProcessor) {
      stylesProcessor.setNormalizer("border", getBorderNormalizer());
      stylesProcessor.setNormalizer("border-top", getBorderPositionNormalizer("top"));
      stylesProcessor.setNormalizer("border-right", getBorderPositionNormalizer("right"));
      stylesProcessor.setNormalizer("border-bottom", getBorderPositionNormalizer("bottom"));
      stylesProcessor.setNormalizer("border-left", getBorderPositionNormalizer("left"));
      stylesProcessor.setNormalizer("border-color", getBorderPropertyNormalizer("color"));
      stylesProcessor.setNormalizer("border-width", getBorderPropertyNormalizer("width"));
      stylesProcessor.setNormalizer("border-style", getBorderPropertyNormalizer("style"));
      stylesProcessor.setNormalizer("border-top-color", getBorderPropertyPositionNormalizer("color", "top"));
      stylesProcessor.setNormalizer("border-top-style", getBorderPropertyPositionNormalizer("style", "top"));
      stylesProcessor.setNormalizer("border-top-width", getBorderPropertyPositionNormalizer("width", "top"));
      stylesProcessor.setNormalizer("border-right-color", getBorderPropertyPositionNormalizer("color", "right"));
      stylesProcessor.setNormalizer("border-right-style", getBorderPropertyPositionNormalizer("style", "right"));
      stylesProcessor.setNormalizer("border-right-width", getBorderPropertyPositionNormalizer("width", "right"));
      stylesProcessor.setNormalizer("border-bottom-color", getBorderPropertyPositionNormalizer("color", "bottom"));
      stylesProcessor.setNormalizer("border-bottom-style", getBorderPropertyPositionNormalizer("style", "bottom"));
      stylesProcessor.setNormalizer("border-bottom-width", getBorderPropertyPositionNormalizer("width", "bottom"));
      stylesProcessor.setNormalizer("border-left-color", getBorderPropertyPositionNormalizer("color", "left"));
      stylesProcessor.setNormalizer("border-left-style", getBorderPropertyPositionNormalizer("style", "left"));
      stylesProcessor.setNormalizer("border-left-width", getBorderPropertyPositionNormalizer("width", "left"));
      stylesProcessor.setExtractor("border-top", getBorderPositionExtractor("top"));
      stylesProcessor.setExtractor("border-right", getBorderPositionExtractor("right"));
      stylesProcessor.setExtractor("border-bottom", getBorderPositionExtractor("bottom"));
      stylesProcessor.setExtractor("border-left", getBorderPositionExtractor("left"));
      stylesProcessor.setExtractor("border-top-color", "border.color.top");
      stylesProcessor.setExtractor("border-right-color", "border.color.right");
      stylesProcessor.setExtractor("border-bottom-color", "border.color.bottom");
      stylesProcessor.setExtractor("border-left-color", "border.color.left");
      stylesProcessor.setExtractor("border-top-width", "border.width.top");
      stylesProcessor.setExtractor("border-right-width", "border.width.right");
      stylesProcessor.setExtractor("border-bottom-width", "border.width.bottom");
      stylesProcessor.setExtractor("border-left-width", "border.width.left");
      stylesProcessor.setExtractor("border-top-style", "border.style.top");
      stylesProcessor.setExtractor("border-right-style", "border.style.right");
      stylesProcessor.setExtractor("border-bottom-style", "border.style.bottom");
      stylesProcessor.setExtractor("border-left-style", "border.style.left");
      stylesProcessor.setReducer("border-color", getBoxSidesValueReducer("border-color"));
      stylesProcessor.setReducer("border-style", getBoxSidesValueReducer("border-style"));
      stylesProcessor.setReducer("border-width", getBoxSidesValueReducer("border-width"));
      stylesProcessor.setReducer("border-top", getBorderPositionReducer("top"));
      stylesProcessor.setReducer("border-right", getBorderPositionReducer("right"));
      stylesProcessor.setReducer("border-bottom", getBorderPositionReducer("bottom"));
      stylesProcessor.setReducer("border-left", getBorderPositionReducer("left"));
      stylesProcessor.setReducer("border", getBorderReducer());
      stylesProcessor.setStyleRelation("border", [
        "border-color",
        "border-style",
        "border-width",
        "border-top",
        "border-right",
        "border-bottom",
        "border-left",
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color",
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style",
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ]);
      stylesProcessor.setStyleRelation("border-color", [
        "border-top-color",
        "border-right-color",
        "border-bottom-color",
        "border-left-color"
      ]);
      stylesProcessor.setStyleRelation("border-style", [
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style"
      ]);
      stylesProcessor.setStyleRelation("border-width", [
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width"
      ]);
      stylesProcessor.setStyleRelation("border-top", [
        "border-top-color",
        "border-top-style",
        "border-top-width"
      ]);
      stylesProcessor.setStyleRelation("border-right", [
        "border-right-color",
        "border-right-style",
        "border-right-width"
      ]);
      stylesProcessor.setStyleRelation("border-bottom", [
        "border-bottom-color",
        "border-bottom-style",
        "border-bottom-width"
      ]);
      stylesProcessor.setStyleRelation("border-left", [
        "border-left-color",
        "border-left-style",
        "border-left-width"
      ]);
    }
    function getBorderNormalizer() {
      return (value) => {
        const { color, style, width } = normalizeBorderShorthand(value);
        return {
          path: "border",
          value: {
            color: getBoxSidesValues(color),
            style: getBoxSidesValues(style),
            width: getBoxSidesValues(width)
          }
        };
      };
    }
    function getBorderPositionNormalizer(side) {
      return (value) => {
        const { color, style, width } = normalizeBorderShorthand(value);
        const border = {};
        if (color !== void 0) {
          border.color = {
            [side]: color
          };
        }
        if (style !== void 0) {
          border.style = {
            [side]: style
          };
        }
        if (width !== void 0) {
          border.width = {
            [side]: width
          };
        }
        return {
          path: "border",
          value: border
        };
      };
    }
    function getBorderPropertyNormalizer(propertyName) {
      return (value) => {
        return {
          path: "border",
          value: toBorderPropertyShorthand(value, propertyName)
        };
      };
    }
    function toBorderPropertyShorthand(value, property2) {
      return {
        [property2]: getBoxSidesValues(value)
      };
    }
    function getBorderPropertyPositionNormalizer(property2, side) {
      return (value) => {
        return {
          path: "border",
          value: {
            [property2]: {
              [side]: value
            }
          }
        };
      };
    }
    function getBorderPositionExtractor(which) {
      return (name, styles) => {
        if (styles.border) {
          return extractBorderPosition(styles.border, which);
        }
      };
    }
    function extractBorderPosition(border, which) {
      const value = {};
      if (border.width && border.width[which]) {
        value.width = border.width[which];
      }
      if (border.style && border.style[which]) {
        value.style = border.style[which];
      }
      if (border.color && border.color[which]) {
        value.color = border.color[which];
      }
      return value;
    }
    function normalizeBorderShorthand(string) {
      const result = {};
      const parts = getShorthandValues(string);
      for (const part of parts) {
        if (isLength(part) || /thin|medium|thick/.test(part)) {
          result.width = part;
        } else if (isLineStyle(part)) {
          result.style = part;
        } else {
          result.color = part;
        }
      }
      return result;
    }
    function getBorderReducer() {
      return (value) => {
        const topStyles = extractBorderPosition(value, "top");
        const rightStyles = extractBorderPosition(value, "right");
        const bottomStyles = extractBorderPosition(value, "bottom");
        const leftStyles = extractBorderPosition(value, "left");
        const borderStyles = [
          topStyles,
          rightStyles,
          bottomStyles,
          leftStyles
        ];
        const borderStylesByType = {
          width: getReducedStyleValueForType(borderStyles, "width"),
          style: getReducedStyleValueForType(borderStyles, "style"),
          color: getReducedStyleValueForType(borderStyles, "color")
        };
        const reducedBorderStyle = reduceBorderPosition(borderStylesByType, "all");
        if (reducedBorderStyle.length) {
          return reducedBorderStyle;
        }
        const reducedStyleTypes = Object.entries(borderStylesByType).reduce((reducedStyleTypes2, [type, value2]) => {
          if (value2) {
            reducedStyleTypes2.push([
              `border-${type}`,
              value2
            ]);
            borderStyles.forEach((style) => delete style[type]);
          }
          return reducedStyleTypes2;
        }, []);
        return [
          ...reducedStyleTypes,
          ...reduceBorderPosition(topStyles, "top"),
          ...reduceBorderPosition(rightStyles, "right"),
          ...reduceBorderPosition(bottomStyles, "bottom"),
          ...reduceBorderPosition(leftStyles, "left")
        ];
      };
      function getReducedStyleValueForType(styles, type) {
        return styles.map((style) => style[type]).reduce((result, style) => result == style ? result : null);
      }
    }
    function getBorderPositionReducer(which) {
      return (value) => reduceBorderPosition(value, which);
    }
    function reduceBorderPosition(value, which) {
      const borderTypes = [];
      if (value && value.width) {
        borderTypes.push("width");
      }
      if (value && value.style) {
        borderTypes.push("style");
      }
      if (value && value.color) {
        borderTypes.push("color");
      }
      if (borderTypes.length == 3) {
        const borderValue = borderTypes.map((item) => value[item]).join(" ");
        return [
          which == "all" ? [
            "border",
            borderValue
          ] : [
            `border-${which}`,
            borderValue
          ]
        ];
      }
      if (which == "all") {
        return [];
      }
      return borderTypes.map((type) => {
        return [
          `border-${which}-${type}`,
          value[type]
        ];
      });
    }
    function addPaddingRules(stylesProcessor) {
      stylesProcessor.setNormalizer("padding", getPositionShorthandNormalizer("padding"));
      stylesProcessor.setNormalizer("padding-top", (value) => ({
        path: "padding.top",
        value
      }));
      stylesProcessor.setNormalizer("padding-right", (value) => ({
        path: "padding.right",
        value
      }));
      stylesProcessor.setNormalizer("padding-bottom", (value) => ({
        path: "padding.bottom",
        value
      }));
      stylesProcessor.setNormalizer("padding-left", (value) => ({
        path: "padding.left",
        value
      }));
      stylesProcessor.setReducer("padding", getBoxSidesValueReducer("padding"));
      stylesProcessor.setStyleRelation("padding", [
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left"
      ]);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Watchdog {
      /**
      * @param {module:watchdog/watchdog~WatchdogConfig} config The watchdog plugin configuration.
      */
      constructor(config) {
        /**
        * An array of crashes saved as an object with the following properties:
        *
        * * `message`: `String`,
        * * `stack`: `String`,
        * * `date`: `Number`,
        * * `filename`: `String | undefined`,
        * * `lineno`: `Number | undefined`,
        * * `colno`: `Number | undefined`,
        */
        __publicField(this, "crashes", []);
        /**
        * Specifies the state of the item watched by the watchdog. The state can be one of the following values:
        *
        * * `initializing` &ndash; Before the first initialization, and after crashes, before the item is ready.
        * * `ready` &ndash; A state when the user can interact with the item.
        * * `crashed` &ndash; A state when an error occurs. It quickly changes to `initializing` or `crashedPermanently`
        * depending on how many and how frequent errors have been caught recently.
        * * `crashedPermanently` &ndash; A state when the watchdog stops reacting to errors and keeps the item it is watching crashed,
        * * `destroyed` &ndash; A state when the item is manually destroyed by the user after calling `watchdog.destroy()`.
        */
        __publicField(this, "state", "initializing");
        /**
        * @see module:watchdog/watchdog~WatchdogConfig
        */
        __publicField(this, "_crashNumberLimit");
        /**
        * Returns the result of the `Date.now()` call. It can be overridden in tests to mock time as some popular
        * approaches like `sinon.useFakeTimers()` do not work well with error handling.
        */
        __publicField(this, "_now", Date.now);
        /**
        * @see module:watchdog/watchdog~WatchdogConfig
        */
        __publicField(this, "_minimumNonErrorTimePeriod");
        /**
        * Checks if the event error comes from the underlying item and restarts the item.
        */
        __publicField(this, "_boundErrorHandler");
        /**
        * A dictionary of event emitter listeners.
        */
        __publicField(this, "_listeners");
        this.crashes = [];
        this._crashNumberLimit = typeof config.crashNumberLimit === "number" ? config.crashNumberLimit : 3;
        this._minimumNonErrorTimePeriod = typeof config.minimumNonErrorTimePeriod === "number" ? config.minimumNonErrorTimePeriod : 5e3;
        this._boundErrorHandler = (evt) => {
          const error = "error" in evt ? evt.error : evt.reason;
          if (error instanceof Error) {
            this._handleError(error, evt);
          }
        };
        this._listeners = {};
        if (!this._restart) {
          throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
      }
      /**
      * Destroys the watchdog and releases the resources.
      */
      destroy() {
        this._stopErrorHandling();
        this._listeners = {};
      }
      /**
      * Starts listening to a specific event name by registering a callback that will be executed
      * whenever an event with a given name fires.
      *
      * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
      *
      * @param eventName The event name.
      * @param callback A callback which will be added to event listeners.
      */
      on(eventName, callback) {
        if (!this._listeners[eventName]) {
          this._listeners[eventName] = [];
        }
        this._listeners[eventName].push(callback);
      }
      /**
      * Stops listening to the specified event name by removing the callback from event listeners.
      *
      * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
      *
      * @param eventName The event name.
      * @param callback A callback which will be removed from event listeners.
      */
      off(eventName, callback) {
        this._listeners[eventName] = this._listeners[eventName].filter((cb) => cb !== callback);
      }
      /**
      * Fires an event with a given event name and arguments.
      *
      * Note that this method differs from the CKEditor 5's default `EventEmitterMixin` implementation.
      */
      _fire(eventName, ...args) {
        const callbacks = this._listeners[eventName] || [];
        for (const callback of callbacks) {
          callback.apply(this, [
            null,
            ...args
          ]);
        }
      }
      /**
      * Starts error handling by attaching global error handlers.
      */
      _startErrorHandling() {
        window.addEventListener("error", this._boundErrorHandler);
        window.addEventListener("unhandledrejection", this._boundErrorHandler);
      }
      /**
      * Stops error handling by detaching global error handlers.
      */
      _stopErrorHandling() {
        window.removeEventListener("error", this._boundErrorHandler);
        window.removeEventListener("unhandledrejection", this._boundErrorHandler);
      }
      /**
      * Checks if an error comes from the watched item and restarts it.
      * It reacts to {@link module:utils/ckeditorerror~CKEditorError `CKEditorError` errors} only.
      *
      * @fires error
      * @param error Error.
      * @param evt An error event.
      */
      _handleError(error, evt) {
        if (this._shouldReactToError(error)) {
          this.crashes.push({
            message: error.message,
            stack: error.stack,
            // `evt.filename`, `evt.lineno` and `evt.colno` are available only in ErrorEvent events
            filename: evt instanceof ErrorEvent ? evt.filename : void 0,
            lineno: evt instanceof ErrorEvent ? evt.lineno : void 0,
            colno: evt instanceof ErrorEvent ? evt.colno : void 0,
            date: this._now()
          });
          const causesRestart = this._shouldRestart();
          this.state = "crashed";
          this._fire("stateChange");
          this._fire("error", {
            error,
            causesRestart
          });
          if (causesRestart) {
            this._restart();
          } else {
            this.state = "crashedPermanently";
            this._fire("stateChange");
          }
        }
      }
      /**
      * Checks whether an error should be handled by the watchdog.
      *
      * @param error An error that was caught by the error handling process.
      */
      _shouldReactToError(error) {
        return error.is && error.is("CKEditorError") && error.context !== void 0 && // In some cases the watched item should not be restarted - e.g. during the item initialization.
        // That's why the `null` was introduced as a correct error context which does cause restarting.
        error.context !== null && // Do not react to errors if the watchdog is in states other than `ready`.
        this.state === "ready" && this._isErrorComingFromThisItem(error);
      }
      /**
      * Checks if the watchdog should restart the underlying item.
      */
      _shouldRestart() {
        if (this.crashes.length <= this._crashNumberLimit) {
          return true;
        }
        const lastErrorTime = this.crashes[this.crashes.length - 1].date;
        const firstMeaningfulErrorTime = this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date;
        const averageNonErrorTimePeriod = (lastErrorTime - firstMeaningfulErrorTime) / this._crashNumberLimit;
        return averageNonErrorTimePeriod > this._minimumNonErrorTimePeriod;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getSubNodes(head, excludedProperties = /* @__PURE__ */ new Set()) {
      const nodes = [
        head
      ];
      const subNodes = /* @__PURE__ */ new Set();
      let nodeIndex = 0;
      while (nodes.length > nodeIndex) {
        const node = nodes[nodeIndex++];
        if (subNodes.has(node) || !shouldNodeBeIncluded(node) || excludedProperties.has(node)) {
          continue;
        }
        subNodes.add(node);
        if (Symbol.iterator in node) {
          try {
            for (const n of node) {
              nodes.push(n);
            }
          } catch (err) {
          }
        } else {
          for (const key in node) {
            if (key === "defaultValue") {
              continue;
            }
            nodes.push(node[key]);
          }
        }
      }
      return subNodes;
    }
    function shouldNodeBeIncluded(node) {
      const type = Object.prototype.toString.call(node);
      const typeOfNode = typeof node;
      return !(typeOfNode === "number" || typeOfNode === "boolean" || typeOfNode === "string" || typeOfNode === "symbol" || typeOfNode === "function" || type === "[object Date]" || type === "[object RegExp]" || type === "[object Module]" || node === void 0 || node === null || // This flag is meant to exclude singletons shared across editor instances. So when an error is thrown in one editor,
      // the other editors connected through the reference to the same singleton are not restarted. This is a temporary workaround
      // until a better solution is found.
      // More in https://github.com/ckeditor/ckeditor5/issues/12292.
      node._watchdogExcluded || // Skip native DOM objects, e.g. Window, nodes, events, etc.
      node instanceof EventTarget || node instanceof Event);
    }
    function areConnectedThroughProperties(target1, target2, excludedNodes = /* @__PURE__ */ new Set()) {
      if (target1 === target2 && isObject(target1)) {
        return true;
      }
      const subNodes1 = getSubNodes(target1, excludedNodes);
      const subNodes2 = getSubNodes(target2, excludedNodes);
      for (const node of subNodes1) {
        if (subNodes2.has(node)) {
          return true;
        }
      }
      return false;
    }
    function isObject(structure) {
      return typeof structure === "object" && structure !== null;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class EditorWatchdog extends Watchdog {
      /**
      * @param Editor The editor class.
      * @param watchdogConfig The watchdog plugin configuration.
      */
      constructor(Editor2, watchdogConfig = {}) {
        super(watchdogConfig);
        /**
        * The current editor instance.
        */
        __publicField(this, "_editor", null);
        /**
        * A promise associated with the life cycle of the editor (creation or destruction processes).
        *
        * It is used to prevent the initialization of the editor if the previous instance has not been destroyed yet,
        * and conversely, to prevent the destruction of the editor if it has not been initialized.
        */
        __publicField(this, "_lifecyclePromise", null);
        /**
        * Throttled save method. The `save()` method is called the specified `saveInterval` after `throttledSave()` is called,
        * unless a new action happens in the meantime.
        */
        __publicField(this, "_throttledSave");
        /**
        * The latest saved editor data represented as a root name -> root data object.
        */
        __publicField(this, "_data");
        /**
        * The last document version.
        */
        __publicField(this, "_lastDocumentVersion");
        /**
        * The editor source element or data.
        */
        __publicField(this, "_elementOrData");
        /**
        * Specifies whether the editor was initialized using document data (`true`) or HTML elements (`false`).
        */
        __publicField(this, "_initUsingData", true);
        /**
        * The latest record of the editor editable elements. Used to restart the editor.
        */
        __publicField(this, "_editables", {});
        /**
        * The editor configuration.
        */
        __publicField(this, "_config");
        __publicField(this, "_excludedProps");
        this._throttledSave = throttle(this._save.bind(this), typeof watchdogConfig.saveInterval === "number" ? watchdogConfig.saveInterval : 5e3);
        if (Editor2) {
          this._creator = (elementOrData, config) => Editor2.create(elementOrData, config);
        }
        this._destructor = (editor) => editor.destroy();
      }
      /**
      * The current editor instance.
      */
      get editor() {
        return this._editor;
      }
      /**
      * @internal
      */
      get _item() {
        return this._editor;
      }
      /**
      * Sets the function that is responsible for the editor creation.
      * It expects a function that should return a promise.
      *
      * ```ts
      * watchdog.setCreator( ( element, config ) => ClassicEditor.create( element, config ) );
      * ```
      */
      setCreator(creator) {
        this._creator = creator;
      }
      /**
      * Sets the function that is responsible for the editor destruction.
      * Overrides the default destruction function, which destroys only the editor instance.
      * It expects a function that should return a promise or `undefined`.
      *
      * ```ts
      * watchdog.setDestructor( editor => {
      * 	// Do something before the editor is destroyed.
      *
      * 	return editor
      * 		.destroy()
      * 		.then( () => {
      * 			// Do something after the editor is destroyed.
      * 		} );
      * } );
      * ```
      */
      setDestructor(destructor) {
        this._destructor = destructor;
      }
      /**
      * Restarts the editor instance. This method is called whenever an editor error occurs. It fires the `restart` event and changes
      * the state to `initializing`.
      *
      * @fires restart
      */
      _restart() {
        return Promise.resolve().then(() => {
          this.state = "initializing";
          this._fire("stateChange");
          return this._destroy();
        }).catch((err) => {
          console.error("An error happened during the editor destroying.", err);
        }).then(() => {
          const existingRoots = {};
          const lazyRoots = [];
          const oldRootsAttributes = this._config.rootsAttributes || {};
          const rootsAttributes = {};
          for (const [rootName, rootData] of Object.entries(this._data.roots)) {
            if (rootData.isLoaded) {
              existingRoots[rootName] = "";
              rootsAttributes[rootName] = oldRootsAttributes[rootName] || {};
            } else {
              lazyRoots.push(rootName);
            }
          }
          const updatedConfig = {
            ...this._config,
            extraPlugins: this._config.extraPlugins || [],
            lazyRoots,
            rootsAttributes,
            _watchdogInitialData: this._data
          };
          delete updatedConfig.initialData;
          updatedConfig.extraPlugins.push(EditorWatchdogInitPlugin);
          if (this._initUsingData) {
            return this.create(existingRoots, updatedConfig, updatedConfig.context);
          } else {
            if (isElement$1(this._elementOrData)) {
              return this.create(this._elementOrData, updatedConfig, updatedConfig.context);
            } else {
              return this.create(this._editables, updatedConfig, updatedConfig.context);
            }
          }
        }).then(() => {
          this._fire("restart");
        });
      }
      /**
      * Creates the editor instance and keeps it running, using the defined creator and destructor.
      *
      * @param elementOrData The editor source element or the editor data.
      * @param config The editor configuration.
      * @param context A context for the editor.
      */
      create(elementOrData = this._elementOrData, config = this._config, context) {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
          super._startErrorHandling();
          this._elementOrData = elementOrData;
          this._initUsingData = typeof elementOrData == "string" || Object.keys(elementOrData).length > 0 && typeof Object.values(elementOrData)[0] == "string";
          this._config = this._cloneEditorConfiguration(config) || {};
          this._config.context = context;
          return this._creator(elementOrData, this._config);
        }).then((editor) => {
          this._editor = editor;
          editor.model.document.on("change:data", this._throttledSave);
          this._lastDocumentVersion = editor.model.document.version;
          this._data = this._getData();
          if (!this._initUsingData) {
            this._editables = this._getEditables();
          }
          this.state = "ready";
          this._fire("stateChange");
        }).finally(() => {
          this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
      }
      /**
      * Destroys the watchdog and the current editor instance. It fires the callback
      * registered in {@link #setDestructor `setDestructor()`} and uses it to destroy the editor instance.
      * It also sets the state to `destroyed`.
      */
      destroy() {
        this._lifecyclePromise = Promise.resolve(this._lifecyclePromise).then(() => {
          this.state = "destroyed";
          this._fire("stateChange");
          super.destroy();
          return this._destroy();
        }).finally(() => {
          this._lifecyclePromise = null;
        });
        return this._lifecyclePromise;
      }
      _destroy() {
        return Promise.resolve().then(() => {
          this._stopErrorHandling();
          this._throttledSave.cancel();
          const editor = this._editor;
          this._editor = null;
          editor.model.document.off("change:data", this._throttledSave);
          return this._destructor(editor);
        });
      }
      /**
      * Saves the editor data, so it can be restored after the crash even if the data cannot be fetched at
      * the moment of the crash.
      */
      _save() {
        const version2 = this._editor.model.document.version;
        try {
          this._data = this._getData();
          if (!this._initUsingData) {
            this._editables = this._getEditables();
          }
          this._lastDocumentVersion = version2;
        } catch (err) {
          console.error(err, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
        }
      }
      /**
      * @internal
      */
      _setExcludedProperties(props) {
        this._excludedProps = props;
      }
      /**
      * Gets all data that is required to reinitialize editor instance.
      */
      _getData() {
        const editor = this._editor;
        const roots = editor.model.document.roots.filter((root2) => root2.isAttached() && root2.rootName != "$graveyard");
        const { plugins } = editor;
        const commentsRepository = plugins.has("CommentsRepository") && plugins.get("CommentsRepository");
        const trackChanges = plugins.has("TrackChanges") && plugins.get("TrackChanges");
        const data = {
          roots: {},
          markers: {},
          commentThreads: JSON.stringify([]),
          suggestions: JSON.stringify([])
        };
        roots.forEach((root2) => {
          data.roots[root2.rootName] = {
            content: JSON.stringify(Array.from(root2.getChildren())),
            attributes: JSON.stringify(Array.from(root2.getAttributes())),
            isLoaded: root2._isLoaded
          };
        });
        for (const marker of editor.model.markers) {
          if (!marker._affectsData) {
            continue;
          }
          data.markers[marker.name] = {
            rangeJSON: marker.getRange().toJSON(),
            usingOperation: marker._managedUsingOperations,
            affectsData: marker._affectsData
          };
        }
        if (commentsRepository) {
          data.commentThreads = JSON.stringify(commentsRepository.getCommentThreads({
            toJSON: true,
            skipNotAttached: true
          }));
        }
        if (trackChanges) {
          data.suggestions = JSON.stringify(trackChanges.getSuggestions({
            toJSON: true,
            skipNotAttached: true
          }));
        }
        return data;
      }
      /**
      * For each attached model root, returns its HTML editable element (if available).
      */
      _getEditables() {
        const editables = {};
        for (const rootName of this.editor.model.document.getRootNames()) {
          const editable = this.editor.ui.getEditableElement(rootName);
          if (editable) {
            editables[rootName] = editable;
          }
        }
        return editables;
      }
      /**
      * Traverses the error context and the current editor to find out whether these structures are connected
      * to each other via properties.
      *
      * @internal
      */
      _isErrorComingFromThisItem(error) {
        return areConnectedThroughProperties(this._editor, error.context, this._excludedProps);
      }
      /**
      * Clones the editor configuration.
      */
      _cloneEditorConfiguration(config) {
        return cloneDeepWith(config, (value, key) => {
          if (isElement$1(value)) {
            return value;
          }
          if (key === "context") {
            return value;
          }
        });
      }
    }
    class EditorWatchdogInitPlugin {
      constructor(editor) {
        __publicField(this, "editor");
        __publicField(this, "_data");
        this.editor = editor;
        this._data = editor.config.get("_watchdogInitialData");
      }
      /**
      * @inheritDoc
      */
      init() {
        this.editor.data.on("init", (evt) => {
          evt.stop();
          this.editor.model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            this._restoreCollaborationData();
            this._restoreEditorData(writer);
          });
          this.editor.data.fire("ready");
        }, {
          priority: 1e3 - 1
        });
      }
      /**
      * Creates a model node (element or text) based on provided JSON.
      */
      _createNode(writer, jsonNode) {
        if ("name" in jsonNode) {
          const element = writer.createElement(jsonNode.name, jsonNode.attributes);
          if (jsonNode.children) {
            for (const child of jsonNode.children) {
              element._appendChild(this._createNode(writer, child));
            }
          }
          return element;
        } else {
          return writer.createText(jsonNode.data, jsonNode.attributes);
        }
      }
      /**
      * Restores the editor by setting the document data, roots attributes and markers.
      */
      _restoreEditorData(writer) {
        const editor = this.editor;
        Object.entries(this._data.roots).forEach(([rootName, { content, attributes }]) => {
          const parsedNodes = JSON.parse(content);
          const parsedAttributes = JSON.parse(attributes);
          const rootElement = editor.model.document.getRoot(rootName);
          for (const [key, value] of parsedAttributes) {
            writer.setAttribute(key, value, rootElement);
          }
          for (const child of parsedNodes) {
            const node = this._createNode(writer, child);
            writer.insert(node, rootElement, "end");
          }
        });
        Object.entries(this._data.markers).forEach(([markerName, markerOptions]) => {
          const { document: document2 } = editor.model;
          const { rangeJSON: { start, end }, ...options } = markerOptions;
          const root2 = document2.getRoot(start.root);
          const startPosition = writer.createPositionFromPath(root2, start.path, start.stickiness);
          const endPosition = writer.createPositionFromPath(root2, end.path, end.stickiness);
          const range = writer.createRange(startPosition, endPosition);
          writer.addMarker(markerName, {
            range,
            ...options
          });
        });
      }
      /**
      * Restores the editor collaboration data - comment threads and suggestions.
      */
      _restoreCollaborationData() {
        const parsedCommentThreads = JSON.parse(this._data.commentThreads);
        const parsedSuggestions = JSON.parse(this._data.suggestions);
        parsedCommentThreads.forEach((commentThreadData) => {
          const channelId = this.editor.config.get("collaboration.channelId");
          const commentsRepository = this.editor.plugins.get("CommentsRepository");
          if (commentsRepository.hasCommentThread(commentThreadData.threadId)) {
            const commentThread = commentsRepository.getCommentThread(commentThreadData.threadId);
            commentThread.remove();
          }
          commentsRepository.addCommentThread({
            channelId,
            ...commentThreadData
          });
        });
        parsedSuggestions.forEach((suggestionData) => {
          const trackChangesEditing = this.editor.plugins.get("TrackChangesEditing");
          if (trackChangesEditing.hasSuggestion(suggestionData.id)) {
            const suggestion = trackChangesEditing.getSuggestion(suggestionData.id);
            suggestion.attributes = suggestionData.attributes;
          } else {
            trackChangesEditing.addSuggestionData(suggestionData);
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const mainQueueId = Symbol("MainQueueId");
    class ContextWatchdog extends Watchdog {
      /**
      * The context watchdog class constructor.
      *
      * ```ts
      * const watchdog = new ContextWatchdog( Context );
      *
      * await watchdog.create( contextConfiguration );
      *
      * await watchdog.add( item );
      * ```
      *
      * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.
      *
      * @param Context The {@link module:core/context~Context} class.
      * @param watchdogConfig The watchdog configuration.
      */
      constructor(Context2, watchdogConfig = {}) {
        super(watchdogConfig);
        /**
        * A map of internal watchdogs for added items.
        */
        __publicField(this, "_watchdogs", /* @__PURE__ */ new Map());
        /**
        * The watchdog configuration.
        */
        __publicField(this, "_watchdogConfig");
        /**
        * The current context instance.
        */
        __publicField(this, "_context", null);
        /**
        * Context properties (nodes/references) that are gathered during the initial context creation
        * and are used to distinguish the origin of an error.
        */
        __publicField(this, "_contextProps", /* @__PURE__ */ new Set());
        /**
        * An action queue, which is used to handle async functions queuing.
        */
        __publicField(this, "_actionQueues", new ActionQueues());
        /**
        * The configuration for the {@link module:core/context~Context}.
        */
        __publicField(this, "_contextConfig");
        /**
        * The watched item.
        */
        __publicField(this, "_item");
        this._watchdogConfig = watchdogConfig;
        this._creator = (contextConfig) => Context2.create(contextConfig);
        this._destructor = (context) => context.destroy();
        this._actionQueues.onEmpty(() => {
          if (this.state === "initializing") {
            this.state = "ready";
            this._fire("stateChange");
          }
        });
      }
      /**
      * Sets the function that is responsible for the context creation.
      * It expects a function that should return a promise (or `undefined`).
      *
      * ```ts
      * watchdog.setCreator( config => Context.create( config ) );
      * ```
      */
      setCreator(creator) {
        this._creator = creator;
      }
      /**
      * Sets the function that is responsible for the context destruction.
      * Overrides the default destruction function, which destroys only the context instance.
      * It expects a function that should return a promise (or `undefined`).
      *
      * ```ts
      * watchdog.setDestructor( context => {
      * 	// Do something before the context is destroyed.
      *
      * 	return context
      * 		.destroy()
      * 		.then( () => {
      * 			// Do something after the context is destroyed.
      * 		} );
      * } );
      * ```
      */
      setDestructor(destructor) {
        this._destructor = destructor;
      }
      /**
      * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,
      * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.
      */
      get context() {
        return this._context;
      }
      /**
      * Initializes the context watchdog. Once it is created, the watchdog takes care about
      * recreating the context and the provided items, and starts the error handling mechanism.
      *
      * ```ts
      * await watchdog.create( {
      * 	plugins: []
      * } );
      * ```
      *
      * @param contextConfig The context configuration. See {@link module:core/context~Context}.
      */
      create(contextConfig = {}) {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this._contextConfig = contextConfig;
          return this._create();
        });
      }
      /**
      * Returns an item instance with the given `itemId`.
      *
      * ```ts
      * const editor1 = watchdog.getItem( 'editor1' );
      * ```
      *
      * @param itemId The item ID.
      * @returns The item instance or `undefined` if an item with a given ID has not been found.
      */
      getItem(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog._item;
      }
      /**
      * Gets the state of the given item. See {@link #state} for a list of available states.
      *
      * ```ts
      * const editor1State = watchdog.getItemState( 'editor1' );
      * ```
      *
      * @param itemId Item ID.
      * @returns The state of the item.
      */
      getItemState(itemId) {
        const watchdog = this._getWatchdog(itemId);
        return watchdog.state;
      }
      /**
      * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.
      *
      * Items can be passed together as an array of objects:
      *
      * ```ts
      * await watchdog.add( [ {
      * 	id: 'editor1',
      * 	type: 'editor',
      * 	sourceElementOrData: document.querySelector( '#editor' ),
      * 	config: {
      * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
      * 		toolbar: [ 'bold', 'italic', 'alignment' ]
      * 	},
      * 	creator: ( element, config ) => ClassicEditor.create( element, config )
      * } ] );
      * ```
      *
      * Or one by one as objects:
      *
      * ```ts
      * await watchdog.add( {
      * 	id: 'editor1',
      * 	type: 'editor',
      * 	sourceElementOrData: document.querySelector( '#editor' ),
      * 	config: {
      * 		plugins: [ Essentials, Paragraph, Bold, Italic ],
      * 		toolbar: [ 'bold', 'italic', 'alignment' ]
      * 	},
      * 	creator: ( element, config ) => ClassicEditor.create( element, config )
      * ] );
      * ```
      *
      * Then an instance can be retrieved using the {@link #getItem} method:
      *
      * ```ts
      * const editor1 = watchdog.getItem( 'editor1' );
      * ```
      *
      * Note that this method can be called multiple times, but for performance reasons it is better
      * to pass all items together.
      *
      * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.
      */
      add(itemConfigurationOrItemConfigurations) {
        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);
        return Promise.all(itemConfigurations.map((item) => {
          return this._actionQueues.enqueue(item.id, () => {
            if (this.state === "destroyed") {
              throw new Error("Cannot add items to destroyed watchdog.");
            }
            if (!this._context) {
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            }
            let watchdog;
            if (this._watchdogs.has(item.id)) {
              throw new Error(`Item with the given id is already added: '${item.id}'.`);
            }
            if (item.type === "editor") {
              watchdog = new EditorWatchdog(null, this._watchdogConfig);
              watchdog.setCreator(item.creator);
              watchdog._setExcludedProperties(this._contextProps);
              if (item.destructor) {
                watchdog.setDestructor(item.destructor);
              }
              this._watchdogs.set(item.id, watchdog);
              watchdog.on("error", (evt, { error, causesRestart }) => {
                this._fire("itemError", {
                  itemId: item.id,
                  error
                });
                if (!causesRestart) {
                  return;
                }
                this._actionQueues.enqueue(item.id, () => new Promise((res) => {
                  const rethrowRestartEventOnce = () => {
                    watchdog.off("restart", rethrowRestartEventOnce);
                    this._fire("itemRestart", {
                      itemId: item.id
                    });
                    res();
                  };
                  watchdog.on("restart", rethrowRestartEventOnce);
                }));
              });
              return watchdog.create(item.sourceElementOrData, item.config, this._context);
            } else {
              throw new Error(`Not supported item type: '${item.type}'.`);
            }
          });
        }));
      }
      /**
      * Removes and destroys item(s) with given ID(s).
      *
      * ```ts
      * await watchdog.remove( 'editor1' );
      * ```
      *
      * Or
      *
      * ```ts
      * await watchdog.remove( [ 'editor1', 'editor2' ] );
      * ```
      *
      * @param itemIdOrItemIds Item ID or an array of item IDs.
      */
      remove(itemIdOrItemIds) {
        const itemIds = toArray(itemIdOrItemIds);
        return Promise.all(itemIds.map((itemId) => {
          return this._actionQueues.enqueue(itemId, () => {
            const watchdog = this._getWatchdog(itemId);
            this._watchdogs.delete(itemId);
            return watchdog.destroy();
          });
        }));
      }
      /**
      * Destroys the context watchdog and all added items.
      * Once the context watchdog is destroyed, new items cannot be added.
      *
      * ```ts
      * await watchdog.destroy();
      * ```
      */
      destroy() {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this.state = "destroyed";
          this._fire("stateChange");
          super.destroy();
          return this._destroy();
        });
      }
      /**
      * Restarts the context watchdog.
      */
      _restart() {
        return this._actionQueues.enqueue(mainQueueId, () => {
          this.state = "initializing";
          this._fire("stateChange");
          return this._destroy().catch((err) => {
            console.error("An error happened during destroying the context or items.", err);
          }).then(() => this._create()).then(() => this._fire("restart"));
        });
      }
      /**
      * Initializes the context watchdog.
      */
      _create() {
        return Promise.resolve().then(() => {
          this._startErrorHandling();
          return this._creator(this._contextConfig);
        }).then((context) => {
          this._context = context;
          this._contextProps = getSubNodes(this._context);
          return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => {
            watchdog._setExcludedProperties(this._contextProps);
            return watchdog.create(void 0, void 0, this._context);
          }));
        });
      }
      /**
      * Destroys the context instance and all added items.
      */
      _destroy() {
        return Promise.resolve().then(() => {
          this._stopErrorHandling();
          const context = this._context;
          this._context = null;
          this._contextProps = /* @__PURE__ */ new Set();
          return Promise.all(Array.from(this._watchdogs.values()).map((watchdog) => watchdog.destroy())).then(() => this._destructor(context));
        });
      }
      /**
      * Returns the watchdog for a given item ID.
      *
      * @param itemId Item ID.
      */
      _getWatchdog(itemId) {
        const watchdog = this._watchdogs.get(itemId);
        if (!watchdog) {
          throw new Error(`Item with the given id was not registered: ${itemId}.`);
        }
        return watchdog;
      }
      /**
      * Checks whether an error comes from the context instance and not from the item instances.
      *
      * @internal
      */
      _isErrorComingFromThisItem(error) {
        for (const watchdog of this._watchdogs.values()) {
          if (watchdog._isErrorComingFromThisItem(error)) {
            return false;
          }
        }
        return areConnectedThroughProperties(this._context, error.context);
      }
    }
    class ActionQueues {
      constructor() {
        __publicField(this, "_onEmptyCallbacks", []);
        __publicField(this, "_queues", /* @__PURE__ */ new Map());
        __publicField(this, "_activeActions", 0);
      }
      /**
      * Used to register callbacks that will be run when the queue becomes empty.
      *
      * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.
      */
      onEmpty(onEmptyCallback) {
        this._onEmptyCallbacks.push(onEmptyCallback);
      }
      /**
      * It adds asynchronous actions (functions) to the proper queue and runs them one by one.
      *
      * @param queueId The action queue ID.
      * @param action A function that should be enqueued.
      */
      enqueue(queueId, action) {
        const isMainAction = queueId === mainQueueId;
        this._activeActions++;
        if (!this._queues.get(queueId)) {
          this._queues.set(queueId, Promise.resolve());
        }
        const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([
          this._queues.get(mainQueueId),
          this._queues.get(queueId)
        ]);
        const queueWithAction = awaitedActions.then(action);
        const nonErrorQueue = queueWithAction.catch(() => {
        });
        this._queues.set(queueId, nonErrorQueue);
        return queueWithAction.finally(() => {
          this._activeActions--;
          if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {
            this._onEmptyCallbacks.forEach((cb) => cb());
          }
        });
      }
    }
    function toArray(elementOrArray) {
      return Array.isArray(elementOrArray) ? elementOrArray : [
        elementOrArray
      ];
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Plugin extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super();
        /**
        * The editor instance.
        *
        * Note that most editors implement the {@link module:core/editor/editor~Editor#ui} property.
        * However, editors with an external UI (i.e. Bootstrap-based) or a headless editor may not have this property or
        * throw an error when accessing it.
        *
        * Because of above, to make plugins more universal, it is recommended to split features into:
        *  - The "editing" part that uses the {@link module:core/editor/editor~Editor} class without `ui` property.
        *  - The "UI" part that uses the {@link module:core/editor/editor~Editor} class and accesses `ui` property.
        */
        __publicField(this, "editor");
        /**
        * Holds identifiers for {@link #forceDisabled} mechanism.
        */
        __publicField(this, "_disableStack", /* @__PURE__ */ new Set());
        this.editor = editor;
        this.set("isEnabled", true);
      }
      /**
      * Disables the plugin.
      *
      * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
      * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
      * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
      *
      * Disabling and enabling a plugin:
      *
      * ```ts
      * plugin.isEnabled; // -> true
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> false
      * plugin.clearForceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> true
      * ```
      *
      * Plugin disabled by multiple features:
      *
      * ```ts
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.forceDisabled( 'OtherFeature' );
      * plugin.clearForceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> false
      * plugin.clearForceDisabled( 'OtherFeature' );
      * plugin.isEnabled; // -> true
      * ```
      *
      * Multiple disabling with the same identifier is redundant:
      *
      * ```ts
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.forceDisabled( 'MyFeature' );
      * plugin.clearForceDisabled( 'MyFeature' );
      * plugin.isEnabled; // -> true
      * ```
      *
      * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
      * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
      *
      * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
      */
      forceDisabled(id) {
        this._disableStack.add(id);
        if (this._disableStack.size == 1) {
          this.on("set:isEnabled", forceDisable$1, {
            priority: "highest"
          });
          this.isEnabled = false;
        }
      }
      /**
      * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
      *
      * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
      */
      clearForceDisabled(id) {
        this._disableStack.delete(id);
        if (this._disableStack.size == 0) {
          this.off("set:isEnabled", forceDisable$1);
          this.isEnabled = true;
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this.stopListening();
      }
      /**
      * @inheritDoc
      */
      static get isContextPlugin() {
        return false;
      }
    }
    function forceDisable$1(evt) {
      evt.return = false;
      evt.stop();
    }
    class Command extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new `Command` instance.
      *
      * @param editor The editor on which this command will be used.
      */
      constructor(editor) {
        super();
        /**
        * The editor on which this command will be used.
        */
        __publicField(this, "editor");
        /**
        * A flag indicating whether a command's `isEnabled` state should be changed depending on where the document
        * selection is placed.
        *
        * By default, it is set to `true`. If the document selection is placed in a
        * {@link module:engine/model/model~Model#canEditAt non-editable} place (such as non-editable root), the command becomes disabled.
        *
        * The flag should be changed to `false` in a concrete command's constructor if the command should not change its `isEnabled`
        * accordingly to the document selection.
        */
        __publicField(this, "_isEnabledBasedOnSelection");
        /**
        * A flag indicating whether a command execution changes the editor data or not.
        *
        * @see #affectsData
        */
        __publicField(this, "_affectsData");
        /**
        * Holds identifiers for {@link #forceDisabled} mechanism.
        */
        __publicField(this, "_disableStack");
        this.editor = editor;
        this.set("value", void 0);
        this.set("isEnabled", false);
        this._affectsData = true;
        this._isEnabledBasedOnSelection = true;
        this._disableStack = /* @__PURE__ */ new Set();
        this.decorate("execute");
        this.listenTo(this.editor.model.document, "change", () => {
          this.refresh();
        });
        this.listenTo(editor, "change:isReadOnly", () => {
          this.refresh();
        });
        this.on("set:isEnabled", (evt) => {
          if (!this.affectsData) {
            return;
          }
          const selection = editor.model.document.selection;
          const selectionInGraveyard = selection.getFirstPosition().root.rootName == "$graveyard";
          const canEditAtSelection = !selectionInGraveyard && editor.model.canEditAt(selection);
          if (editor.isReadOnly || this._isEnabledBasedOnSelection && !canEditAtSelection) {
            evt.return = false;
            evt.stop();
          }
        }, {
          priority: "highest"
        });
        this.on("execute", (evt) => {
          if (!this.isEnabled) {
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
      /**
      * A flag indicating whether a command execution changes the editor data or not.
      *
      * Commands with `affectsData` set to `false` will not be automatically disabled in
      * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
      * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
      *
      * **Note:** You do not have to set it for your every command. It is `true` by default.
      *
      * @default true
      */
      get affectsData() {
        return this._affectsData;
      }
      set affectsData(affectsData) {
        this._affectsData = affectsData;
      }
      /**
      * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
      * in this method.
      *
      * This method is automatically called when
      * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
      */
      refresh() {
        this.isEnabled = true;
      }
      /**
      * Disables the command.
      *
      * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
      * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
      * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
      *
      * Disabling and enabling a command:
      *
      * ```ts
      * command.isEnabled; // -> true
      * command.forceDisabled( 'MyFeature' );
      * command.isEnabled; // -> false
      * command.clearForceDisabled( 'MyFeature' );
      * command.isEnabled; // -> true
      * ```
      *
      * Command disabled by multiple features:
      *
      * ```ts
      * command.forceDisabled( 'MyFeature' );
      * command.forceDisabled( 'OtherFeature' );
      * command.clearForceDisabled( 'MyFeature' );
      * command.isEnabled; // -> false
      * command.clearForceDisabled( 'OtherFeature' );
      * command.isEnabled; // -> true
      * ```
      *
      * Multiple disabling with the same identifier is redundant:
      *
      * ```ts
      * command.forceDisabled( 'MyFeature' );
      * command.forceDisabled( 'MyFeature' );
      * command.clearForceDisabled( 'MyFeature' );
      * command.isEnabled; // -> true
      * ```
      *
      * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
      * so the command might be still disabled after {@link #clearForceDisabled} was used.
      *
      * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
      */
      forceDisabled(id) {
        this._disableStack.add(id);
        if (this._disableStack.size == 1) {
          this.on("set:isEnabled", forceDisable, {
            priority: "highest"
          });
          this.isEnabled = false;
        }
      }
      /**
      * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
      *
      * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
      */
      clearForceDisabled(id) {
        this._disableStack.delete(id);
        if (this._disableStack.size == 0) {
          this.off("set:isEnabled", forceDisable);
          this.refresh();
        }
      }
      /**
      * Executes the command.
      *
      * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
      * to the command.
      *
      * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
      * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
      *
      * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
      *
      * This method may return a value, which would be forwarded all the way down to the
      * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
      *
      * @fires execute
      */
      execute(...args) {
        return void 0;
      }
      /**
      * Destroys the command.
      */
      destroy() {
        this.stopListening();
      }
    }
    function forceDisable(evt) {
      evt.return = false;
      evt.stop();
    }
    class PluginCollection extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the plugin collection class.
      * Allows loading and initializing plugins and their dependencies.
      * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
      *
      * @param availablePlugins Plugins (constructors) which the collection will be able to use
      * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
      * Usually, the editor will pass its built-in plugins to the collection so they can later be
      * used in `config.plugins` or `config.removePlugins` by names.
      * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
      */
      constructor(context, availablePlugins = [], contextPlugins = []) {
        super();
        __publicField(this, "_context");
        __publicField(this, "_plugins", /* @__PURE__ */ new Map());
        /**
        * A map of plugin constructors that can be retrieved by their names.
        */
        __publicField(this, "_availablePlugins");
        /**
        * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.
        */
        __publicField(this, "_contextPlugins");
        this._context = context;
        this._availablePlugins = /* @__PURE__ */ new Map();
        for (const PluginConstructor of availablePlugins) {
          if (PluginConstructor.pluginName) {
            this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
          }
        }
        this._contextPlugins = /* @__PURE__ */ new Map();
        for (const [PluginConstructor, pluginInstance] of contextPlugins) {
          this._contextPlugins.set(PluginConstructor, pluginInstance);
          this._contextPlugins.set(pluginInstance, PluginConstructor);
          if (PluginConstructor.pluginName) {
            this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
          }
        }
      }
      /**
      * Iterable interface.
      *
      * Returns `[ PluginConstructor, pluginInstance ]` pairs.
      */
      *[Symbol.iterator]() {
        for (const entry of this._plugins) {
          if (typeof entry[0] == "function") {
            yield entry;
          }
        }
      }
      /**
      * Gets the plugin instance by its constructor or name.
      *
      * ```ts
      * // Check if 'Clipboard' plugin was loaded.
      * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
      * 	// Get clipboard plugin instance
      * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
      *
      * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
      * 		// Do something on clipboard input.
      * 	} );
      * }
      * ```
      *
      * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
      * to check if a plugin is available.
      *
      * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
      */
      get(key) {
        const plugin = this._plugins.get(key);
        if (!plugin) {
          let pluginName = key;
          if (typeof key == "function") {
            pluginName = key.pluginName || key.name;
          }
          throw new CKEditorError("plugincollection-plugin-not-loaded", this._context, {
            plugin: pluginName
          });
        }
        return plugin;
      }
      /**
      * Checks if a plugin is loaded.
      *
      * ```ts
      * // Check if the 'Clipboard' plugin was loaded.
      * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
      * 	// Now use the clipboard plugin instance:
      * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
      *
      * 	// ...
      * }
      * ```
      *
      * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
      */
      has(key) {
        return this._plugins.has(key);
      }
      /**
      * Initializes a set of plugins and adds them to the collection.
      *
      * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
      * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
      * @param pluginsToRemove Names of the plugins or plugin constructors
      * that should not be loaded (despite being specified in the `plugins` array).
      * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
      * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
      * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
      * must follow these rules:
      *   * The new plugin must be a class.
      *   * The new plugin must be named.
      *   * Both plugins must not depend on other plugins.
      * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
      */
      init(plugins, pluginsToRemove = [], pluginsSubstitutions = []) {
        const that = this;
        const context = this._context;
        findAvailablePluginConstructors(plugins);
        validatePlugins(plugins);
        const pluginsToLoad = plugins.filter((plugin) => !isPluginRemoved(plugin, pluginsToRemove));
        const pluginConstructors = [
          ...getPluginConstructors(pluginsToLoad)
        ];
        substitutePlugins(pluginConstructors, pluginsSubstitutions);
        const pluginInstances = loadPlugins(pluginConstructors);
        return initPlugins(pluginInstances, "init").then(() => initPlugins(pluginInstances, "afterInit")).then(() => pluginInstances);
        function isPluginConstructor(plugin) {
          return typeof plugin === "function";
        }
        function isContextPlugin(plugin) {
          return isPluginConstructor(plugin) && !!plugin.isContextPlugin;
        }
        function isPluginRemoved(plugin, pluginsToRemove2) {
          return pluginsToRemove2.some((removedPlugin) => {
            if (removedPlugin === plugin) {
              return true;
            }
            if (getPluginName(plugin) === removedPlugin) {
              return true;
            }
            if (getPluginName(removedPlugin) === plugin) {
              return true;
            }
            return false;
          });
        }
        function getPluginName(plugin) {
          return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;
        }
        function findAvailablePluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
          plugins2.forEach((plugin) => {
            if (!isPluginConstructor(plugin)) {
              return;
            }
            if (processed.has(plugin)) {
              return;
            }
            processed.add(plugin);
            if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {
              that._availablePlugins.set(plugin.pluginName, plugin);
            }
            if (plugin.requires) {
              findAvailablePluginConstructors(plugin.requires, processed);
            }
          });
        }
        function getPluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
          return plugins2.map((plugin) => {
            return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);
          }).reduce((result, plugin) => {
            if (processed.has(plugin)) {
              return result;
            }
            processed.add(plugin);
            if (plugin.requires) {
              validatePlugins(plugin.requires, plugin);
              getPluginConstructors(plugin.requires, processed).forEach((plugin2) => result.add(plugin2));
            }
            return result.add(plugin);
          }, /* @__PURE__ */ new Set());
        }
        function validatePlugins(plugins2, parentPluginConstructor = null) {
          plugins2.map((plugin) => {
            return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;
          }).forEach((plugin) => {
            checkMissingPlugin(plugin, parentPluginConstructor);
            checkContextPlugin(plugin, parentPluginConstructor);
            checkRemovedPlugin(plugin, parentPluginConstructor);
          });
        }
        function checkMissingPlugin(plugin, parentPluginConstructor) {
          if (isPluginConstructor(plugin)) {
            return;
          }
          if (parentPluginConstructor) {
            throw new CKEditorError("plugincollection-soft-required", context, {
              missingPlugin: plugin,
              requiredBy: getPluginName(parentPluginConstructor)
            });
          }
          throw new CKEditorError("plugincollection-plugin-not-found", context, {
            plugin
          });
        }
        function checkContextPlugin(plugin, parentPluginConstructor) {
          if (!isContextPlugin(parentPluginConstructor)) {
            return;
          }
          if (isContextPlugin(plugin)) {
            return;
          }
          throw new CKEditorError("plugincollection-context-required", context, {
            plugin: getPluginName(plugin),
            requiredBy: getPluginName(parentPluginConstructor)
          });
        }
        function checkRemovedPlugin(plugin, parentPluginConstructor) {
          if (!parentPluginConstructor) {
            return;
          }
          if (!isPluginRemoved(plugin, pluginsToRemove)) {
            return;
          }
          throw new CKEditorError("plugincollection-required", context, {
            plugin: getPluginName(plugin),
            requiredBy: getPluginName(parentPluginConstructor)
          });
        }
        function loadPlugins(pluginConstructors2) {
          return pluginConstructors2.map((PluginConstructor) => {
            let pluginInstance = that._contextPlugins.get(PluginConstructor);
            pluginInstance = pluginInstance || new PluginConstructor(context);
            that._add(PluginConstructor, pluginInstance);
            return pluginInstance;
          });
        }
        function initPlugins(pluginInstances2, method) {
          return pluginInstances2.reduce((promise, plugin) => {
            if (!plugin[method]) {
              return promise;
            }
            if (that._contextPlugins.has(plugin)) {
              return promise;
            }
            return promise.then(plugin[method].bind(plugin));
          }, Promise.resolve());
        }
        function substitutePlugins(pluginConstructors2, pluginsSubstitutions2) {
          for (const pluginItem of pluginsSubstitutions2) {
            if (typeof pluginItem != "function") {
              throw new CKEditorError("plugincollection-replace-plugin-invalid-type", null, {
                pluginItem
              });
            }
            const pluginName = pluginItem.pluginName;
            if (!pluginName) {
              throw new CKEditorError("plugincollection-replace-plugin-missing-name", null, {
                pluginItem
              });
            }
            if (pluginItem.requires && pluginItem.requires.length) {
              throw new CKEditorError("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, {
                pluginName
              });
            }
            const pluginToReplace = that._availablePlugins.get(pluginName);
            if (!pluginToReplace) {
              throw new CKEditorError("plugincollection-plugin-for-replacing-not-exist", null, {
                pluginName
              });
            }
            const indexInPluginConstructors = pluginConstructors2.indexOf(pluginToReplace);
            if (indexInPluginConstructors === -1) {
              if (that._contextPlugins.has(pluginToReplace)) {
                return;
              }
              throw new CKEditorError("plugincollection-plugin-for-replacing-not-loaded", null, {
                pluginName
              });
            }
            if (pluginToReplace.requires && pluginToReplace.requires.length) {
              throw new CKEditorError("plugincollection-replaced-plugin-cannot-have-dependencies", null, {
                pluginName
              });
            }
            pluginConstructors2.splice(indexInPluginConstructors, 1, pluginItem);
            that._availablePlugins.set(pluginName, pluginItem);
          }
        }
      }
      /**
      * Destroys all loaded plugins.
      */
      destroy() {
        const promises = [];
        for (const [, pluginInstance] of this) {
          if (typeof pluginInstance.destroy == "function" && !this._contextPlugins.has(pluginInstance)) {
            promises.push(pluginInstance.destroy());
          }
        }
        return Promise.all(promises);
      }
      /**
      * Adds the plugin to the collection. Exposed mainly for testing purposes.
      *
      * @param PluginConstructor The plugin constructor.
      * @param plugin The instance of the plugin.
      */
      _add(PluginConstructor, plugin) {
        this._plugins.set(PluginConstructor, plugin);
        const pluginName = PluginConstructor.pluginName;
        if (!pluginName) {
          return;
        }
        if (this._plugins.has(pluginName)) {
          throw new CKEditorError("plugincollection-plugin-name-conflict", null, {
            pluginName,
            plugin1: this._plugins.get(pluginName).constructor,
            plugin2: PluginConstructor
          });
        }
        this._plugins.set(pluginName, plugin);
      }
    }
    class Context {
      /**
      * Creates a context instance with a given configuration.
      *
      * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
      *
      * @param config The context configuration.
      */
      constructor(config) {
        /**
        * Stores all the configurations specific to this context instance.
        */
        __publicField(this, "config");
        /**
        * The plugins loaded and in use by this context instance.
        */
        __publicField(this, "plugins");
        __publicField(this, "locale");
        /**
        * Shorthand for {@link module:utils/locale~Locale#t}.
        */
        __publicField(this, "t");
        /**
        * A list of editors that this context instance is injected to.
        */
        __publicField(this, "editors");
        /**
        * Reference to the editor which created the context.
        * Null when the context was created outside of the editor.
        *
        * It is used to destroy the context when removing the editor that has created the context.
        */
        __publicField(this, "_contextOwner", null);
        const { translations, ...rest } = config || {};
        this.config = new Config(rest, this.constructor.defaultConfig);
        const availablePlugins = this.constructor.builtinPlugins;
        this.config.define("plugins", availablePlugins);
        this.plugins = new PluginCollection(this, availablePlugins);
        const languageConfig = this.config.get("language") || {};
        this.locale = new Locale({
          uiLanguage: typeof languageConfig === "string" ? languageConfig : languageConfig.ui,
          contentLanguage: this.config.get("language.content"),
          translations
        });
        this.t = this.locale.t;
        this.editors = new Collection();
      }
      /**
      * Loads and initializes plugins specified in the configuration.
      *
      * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
      */
      initPlugins() {
        const plugins = this.config.get("plugins") || [];
        const substitutePlugins = this.config.get("substitutePlugins") || [];
        for (const Plugin2 of plugins.concat(substitutePlugins)) {
          if (typeof Plugin2 != "function") {
            throw new CKEditorError("context-initplugins-constructor-only", null, {
              Plugin: Plugin2
            });
          }
          if (Plugin2.isContextPlugin !== true) {
            throw new CKEditorError("context-initplugins-invalid-plugin", null, {
              Plugin: Plugin2
            });
          }
        }
        return this.plugins.init(plugins, [], substitutePlugins);
      }
      /**
      * Destroys the context instance and all editors used with the context,
      * releasing all resources used by the context.
      *
      * @returns A promise that resolves once the context instance is fully destroyed.
      */
      destroy() {
        return Promise.all(Array.from(this.editors, (editor) => editor.destroy())).then(() => this.plugins.destroy());
      }
      /**
      * Adds a reference to the editor which is used with this context.
      *
      * When the given editor has created the context, the reference to this editor will be stored
      * as a {@link ~Context#_contextOwner}.
      *
      * This method should only be used by the editor.
      *
      * @internal
      * @param isContextOwner Stores the given editor as a context owner.
      */
      _addEditor(editor, isContextOwner) {
        if (this._contextOwner) {
          throw new CKEditorError("context-addeditor-private-context");
        }
        this.editors.add(editor);
        if (isContextOwner) {
          this._contextOwner = editor;
        }
      }
      /**
      * Removes a reference to the editor which was used with this context.
      * When the context was created by the given editor, the context will be destroyed.
      *
      * This method should only be used by the editor.
      *
      * @internal
      * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
      */
      _removeEditor(editor) {
        if (this.editors.has(editor)) {
          this.editors.remove(editor);
        }
        if (this._contextOwner === editor) {
          return this.destroy();
        }
        return Promise.resolve();
      }
      /**
      * Returns the context configuration which will be copied to the editors created using this context.
      *
      * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
      * through another mechanism.
      *
      * This method should only be used by the editor.
      *
      * @internal
      * @returns Configuration as a plain object.
      */
      _getEditorConfig() {
        const result = {};
        for (const name of this.config.names()) {
          if (![
            "plugins",
            "removePlugins",
            "extraPlugins"
          ].includes(name)) {
            result[name] = this.config.get(name);
          }
        }
        return result;
      }
      /**
      * Creates and initializes a new context instance.
      *
      * ```ts
      * const commonConfig = { ... }; // Configuration for all the plugins and editors.
      * const editorPlugins = [ ... ]; // Regular plugins here.
      *
      * Context
      * 	.create( {
      * 		// Only context plugins here.
      * 		plugins: [ ... ],
      *
      * 		// Configure the language for all the editors (it cannot be overwritten).
      * 		language: { ... },
      *
      * 		// Configuration for context plugins.
      * 		comments: { ... },
      * 		...
      *
      * 		// Default configuration for editor plugins.
      * 		toolbar: { ... },
      * 		image: { ... },
      * 		...
      * 	} )
      * 	.then( context => {
      * 		const promises = [];
      *
      * 		promises.push( ClassicEditor.create(
      * 			document.getElementById( 'editor1' ),
      * 			{
      * 				editorPlugins,
      * 				context
      * 			}
      * 		) );
      *
      * 		promises.push( ClassicEditor.create(
      * 			document.getElementById( 'editor2' ),
      * 			{
      * 				editorPlugins,
      * 				context,
      * 				toolbar: { ... } // You can overwrite the configuration of the context.
      * 			}
      * 		) );
      *
      * 		return Promise.all( promises );
      * 	} );
      * ```
      *
      * @param config The context configuration.
      * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
      */
      static create(config) {
        return new Promise((resolve) => {
          const context = new this(config);
          resolve(context.initPlugins().then(() => context));
        });
      }
    }
    /**
    * The default configuration which is built into the `Context` class.
    *
    * It is used in CKEditor 5 builds featuring `Context` to provide the default configuration options which are later used during the
    * context initialization.
    *
    * ```ts
    * Context.defaultConfig = {
    * 	foo: 1,
    * 	bar: 2
    * };
    *
    * Context
    * 	.create()
    * 	.then( context => {
    * 		context.config.get( 'foo' ); // -> 1
    * 		context.config.get( 'bar' ); // -> 2
    * 	} );
    *
    * // The default options can be overridden by the configuration passed to create().
    * Context
    * 	.create( { bar: 3 } )
    * 	.then( context => {
    * 		context.config.get( 'foo' ); // -> 1
    * 		context.config.get( 'bar' ); // -> 3
    * 	} );
    * ```
    *
    * See also {@link module:core/context~Context.builtinPlugins `Context.builtinPlugins`}
    * and {@link module:core/editor/editor~Editor.defaultConfig `Editor.defaultConfig`}.
    */
    __publicField(Context, "defaultConfig");
    /**
    * An array of plugins built into the `Context` class.
    *
    * It is used in CKEditor 5 builds featuring `Context` to provide a list of context plugins which are later automatically initialized
    * during the context initialization.
    *
    * They will be automatically initialized by `Context` unless `config.plugins` is passed.
    *
    * ```ts
    * // Build some context plugins into the Context class first.
    * Context.builtinPlugins = [ FooPlugin, BarPlugin ];
    *
    * // Normally, you need to define config.plugins, but since Context.builtinPlugins was
    * // defined, now you can call create() without any configuration.
    * Context
    * 	.create()
    * 	.then( context => {
    * 		context.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
    * 		context.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
    * 	} );
    * ```
    *
    * See also {@link module:core/context~Context.defaultConfig `Context.defaultConfig`}
    * and {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.
    */
    __publicField(Context, "builtinPlugins");
    class ContextPlugin extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new plugin instance.
      */
      constructor(context) {
        super();
        /**
        * The context or editor instance.
        */
        __publicField(this, "context");
        this.context = context;
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this.stopListening();
      }
      /**
      * @inheritDoc
      */
      static get isContextPlugin() {
        return true;
      }
    }
    class CommandCollection {
      /**
      * Creates collection instance.
      */
      constructor() {
        /**
        * Command map.
        */
        __publicField(this, "_commands");
        this._commands = /* @__PURE__ */ new Map();
      }
      /**
      * Registers a new command.
      *
      * @param commandName The name of the command.
      */
      add(commandName, command) {
        this._commands.set(commandName, command);
      }
      /**
      * Retrieves a command from the collection.
      *
      * @param commandName The name of the command.
      */
      get(commandName) {
        return this._commands.get(commandName);
      }
      /**
      * Executes a command.
      *
      * @param commandName The name of the command.
      * @param commandParams Command parameters.
      * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
      */
      execute(commandName, ...commandParams) {
        const command = this.get(commandName);
        if (!command) {
          throw new CKEditorError("commandcollection-command-not-found", this, {
            commandName
          });
        }
        return command.execute(...commandParams);
      }
      /**
      * Returns iterator of command names.
      */
      *names() {
        yield* this._commands.keys();
      }
      /**
      * Returns iterator of command instances.
      */
      *commands() {
        yield* this._commands.values();
      }
      /**
      * Iterable interface.
      *
      * Returns `[ commandName, commandInstance ]` pairs.
      */
      [Symbol.iterator]() {
        return this._commands[Symbol.iterator]();
      }
      /**
      * Destroys all collection commands.
      */
      destroy() {
        for (const command of this.commands()) {
          command.destroy();
        }
      }
    }
    class EditingKeystrokeHandler extends KeystrokeHandler {
      /**
      * Creates an instance of the keystroke handler.
      */
      constructor(editor) {
        super();
        /**
        * The editor instance.
        */
        __publicField(this, "editor");
        this.editor = editor;
      }
      /**
      * Registers a handler for the specified keystroke.
      *
      * The handler can be specified as a command name or a callback.
      *
      * @param keystroke Keystroke defined in a format accepted by
      * the {@link module:utils/keyboard~parseKeystroke} function.
      * @param callback If a string is passed, then the keystroke will
      * {@link module:core/editor/editor~Editor#execute execute a command}.
      * If a function, then it will be called with the
      * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
      * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
      * @param options Additional options.
      * @param options.priority The priority of the keystroke callback. The higher the priority value
      * the sooner the callback will be executed. Keystrokes having the same priority
      * are called in the order they were added.
      */
      set(keystroke, callback, options = {}) {
        if (typeof callback == "string") {
          const commandName = callback;
          callback = (evtData, cancel2) => {
            this.editor.execute(commandName);
            cancel2();
          };
        }
        super.set(keystroke, callback, options);
      }
    }
    const DEFAULT_CATEGORY_ID = "contentEditing";
    const DEFAULT_GROUP_ID = "common";
    class Accessibility {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        /**
        * Stores information about keystrokes brought by editor features for the users to interact with the editor, mainly
        * keystroke combinations and their accessible labels.
        *
        * This information is particularly useful for screen reader and other assistive technology users. It gets displayed
        * by the {@link module:ui/editorui/accessibilityhelp/accessibilityhelp~AccessibilityHelp Accessibility help} dialog.
        *
        * Keystrokes are organized in categories and groups. They can be added using ({@link #addKeystrokeInfoCategory},
        * {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}) methods.
        *
        * Please note that:
        * * two categories are always available:
        *   * `'contentEditing'` for keystrokes related to content creation,
        *   * `'navigation'` for keystrokes related to navigation in the UI and the content.
        * * unless specified otherwise, new keystrokes are added into the `'contentEditing'` category and the `'common'`
        * keystroke group within that category while using the {@link #addKeystrokeInfos} method.
        */
        __publicField(this, "keystrokeInfos", /* @__PURE__ */ new Map());
        /**
        * The editor instance.
        */
        __publicField(this, "_editor");
        this._editor = editor;
        const isMenuBarVisible = editor.config.get("menuBar.isVisible");
        const t = editor.locale.t;
        this.addKeystrokeInfoCategory({
          id: DEFAULT_CATEGORY_ID,
          label: t("Content editing keystrokes"),
          description: t("These keyboard shortcuts allow for quick access to content editing features.")
        });
        const navigationKeystrokes = [
          {
            label: t("Close contextual balloons, dropdowns, and dialogs"),
            keystroke: "Esc"
          },
          {
            label: t("Open the accessibility help dialog"),
            keystroke: "Alt+0"
          },
          {
            label: t("Move focus between form fields (inputs, buttons, etc.)"),
            keystroke: [
              [
                "Tab"
              ],
              [
                "Shift+Tab"
              ]
            ]
          },
          {
            label: t("Move focus to the toolbar, navigate between toolbars"),
            keystroke: "Alt+F10",
            mayRequireFn: true
          },
          {
            label: t("Navigate through the toolbar or menu bar"),
            keystroke: [
              [
                "arrowup"
              ],
              [
                "arrowright"
              ],
              [
                "arrowdown"
              ],
              [
                "arrowleft"
              ]
            ]
          },
          {
            // eslint-disable-next-line max-len
            label: t("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
            keystroke: [
              [
                "Enter"
              ],
              [
                "Space"
              ]
            ]
          }
        ];
        if (isMenuBarVisible) {
          navigationKeystrokes.push({
            label: t("Move focus to the menu bar, navigate between menu bars"),
            keystroke: "Alt+F9",
            mayRequireFn: true
          });
        }
        this.addKeystrokeInfoCategory({
          id: "navigation",
          label: t("User interface and content navigation keystrokes"),
          description: t("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
          groups: [
            {
              id: "common",
              keystrokes: navigationKeystrokes
            }
          ]
        });
      }
      /**
      * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
      *
      * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
      * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
      * with a `'common'` group by default.
      *
      * By default, two categories are available:
      * * `'contentEditing'` for keystrokes related to content creation,
      * * `'navigation'` for keystrokes related to navigation in the UI and the content.
      *
      * To create a new keystroke category with new groups, use the following code:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfoCategory( {
      * 			id: 'myCategory',
      * 			label: t( 'My category' ),
      * 			description: t( 'My category description.' ),
      * 			groups: [
      * 				{
      * 					id: 'myGroup',
      * 					label: t( 'My keystroke group' ),
      * 					keystrokes: [
      * 						{
      * 							label: t( 'Keystroke label 1' ),
      * 							keystroke: 'Ctrl+Shift+N'
      * 						},
      * 						{
      * 							label: t( 'Keystroke label 2' ),
      * 							keystroke: 'Ctrl+Shift+M'
      * 						}
      * 					]
      * 				}
      * 			]
      * 		};
      * 	}
      * }
      * ```
      *
      * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
      */
      addKeystrokeInfoCategory({ id, label, description, groups }) {
        this.keystrokeInfos.set(id, {
          id,
          label,
          description,
          groups: /* @__PURE__ */ new Map()
        });
        this.addKeystrokeInfoGroup({
          categoryId: id,
          id: DEFAULT_GROUP_ID
        });
        if (groups) {
          groups.forEach((group) => {
            this.addKeystrokeInfoGroup({
              categoryId: id,
              ...group
            });
          });
        }
      }
      /**
      * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
      *
      * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
      * the group goes to the `'contentEditing'` category (default).
      *
      * To create a new group within an existing category, use the following code:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfoGroup( {
      * 			id: 'myGroup',
      * 			categoryId: 'navigation',
      * 			label: t( 'My keystroke group' ),
      * 			keystrokes: [
      * 				{
      * 					label: t( 'Keystroke label 1' ),
      * 					keystroke: 'Ctrl+Shift+N'
      * 				},
      * 				{
      * 					label: t( 'Keystroke label 2' ),
      * 					keystroke: 'Ctrl+Shift+M'
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      *
      * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
      */
      addKeystrokeInfoGroup({ categoryId = DEFAULT_CATEGORY_ID, id, label, keystrokes }) {
        const category = this.keystrokeInfos.get(categoryId);
        if (!category) {
          throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, {
            groupId: id,
            categoryId
          });
        }
        category.groups.set(id, {
          id,
          label,
          keystrokes: keystrokes || []
        });
      }
      /**
      * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
      *
      * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
      *
      * To add a keystroke brought by your plugin (using default group and category), use the following code:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfos( {
      * 			keystrokes: [
      * 				{
      * 					label: t( 'Keystroke label' ),
      * 					keystroke: 'CTRL+B'
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfos( {
      * 			// Add a keystroke to the existing "widget" group.
      * 			groupId: 'widget',
      * 			keystrokes: [
      * 				{
      * 					label: t( 'A an action on a selected widget' ),
      * 					keystroke: 'Ctrl+D',
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      *
      * To add a keystroke to another existing category (using default group):
      *
      * ```js
      * class MyPlugin extends Plugin {
      * 	// ...
      * 	init() {
      * 		const editor = this.editor;
      * 		const t = editor.t;
      *
      * 		// ...
      *
      * 		editor.accessibility.addKeystrokeInfos( {
      * 			// Add keystrokes to the "navigation" category (one of defaults).
      * 			categoryId: 'navigation',
      * 			keystrokes: [
      * 				{
      * 					label: t( 'Keystroke label' ),
      * 					keystroke: 'CTRL+B'
      * 				}
      * 			]
      * 		} );
      * 	}
      * }
      * ```
      *
      * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
      */
      addKeystrokeInfos({ categoryId = DEFAULT_CATEGORY_ID, groupId = DEFAULT_GROUP_ID, keystrokes }) {
        if (!this.keystrokeInfos.has(categoryId)) {
          throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, {
            categoryId,
            keystrokes
          });
        }
        const category = this.keystrokeInfos.get(categoryId);
        if (!category.groups.has(groupId)) {
          throw new CKEditorError("accessibility-unknown-keystroke-info-group", this._editor, {
            groupId,
            categoryId,
            keystrokes
          });
        }
        category.groups.get(groupId).keystrokes.push(...keystrokes);
      }
    }
    class Editor extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new instance of the editor class.
      *
      * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
      *
      * @param config The editor configuration.
      */
      constructor(config = {}) {
        super();
        /**
        * A namespace for the accessibility features of the editor.
        */
        __publicField(this, "accessibility");
        /**
        * Commands registered to the editor.
        *
        * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:
        *
        * ```ts
        * // Execute the bold command:
        * editor.execute( 'bold' );
        *
        * // Check the state of the bold command:
        * editor.commands.get( 'bold' ).value;
        * ```
        */
        __publicField(this, "commands");
        /**
        * Stores all configurations specific to this editor instance.
        *
        * ```ts
        * editor.config.get( 'image.toolbar' );
        * // -> [ 'imageStyle:block', 'imageStyle:side', '|', 'toggleImageCaption', 'imageTextAlternative' ]
        * ```
        */
        __publicField(this, "config");
        /**
        * Conversion manager through which you can register model-to-view and view-to-model converters.
        *
        * See the {@link module:engine/conversion/conversion~Conversion} documentation to learn how to add converters.
        */
        __publicField(this, "conversion");
        /**
        * The {@link module:engine/controller/datacontroller~DataController data controller}.
        * Used e.g. for setting and retrieving the editor data.
        */
        __publicField(this, "data");
        /**
        * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.
        * Controls user input and rendering the content for editing.
        */
        __publicField(this, "editing");
        /**
        * The locale instance.
        */
        __publicField(this, "locale");
        /**
        * The editor's model.
        *
        * The central point of the editor's abstract data model.
        */
        __publicField(this, "model");
        /**
        * The plugins loaded and in use by this editor instance.
        *
        * ```ts
        * editor.plugins.get( 'ClipboardPipeline' ); // -> An instance of the clipboard pipeline plugin.
        * ```
        */
        __publicField(this, "plugins");
        /**
        * An instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.
        *
        * It allows setting simple keystrokes:
        *
        * ```ts
        * // Execute the bold command on Ctrl+E:
        * editor.keystrokes.set( 'Ctrl+E', 'bold' );
        *
        * // Execute your own callback:
        * editor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {
        * 	console.log( data.keyCode );
        *
        * 	// Prevent the default (native) action and stop the underlying keydown event
        * 	// so no other editor feature will interfere.
        * 	cancel();
        * } );
        * ```
        *
        * Note: Certain typing-oriented keystrokes (like <kbd>Backspace</kbd> or <kbd>Enter</kbd>) are handled
        * by a low-level mechanism and trying to listen to them via the keystroke handler will not work reliably.
        * To handle these specific keystrokes, see the events fired by the
        * {@link module:engine/view/document~Document editing view document} (`editor.editing.view.document`).
        */
        __publicField(this, "keystrokes");
        /**
        * Shorthand for {@link module:utils/locale~Locale#t}.
        *
        * @see module:utils/locale~Locale#t
        */
        __publicField(this, "t");
        /**
        * The editor context.
        * When it is not provided through the configuration, the editor creates it.
        */
        __publicField(this, "_context");
        /**
        * A set of lock IDs for the {@link #isReadOnly} getter.
        */
        __publicField(this, "_readOnlyLocks");
        const constructor = this.constructor;
        const { translations: defaultTranslations, ...defaultConfig2 } = constructor.defaultConfig || {};
        const { translations = defaultTranslations, ...rest } = config;
        const language = config.language || defaultConfig2.language;
        this._context = config.context || new Context({
          language,
          translations
        });
        this._context._addEditor(this, !config.context);
        const availablePlugins = Array.from(constructor.builtinPlugins || []);
        this.config = new Config(rest, defaultConfig2);
        this.config.define("plugins", availablePlugins);
        this.config.define(this._context._getEditorConfig());
        this.plugins = new PluginCollection(this, availablePlugins, this._context.plugins);
        this.locale = this._context.locale;
        this.t = this.locale.t;
        this._readOnlyLocks = /* @__PURE__ */ new Set();
        this.commands = new CommandCollection();
        this.set("state", "initializing");
        this.once("ready", () => this.state = "ready", {
          priority: "high"
        });
        this.once("destroy", () => this.state = "destroyed", {
          priority: "high"
        });
        this.model = new Model$1();
        this.on("change:isReadOnly", () => {
          this.model.document.isReadOnly = this.isReadOnly;
        });
        const stylesProcessor = new StylesProcessor();
        this.data = new DataController(this.model, stylesProcessor);
        this.editing = new EditingController(this.model, stylesProcessor);
        this.editing.view.document.bind("isReadOnly").to(this);
        this.conversion = new Conversion([
          this.editing.downcastDispatcher,
          this.data.downcastDispatcher
        ], this.data.upcastDispatcher);
        this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
        this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
        this.keystrokes = new EditingKeystrokeHandler(this);
        this.keystrokes.listenTo(this.editing.view.document);
        this.accessibility = new Accessibility(this);
      }
      /**
      * Defines whether the editor is in the read-only mode.
      *
      * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
      * to modify the document by using them. Also, the editable element(s) become non-editable.
      *
      * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
      *
      * ```ts
      * editor.enableReadOnlyMode( 'feature-id' );
      * ```
      *
         * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
      *
      * ```ts
      * editor.disableReadOnlyMode( 'feature-id' );
      * ```
      *
      * @readonly
      * @observable
      */
      get isReadOnly() {
        return this._readOnlyLocks.size > 0;
      }
      set isReadOnly(value) {
        throw new CKEditorError("editor-isreadonly-has-no-setter");
      }
      /**
      * Turns on the read-only mode in the editor.
      *
      * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
      * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
      * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
      * could lead to errors).
      *
      * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
      * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
      *
      * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
      *
      * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
      *
      * ```ts
      * editor.isReadOnly; // `false`.
      * editor.enableReadOnlyMode( 'my-feature-id' );
      * editor.isReadOnly; // `true`.
      * ```
      *
      * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
      *
      * ```ts
      * editor.enableReadOnlyMode( 'my-feature-id' );
      * // ...
      * editor.disableReadOnlyMode( 'my-feature-id' );
      * editor.isReadOnly; // `false`.
      * ```
      *
      * All "locks" need to be removed to enable editing:
      *
      * ```ts
      * editor.enableReadOnlyMode( 'my-feature-id' );
      * editor.enableReadOnlyMode( 'my-other-feature-id' );
      * // ...
      * editor.disableReadOnlyMode( 'my-feature-id' );
      * editor.isReadOnly; // `true`.
      * editor.disableReadOnlyMode( 'my-other-feature-id' );
      * editor.isReadOnly; // `false`.
      * ```
      *
      * @param lockId A unique ID for setting the editor to the read-only state.
      */
      enableReadOnlyMode(lockId) {
        if (typeof lockId !== "string" && typeof lockId !== "symbol") {
          throw new CKEditorError("editor-read-only-lock-id-invalid", null, {
            lockId
          });
        }
        if (this._readOnlyLocks.has(lockId)) {
          return;
        }
        this._readOnlyLocks.add(lockId);
        if (this._readOnlyLocks.size === 1) {
          this.fire("change:isReadOnly", "isReadOnly", true, false);
        }
      }
      /**
      * Removes the read-only lock from the editor with given lock ID.
      *
      * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
      *
      * @param lockId The lock ID for setting the editor to the read-only state.
      */
      disableReadOnlyMode(lockId) {
        if (typeof lockId !== "string" && typeof lockId !== "symbol") {
          throw new CKEditorError("editor-read-only-lock-id-invalid", null, {
            lockId
          });
        }
        if (!this._readOnlyLocks.has(lockId)) {
          return;
        }
        this._readOnlyLocks.delete(lockId);
        if (this._readOnlyLocks.size === 0) {
          this.fire("change:isReadOnly", "isReadOnly", false, true);
        }
      }
      /**
      * Sets the data in the editor.
      *
      * ```ts
      * editor.setData( '<p>This is editor!</p>' );
      * ```
      *
      * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
      * to the editor root names and values equal to the data that should be set in each root:
      *
      * ```ts
      * editor.setData( {
      *     header: '<p>Content for header part.</p>',
      *     content: '<p>Content for main part.</p>',
      *     footer: '<p>Content for footer part.</p>'
      * } );
      * ```
      *
      * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
      * See the {@glink features/markdown Markdown output} guide for more details.
      *
      * @param data Input data.
      */
      setData(data) {
        this.data.set(data);
      }
      /**
      * Gets the data from the editor.
      *
      * ```ts
      * editor.getData(); // -> '<p>This is editor!</p>'
      * ```
      *
      * If your editor implementation uses multiple roots, you should pass root name as one of the options:
      *
      * ```ts
      * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
      * ```
      *
      * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
      * See the {@glink features/markdown Markdown output} guide for more details.
      *
      * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
      * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
      *
      * @param options Additional configuration for the retrieved data.
      * Editor features may introduce more configuration options that can be set through this parameter.
      * @param options.rootName Root name. Defaults to `'main'`.
      * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
      * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
      * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
      * @returns Output data.
      */
      getData(options) {
        return this.data.get(options);
      }
      /**
      * Loads and initializes plugins specified in the configuration.
      *
      * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
      */
      initPlugins() {
        const config = this.config;
        const plugins = config.get("plugins");
        const removePlugins = config.get("removePlugins") || [];
        const extraPlugins = config.get("extraPlugins") || [];
        const substitutePlugins = config.get("substitutePlugins") || [];
        return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins);
      }
      /**
      * Destroys the editor instance, releasing all resources used by it.
      *
      * **Note** The editor cannot be destroyed during the initialization phase so if it is called
      * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
      *
      * @fires destroy
      * @returns A promise that resolves once the editor instance is fully destroyed.
      */
      destroy() {
        let readyPromise = Promise.resolve();
        if (this.state == "initializing") {
          readyPromise = new Promise((resolve) => this.once("ready", resolve));
        }
        return readyPromise.then(() => {
          this.fire("destroy");
          this.stopListening();
          this.commands.destroy();
        }).then(() => this.plugins.destroy()).then(() => {
          this.model.destroy();
          this.data.destroy();
          this.editing.destroy();
          this.keystrokes.destroy();
        }).then(() => this._context._removeEditor(this));
      }
      /**
      * Executes the specified command with given parameters.
      *
      * Shorthand for:
      *
      * ```ts
      * editor.commands.get( commandName ).execute( ... );
      * ```
      *
      * @param commandName The name of the command to execute.
      * @param commandParams Command parameters.
      * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
      */
      execute(commandName, ...commandParams) {
        try {
          return this.commands.execute(commandName, ...commandParams);
        } catch (err) {
          /* istanbul ignore next -- @preserve */
          CKEditorError.rethrowUnexpectedError(err, this);
        }
      }
      /**
      * Focuses the editor.
      *
      * **Note** To explicitly focus the editing area of the editor, use the
      * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
      *
      * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
      * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
      */
      focus() {
        this.editing.view.focus();
      }
      /* istanbul ignore next -- @preserve */
      /**
      * Creates and initializes a new editor instance.
      *
      * This is an abstract method. Every editor type needs to implement its own initialization logic.
      *
      * See the `create()` methods of the existing editor types to learn how to use them:
      *
      * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
      * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
      * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
      * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
      */
      static create(...args) {
        throw new Error("This is an abstract method.");
      }
    }
    /**
    * The default configuration which is built into the editor class.
    *
    * It is used in CKEditor 5 builds to provide the default configuration options which are later used during the editor initialization.
    *
    * ```ts
    * ClassicEditor.defaultConfig = {
    * 	foo: 1,
    * 	bar: 2
    * };
    *
    * ClassicEditor
    * 	.create( sourceElement )
    * 	.then( editor => {
    * 		editor.config.get( 'foo' ); // -> 1
    * 		editor.config.get( 'bar' ); // -> 2
    * 	} );
    *
    * // The default options can be overridden by the configuration passed to create().
    * ClassicEditor
    * 	.create( sourceElement, { bar: 3 } )
    * 	.then( editor => {
    * 		editor.config.get( 'foo' ); // -> 1
    * 		editor.config.get( 'bar' ); // -> 3
    * 	} );
    * ```
    *
    * See also {@link module:core/editor/editor~Editor.builtinPlugins}.
    */
    __publicField(Editor, "defaultConfig");
    /**
    * An array of plugins built into this editor class.
    *
    * It is used in CKEditor 5 builds to provide a list of plugins which are later automatically initialized
    * during the editor initialization.
    *
    * They will be automatically initialized by the editor, unless listed in `config.removePlugins` and
    * unless `config.plugins` is passed.
    *
    * ```ts
    * // Build some plugins into the editor class first.
    * ClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];
    *
    * // Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was
    * // defined, now you can call create() without any configuration.
    * ClassicEditor
    * 	.create( sourceElement )
    * 	.then( editor => {
    * 		editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
    * 		editor.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
    * 	} );
    *
    * ClassicEditor
    * 	.create( sourceElement, {
    * 		// Do not initialize these plugins (note: it is defined by a string):
    * 		removePlugins: [ 'Foo' ]
    * 	} )
    * 	.then( editor => {
    * 		editor.plugins.get( FooPlugin ); // -> Undefined.
    * 		editor.config.get( BarPlugin ); // -> An instance of the Bar plugin.
    * 	} );
    *
    * ClassicEditor
    * 	.create( sourceElement, {
    * 		// Load only this plugin. It can also be defined by a string if
    * 		// this plugin was built into the editor class.
    * 		plugins: [ FooPlugin ]
    * 	} )
    * 	.then( editor => {
    * 		editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
    * 		editor.config.get( BarPlugin ); // -> Undefined.
    * 	} );
    * ```
    *
    * See also {@link module:core/editor/editor~Editor.defaultConfig}.
    */
    __publicField(Editor, "builtinPlugins");
    /**
    * The {@link module:core/context~Context} class.
    *
    * Exposed as static editor field for easier access in editor builds.
    */
    __publicField(Editor, "Context", Context);
    /**
    * The {@link module:watchdog/editorwatchdog~EditorWatchdog} class.
    *
    * Exposed as static editor field for easier access in editor builds.
    */
    __publicField(Editor, "EditorWatchdog", EditorWatchdog);
    /**
    * The {@link module:watchdog/contextwatchdog~ContextWatchdog} class.
    *
    * Exposed as static editor field for easier access in editor builds.
    */
    __publicField(Editor, "ContextWatchdog", ContextWatchdog);
    function ElementApiMixin(base) {
      class Mixin extends base {
        constructor() {
          super(...arguments);
          __publicField(this, "sourceElement");
        }
        updateSourceElement(data) {
          if (!this.sourceElement) {
            throw new CKEditorError("editor-missing-sourceelement", this);
          }
          const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
          const isSourceElementTextArea = this.sourceElement instanceof HTMLTextAreaElement;
          if (!shouldUpdateSourceElement && !isSourceElementTextArea) {
            setDataInElement(this.sourceElement, "");
            return;
          }
          const dataToSet = typeof data === "string" ? data : this.data.get();
          setDataInElement(this.sourceElement, dataToSet);
        }
      }
      return Mixin;
    }
    ElementApiMixin.updateSourceElement = ElementApiMixin(Object).prototype.updateSourceElement;
    function secureSourceElement(editor, sourceElement) {
      if (sourceElement.ckeditorInstance) {
        throw new CKEditorError("editor-source-element-already-used", editor);
      }
      sourceElement.ckeditorInstance = editor;
      editor.once("destroy", () => {
        delete sourceElement.ckeditorInstance;
      });
    }
    class PendingActions extends ContextPlugin {
      constructor() {
        super(...arguments);
        /**
        * A list of pending actions.
        */
        __publicField(this, "_actions");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "PendingActions";
      }
      /**
      * @inheritDoc
      */
      init() {
        this.set("hasAny", false);
        this._actions = new Collection({
          idProperty: "_id"
        });
        this._actions.delegate("add", "remove").to(this);
      }
      /**
      * Adds an action to the list of pending actions.
      *
      * This method returns an action object with an observable message property.
      * The action object can be later used in the {@link #remove} method. It also allows you to change the message.
      *
      * @param message The action message.
      * @returns An observable object that represents a pending action.
      */
      add(message) {
        if (typeof message !== "string") {
          throw new CKEditorError("pendingactions-add-invalid-message", this);
        }
        const action = new (ObservableMixin())();
        action.set("message", message);
        this._actions.add(action);
        this.hasAny = true;
        return action;
      }
      /**
      * Removes an action from the list of pending actions.
      *
      * @param action An action object.
      */
      remove(action) {
        this._actions.remove(action);
        this.hasAny = !!this._actions.length;
      }
      /**
      * Returns the first action from the list or null if the list is empty
      *
      * @returns The pending action object.
      */
      get first() {
        return this._actions.get(0);
      }
      /**
      * Iterable interface.
      */
      [Symbol.iterator]() {
        return this._actions[Symbol.iterator]();
      }
    }
    var cancel = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
    var caption = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>';
    var check = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
    var cog = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>';
    var colorPalette = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';
    var eraser = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>';
    var history = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>';
    var lowVision = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
    var textAlternative = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.035 1C2.446 1 2 1.54 2 2.098V10.5h1.5v-8h13v8H18V2.098C18 1.539 17.48 1 16.9 1H3.035Zm10.453 2.61a1.885 1.885 0 0 0-1.442.736 1.89 1.89 0 0 0 1.011 2.976 1.903 1.903 0 0 0 2.253-1.114 1.887 1.887 0 0 0-1.822-2.598ZM7.463 8.163a.611.611 0 0 0-.432.154L5.071 10.5h5.119L7.88 8.348a.628.628 0 0 0-.417-.185Zm6.236 1.059a.62.62 0 0 0-.42.164L12.07 10.5h2.969l-.92-1.113a.618.618 0 0 0-.42-.165ZM.91 11.5a.91.91 0 0 0-.91.912v6.877c0 .505.405.91.91.91h18.178a.91.91 0 0 0 .912-.91v-6.877a.908.908 0 0 0-.912-.912H.91ZM3.668 13h1.947l2.135 5.7H5.898l-.28-.946H3.601l-.278.945H1.516L3.668 13Zm4.947 0h1.801v4.3h2.7v1.4h-4.5V13h-.001Zm4.5 0h5.4v1.4h-1.798v4.3h-1.701v-4.3h-1.9V13h-.001Zm-8.517 1.457-.614 2.059h1.262l-.648-2.059Z"/></svg>';
    var loupe = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>';
    var previousArrow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
    var nextArrow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
    var image = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.66 9.118a.693.693 0 0 1 .956.032l3.65 3.411 2.422-2.238a.695.695 0 0 1 .945 0L17.5 13.6V2.5h-15v11.1l4.16-4.482ZM17.8 1c.652 0 1.2.47 1.2 1.1v14.362c0 .64-.532 1.038-1.184 1.038H2.184C1.532 17.5 1 17.103 1 16.462V2.1C1 1.47 1.537 1 2.2 1h15.6Zm-5.655 6a2.128 2.128 0 0 1 .157-2.364A2.133 2.133 0 1 1 12.145 7Z"/></svg>';
    var imageUpload = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h9.494a2.97 2.97 0 0 1-.414-.287 2.998 2.998 0 0 1-1.055-2.03 3.003 3.003 0 0 1 .693-2.185l.383-.455-.02.018-3.65-3.41a.695.695 0 0 0-.957-.034L1.5 13.6V2.5h15v5.535a2.97 2.97 0 0 1 1.412.932l.088.105V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.146 2.146 0 0 0-2.049 1.992 2.14 2.14 0 0 0 1.28 2.096 2.13 2.13 0 0 0 2.644-3.11 2.134 2.134 0 0 0-1.875-.978Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/><path d="M15.522 19.1a.79.79 0 0 0 .79-.79v-5.373l2.059 2.455a.79.79 0 1 0 1.211-1.015l-3.352-3.995a.79.79 0 0 0-.995-.179.784.784 0 0 0-.299.221l-3.35 3.99a.79.79 0 1 0 1.21 1.017l1.936-2.306v5.185c0 .436.353.79.79.79Z"/></svg>';
    var imageAssetManager = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1c-.662 0-1.2.47-1.2 1.1v14.248c0 .64.533 1.152 1.185 1.152h6.623v-7.236L6.617 9.15a.694.694 0 0 0-.957-.033L1.602 13.55V2.553l14.798.003V9.7H18V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.723 2.805a2.094 2.094 0 0 0-1.621.832 2.127 2.127 0 0 0 1.136 3.357 2.13 2.13 0 0 0 2.611-1.506 2.133 2.133 0 0 0-.76-2.244 2.13 2.13 0 0 0-1.366-.44Z"/><path clip-rule="evenodd" d="M19.898 12.369v6.187a.844.844 0 0 1-.844.844h-8.719a.844.844 0 0 1-.843-.844v-7.312a.844.844 0 0 1 .843-.844h2.531a.843.843 0 0 1 .597.248l.838.852h4.75c.223 0 .441.114.6.272a.844.844 0 0 1 .247.597Zm-1.52.654-4.377.02-1.1-1.143H11v6h7.4l-.023-4.877Z"/></svg>';
    var imageUrl = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M1.201 1C.538 1 0 1.47 0 2.1v14.363c0 .64.534 1.037 1.186 1.037h7.029a5.401 5.401 0 0 1 .615-4.338l.762-1.232-2.975-2.78a.696.696 0 0 0-.957-.033L1.5 13.6V2.5h15v6.023c.449.131.887.32 1.307.573l.058.033c.046.028.09.057.135.086V2.1c0-.63-.547-1.1-1.2-1.1H1.202Zm11.713 2.803a2.15 2.15 0 0 0-1.611.834 2.118 2.118 0 0 0-.438 1.158 2.14 2.14 0 0 0 1.277 2.096 2.132 2.132 0 0 0 2.645-3.11 2.13 2.13 0 0 0-1.873-.978Z"/><path d="M16.63 10.294a3.003 3.003 0 0 0-4.142.887l-.117.177a.647.647 0 0 0-.096.492.664.664 0 0 0 .278.418.7.7 0 0 0 .944-.234 1.741 1.741 0 0 1 2.478-.463 1.869 1.869 0 0 1 .476 2.55.637.637 0 0 0-.071.5.646.646 0 0 0 .309.396.627.627 0 0 0 .869-.19l.027-.041a3.226 3.226 0 0 0-.956-4.492Zm-6.061 3.78-.044.066a3.228 3.228 0 0 0 .82 4.403 3.005 3.005 0 0 0 4.275-.798l.13-.197a.626.626 0 0 0 .092-.475.638.638 0 0 0-.268-.402.713.713 0 0 0-.99.26l-.018.029a1.741 1.741 0 0 1-2.477.461 1.87 1.87 0 0 1-.475-2.55l.029-.047a.647.647 0 0 0 .086-.485.66.66 0 0 0-.275-.408l-.04-.027a.609.609 0 0 0-.845.17Z"/><path d="M15.312 13.925c.24-.36.154-.838-.19-1.067-.346-.23-.82-.124-1.059.236l-1.268 1.907c-.239.36-.153.838.192 1.067.345.23.818.123 1.057-.236l1.268-1.907Z"/></svg>';
    var alignBottom = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>';
    var alignMiddle = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>';
    var alignTop = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>';
    var alignLeft = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
    var alignCenter = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>';
    var alignRight = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>';
    var alignJustify = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>';
    var objectBlockLeft = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
    var objectCenter = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>';
    var objectBlockRight = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
    var objectFullWidth = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>';
    var objectInline = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
    var objectLeft = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>';
    var objectRight = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>';
    var objectSizeFull = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>';
    var objectSizeCustom = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:v="https://vecta.io/nano" viewBox="0 0 20 20"><path d="M.95 1.43a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h.75v6.3H.95a.95.95 0 0 0-.95.95v3.1a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-.65h1.932l1.539-1.5H5v-.95a.95.95 0 0 0-.95-.95H3.2v-6.3h.85A.95.95 0 0 0 5 5.48v-.55h10v.55a.95.95 0 0 0 .95.95h3.1a.95.95 0 0 0 .95-.95v-3.1a.95.95 0 0 0-.95-.95h-3.1a.95.95 0 0 0-.95.95v1.05H5V2.38a.95.95 0 0 0-.95-.95H.95zm.55 3.5v-2h2v2h-2zm0 9.3v2h2v-2h-2zm15-11.3v2h2v-2h-2z"/><path d="M8.139 20.004v-2.388l7.045-7.048 2.391 2.391-7.046 7.046h-2.39zm11.421-9.101a.64.64 0 0 1-.138.206l-1.165 1.168-2.391-2.391 1.167-1.163a.63.63 0 0 1 .206-.138.635.635 0 0 1 .243-.049.63.63 0 0 1 .449.187l1.491 1.488c.059.059.108.129.138.206s.049.16.049.243a.6.6 0 0 1-.049.243z"/></svg>';
    var objectSizeLarge = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M13 5.5H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2ZM13 7a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-8A.5.5 0 0 1 2 7h11Z"/></svg>';
    var objectSizeSmall = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M7 9.5H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2ZM7 11a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4A.5.5 0 0 1 2 11h5Z"/></svg>';
    var objectSizeMedium = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 16.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1ZM1 15v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 13v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 11v1H0v-1h1Zm19 0v1h-1v-1h1ZM1 9v1H0V9h1Zm19 0v1h-1V9h1ZM1 7v1H0V7h1Zm19 0v1h-1V7h1ZM1 5v1H0V5h1Zm19 0v1h-1V5h1Zm0-2v1h-1V3h1ZM1 3v1H0V3h1Zm13.5-1.5v1h-1v-1h1Zm2 0v1h-1v-1h1Zm2 0v1h-1v-1h1Zm-8 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm-2 0v1h-1v-1h1Zm8 0v1h-1v-1h1Zm-10 0v1h-1v-1h1Z"/><path d="M10 7.5H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2ZM10 9a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6A.5.5 0 0 1 2 9h8Z"/></svg>';
    var pencil = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>';
    var pilcrow = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>';
    var quote = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
    var threeVerticalDots = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
    var dragIndicator = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>';
    var bold = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
    var paragraph = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>';
    var plus = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>';
    var text = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>';
    var importExport = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>';
    var redo = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
    var undo = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
    var bulletedList = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
    var numberedList = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
    var todoList = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m2.315 14.705 2.224-2.24a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .949L2.865 16.07a.682.682 0 0 1-.112.089.647.647 0 0 1-.852-.051L.688 14.886a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.717.722zm5.185.045a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75zM2.329 5.745l2.21-2.226a.689.689 0 0 1 .963 0 .664.664 0 0 1 0 .95L2.865 7.125a.685.685 0 0 1-.496.196.644.644 0 0 1-.468-.187L.688 5.912a.635.635 0 0 1 0-.903.647.647 0 0 1 .91 0l.73.736zM7.5 5.75A.75.75 0 0 1 8.25 5h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
    var codeBlock = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>';
    var browseFiles = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>';
    var heading1 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 9v10h-2v-8h-2V9h4zM4 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H10a1 1 0 0 1-1-1V11H4v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H3a1 1 0 0 1 1 1v4.5z"/></svg>';
    var heading2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm16.076 8.343V18.5h-6.252c.067-.626.27-1.22.61-1.78.338-.561 1.006-1.305 2.005-2.232.804-.749 1.297-1.257 1.479-1.523.245-.368.368-.732.368-1.092 0-.398-.107-.703-.32-.917-.214-.214-.51-.32-.886-.32-.372 0-.669.111-.889.336-.22.224-.347.596-.38 1.117l-1.778-.178c.106-.982.438-1.686.997-2.114.558-.427 1.257-.64 2.095-.64.918 0 1.64.247 2.164.742.525.495.787 1.11.787 1.847 0 .419-.075.818-.225 1.197-.15.378-.388.775-.714 1.19-.216.275-.605.67-1.168 1.187-.563.516-.92.859-1.07 1.028a3.11 3.11 0 0 0-.365.495h3.542z"/></svg>';
    var heading3 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1V11H3v4.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1H2a1 1 0 0 1 1 1v4.5zm9.989 7.53 1.726-.209c.055.44.203.777.445 1.01.24.232.533.349.876.349.368 0 .678-.14.93-.42.251-.279.377-.655.377-1.13 0-.448-.12-.803-.362-1.066a1.153 1.153 0 0 0-.882-.393c-.228 0-.501.044-.819.133l.197-1.453c.482.012.85-.092 1.105-.315.253-.222.38-.517.38-.885 0-.313-.093-.563-.279-.75-.186-.185-.434-.278-.743-.278a1.07 1.07 0 0 0-.78.317c-.216.212-.347.52-.394.927l-1.644-.28c.114-.562.287-1.012.517-1.348.231-.337.553-.601.965-.794a3.24 3.24 0 0 1 1.387-.289c.876 0 1.579.28 2.108.838.436.457.653.973.653 1.549 0 .817-.446 1.468-1.339 1.955.533.114.96.37 1.28.768.319.398.478.878.478 1.441 0 .817-.298 1.513-.895 2.088-.596.576-1.339.864-2.228.864-.842 0-1.54-.243-2.094-.727-.555-.485-.876-1.118-.965-1.901z"/></svg>';
    var heading4 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm13.55 10v-1.873h-3.81v-1.561l4.037-5.91h1.498v5.904h1.156v1.567h-1.156V18.5H17.05zm0-3.44v-3.18l-2.14 3.18h2.14z"/></svg>';
    var heading5 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm9.578 7.607 1.777-.184c.05.402.201.72.45.955a1.223 1.223 0 0 0 1.81-.101c.258-.303.387-.759.387-1.368 0-.572-.128-1-.384-1.286-.256-.285-.59-.428-1-.428-.512 0-.971.226-1.377.679l-1.448-.21.915-4.843h4.716v1.67H15.56l-.28 1.58a2.697 2.697 0 0 1 1.219-.298 2.68 2.68 0 0 1 2.012.863c.55.576.825 1.323.825 2.241a3.36 3.36 0 0 1-.666 2.05c-.605.821-1.445 1.232-2.52 1.232-.86 0-1.56-.23-2.101-.692-.542-.461-.866-1.081-.971-1.86z"/></svg>';
    var heading6 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3.5 8.5h5V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v11.5a1 1 0 0 1-1 1h-.5a1 1 0 0 1-1-1V11h-5v4.5a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h.5a1 1 0 0 1 1 1v4.5zm15.595 2.973-1.726.19c-.043-.355-.153-.617-.33-.787-.178-.169-.409-.253-.692-.253-.377 0-.695.169-.956.507-.26.339-.424 1.043-.492 2.114.445-.525.997-.787 1.657-.787.745 0 1.383.284 1.914.85.531.568.797 1.3.797 2.197 0 .952-.28 1.716-.838 2.291-.559.576-1.276.864-2.152.864-.94 0-1.712-.365-2.317-1.095-.605-.73-.908-1.927-.908-3.59 0-1.705.316-2.935.946-3.688.63-.753 1.45-1.13 2.457-1.13.706 0 1.291.198 1.755.594.463.395.758.97.885 1.723zm-4.043 3.891c0 .58.133 1.028.4 1.343.266.315.57.473.914.473.33 0 .605-.13.825-.388.22-.258.33-.68.33-1.27 0-.604-.118-1.047-.355-1.329a1.115 1.115 0 0 0-.89-.422c-.342 0-.632.134-.869.403s-.355.666-.355 1.19z"/></svg>';
    var horizontalLine = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>';
    var html = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>';
    var indent = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
    var outdent = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
    var table = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 5.5v3h4v-3H3Zm0 4v3h4v-3H3Zm0 4v3h4v-3H3Zm5 3h4v-3H8v3Zm5 0h4v-3h-4v3Zm4-4v-3h-4v3h4Zm0-4v-3h-4v3h4Zm1.5 8A1.5 1.5 0 0 1 17 18H3a1.5 1.5 0 0 1-1.5-1.5V3c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13.5Zm-6.5-4v-3H8v3h4Zm0-4v-3H8v3h4Z"/></svg>';
    const icons = {
      bold,
      cancel,
      caption,
      check,
      cog,
      colorPalette,
      eraser,
      history,
      image,
      imageUpload,
      imageAssetManager,
      imageUrl,
      lowVision,
      textAlternative,
      loupe,
      previousArrow,
      nextArrow,
      importExport,
      paragraph,
      plus,
      text,
      alignBottom,
      alignMiddle,
      alignTop,
      alignLeft,
      alignCenter,
      alignRight,
      alignJustify,
      objectLeft,
      objectCenter,
      objectRight,
      objectFullWidth,
      objectInline,
      objectBlockLeft,
      objectBlockRight,
      objectSizeCustom,
      objectSizeFull,
      objectSizeLarge,
      objectSizeSmall,
      objectSizeMedium,
      pencil,
      pilcrow,
      quote,
      threeVerticalDots,
      dragIndicator,
      redo,
      undo,
      bulletedList,
      numberedList,
      todoList,
      codeBlock,
      browseFiles,
      heading1,
      heading2,
      heading3,
      heading4,
      heading5,
      heading6,
      horizontalLine,
      html,
      indent,
      outdent,
      table
    };
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class FileReader extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates an instance of the FileReader.
      */
      constructor() {
        super();
        __publicField(this, "total");
        /**
        * Instance of native FileReader.
        */
        __publicField(this, "_reader");
        /**
        * Holds the data of an already loaded file. The file must be first loaded
        * by using {@link module:upload/filereader~FileReader#read `read()`}.
        */
        __publicField(this, "_data");
        const reader = new window.FileReader();
        this._reader = reader;
        this._data = void 0;
        this.set("loaded", 0);
        reader.onprogress = (evt) => {
          this.loaded = evt.loaded;
        };
      }
      /**
      * Returns error that occurred during file reading.
      */
      get error() {
        return this._reader.error;
      }
      /**
      * Holds the data of an already loaded file. The file must be first loaded
      * by using {@link module:upload/filereader~FileReader#read `read()`}.
      */
      get data() {
        return this._data;
      }
      /**
      * Reads the provided file.
      *
      * @param file Native File object.
      * @returns Returns a promise that will be resolved with file's content.
      * The promise will be rejected in case of an error or when the reading process is aborted.
      */
      read(file) {
        const reader = this._reader;
        this.total = file.size;
        return new Promise((resolve, reject) => {
          reader.onload = () => {
            const result = reader.result;
            this._data = result;
            resolve(result);
          };
          reader.onerror = () => {
            reject("error");
          };
          reader.onabort = () => {
            reject("aborted");
          };
          this._reader.readAsDataURL(file);
        });
      }
      /**
      * Aborts file reader.
      */
      abort() {
        this._reader.abort();
      }
    }
    class FileRepository extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Collection of loaders associated with this repository.
        */
        __publicField(this, "loaders", new Collection());
        /**
        * Loaders mappings used to retrieve loaders references.
        */
        __publicField(this, "_loadersMap", /* @__PURE__ */ new Map());
        /**
        * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin
        * while upload is in progress. When there is no upload then value is `null`.
        */
        __publicField(this, "_pendingAction", null);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FileRepository";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          PendingActions
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        this.loaders.on("change", () => this._updatePendingAction());
        this.set("uploaded", 0);
        this.set("uploadTotal", null);
        this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
          return total ? uploaded / total * 100 : 0;
        });
      }
      /**
      * Returns the loader associated with specified file or promise.
      *
      * To get loader by id use `fileRepository.loaders.get( id )`.
      *
      * @param fileOrPromise Native file or promise handle.
      */
      getLoader(fileOrPromise) {
        return this._loadersMap.get(fileOrPromise) || null;
      }
      /**
      * Creates a loader instance for the given file.
      *
      * Requires {@link #createUploadAdapter} factory to be defined.
      *
      * @param fileOrPromise Native File object or native Promise object which resolves to a File.
      */
      createLoader(fileOrPromise) {
        if (!this.createUploadAdapter) {
          logWarning("filerepository-no-upload-adapter");
          return null;
        }
        const loader = new FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);
        this.loaders.add(loader);
        this._loadersMap.set(fileOrPromise, loader);
        if (fileOrPromise instanceof Promise) {
          loader.file.then((file) => {
            this._loadersMap.set(file, loader);
          }).catch(() => {
          });
        }
        loader.on("change:uploaded", () => {
          let aggregatedUploaded = 0;
          for (const loader2 of this.loaders) {
            aggregatedUploaded += loader2.uploaded;
          }
          this.uploaded = aggregatedUploaded;
        });
        loader.on("change:uploadTotal", () => {
          let aggregatedTotal = 0;
          for (const loader2 of this.loaders) {
            if (loader2.uploadTotal) {
              aggregatedTotal += loader2.uploadTotal;
            }
          }
          this.uploadTotal = aggregatedTotal;
        });
        return loader;
      }
      /**
      * Destroys the given loader.
      *
      * @param fileOrPromiseOrLoader File or Promise associated with that loader or loader itself.
      */
      destroyLoader(fileOrPromiseOrLoader) {
        const loader = fileOrPromiseOrLoader instanceof FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);
        loader._destroy();
        this.loaders.remove(loader);
        this._loadersMap.forEach((value, key) => {
          if (value === loader) {
            this._loadersMap.delete(key);
          }
        });
      }
      /**
      * Registers or deregisters pending action bound with upload progress.
      */
      _updatePendingAction() {
        const pendingActions = this.editor.plugins.get(PendingActions);
        if (this.loaders.length) {
          if (!this._pendingAction) {
            const t = this.editor.t;
            const getMessage = (value) => `${t("Upload in progress")} ${parseInt(value)}%.`;
            this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));
            this._pendingAction.bind("message").to(this, "uploadedPercent", getMessage);
          }
        } else {
          pendingActions.remove(this._pendingAction);
          this._pendingAction = null;
        }
      }
    }
    class FileLoader extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new instance of `FileLoader`.
      *
      * @param filePromise A promise which resolves to a file instance.
      * @param uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
      */
      constructor(filePromise, uploadAdapterCreator) {
        super();
        /**
        * Unique id of FileLoader instance.
        *
        * @readonly
        */
        __publicField(this, "id");
        /**
        * Additional wrapper over the initial file promise passed to this loader.
        */
        __publicField(this, "_filePromiseWrapper");
        /**
        * Adapter instance associated with this file loader.
        */
        __publicField(this, "_adapter");
        /**
        * FileReader used by FileLoader.
        */
        __publicField(this, "_reader");
        this.id = uid();
        this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);
        this._adapter = uploadAdapterCreator(this);
        this._reader = new FileReader();
        this.set("status", "idle");
        this.set("uploaded", 0);
        this.set("uploadTotal", null);
        this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (uploaded, total) => {
          return total ? uploaded / total * 100 : 0;
        });
        this.set("uploadResponse", null);
      }
      /**
      * A `Promise` which resolves to a `File` instance associated with this file loader.
      */
      get file() {
        if (!this._filePromiseWrapper) {
          return Promise.resolve(null);
        } else {
          return this._filePromiseWrapper.promise.then((file) => this._filePromiseWrapper ? file : null);
        }
      }
      /**
      * Returns the file data. To read its data, you need for first load the file
      * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
      */
      get data() {
        return this._reader.data;
      }
      /**
      * Reads file using {@link module:upload/filereader~FileReader}.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
      * is different than `idle`.
      *
      * Example usage:
      *
      * ```ts
      * fileLoader.read()
      * 	.then( data => { ... } )
      * 	.catch( err => {
      * 		if ( err === 'aborted' ) {
      * 			console.log( 'Reading aborted.' );
      * 		} else {
      * 			console.log( 'Reading error.', err );
      * 		}
      * 	} );
      * ```
      *
      * @returns Returns promise that will be resolved with read data. Promise will be rejected if error
      * occurs or if read process is aborted.
      */
      read() {
        if (this.status != "idle") {
          throw new CKEditorError("filerepository-read-wrong-status", this);
        }
        this.status = "reading";
        return this.file.then((file) => this._reader.read(file)).then((data) => {
          if (this.status !== "reading") {
            throw this.status;
          }
          this.status = "idle";
          return data;
        }).catch((err) => {
          if (err === "aborted") {
            this.status = "aborted";
            throw "aborted";
          }
          this.status = "error";
          throw this._reader.error ? this._reader.error : err;
        });
      }
      /**
      * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
      *
      * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
      * is different than `idle`.
      * Example usage:
      *
      * ```ts
      * fileLoader.upload()
      * 	.then( data => { ... } )
      * 	.catch( e => {
      * 		if ( e === 'aborted' ) {
      * 			console.log( 'Uploading aborted.' );
      * 		} else {
      * 			console.log( 'Uploading error.', e );
      * 		}
      * 	} );
      * ```
      *
      * @returns Returns promise that will be resolved with response data. Promise will be rejected if error
      * occurs or if read process is aborted.
      */
      upload() {
        if (this.status != "idle") {
          throw new CKEditorError("filerepository-upload-wrong-status", this);
        }
        this.status = "uploading";
        return this.file.then(() => this._adapter.upload()).then((data) => {
          this.uploadResponse = data;
          this.status = "idle";
          return data;
        }).catch((err) => {
          if (this.status === "aborted") {
            throw "aborted";
          }
          this.status = "error";
          throw err;
        });
      }
      /**
      * Aborts loading process.
      */
      abort() {
        const status = this.status;
        this.status = "aborted";
        if (!this._filePromiseWrapper.isFulfilled) {
          this._filePromiseWrapper.promise.catch(() => {
          });
          this._filePromiseWrapper.rejecter("aborted");
        } else if (status == "reading") {
          this._reader.abort();
        } else if (status == "uploading" && this._adapter.abort) {
          this._adapter.abort();
        }
        this._destroy();
      }
      /**
      * Performs cleanup.
      *
      * @internal
      */
      _destroy() {
        this._filePromiseWrapper = void 0;
        this._reader = void 0;
        this._adapter = void 0;
        this.uploadResponse = void 0;
      }
      /**
      * Wraps a given file promise into another promise giving additional
      * control (resolving, rejecting, checking if fulfilled) over it.
      *
      * @param filePromise The initial file promise to be wrapped.
      */
      _createFilePromiseWrapper(filePromise) {
        const wrapper = {};
        wrapper.promise = new Promise((resolve, reject) => {
          wrapper.rejecter = reject;
          wrapper.isFulfilled = false;
          filePromise.then((file) => {
            wrapper.isFulfilled = true;
            resolve(file);
          }).catch((err) => {
            wrapper.isFulfilled = true;
            reject(err);
          });
        });
        return wrapper;
      }
    }
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    const names = /* @__PURE__ */ getDefaultExportFromCjs(colorName);
    var baseHues = {
      red: 0,
      orange: 60,
      yellow: 120,
      green: 180,
      blue: 240,
      purple: 300
    };
    function parse(cstr) {
      var m, parts = [], alpha = 1, space;
      if (typeof cstr === "string") {
        if (names[cstr]) {
          parts = names[cstr].slice();
          space = "rgb";
        } else if (cstr === "transparent") {
          alpha = 0;
          space = "rgb";
          parts = [0, 0, 0];
        } else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
          var base = cstr.slice(1);
          var size = base.length;
          var isShort = size <= 4;
          alpha = 1;
          if (isShort) {
            parts = [
              parseInt(base[0] + base[0], 16),
              parseInt(base[1] + base[1], 16),
              parseInt(base[2] + base[2], 16)
            ];
            if (size === 4) {
              alpha = parseInt(base[3] + base[3], 16) / 255;
            }
          } else {
            parts = [
              parseInt(base[0] + base[1], 16),
              parseInt(base[2] + base[3], 16),
              parseInt(base[4] + base[5], 16)
            ];
            if (size === 8) {
              alpha = parseInt(base[6] + base[7], 16) / 255;
            }
          }
          if (!parts[0]) parts[0] = 0;
          if (!parts[1]) parts[1] = 0;
          if (!parts[2]) parts[2] = 0;
          space = "rgb";
        } else if (m = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
          var name = m[1];
          var isRGB = name === "rgb";
          var base = name.replace(/a$/, "");
          space = base;
          var size = base === "cmyk" ? 4 : base === "gray" ? 1 : 3;
          parts = m[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(x, i) {
            if (/%$/.test(x)) {
              if (i === size) return parseFloat(x) / 100;
              if (base === "rgb") return parseFloat(x) * 255 / 100;
              return parseFloat(x);
            } else if (base[i] === "h") {
              if (/deg$/.test(x)) {
                return parseFloat(x);
              } else if (baseHues[x] !== void 0) {
                return baseHues[x];
              }
            }
            return parseFloat(x);
          });
          if (name === base) parts.push(1);
          alpha = isRGB ? 1 : parts[size] === void 0 ? 1 : parts[size];
          parts = parts.slice(0, size);
        } else if (cstr.length > 10 && /[0-9](?:\s|\/)/.test(cstr)) {
          parts = cstr.match(/([0-9]+)/g).map(function(value) {
            return parseFloat(value);
          });
          space = cstr.match(/([a-z])/ig).join("").toLowerCase();
        }
      } else if (!isNaN(cstr)) {
        space = "rgb";
        parts = [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255];
      } else if (Array.isArray(cstr) || cstr.length) {
        parts = [cstr[0], cstr[1], cstr[2]];
        space = "rgb";
        alpha = cstr.length === 4 ? cstr[3] : 1;
      } else if (cstr instanceof Object) {
        if (cstr.r != null || cstr.red != null || cstr.R != null) {
          space = "rgb";
          parts = [
            cstr.r || cstr.red || cstr.R || 0,
            cstr.g || cstr.green || cstr.G || 0,
            cstr.b || cstr.blue || cstr.B || 0
          ];
        } else {
          space = "hsl";
          parts = [
            cstr.h || cstr.hue || cstr.H || 0,
            cstr.s || cstr.saturation || cstr.S || 0,
            cstr.l || cstr.lightness || cstr.L || cstr.b || cstr.brightness
          ];
        }
        alpha = cstr.a || cstr.alpha || cstr.opacity || 1;
        if (cstr.opacity != null) alpha /= 100;
      }
      return {
        space,
        values: parts,
        alpha
      };
    }
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    const convert$2 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$2;
    for (const model of Object.keys(convert$2)) {
      if (!("channels" in convert$2[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$2[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$2[model].labels.length !== convert$2[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$2[model];
      delete convert$2[model].channels;
      delete convert$2[model].labels;
      Object.defineProperty(convert$2[model], "channels", { value: channels });
      Object.defineProperty(convert$2[model], "labels", { value: labels });
    }
    convert$2.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert$2.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff2 = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff2 / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert$2.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert$2.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert$2.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert$2.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$2.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$2.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert$2.rgb.lab = function(rgb) {
      const xyz = convert$2.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$2.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert$2.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert$2.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert$2.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert$2.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert$2.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert$2.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert$2.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$2.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert$2.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert$2.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert$2.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert$2.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$2.hsv.ansi16 = function(args) {
      return convert$2.rgb.ansi16(convert$2.hsv.rgb(args), args[2]);
    };
    convert$2.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert$2.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert$2.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert$2.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$2.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert$2.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$2.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert$2.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert$2.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert$2.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert$2.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert$2.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$2.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert$2.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$2.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$2.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$2.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$2.gray.hsv = convert$2.gray.hsl;
    convert$2.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$2.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$2.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$2.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$2.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len = models2.length, i = 0; i < len; i++) {
        graph[models2[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions$1[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len = models2.length, i = 0; i < len; i++) {
        const toModel = models2[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    var colorConvert = convert;
    const index = /* @__PURE__ */ getDefaultExportFromCjs(colorConvert);
    const convert$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: index
    }, [colorConvert]);
    const clamp$1 = (number, min = 0, max = 1) => {
      return number > max ? max : number < min ? min : number;
    };
    const round = (number, digits = 0, base = Math.pow(10, digits)) => {
      return Math.round(base * number) / base;
    };
    const hexToHsva = (hex) => rgbaToHsva(hexToRgba(hex));
    const hexToRgba = (hex) => {
      if (hex[0] === "#")
        hex = hex.substring(1);
      if (hex.length < 6) {
        return {
          r: parseInt(hex[0] + hex[0], 16),
          g: parseInt(hex[1] + hex[1], 16),
          b: parseInt(hex[2] + hex[2], 16),
          a: hex.length === 4 ? round(parseInt(hex[3] + hex[3], 16) / 255, 2) : 1
        };
      }
      return {
        r: parseInt(hex.substring(0, 2), 16),
        g: parseInt(hex.substring(2, 4), 16),
        b: parseInt(hex.substring(4, 6), 16),
        a: hex.length === 8 ? round(parseInt(hex.substring(6, 8), 16) / 255, 2) : 1
      };
    };
    const hsvaToHex = (hsva) => rgbaToHex(hsvaToRgba(hsva));
    const hsvaToHsla = ({ h, s, v, a }) => {
      const hh = (200 - s) * v / 100;
      return {
        h: round(h),
        s: round(hh > 0 && hh < 200 ? s * v / 100 / (hh <= 100 ? hh : 200 - hh) * 100 : 0),
        l: round(hh / 2),
        a: round(a, 2)
      };
    };
    const hsvaToHslString = (hsva) => {
      const { h, s, l } = hsvaToHsla(hsva);
      return `hsl(${h}, ${s}%, ${l}%)`;
    };
    const hsvaToRgba = ({ h, s, v, a }) => {
      h = h / 360 * 6;
      s = s / 100;
      v = v / 100;
      const hh = Math.floor(h), b = v * (1 - s), c = v * (1 - (h - hh) * s), d = v * (1 - (1 - h + hh) * s), module2 = hh % 6;
      return {
        r: round([v, c, b, b, d, v][module2] * 255),
        g: round([d, v, v, c, b, b][module2] * 255),
        b: round([b, b, d, v, v, c][module2] * 255),
        a: round(a, 2)
      };
    };
    const format = (number) => {
      const hex = number.toString(16);
      return hex.length < 2 ? "0" + hex : hex;
    };
    const rgbaToHex = ({ r, g, b, a }) => {
      const alphaHex = a < 1 ? format(round(a * 255)) : "";
      return "#" + format(r) + format(g) + format(b) + alphaHex;
    };
    const rgbaToHsva = ({ r, g, b, a }) => {
      const max = Math.max(r, g, b);
      const delta = max - Math.min(r, g, b);
      const hh = delta ? max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta : 0;
      return {
        h: round(60 * (hh < 0 ? hh + 6 : hh)),
        s: round(max ? delta / max * 100 : 0),
        v: round(max / 255 * 100),
        a
      };
    };
    const equalColorObjects = (first2, second) => {
      if (first2 === second)
        return true;
      for (const prop in first2) {
        if (first2[prop] !== second[prop])
          return false;
      }
      return true;
    };
    const equalHex = (first2, second) => {
      if (first2.toLowerCase() === second.toLowerCase())
        return true;
      return equalColorObjects(hexToRgba(first2), hexToRgba(second));
    };
    const cache = {};
    const tpl = (html2) => {
      let template = cache[html2];
      if (!template) {
        template = document.createElement("template");
        template.innerHTML = html2;
        cache[html2] = template;
      }
      return template;
    };
    const fire = (target, type, detail) => {
      target.dispatchEvent(new CustomEvent(type, {
        bubbles: true,
        detail
      }));
    };
    let hasTouched = false;
    const isTouch = (e) => "touches" in e;
    const isValid = (event) => {
      if (hasTouched && !isTouch(event))
        return false;
      if (!hasTouched)
        hasTouched = isTouch(event);
      return true;
    };
    const pointerMove = (target, event) => {
      const pointer = isTouch(event) ? event.touches[0] : event;
      const rect = target.el.getBoundingClientRect();
      fire(target.el, "move", target.getMove({
        x: clamp$1((pointer.pageX - (rect.left + window.pageXOffset)) / rect.width),
        y: clamp$1((pointer.pageY - (rect.top + window.pageYOffset)) / rect.height)
      }));
    };
    const keyMove = (target, event) => {
      const keyCode = event.keyCode;
      if (keyCode > 40 || target.xy && keyCode < 37 || keyCode < 33)
        return;
      event.preventDefault();
      fire(target.el, "move", target.getMove({
        x: keyCode === 39 ? 0.01 : keyCode === 37 ? -0.01 : keyCode === 34 ? 0.05 : keyCode === 33 ? -0.05 : keyCode === 35 ? 1 : keyCode === 36 ? -1 : 0,
        y: keyCode === 40 ? 0.01 : keyCode === 38 ? -0.01 : 0
      }, true));
    };
    class Slider {
      constructor(root2, part, aria, xy) {
        const template = tpl(`<div role="slider" tabindex="0" part="${part}" ${aria}><div part="${part}-pointer"></div></div>`);
        root2.appendChild(template.content.cloneNode(true));
        const el = root2.querySelector(`[part=${part}]`);
        el.addEventListener("mousedown", this);
        el.addEventListener("touchstart", this);
        el.addEventListener("keydown", this);
        this.el = el;
        this.xy = xy;
        this.nodes = [el.firstChild, el];
      }
      set dragging(state) {
        const toggleEvent = state ? document.addEventListener : document.removeEventListener;
        toggleEvent(hasTouched ? "touchmove" : "mousemove", this);
        toggleEvent(hasTouched ? "touchend" : "mouseup", this);
      }
      handleEvent(event) {
        switch (event.type) {
          case "mousedown":
          case "touchstart":
            event.preventDefault();
            if (!isValid(event) || !hasTouched && event.button != 0)
              return;
            this.el.focus();
            pointerMove(this, event);
            this.dragging = true;
            break;
          case "mousemove":
          case "touchmove":
            event.preventDefault();
            pointerMove(this, event);
            break;
          case "mouseup":
          case "touchend":
            this.dragging = false;
            break;
          case "keydown":
            keyMove(this, event);
            break;
        }
      }
      style(styles) {
        styles.forEach((style, i) => {
          for (const p in style) {
            this.nodes[i].style.setProperty(p, style[p]);
          }
        });
      }
    }
    class Hue extends Slider {
      constructor(root2) {
        super(root2, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
      }
      update({ h }) {
        this.h = h;
        this.style([
          {
            left: `${h / 360 * 100}%`,
            color: hsvaToHslString({ h, s: 100, v: 100, a: 1 })
          }
        ]);
        this.el.setAttribute("aria-valuenow", `${round(h)}`);
      }
      getMove(offset, key) {
        return { h: key ? clamp$1(this.h + offset.x * 360, 0, 360) : 360 * offset.x };
      }
    }
    class Saturation extends Slider {
      constructor(root2) {
        super(root2, "saturation", 'aria-label="Color"', true);
      }
      update(hsva) {
        this.hsva = hsva;
        this.style([
          {
            top: `${100 - hsva.v}%`,
            left: `${hsva.s}%`,
            color: hsvaToHslString(hsva)
          },
          {
            "background-color": hsvaToHslString({ h: hsva.h, s: 100, v: 100, a: 1 })
          }
        ]);
        this.el.setAttribute("aria-valuetext", `Saturation ${round(hsva.s)}%, Brightness ${round(hsva.v)}%`);
      }
      getMove(offset, key) {
        return {
          s: key ? clamp$1(this.hsva.s + offset.x * 100, 0, 100) : offset.x * 100,
          v: key ? clamp$1(this.hsva.v - offset.y * 100, 0, 100) : Math.round(100 - offset.y * 100)
        };
      }
    }
    const css = `:host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}`;
    const hueCss = `[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}`;
    const saturationCss = `[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}`;
    const $isSame = Symbol("same");
    const $color = Symbol("color");
    const $hsva = Symbol("hsva");
    const $update = Symbol("update");
    const $parts = Symbol("parts");
    const $css = Symbol("css");
    const $sliders = Symbol("sliders");
    class ColorPicker extends HTMLElement {
      static get observedAttributes() {
        return ["color"];
      }
      get [$css]() {
        return [css, hueCss, saturationCss];
      }
      get [$sliders]() {
        return [Saturation, Hue];
      }
      get color() {
        return this[$color];
      }
      set color(newColor) {
        if (!this[$isSame](newColor)) {
          const newHsva = this.colorModel.toHsva(newColor);
          this[$update](newHsva);
          this[$color] = newColor;
        }
      }
      constructor() {
        super();
        const template = tpl(`<style>${this[$css].join("")}</style>`);
        const root2 = this.attachShadow({ mode: "open" });
        root2.appendChild(template.content.cloneNode(true));
        root2.addEventListener("move", this);
        this[$parts] = this[$sliders].map((slider) => new slider(root2));
      }
      connectedCallback() {
        if (this.hasOwnProperty("color")) {
          const value = this.color;
          delete this["color"];
          this.color = value;
        } else if (!this.color) {
          this.color = this.colorModel.defaultColor;
        }
      }
      attributeChangedCallback(_attr, _oldVal, newVal) {
        const color = this.colorModel.fromAttr(newVal);
        if (!this[$isSame](color)) {
          this.color = color;
        }
      }
      handleEvent(event) {
        const oldHsva = this[$hsva];
        const newHsva = { ...oldHsva, ...event.detail };
        this[$update](newHsva);
        let newColor;
        if (!equalColorObjects(newHsva, oldHsva) && !this[$isSame](newColor = this.colorModel.fromHsva(newHsva))) {
          this[$color] = newColor;
          fire(this, "color-changed", { value: newColor });
        }
      }
      [$isSame](color) {
        return this.color && this.colorModel.equal(color, this.color);
      }
      [$update](hsva) {
        this[$hsva] = hsva;
        this[$parts].forEach((part) => part.update(hsva));
      }
    }
    const colorModel = {
      defaultColor: "#000",
      toHsva: hexToHsva,
      fromHsva: ({ h, s, v }) => hsvaToHex({ h, s, v, a: 1 }),
      equal: equalHex,
      fromAttr: (color) => color
    };
    class HexBase extends ColorPicker {
      get colorModel() {
        return colorModel;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ViewCollection extends Collection {
      /**
      * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
      *
      * @param initialItems The initial items of the collection.
      */
      constructor(initialItems = []) {
        super(initialItems, {
          // An #id Number attribute should be legal and not break the `ViewCollection` instance.
          // https://github.com/ckeditor/ckeditor5-ui/issues/93
          idProperty: "viewUid"
        });
        /**
        * A parent element within which child views are rendered and managed in DOM.
        */
        __publicField(this, "_parentElement");
        this.on("add", (evt, view, index2) => {
          this._renderViewIntoCollectionParent(view, index2);
        });
        this.on("remove", (evt, view) => {
          if (view.element && this._parentElement) {
            view.element.remove();
          }
        });
        this._parentElement = null;
      }
      /**
      * Destroys the view collection along with child views.
      * See the view {@link module:ui/view~View#destroy} method.
      */
      destroy() {
        this.map((view) => view.destroy());
      }
      /**
      * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
      * {@link #remove removing} views in the collection synchronizes their
      * {@link module:ui/view~View#element elements} in the parent element.
      *
      * @param element A new parent element.
      */
      setParent(elementOrDocFragment) {
        this._parentElement = elementOrDocFragment;
        for (const view of this) {
          this._renderViewIntoCollectionParent(view);
        }
      }
      /**
      * Delegates selected events coming from within views in the collection to any
      * {@link module:utils/emittermixin~Emitter}.
      *
      * For the following views and collection:
      *
      * ```ts
      * const viewA = new View();
      * const viewB = new View();
      * const viewC = new View();
      *
      * const views = parentView.createCollection();
      *
      * views.delegate( 'eventX' ).to( viewB );
      * views.delegate( 'eventX', 'eventY' ).to( viewC );
      *
      * views.add( viewA );
      * ```
      *
      * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
      *
      * ```ts
      * viewA.fire( 'eventX', customData );
      * ```
      *
      * and `eventY` is delegated (fired by) `viewC` along with `customData`:
      *
      * ```ts
      * viewA.fire( 'eventY', customData );
      * ```
      *
      * See {@link module:utils/emittermixin~Emitter#delegate}.
      *
      * @param events {@link module:ui/view~View} event names to be delegated to another
      * {@link module:utils/emittermixin~Emitter}.
      * @returns Object with `to` property, a function which accepts the destination
      * of {@link module:utils/emittermixin~Emitter#delegate delegated} events.
      */
      delegate(...events) {
        if (!events.length || !isStringArray(events)) {
          throw new CKEditorError("ui-viewcollection-delegate-wrong-events", this);
        }
        return {
          to: (dest) => {
            for (const view of this) {
              for (const evtName of events) {
                view.delegate(evtName).to(dest);
              }
            }
            this.on("add", (evt, view) => {
              for (const evtName of events) {
                view.delegate(evtName).to(dest);
              }
            });
            this.on("remove", (evt, view) => {
              for (const evtName of events) {
                view.stopDelegating(evtName, dest);
              }
            });
          }
        };
      }
      /**
      * This method {@link module:ui/view~View#render renders} a new view added to the collection.
      *
      * If the {@link #_parentElement parent element} of the collection is set, this method also adds
      * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
      *
      * **Note**: If index is not specified, the view's element is pushed as the last child
      * of the parent element.
      *
      * @param view A new view added to the collection.
      * @param index An index the view holds in the collection. When not specified,
      * the view is added at the end.
      */
      _renderViewIntoCollectionParent(view, index2) {
        if (!view.isRendered) {
          view.render();
        }
        if (view.element && this._parentElement) {
          this._parentElement.insertBefore(view.element, this._parentElement.children[index2]);
        }
      }
      /**
      * Removes a child view from the collection. If the {@link #setParent parent element} of the
      * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
      * in DOM, reflecting the order of the collection.
      *
      * See the {@link #add} method.
      *
      * @param subject The view to remove, its id or index in the collection.
      * @returns The removed view.
      */
      remove(subject) {
        return super.remove(subject);
      }
    }
    function isStringArray(arr) {
      return arr.every((a) => typeof a == "string");
    }
    const xhtmlNs = "http://www.w3.org/1999/xhtml";
    class Template extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the {@link ~Template} class.
      *
      * @param def The definition of the template.
      */
      constructor(def) {
        super();
        __publicField(this, "ns");
        /**
        * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template
        * renders to an HTML element.
        */
        __publicField(this, "tag");
        /**
        * The text of the template. It also indicates that the template renders to a DOM text node.
        */
        __publicField(this, "text");
        /**
        * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with
        * the attributes of an HTML element.
        *
        * **Note**: This property only makes sense when {@link #tag} is defined.
        */
        __publicField(this, "attributes");
        /**
        * The children of the template. They can be either:
        * * independent instances of {@link ~Template} (sub–templates),
        * * native DOM Nodes.
        *
        * **Note**: This property only makes sense when {@link #tag} is defined.
        */
        __publicField(this, "children");
        /**
        * The DOM event listeners of the template.
        */
        __publicField(this, "eventListeners");
        /**
        * Indicates whether this particular Template instance has been
        * {@link #render rendered}.
        */
        __publicField(this, "_isRendered");
        /**
        * The data used by the {@link #revert} method to restore a node to its original state.
        *
        * See: {@link #apply}.
        */
        __publicField(this, "_revertData");
        Object.assign(this, normalize(clone(def)));
        this._isRendered = false;
        this._revertData = null;
      }
      /**
      * Renders a DOM Node (an HTML element or text) out of the template.
      *
      * ```ts
      * const domNode = new Template( { ... } ).render();
      * ```
      *
      * See: {@link #apply}.
      */
      render() {
        const node = this._renderNode({
          intoFragment: true
        });
        this._isRendered = true;
        return node;
      }
      /**
      * Applies the template to an existing DOM Node, either HTML element or text.
      *
      * **Note:** No new DOM nodes will be created. Applying extends:
      *
      * {@link module:ui/template~TemplateDefinition attributes},
      * {@link module:ui/template~TemplateDefinition event listeners}, and
      * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
      *
      * **Note:** Existing `class` and `style` attributes are extended when a template
      * is applied to an HTML element, while other attributes and `textContent` are overridden.
      *
      * **Note:** The process of applying a template can be easily reverted using the
      * {@link module:ui/template~Template#revert} method.
      *
      * ```ts
      * const element = document.createElement( 'div' );
      * const observable = new Model( { divClass: 'my-div' } );
      * const emitter = Object.create( EmitterMixin );
      * const bind = Template.bind( observable, emitter );
      *
      * new Template( {
      * 	attributes: {
      * 		id: 'first-div',
      * 		class: bind.to( 'divClass' )
      * 	},
      * 	on: {
      * 		click: bind( 'elementClicked' ) // Will be fired by the observable.
      * 	},
      * 	children: [
      * 		'Div text.'
      * 	]
      * } ).apply( element );
      *
      * console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
      * ```
      *
      * @see module:ui/template~Template#render
      * @see module:ui/template~Template#revert
      * @param node Root node for the template to apply.
      */
      apply(node) {
        this._revertData = getEmptyRevertData();
        this._renderNode({
          node,
          intoFragment: false,
          isApplying: true,
          revertData: this._revertData
        });
        return node;
      }
      /**
      * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
      *
      * @param node The root node for the template to revert. In most of the cases, it is the
      * same node used by {@link module:ui/template~Template#apply}.
      */
      revert(node) {
        if (!this._revertData) {
          throw new CKEditorError("ui-template-revert-not-applied", [
            this,
            node
          ]);
        }
        this._revertTemplateFromNode(node, this._revertData);
      }
      /**
      * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
      * instances and returns them one by one.
      *
      * ```ts
      * const viewFoo = new View();
      * const viewBar = new View();
      * const viewBaz = new View();
      * const template = new Template( {
      * 	tag: 'div',
      * 	children: [
      * 		viewFoo,
      * 		{
      * 			tag: 'div',
      * 			children: [
      * 				viewBar
      * 			]
      * 		},
      * 		viewBaz
      * 	]
      * } );
      *
      * // Logs: viewFoo, viewBar, viewBaz
      * for ( const view of template.getViews() ) {
      * 	console.log( view );
      * }
      * ```
      */
      *getViews() {
        function* search(def) {
          if (def.children) {
            for (const child of def.children) {
              if (isView(child)) {
                yield child;
              } else if (isTemplate(child)) {
                yield* search(child);
              }
            }
          }
        }
        yield* search(this);
      }
      /**
      * An entry point to the interface which binds DOM nodes to
      * {@link module:utils/observablemixin~Observable observables}.
      * There are two types of bindings:
      *
      * * HTML element attributes or text `textContent` synchronized with attributes of an
      * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
      * and {@link module:ui/template~BindChain#if}.
      *
      * ```ts
      * const bind = Template.bind( observable, emitter );
      *
      * new Template( {
      * 	attributes: {
      * 		// Binds the element "class" attribute to observable#classAttribute.
      * 		class: bind.to( 'classAttribute' )
      * 	}
      * } ).render();
      * ```
      *
      * * DOM events fired on HTML element propagated through
      * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
      *
      * ```ts
      * const bind = Template.bind( observable, emitter );
      *
      * new Template( {
      * 	on: {
      * 		// Will be fired by the observable.
      * 		click: bind( 'elementClicked' )
      * 	}
      * } ).render();
      * ```
      *
      * Also see {@link module:ui/view~View#bindTemplate}.
      *
      * @param observable An observable which provides boundable attributes.
      * @param emitter An emitter that listens to observable attribute
      * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
      */
      static bind(observable, emitter) {
        return {
          to(eventNameOrFunctionOrAttribute, callback) {
            return new TemplateToBinding({
              eventNameOrFunction: eventNameOrFunctionOrAttribute,
              attribute: eventNameOrFunctionOrAttribute,
              observable,
              emitter,
              callback
            });
          },
          if(attribute, valueIfTrue, callback) {
            return new TemplateIfBinding({
              observable,
              emitter,
              attribute,
              valueIfTrue,
              callback
            });
          }
        };
      }
      /**
      * Extends an existing {@link module:ui/template~Template} instance with some additional content
      * from another {@link module:ui/template~TemplateDefinition}.
      *
      * ```ts
      * const bind = Template.bind( observable, emitter );
      *
      * const template = new Template( {
      * 	tag: 'p',
      * 	attributes: {
      * 		class: 'a',
      * 		data-x: bind.to( 'foo' )
      * 	},
      * 	children: [
      * 		{
      * 			tag: 'span',
      * 			attributes: {
      * 				class: 'b'
      * 			},
      * 			children: [
      * 				'Span'
      * 			]
      * 		}
      * 	]
      *  } );
      *
      * // Instance-level extension.
      * Template.extend( template, {
      * 	attributes: {
      * 		class: 'b',
      * 		data-x: bind.to( 'bar' )
      * 	},
      * 	children: [
      * 		{
      * 			attributes: {
      * 				class: 'c'
      * 			}
      * 		}
      * 	]
      * } );
      *
      * // Child extension.
      * Template.extend( template.children[ 0 ], {
      * 	attributes: {
      * 		class: 'd'
      * 	}
      * } );
      * ```
      *
      * the `outerHTML` of `template.render()` is:
      *
      * ```html
      * <p class="a b" data-x="{ observable.foo } { observable.bar }">
      * 	<span class="b c d">Span</span>
      * </p>
      * ```
      *
      * @param template An existing template instance to be extended.
      * @param def Additional definition to be applied to a template.
      */
      static extend(template, def) {
        if (template._isRendered) {
          throw new CKEditorError("template-extend-render", [
            this,
            template
          ]);
        }
        extendTemplate(template, normalize(clone(def)));
      }
      /**
      * Renders a DOM Node (either an HTML element or text) out of the template.
      *
      * @param data Rendering data.
      */
      _renderNode(data) {
        let isInvalid;
        if (data.node) {
          isInvalid = this.tag && this.text;
        } else {
          isInvalid = this.tag ? this.text : !this.text;
        }
        if (isInvalid) {
          throw new CKEditorError("ui-template-wrong-syntax", this);
        }
        if (this.text) {
          return this._renderText(data);
        } else {
          return this._renderElement(data);
        }
      }
      /**
      * Renders an HTML element out of the template.
      *
      * @param data Rendering data.
      */
      _renderElement(data) {
        let node = data.node;
        if (!node) {
          node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
        }
        this._renderAttributes(data);
        this._renderElementChildren(data);
        this._setUpListeners(data);
        return node;
      }
      /**
      * Renders a text node out of {@link module:ui/template~Template#text}.
      *
      * @param data Rendering data.
      */
      _renderText(data) {
        let node = data.node;
        if (node) {
          data.revertData.text = node.textContent;
        } else {
          node = data.node = document.createTextNode("");
        }
        if (hasTemplateBinding(this.text)) {
          this._bindToObservable({
            schema: this.text,
            updater: getTextUpdater(node),
            data
          });
        } else {
          node.textContent = this.text.join("");
        }
        return node;
      }
      /**
      * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
      *
      * @param data Rendering data.
      */
      _renderAttributes(data) {
        if (!this.attributes) {
          return;
        }
        const node = data.node;
        const revertData = data.revertData;
        for (const attrName in this.attributes) {
          const domAttrValue = node.getAttribute(attrName);
          const attrValue = this.attributes[attrName];
          if (revertData) {
            revertData.attributes[attrName] = domAttrValue;
          }
          const attrNs = isNamespaced(attrValue) ? attrValue[0].ns : null;
          if (hasTemplateBinding(attrValue)) {
            const valueToBind = isNamespaced(attrValue) ? attrValue[0].value : attrValue;
            if (revertData && shouldExtend(attrName)) {
              valueToBind.unshift(domAttrValue);
            }
            this._bindToObservable({
              schema: valueToBind,
              updater: getAttributeUpdater(node, attrName, attrNs),
              data
            });
          } else if (attrName == "style" && typeof attrValue[0] !== "string") {
            this._renderStyleAttribute(attrValue[0], data);
          } else {
            if (revertData && domAttrValue && shouldExtend(attrName)) {
              attrValue.unshift(domAttrValue);
            }
            const value = attrValue.map((val) => val ? val.value || val : val).reduce((prev, next) => prev.concat(next), []).reduce(arrayValueReducer, "");
            if (!isFalsy(value)) {
              node.setAttributeNS(attrNs, attrName, value);
            }
          }
        }
      }
      /**
      * Renders the `style` attribute of an HTML element based on
      * {@link module:ui/template~Template#attributes}.
      *
      * A style attribute is an object with static values:
      *
      * ```ts
      * attributes: {
      * 	style: {
      * 		color: 'red'
      * 	}
      * }
      * ```
      *
      * or values bound to {@link module:ui/model~Model} properties:
      *
      * ```ts
      * attributes: {
      * 	style: {
      * 		color: bind.to( ... )
      * 	}
      * }
      * ```
      *
      * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
      * needed.
      *
      * @param styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
      * @param data Rendering data.
      */
      _renderStyleAttribute(styles, data) {
        const node = data.node;
        for (const styleName in styles) {
          const styleValue = styles[styleName];
          if (hasTemplateBinding(styleValue)) {
            this._bindToObservable({
              schema: [
                styleValue
              ],
              updater: getStyleUpdater(node, styleName),
              data
            });
          } else {
            node.style[styleName] = styleValue;
          }
        }
      }
      /**
      * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
      *
      * @param data Rendering data.
      */
      _renderElementChildren(data) {
        const node = data.node;
        const container = data.intoFragment ? document.createDocumentFragment() : node;
        const isApplying = data.isApplying;
        let childIndex = 0;
        for (const child of this.children) {
          if (isViewCollection(child)) {
            if (!isApplying) {
              child.setParent(node);
              for (const view of child) {
                container.appendChild(view.element);
              }
            }
          } else if (isView(child)) {
            if (!isApplying) {
              if (!child.isRendered) {
                child.render();
              }
              container.appendChild(child.element);
            }
          } else if (isNode(child)) {
            container.appendChild(child);
          } else {
            if (isApplying) {
              const revertData = data.revertData;
              const childRevertData = getEmptyRevertData();
              revertData.children.push(childRevertData);
              child._renderNode({
                intoFragment: false,
                node: container.childNodes[childIndex++],
                isApplying: true,
                revertData: childRevertData
              });
            } else {
              container.appendChild(child.render());
            }
          }
        }
        if (data.intoFragment) {
          node.appendChild(container);
        }
      }
      /**
      * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
      * on an HTML element.
      *
      * @param data Rendering data.
      */
      _setUpListeners(data) {
        if (!this.eventListeners) {
          return;
        }
        for (const key in this.eventListeners) {
          const revertBindings = this.eventListeners[key].map((schemaItem) => {
            const [domEvtName, domSelector] = key.split("@");
            return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
          });
          if (data.revertData) {
            data.revertData.bindings.push(revertBindings);
          }
        }
      }
      /**
      * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
      * activates the binding and sets its initial value.
      *
      * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
      * text node `textContent`.
      *
      * @param options Binding options.
      * @param options.updater A function which updates the DOM (like attribute or text).
      * @param options.data Rendering data.
      */
      _bindToObservable({ schema, updater, data }) {
        const revertData = data.revertData;
        syncValueSchemaValue(schema, updater, data);
        const revertBindings = schema.filter((item) => !isFalsy(item)).filter((item) => item.observable).map((templateBinding) => templateBinding.activateAttributeListener(schema, updater, data));
        if (revertData) {
          revertData.bindings.push(revertBindings);
        }
      }
      /**
      * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
      * return it to the original state.
      *
      * @param node A node to be reverted.
      * @param revertData An object that stores information about what changes have been made by
      * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
      */
      _revertTemplateFromNode(node, revertData) {
        for (const binding of revertData.bindings) {
          for (const revertBinding of binding) {
            revertBinding();
          }
        }
        if (revertData.text) {
          node.textContent = revertData.text;
          return;
        }
        const element = node;
        for (const attrName in revertData.attributes) {
          const attrValue = revertData.attributes[attrName];
          if (attrValue === null) {
            element.removeAttribute(attrName);
          } else {
            element.setAttribute(attrName, attrValue);
          }
        }
        for (let i = 0; i < revertData.children.length; ++i) {
          this._revertTemplateFromNode(element.childNodes[i], revertData.children[i]);
        }
      }
    }
    class TemplateBinding {
      /**
      * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
      *
      * @param def The definition of the binding.
      */
      constructor(def) {
        /**
        * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.
        */
        __publicField(this, "attribute");
        /**
        * An observable instance of the binding. It either:
        *
        * * provides the attribute with the value,
        * * or passes the event when a corresponding DOM event is fired.
        */
        __publicField(this, "observable");
        /**
        * An {@link module:utils/emittermixin~Emitter} used by the binding to:
        *
        * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},
        * * or listen to the event in the DOM.
        */
        __publicField(this, "emitter");
        /**
        * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.
        */
        __publicField(this, "callback");
        this.attribute = def.attribute;
        this.observable = def.observable;
        this.emitter = def.emitter;
        this.callback = def.callback;
      }
      /**
      * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
      * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
      * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
      *
      * @param node A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
      * @returns The value of {@link module:ui/template~TemplateBinding#attribute} in
      * {@link module:ui/template~TemplateBinding#observable}.
      */
      getValue(node) {
        const value = this.observable[this.attribute];
        return this.callback ? this.callback(value, node) : value;
      }
      /**
      * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
      * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
      * value of {@link module:ui/template~TemplateValueSchema}.
      *
      * @param schema A full schema to generate an attribute or text in the DOM.
      * @param updater A DOM updater function used to update the native DOM attribute or text.
      * @param data Rendering data.
      * @returns A function to sever the listener binding.
      */
      activateAttributeListener(schema, updater, data) {
        const callback = () => syncValueSchemaValue(schema, updater, data);
        this.emitter.listenTo(this.observable, `change:${this.attribute}`, callback);
        return () => {
          this.emitter.stopListening(this.observable, `change:${this.attribute}`, callback);
        };
      }
    }
    class TemplateToBinding extends TemplateBinding {
      constructor(def) {
        super(def);
        __publicField(this, "eventNameOrFunction");
        this.eventNameOrFunction = def.eventNameOrFunction;
      }
      /**
      * Activates the listener for the native DOM event, which when fired, is propagated by
      * the {@link module:ui/template~TemplateBinding#emitter}.
      *
      * @param domEvtName The name of the native DOM event.
      * @param domSelector The selector in the DOM to filter delegated events.
      * @param data Rendering data.
      * @returns A function to sever the listener binding.
      */
      activateDomEventListener(domEvtName, domSelector, data) {
        const callback = (evt, domEvt) => {
          if (!domSelector || domEvt.target.matches(domSelector)) {
            if (typeof this.eventNameOrFunction == "function") {
              this.eventNameOrFunction(domEvt);
            } else {
              this.observable.fire(this.eventNameOrFunction, domEvt);
            }
          }
        };
        this.emitter.listenTo(data.node, domEvtName, callback);
        return () => {
          this.emitter.stopListening(data.node, domEvtName, callback);
        };
      }
    }
    class TemplateIfBinding extends TemplateBinding {
      constructor(def) {
        super(def);
        /**
        * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in
        * {@link module:ui/template~TemplateBinding#observable} is `true`.
        */
        __publicField(this, "valueIfTrue");
        this.valueIfTrue = def.valueIfTrue;
      }
      /**
      * @inheritDoc
      */
      getValue(node) {
        const value = super.getValue(node);
        return isFalsy(value) ? false : this.valueIfTrue || true;
      }
    }
    function hasTemplateBinding(schema) {
      if (!schema) {
        return false;
      }
      if (schema.value) {
        schema = schema.value;
      }
      if (Array.isArray(schema)) {
        return schema.some(hasTemplateBinding);
      } else if (schema instanceof TemplateBinding) {
        return true;
      }
      return false;
    }
    function getValueSchemaValue(schema, node) {
      return schema.map((schemaItem) => {
        if (schemaItem instanceof TemplateBinding) {
          return schemaItem.getValue(node);
        }
        return schemaItem;
      });
    }
    function syncValueSchemaValue(schema, updater, { node }) {
      const values = getValueSchemaValue(schema, node);
      let value;
      if (schema.length == 1 && schema[0] instanceof TemplateIfBinding) {
        value = values[0];
      } else {
        value = values.reduce(arrayValueReducer, "");
      }
      if (isFalsy(value)) {
        updater.remove();
      } else {
        updater.set(value);
      }
    }
    function getTextUpdater(node) {
      return {
        set(value) {
          node.textContent = value;
        },
        remove() {
          node.textContent = "";
        }
      };
    }
    function getAttributeUpdater(el, attrName, ns) {
      return {
        set(value) {
          el.setAttributeNS(ns, attrName, value);
        },
        remove() {
          el.removeAttributeNS(ns, attrName);
        }
      };
    }
    function getStyleUpdater(el, styleName) {
      return {
        set(value) {
          el.style[styleName] = value;
        },
        remove() {
          el.style[styleName] = null;
        }
      };
    }
    function clone(def) {
      const clone2 = cloneDeepWith(def, (value) => {
        if (value && (value instanceof TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
          return value;
        }
      });
      return clone2;
    }
    function normalize(def) {
      if (typeof def == "string") {
        def = normalizePlainTextDefinition(def);
      } else if (def.text) {
        normalizeTextDefinition(def);
      }
      if (def.on) {
        def.eventListeners = normalizeListeners(def.on);
        delete def.on;
      }
      if (!def.text) {
        if (def.attributes) {
          normalizeAttributes(def.attributes);
        }
        const children = [];
        if (def.children) {
          if (isViewCollection(def.children)) {
            children.push(def.children);
          } else {
            for (const child of def.children) {
              if (isTemplate(child) || isView(child) || isNode(child)) {
                children.push(child);
              } else {
                children.push(new Template(child));
              }
            }
          }
        }
        def.children = children;
      }
      return def;
    }
    function normalizeAttributes(attributes) {
      for (const a in attributes) {
        if (attributes[a].value) {
          attributes[a].value = toArray$1(attributes[a].value);
        }
        arrayify(attributes, a);
      }
    }
    function normalizeListeners(listeners) {
      for (const l in listeners) {
        arrayify(listeners, l);
      }
      return listeners;
    }
    function normalizePlainTextDefinition(def) {
      return {
        text: [
          def
        ]
      };
    }
    function normalizeTextDefinition(def) {
      def.text = toArray$1(def.text);
    }
    function arrayify(obj, key) {
      obj[key] = toArray$1(obj[key]);
    }
    function arrayValueReducer(prev, cur) {
      if (isFalsy(cur)) {
        return prev;
      } else if (isFalsy(prev)) {
        return cur;
      } else {
        return `${prev} ${cur}`;
      }
    }
    function extendObjectValueArray(obj, ext) {
      for (const a in ext) {
        if (obj[a]) {
          obj[a].push(...ext[a]);
        } else {
          obj[a] = ext[a];
        }
      }
    }
    function extendTemplate(template, def) {
      if (def.attributes) {
        if (!template.attributes) {
          template.attributes = {};
        }
        extendObjectValueArray(template.attributes, def.attributes);
      }
      if (def.eventListeners) {
        if (!template.eventListeners) {
          template.eventListeners = {};
        }
        extendObjectValueArray(template.eventListeners, def.eventListeners);
      }
      if (def.text) {
        template.text.push(...def.text);
      }
      if (def.children && def.children.length) {
        if (template.children.length != def.children.length) {
          throw new CKEditorError("ui-template-extend-children-mismatch", template);
        }
        let childIndex = 0;
        for (const childDef of def.children) {
          extendTemplate(template.children[childIndex++], childDef);
        }
      }
    }
    function isFalsy(value) {
      return !value && value !== 0;
    }
    function isView(item) {
      return item instanceof View;
    }
    function isTemplate(item) {
      return item instanceof Template;
    }
    function isViewCollection(item) {
      return item instanceof ViewCollection;
    }
    function isNamespaced(attrValue) {
      return isObject$1(attrValue[0]) && attrValue[0].ns;
    }
    function getEmptyRevertData() {
      return {
        children: [],
        bindings: [],
        attributes: {}
      };
    }
    function shouldExtend(attrName) {
      return attrName == "class" || attrName == "style";
    }
    class View extends (/* @__PURE__ */ DomEmitterMixin(/* @__PURE__ */ ObservableMixin())) {
      /**
      * Creates an instance of the {@link module:ui/view~View} class.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super();
        /**
        * An HTML element of the view. `null` until {@link #render rendered}
        * from the {@link #template}.
        *
        * ```ts
        * class SampleView extends View {
        * 	constructor() {
        * 		super();
        *
        * 		// A template instance the #element will be created from.
        * 		this.setTemplate( {
        * 			tag: 'p'
        *
        * 			// ...
        * 		} );
        * 	}
        * }
        *
        * const view = new SampleView();
        *
        * // Renders the #template.
        * view.render();
        *
        * // Append the HTML element of the view to <body>.
        * document.body.appendChild( view.element );
        * ```
        *
        * **Note**: The element of the view can also be assigned directly:
        *
        * ```ts
        * view.element = document.querySelector( '#my-container' );
        * ```
        */
        __publicField(this, "element");
        /**
        * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.
        *
        * @readonly
        */
        __publicField(this, "isRendered");
        /**
        * A set of tools to localize the user interface.
        *
        * Also see {@link module:core/editor/editor~Editor#locale}.
        *
        * @readonly
        */
        __publicField(this, "locale");
        /**
        * Shorthand for {@link module:utils/locale~Locale#t}.
        *
        * Note: If {@link #locale} instance hasn't been passed to the view this method may not
        * be available.
        *
        * @see module:utils/locale~Locale#t
        */
        __publicField(this, "t");
        /**
        * Template of this view. It provides the {@link #element} representing
        * the view in DOM, which is {@link #render rendered}.
        */
        __publicField(this, "template");
        /**
        * Collections registered with {@link #createCollection}.
        */
        __publicField(this, "_viewCollections");
        /**
        * A collection of view instances, which have been added directly
        * into the {@link module:ui/template~Template#children}.
        */
        __publicField(this, "_unboundChildren");
        /**
        * Cached {@link module:ui/template~BindChain bind chain} object created by the
        * {@link #template}. See {@link #bindTemplate}.
        */
        __publicField(this, "_bindTemplate");
        this.element = null;
        this.isRendered = false;
        this.locale = locale;
        this.t = locale && locale.t;
        this._viewCollections = new Collection();
        this._unboundChildren = this.createCollection();
        this._viewCollections.on("add", (evt, collection) => {
          collection.locale = locale;
          collection.t = locale && locale.t;
        });
        this.decorate("render");
      }
      /**
      * Shorthand for {@link module:ui/template~Template.bind}, a binding
      * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
      *
      * It provides {@link module:ui/template~BindChain#to `to()`} and
      * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
      * observable attributes and attach DOM listeners.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		const bind = this.bindTemplate;
      *
      * 		// These {@link module:utils/observablemixin~Observable observable} attributes will control
      * 		// the state of the view in DOM.
      * 		this.set( {
      * 			elementClass: 'foo',
      * 		 	isEnabled: true
      * 		 } );
      *
      * 		this.setTemplate( {
      * 			tag: 'p',
      *
      * 			attributes: {
      * 				// The class HTML attribute will follow elementClass
      * 				// and isEnabled view attributes.
      * 				class: [
      * 					bind.to( 'elementClass' )
      * 					bind.if( 'isEnabled', 'present-when-enabled' )
      * 				]
      * 			},
      *
      * 			on: {
      * 				// The view will fire the "clicked" event upon clicking <p> in DOM.
      * 				click: bind.to( 'clicked' )
      * 			}
      * 		} );
      * 	}
      * }
      * ```
      */
      get bindTemplate() {
        if (this._bindTemplate) {
          return this._bindTemplate;
        }
        return this._bindTemplate = Template.bind(this, this);
      }
      /**
      * Creates a new collection of views, which can be used as
      * {@link module:ui/template~Template#children} of this view.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		const child = new ChildView( locale );
      * 		this.items = this.createCollection( [ child ] );
       *
      * 		this.setTemplate( {
      * 			tag: 'p',
      *
      * 			// `items` collection will render here.
      * 			children: this.items
      * 		} );
      * 	}
      * }
      *
      * const view = new SampleView( locale );
      * view.render();
      *
      * // It will append <p><child#element></p> to the <body>.
      * document.body.appendChild( view.element );
      * ```
      *
      * @param views Initial views of the collection.
      * @returns A new collection of view instances.
      */
      createCollection(views) {
        const collection = new ViewCollection(views);
        this._viewCollections.add(collection);
        return collection;
      }
      /**
      * Registers a new child view under the view instance. Once registered, a child
      * view is managed by its parent, including {@link #render rendering}
      * and {@link #destroy destruction}.
      *
      * To revert this, use {@link #deregisterChild}.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		this.childA = new SomeChildView( locale );
      * 		this.childB = new SomeChildView( locale );
      *
      * 		this.setTemplate( { tag: 'p' } );
      *
      * 		// Register the children.
      * 		this.registerChild( [ this.childA, this.childB ] );
      * 	}
      *
      * 	render() {
      * 		super.render();
      *
      * 		this.element.appendChild( this.childA.element );
      * 		this.element.appendChild( this.childB.element );
      * 	}
      * }
      *
      * const view = new SampleView( locale );
      *
      * view.render();
      *
      * // Will append <p><childA#element><b></b><childB#element></p>.
      * document.body.appendChild( view.element );
      * ```
      *
      * **Note**: There's no need to add child views if they're already referenced in the
      * {@link #template}:
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor( locale ) {
      * 		super( locale );
      *
      * 		this.childA = new SomeChildView( locale );
      * 		this.childB = new SomeChildView( locale );
      *
      * 		this.setTemplate( {
      * 			tag: 'p',
      *
       * 			// These children will be added automatically. There's no
       * 			// need to call {@link #registerChild} for any of them.
      * 			children: [ this.childA, this.childB ]
      * 		} );
      * 	}
      *
      * 	// ...
      * }
      * ```
      *
      * @param children Children views to be registered.
      */
      registerChild(children) {
        if (!isIterable(children)) {
          children = [
            children
          ];
        }
        for (const child of children) {
          this._unboundChildren.add(child);
        }
      }
      /**
      * The opposite of {@link #registerChild}. Removes a child view from this view instance.
      * Once removed, the child is no longer managed by its parent, e.g. it can safely
      * become a child of another parent view.
      *
      * @see #registerChild
      * @param children Child views to be removed.
      */
      deregisterChild(children) {
        if (!isIterable(children)) {
          children = [
            children
          ];
        }
        for (const child of children) {
          this._unboundChildren.remove(child);
        }
      }
      /**
      * Sets the {@link #template} of the view with with given definition.
      *
      * A shorthand for:
      *
      * ```ts
      * view.setTemplate( definition );
      * ```
      *
      * @param definition Definition of view's template.
      */
      setTemplate(definition) {
        this.template = new Template(definition);
      }
      /**
      * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
      * with given definition.
      *
      * A shorthand for:
      *
      * ```ts
      * Template.extend( view.template, definition );
      * ```
      *
      * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
      *
      * @param definition Definition which extends the {@link #template}.
      */
      extendTemplate(definition) {
        Template.extend(this.template, definition);
      }
      /**
      * Recursively renders the view.
      *
      * Once the view is rendered:
      * * the {@link #element} becomes an HTML element out of {@link #template},
      * * the {@link #isRendered} flag is set `true`.
      *
      * **Note**: The children of the view:
      * * defined directly in the {@link #template}
      * * residing in collections created by the {@link #createCollection} method,
      * * and added by {@link #registerChild}
      * are also rendered in the process.
      *
      * In general, `render()` method is the right place to keep the code which refers to the
      * {@link #element} and should be executed at the very beginning of the view's life cycle.
      *
      * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
      * the view is rendered. To allow an early customization of the view (e.g. by its parent),
      * such references should be done in `render()`.
      *
      * ```ts
      * class SampleView extends View {
      * 	constructor() {
      * 		this.setTemplate( {
      * 			// ...
      * 		} );
      * 	},
      *
      * 	render() {
      * 		// View#element becomes available.
      * 		super.render();
      *
      * 		// The "scroll" listener depends on #element.
      * 		this.listenTo( window, 'scroll', () => {
      * 			// A reference to #element would render the #template and make it non-extendable.
      * 			if ( window.scrollY > 0 ) {
      * 				this.element.scrollLeft = 100;
      * 			} else {
      * 				this.element.scrollLeft = 0;
      * 			}
      * 		} );
      * 	}
      * }
      *
      * const view = new SampleView();
      *
      * // Let's customize the view before it gets rendered.
      * view.extendTemplate( {
      * 	attributes: {
      * 		class: [
      * 			'additional-class'
      * 		]
      * 	}
      * } );
      *
      * // Late rendering allows customization of the view.
      * view.render();
      * ```
      */
      render() {
        if (this.isRendered) {
          throw new CKEditorError("ui-view-render-already-rendered", this);
        }
        if (this.template) {
          this.element = this.template.render();
          this.registerChild(this.template.getViews());
        }
        this.isRendered = true;
      }
      /**
      * Recursively destroys the view instance and child views added by {@link #registerChild} and
      * residing in collections created by the {@link #createCollection}.
      *
      * Destruction disables all event listeners:
      * * created on the view, e.g. `view.on( 'event', () => {} )`,
      * * defined in the {@link #template} for DOM events.
      */
      destroy() {
        this.stopListening();
        this._viewCollections.map((c) => c.destroy());
        if (this.template && this.template._revertData) {
          this.template.revert(this.element);
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function clickOutsideHandler({ emitter, activator, callback, contextElements }) {
      emitter.listenTo(document, "mousedown", (evt, domEvt) => {
        if (!activator()) {
          return;
        }
        const path = typeof domEvt.composedPath == "function" ? domEvt.composedPath() : [];
        const contextElementsList = typeof contextElements == "function" ? contextElements() : contextElements;
        for (const contextElement of contextElementsList) {
          if (contextElement.contains(domEvt.target) || path.includes(contextElement)) {
            return;
          }
        }
        callback();
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function CssTransitionDisablerMixin(view) {
      class Mixin extends view {
        disableCssTransitions() {
          this._isCssTransitionsDisabled = true;
        }
        enableCssTransitions() {
          this._isCssTransitionsDisabled = false;
        }
        constructor(...args) {
          super(...args);
          this.set("_isCssTransitionsDisabled", false);
          this.initializeCssTransitionDisablerMixin();
        }
        initializeCssTransitionDisablerMixin() {
          this.extendTemplate({
            attributes: {
              class: [
                this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")
              ]
            }
          });
        }
      }
      return Mixin;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function submitHandler({ view }) {
      view.listenTo(view.element, "submit", (evt, domEvt) => {
        domEvt.preventDefault();
        view.fire("submit");
      }, {
        useCapture: true
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function addKeyboardHandlingForGrid({ keystrokeHandler, focusTracker, gridItems, numberOfColumns, uiLanguageDirection }) {
      const getNumberOfColumns = typeof numberOfColumns === "number" ? () => numberOfColumns : numberOfColumns;
      keystrokeHandler.set("arrowright", getGridItemFocuser((focusedElementIndex, gridItems2) => {
        return uiLanguageDirection === "rtl" ? getLeftElementIndex(focusedElementIndex, gridItems2.length) : getRightElementIndex(focusedElementIndex, gridItems2.length);
      }));
      keystrokeHandler.set("arrowleft", getGridItemFocuser((focusedElementIndex, gridItems2) => {
        return uiLanguageDirection === "rtl" ? getRightElementIndex(focusedElementIndex, gridItems2.length) : getLeftElementIndex(focusedElementIndex, gridItems2.length);
      }));
      keystrokeHandler.set("arrowup", getGridItemFocuser((focusedElementIndex, gridItems2) => {
        let nextIndex = focusedElementIndex - getNumberOfColumns();
        if (nextIndex < 0) {
          nextIndex = focusedElementIndex + getNumberOfColumns() * Math.floor(gridItems2.length / getNumberOfColumns());
          if (nextIndex > gridItems2.length - 1) {
            nextIndex -= getNumberOfColumns();
          }
        }
        return nextIndex;
      }));
      keystrokeHandler.set("arrowdown", getGridItemFocuser((focusedElementIndex, gridItems2) => {
        let nextIndex = focusedElementIndex + getNumberOfColumns();
        if (nextIndex > gridItems2.length - 1) {
          nextIndex = focusedElementIndex % getNumberOfColumns();
        }
        return nextIndex;
      }));
      function getGridItemFocuser(getIndexToFocus) {
        return (evt) => {
          const focusedElement = gridItems.find((item) => item.element === focusTracker.focusedElement);
          const focusedElementIndex = gridItems.getIndex(focusedElement);
          const nextIndexToFocus = getIndexToFocus(focusedElementIndex, gridItems);
          gridItems.get(nextIndexToFocus).focus();
          evt.stopPropagation();
          evt.preventDefault();
        };
      }
      function getRightElementIndex(elementIndex, collectionLength) {
        if (elementIndex === collectionLength - 1) {
          return 0;
        } else {
          return elementIndex + 1;
        }
      }
      function getLeftElementIndex(elementIndex, collectionLength) {
        if (elementIndex === 0) {
          return collectionLength - 1;
        } else {
          return elementIndex - 1;
        }
      }
    }
    const _IconView = class _IconView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        const bind = this.bindTemplate;
        this.set("content", "");
        this.set("viewBox", "0 0 20 20");
        this.set("fillColor", "");
        this.set("isColorInherited", true);
        this.set("isVisible", true);
        this.setTemplate({
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          attributes: {
            class: [
              "ck",
              "ck-icon",
              bind.if("isVisible", "ck-hidden", (value) => !value),
              // Exclude icon internals from the CSS reset to allow rich (non-monochromatic) icons
              // (https://github.com/ckeditor/ckeditor5/issues/12599).
              "ck-reset_all-excluded",
              // The class to remove the dynamic color inheritance is toggleable
              // (https://github.com/ckeditor/ckeditor5/issues/12599).
              bind.if("isColorInherited", "ck-icon_inherit-color")
            ],
            viewBox: bind.to("viewBox")
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this._updateXMLContent();
        this._colorFillPaths();
        this.on("change:content", () => {
          this._updateXMLContent();
          this._colorFillPaths();
        });
        this.on("change:fillColor", () => {
          this._colorFillPaths();
        });
      }
      /**
      * Updates the {@link #element} with the value of {@link #content}.
      */
      _updateXMLContent() {
        if (this.content) {
          const parsed = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml");
          const svg = parsed.querySelector("svg");
          const viewBox = svg.getAttribute("viewBox");
          if (viewBox) {
            this.viewBox = viewBox;
          }
          for (const { name, value } of Array.from(svg.attributes)) {
            if (_IconView.presentationalAttributeNames.includes(name)) {
              this.element.setAttribute(name, value);
            }
          }
          while (this.element.firstChild) {
            this.element.removeChild(this.element.firstChild);
          }
          while (svg.childNodes.length > 0) {
            this.element.appendChild(svg.childNodes[0]);
          }
        }
      }
      /**
      * Fills all child `path.ck-icon__fill` with the `#fillColor`.
      */
      _colorFillPaths() {
        if (this.fillColor) {
          this.element.querySelectorAll(".ck-icon__fill").forEach((path) => {
            path.style.fill = this.fillColor;
          });
        }
      }
    };
    /**
    * A list of presentational attributes that can be set on the `<svg>` element and should be preserved
    * when the icon {@link module:ui/icon/iconview~IconView#content content} is loaded.
    *
    * See the [specification](https://www.w3.org/TR/SVG/styling.html#TermPresentationAttribute) to learn more.
    */
    __publicField(_IconView, "presentationalAttributeNames", [
      "alignment-baseline",
      "baseline-shift",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-rendering",
      "cursor",
      "direction",
      "display",
      "dominant-baseline",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask",
      "opacity",
      "overflow",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-overflow",
      "text-rendering",
      "transform",
      "unicode-bidi",
      "vector-effect",
      "visibility",
      "white-space",
      "word-spacing",
      "writing-mode"
    ]);
    let IconView = _IconView;
    class ButtonLabelView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        this.set({
          style: void 0,
          text: void 0,
          id: void 0
        });
        const bind = this.bindTemplate;
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__label"
            ],
            style: bind.to("style"),
            id: bind.to("id")
          },
          children: [
            {
              text: bind.to("text")
            }
          ]
        });
      }
    }
    class ButtonView extends View {
      /**
      * Creates an instance of the button view class.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param labelView The instance of the button's label. If not provided, an instance of
      * {@link module:ui/button/buttonlabelview~ButtonLabelView} is used.
      */
      constructor(locale, labelView = new ButtonLabelView()) {
        super(locale);
        /**
        * Collection of the child views inside of the button {@link #element}.
        */
        __publicField(this, "children");
        /**
        * Label of the button view. Its text is configurable using the {@link #label label attribute}.
        *
        * If not configured otherwise in the `constructor()`, by default the label is an instance
        * of {@link module:ui/button/buttonlabelview~ButtonLabelView}.
        */
        __publicField(this, "labelView");
        /**
        * The icon view of the button. Will be added to {@link #children} when the
        * {@link #icon icon attribute} is defined.
        */
        __publicField(this, "iconView");
        /**
        * A view displaying the keystroke of the button next to the {@link #labelView label}.
        * Added to {@link #children} when the {@link #withKeystroke `withKeystroke` attribute}
        * is defined.
        */
        __publicField(this, "keystrokeView");
        /**
        * Delayed focus function for focus handling in Safari.
        */
        __publicField(this, "_focusDelayed", null);
        const bind = this.bindTemplate;
        const ariaLabelUid = uid();
        this.set("ariaLabel", void 0);
        this.set("ariaLabelledBy", `ck-editor__aria-label_${ariaLabelUid}`);
        this.set("class", void 0);
        this.set("labelStyle", void 0);
        this.set("icon", void 0);
        this.set("isEnabled", true);
        this.set("isOn", false);
        this.set("isVisible", true);
        this.set("isToggleable", false);
        this.set("keystroke", void 0);
        this.set("label", void 0);
        this.set("role", void 0);
        this.set("tabindex", -1);
        this.set("tooltip", false);
        this.set("tooltipPosition", "s");
        this.set("type", "button");
        this.set("withText", false);
        this.set("withKeystroke", false);
        this.children = this.createCollection();
        this.labelView = this._setupLabelView(labelView);
        this.iconView = new IconView();
        this.iconView.extendTemplate({
          attributes: {
            class: "ck-button__icon"
          }
        });
        this.keystrokeView = this._createKeystrokeView();
        this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
        const template = {
          tag: "button",
          attributes: {
            class: [
              "ck",
              "ck-button",
              bind.to("class"),
              bind.if("isEnabled", "ck-disabled", (value) => !value),
              bind.if("isVisible", "ck-hidden", (value) => !value),
              bind.to("isOn", (value) => value ? "ck-on" : "ck-off"),
              bind.if("withText", "ck-button_with-text"),
              bind.if("withKeystroke", "ck-button_with-keystroke")
            ],
            role: bind.to("role"),
            type: bind.to("type", (value) => value ? value : "button"),
            tabindex: bind.to("tabindex"),
            "aria-checked": bind.to("ariaChecked"),
            "aria-label": bind.to("ariaLabel"),
            "aria-labelledby": bind.to("ariaLabelledBy"),
            "aria-disabled": bind.if("isEnabled", true, (value) => !value),
            "aria-pressed": bind.to("isOn", (value) => this.isToggleable ? String(!!value) : false),
            "data-cke-tooltip-text": bind.to("_tooltipString"),
            "data-cke-tooltip-position": bind.to("tooltipPosition")
          },
          children: this.children,
          on: {
            click: bind.to((evt) => {
              if (this.isEnabled) {
                this.fire("execute");
              } else {
                evt.preventDefault();
              }
            })
          }
        };
        if (env.isSafari) {
          if (!this._focusDelayed) {
            this._focusDelayed = delay(() => this.focus(), 0);
          }
          template.on.mousedown = bind.to(() => {
            this._focusDelayed();
          });
          template.on.mouseup = bind.to(() => {
            this._focusDelayed.cancel();
          });
        }
        this.setTemplate(template);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        if (this.icon) {
          this.iconView.bind("content").to(this, "icon");
          this.children.add(this.iconView);
        }
        this.children.add(this.labelView);
        if (this.withKeystroke && this.keystroke) {
          this.children.add(this.keystrokeView);
        }
      }
      /**
      * Focuses the {@link #element} of the button.
      */
      focus() {
        this.element.focus();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._focusDelayed) {
          this._focusDelayed.cancel();
        }
        super.destroy();
      }
      /**
      * Binds the label view instance it with button attributes.
      */
      _setupLabelView(labelView) {
        labelView.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy");
        return labelView;
      }
      /**
      * Creates a view that displays a keystroke next to a {@link #labelView label }
      * and binds it with button attributes.
      */
      _createKeystrokeView() {
        const keystrokeView = new View();
        keystrokeView.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__keystroke"
            ]
          },
          children: [
            {
              text: this.bindTemplate.to("keystroke", (text2) => getEnvKeystrokeText(text2))
            }
          ]
        });
        return keystrokeView;
      }
      /**
      * Gets the text for the tooltip from the combination of
      * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
      *
      * @see #tooltip
      * @see #_tooltipString
      * @param tooltip Button tooltip.
      * @param label Button label.
      * @param keystroke Button keystroke.
      */
      _getTooltipString(tooltip, label, keystroke) {
        if (tooltip) {
          if (typeof tooltip == "string") {
            return tooltip;
          } else {
            if (keystroke) {
              keystroke = getEnvKeystrokeText(keystroke);
            }
            if (tooltip instanceof Function) {
              return tooltip(label, keystroke);
            } else {
              return `${label}${keystroke ? ` (${keystroke})` : ""}`;
            }
          }
        }
        return "";
      }
    }
    class FormHeaderView extends View {
      /**
      * Creates an instance of the form header class.
      *
      * @param locale The locale instance.
      * @param options.label A label.
      * @param options.class An additional class.
      */
      constructor(locale, options = {}) {
        super(locale);
        /**
        * A collection of header items.
        */
        __publicField(this, "children");
        /**
        * The icon view instance. Defined only if icon was passed in the constructor's options.
        */
        __publicField(this, "iconView");
        const bind = this.bindTemplate;
        this.set("label", options.label || "");
        this.set("class", options.class || null);
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-form__header",
              bind.to("class")
            ]
          },
          children: this.children
        });
        if (options.icon) {
          this.iconView = new IconView();
          this.iconView.content = options.icon;
          this.children.add(this.iconView);
        }
        const label = new View(locale);
        label.setTemplate({
          tag: "h2",
          attributes: {
            class: [
              "ck",
              "ck-form__header__label"
            ],
            role: "presentation"
          },
          children: [
            {
              text: bind.to("label")
            }
          ]
        });
        this.children.add(label);
      }
    }
    class FocusCycler extends (/* @__PURE__ */ EmitterMixin()) {
      /**
      * Creates an instance of the focus cycler utility.
      *
      * @param options Configuration options.
      */
      constructor(options) {
        super();
        /**
        * A {@link module:ui/focuscycler~FocusableView focusable views} collection that the cycler operates on.
        */
        __publicField(this, "focusables");
        /**
        * A focus tracker instance that the cycler uses to determine the current focus
        * state in {@link #focusables}.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
        * which can respond to certain keystrokes and cycle the focus.
        */
        __publicField(this, "keystrokeHandler");
        /**
        * Actions that the cycler can take when a keystroke is pressed. Requires
        * `options.keystrokeHandler` to be passed and working. When an action is
        * performed, `preventDefault` and `stopPropagation` will be called on the event
        * the keystroke fired in the DOM.
        *
        * ```ts
        * actions: {
        * 	// Will call #focusPrevious() when arrowleft or arrowup is pressed.
        * 	focusPrevious: [ 'arrowleft', 'arrowup' ],
        *
        * 	// Will call #focusNext() when arrowdown is pressed.
        * 	focusNext: 'arrowdown'
        * }
        * ```
        */
        __publicField(this, "actions");
        this.focusables = options.focusables;
        this.focusTracker = options.focusTracker;
        this.keystrokeHandler = options.keystrokeHandler;
        this.actions = options.actions;
        if (options.actions && options.keystrokeHandler) {
          for (const methodName in options.actions) {
            let actions = options.actions[methodName];
            if (typeof actions == "string") {
              actions = [
                actions
              ];
            }
            for (const keystroke of actions) {
              options.keystrokeHandler.set(keystroke, (data, cancel2) => {
                this[methodName]();
                cancel2();
              });
            }
          }
        }
        this.on("forwardCycle", () => this.focusFirst(), {
          priority: "low"
        });
        this.on("backwardCycle", () => this.focusLast(), {
          priority: "low"
        });
      }
      /**
      * Returns the first focusable view in {@link #focusables}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get first() {
        return this.focusables.find(isDomFocusable) || null;
      }
      /**
      * Returns the last focusable view in {@link #focusables}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get last() {
        return this.focusables.filter(isDomFocusable).slice(-1)[0] || null;
      }
      /**
      * Returns the next focusable view in {@link #focusables} based on {@link #current}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get next() {
        return this._getDomFocusableItem(1);
      }
      /**
      * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
      * Returns `null` if there is none.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      get previous() {
        return this._getDomFocusableItem(-1);
      }
      /**
      * An index of the view in the {@link #focusables} which is focused according
      * to {@link #focusTracker}. Returns `null` when there is no such view.
      */
      get current() {
        let index2 = null;
        if (this.focusTracker.focusedElement === null) {
          return null;
        }
        this.focusables.find((view, viewIndex) => {
          const focused = view.element === this.focusTracker.focusedElement;
          if (focused) {
            index2 = viewIndex;
          }
          return focused;
        });
        return index2;
      }
      /**
      * Focuses the {@link #first} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusFirst() {
        this._focus(this.first, 1);
      }
      /**
      * Focuses the {@link #last} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusLast() {
        this._focus(this.last, -1);
      }
      /**
      * Focuses the {@link #next} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusNext() {
        const next = this.next;
        if (next && this.focusables.getIndex(next) === this.current) {
          this.fire("forwardCycle");
          return;
        }
        if (next === this.first) {
          this.fire("forwardCycle");
        } else {
          this._focus(next, 1);
        }
      }
      /**
      * Focuses the {@link #previous} item in {@link #focusables}.
      *
      * **Note**: Hidden views (e.g. with `display: none`) are ignored.
      */
      focusPrevious() {
        const previous = this.previous;
        if (previous && this.focusables.getIndex(previous) === this.current) {
          this.fire("backwardCycle");
          return;
        }
        if (previous === this.last) {
          this.fire("backwardCycle");
        } else {
          this._focus(previous, -1);
        }
      }
      /**
      * Focuses the given view if it exists.
      *
      * @param view The view to be focused
      * @param direction The direction of the focus if the view has focusable children.
      * @returns
      */
      _focus(view, direction) {
        if (view && this.focusTracker.focusedElement !== view.element) {
          view.focus(direction);
        }
      }
      /**
      * Returns the next or previous focusable view in {@link #focusables} with respect
      * to {@link #current}.
      *
      * @param step Either `1` for checking forward from {@link #current} or `-1` for checking backwards.
      */
      _getDomFocusableItem(step) {
        const collectionLength = this.focusables.length;
        if (!collectionLength) {
          return null;
        }
        const current = this.current;
        if (current === null) {
          return this[step === 1 ? "first" : "last"];
        }
        let focusableItem = this.focusables.get(current);
        let index2 = (current + collectionLength + step) % collectionLength;
        do {
          const focusableItemCandidate = this.focusables.get(index2);
          if (isDomFocusable(focusableItemCandidate)) {
            focusableItem = focusableItemCandidate;
            break;
          }
          index2 = (index2 + collectionLength + step) % collectionLength;
        } while (index2 !== current);
        return focusableItem;
      }
    }
    function isDomFocusable(view) {
      return isFocusable(view) && isVisible(view.element);
    }
    function isFocusable(view) {
      return !!("focus" in view && typeof view.focus == "function");
    }
    function isViewWithFocusCycler(view) {
      return isFocusable(view) && "focusCycler" in view && view.focusCycler instanceof FocusCycler;
    }
    function DraggableViewMixin(view) {
      class DraggableMixin extends view {
        /**
        * @inheritdoc
        */
        constructor(...args) {
          super(...args);
          /**
          * A bound version of {@link #_onDrag}.
          */
          __publicField(this, "_onDragBound", this._onDrag.bind(this));
          /**
          * A bound version of {@link #_onDragEnd}.
          */
          __publicField(this, "_onDragEndBound", this._onDragEnd.bind(this));
          /**
          * The last coordinates of the view. It is updated on every mouse move.
          */
          __publicField(this, "_lastDraggingCoordinates", {
            x: 0,
            y: 0
          });
          this.on("render", () => {
            this._attachListeners();
          });
          this.set("isDragging", false);
        }
        /**
        * Attaches the listeners for the drag start.
        */
        _attachListeners() {
          this.listenTo(this.element, "mousedown", this._onDragStart.bind(this));
          this.listenTo(this.element, "touchstart", this._onDragStart.bind(this));
        }
        /**
        * Attaches the listeners for the dragging and drag end.
        */
        _attachDragListeners() {
          this.listenTo(global$1.document, "mouseup", this._onDragEndBound);
          this.listenTo(global$1.document, "touchend", this._onDragEndBound);
          this.listenTo(global$1.document, "mousemove", this._onDragBound);
          this.listenTo(global$1.document, "touchmove", this._onDragBound);
        }
        /**
        * Detaches the listeners after the drag end.
        */
        _detachDragListeners() {
          this.stopListening(global$1.document, "mouseup", this._onDragEndBound);
          this.stopListening(global$1.document, "touchend", this._onDragEndBound);
          this.stopListening(global$1.document, "mousemove", this._onDragBound);
          this.stopListening(global$1.document, "touchmove", this._onDragBound);
        }
        /**
        * Starts the dragging listeners and sets the initial view coordinates.
        */
        _onDragStart(evt, domEvt) {
          if (!this._isHandleElementPressed(domEvt)) {
            return;
          }
          this._attachDragListeners();
          let x = 0;
          let y = 0;
          if (domEvt instanceof MouseEvent) {
            x = domEvt.clientX;
            y = domEvt.clientY;
          } else {
            x = domEvt.touches[0].clientX;
            y = domEvt.touches[0].clientY;
          }
          this._lastDraggingCoordinates = {
            x,
            y
          };
          this.isDragging = true;
        }
        /**
        * Updates the view coordinates and fires the `drag` event.
        */
        _onDrag(evt, domEvt) {
          if (!this.isDragging) {
            this._detachDragListeners();
            return;
          }
          let newX = 0;
          let newY = 0;
          if (domEvt instanceof MouseEvent) {
            newX = domEvt.clientX;
            newY = domEvt.clientY;
          } else {
            newX = domEvt.touches[0].clientX;
            newY = domEvt.touches[0].clientY;
          }
          domEvt.preventDefault();
          this.fire("drag", {
            deltaX: Math.round(newX - this._lastDraggingCoordinates.x),
            deltaY: Math.round(newY - this._lastDraggingCoordinates.y)
          });
          this._lastDraggingCoordinates = {
            x: newX,
            y: newY
          };
        }
        /**
        * Stops the dragging and detaches the listeners.
        */
        _onDragEnd() {
          this._detachDragListeners();
          this.isDragging = false;
        }
        /**
        * Checks if the drag handle element was pressed.
        */
        _isHandleElementPressed(domEvt) {
          if (!this.dragHandleElement) {
            return false;
          }
          return this.dragHandleElement === domEvt.target || domEvt.target instanceof HTMLElement && this.dragHandleElement.contains(domEvt.target);
        }
      }
      return DraggableMixin;
    }
    class DialogActionsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of button views.
        */
        __publicField(this, "children");
        /**
        * A keystroke handler instance.
        */
        __publicField(this, "keystrokes");
        /**
        * A focus cycler instance.
        */
        __publicField(this, "focusCycler");
        /**
        * A focus tracker instance.
        */
        __publicField(this, "_focusTracker");
        /**
        * A collection of focusable views.
        */
        __publicField(this, "_focusables");
        this.children = this.createCollection();
        this.keystrokes = new KeystrokeHandler();
        this._focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this.focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this._focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dialog__actions"
            ]
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Creates the button views based on the given definitions.
      * Then adds them to the {@link #children} collection and to the focus cycler.
      */
      setButtons(definitions) {
        for (const definition of definitions) {
          const button = new ButtonView(this.locale);
          let property2;
          button.on("execute", () => definition.onExecute());
          if (definition.onCreate) {
            definition.onCreate(button);
          }
          for (property2 in definition) {
            if (property2 != "onExecute" && property2 != "onCreate") {
              button.set(property2, definition[property2]);
            }
          }
          this.children.add(button);
        }
        this._updateFocusCyclableItems();
      }
      /**
      * @inheritDoc
      */
      focus(direction) {
        if (direction === -1) {
          this.focusCycler.focusLast();
        } else {
          this.focusCycler.focusFirst();
        }
      }
      /**
      * Adds all elements from the {@link #children} collection to the {@link #_focusables} collection
      * and to the {@link #_focusTracker} instance.
      */
      _updateFocusCyclableItems() {
        Array.from(this.children).forEach((v) => {
          this._focusables.add(v);
          this._focusTracker.add(v.element);
        });
      }
    }
    class DialogContentView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of content items.
        */
        __publicField(this, "children");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dialog__content"
            ]
          },
          children: this.children
        });
      }
      /**
      * Removes all the child views.
      */
      reset() {
        while (this.children.length) {
          this.children.remove(0);
        }
      }
    }
    const DialogViewPosition = {
      SCREEN_CENTER: "screen-center",
      EDITOR_CENTER: "editor-center",
      EDITOR_TOP_SIDE: "editor-top-side",
      EDITOR_TOP_CENTER: "editor-top-center",
      EDITOR_BOTTOM_CENTER: "editor-bottom-center",
      EDITOR_ABOVE_CENTER: "editor-above-center",
      EDITOR_BELOW_CENTER: "editor-below-center"
    };
    const toPx$6 = /* @__PURE__ */ toUnit("px");
    const _DialogView = class _DialogView extends (/* @__PURE__ */ DraggableViewMixin(View)) {
      /**
      * @inheritDoc
      */
      constructor(locale, { getCurrentDomRoot, getViewportOffset }) {
        super(locale);
        /**
        * A collection of the child views inside of the dialog.
        * A dialog can have 3 optional parts: header, content, and actions.
        */
        __publicField(this, "parts");
        /**
        * A header view of the dialog. It is also a drag handle of the dialog.
        */
        __publicField(this, "headerView");
        /**
        * A close button view. It is automatically added to the header view if present.
        */
        __publicField(this, "closeButtonView");
        /**
        * A view with the action buttons available to the user.
        */
        __publicField(this, "actionsView");
        /**
        * A view with the dialog content.
        */
        __publicField(this, "contentView");
        /**
        * A keystroke handler instance.
        */
        __publicField(this, "keystrokes");
        /**
        * A focus tracker instance.
        */
        __publicField(this, "focusTracker");
        /**
        * A flag indicating if the dialog was moved manually. If so, its position
        * will not be updated automatically upon window resize or document scroll.
        */
        __publicField(this, "wasMoved", false);
        /**
        * A callback returning the DOM root that requested the dialog.
        */
        __publicField(this, "_getCurrentDomRoot");
        /**
        * A callback returning the configured editor viewport offset.
        */
        __publicField(this, "_getViewportOffset");
        /**
        * The list of the focusable elements inside the dialog view.
        */
        __publicField(this, "_focusables");
        /**
        * The focus cycler instance.
        */
        __publicField(this, "_focusCycler");
        const bind = this.bindTemplate;
        const t = locale.t;
        this.set("className", "");
        this.set("ariaLabel", t("Editor dialog"));
        this.set("isModal", false);
        this.set("position", DialogViewPosition.SCREEN_CENTER);
        this.set("_isVisible", false);
        this.set("_isTransparent", false);
        this.set("_top", 0);
        this.set("_left", 0);
        this._getCurrentDomRoot = getCurrentDomRoot;
        this._getViewportOffset = getViewportOffset;
        this.decorate("moveTo");
        this.parts = this.createCollection();
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dialog-overlay",
              bind.if("isModal", "ck-dialog-overlay__transparent", (isModal) => !isModal),
              bind.if("_isVisible", "ck-hidden", (value) => !value)
            ],
            // Prevent from editor losing focus when clicking on the modal overlay.
            tabindex: "-1"
          },
          children: [
            {
              tag: "div",
              attributes: {
                tabindex: "-1",
                class: [
                  "ck",
                  "ck-dialog",
                  bind.to("className")
                ],
                role: "dialog",
                "aria-label": bind.to("ariaLabel"),
                style: {
                  top: bind.to("_top", (top) => toPx$6(top)),
                  left: bind.to("_left", (left) => toPx$6(left)),
                  visibility: bind.if("_isTransparent", "hidden")
                }
              },
              children: this.parts
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.keystrokes.set("Esc", (data, cancel2) => {
          this.fire("close", {
            source: "escKeyPress"
          });
          cancel2();
        });
        this.on("drag", (evt, { deltaX, deltaY }) => {
          this.wasMoved = true;
          this.moveBy(deltaX, deltaY);
        });
        this.listenTo(global$1.window, "resize", () => {
          if (this._isVisible && !this.wasMoved) {
            this.updatePosition();
          }
        });
        this.listenTo(global$1.document, "scroll", () => {
          if (this._isVisible && !this.wasMoved) {
            this.updatePosition();
          }
        });
        this.on("change:_isVisible", (evt, name, isVisible2) => {
          if (isVisible2) {
            this._isTransparent = true;
            setTimeout(() => {
              this.updatePosition();
              this._isTransparent = false;
              this.focus();
            }, 10);
          }
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Returns the element that should be used as a drag handle.
      */
      get dragHandleElement() {
        if (this.headerView) {
          return this.headerView.element;
        } else {
          return null;
        }
      }
      /**
      * Creates the dialog parts. Which of them are created depends on the arguments passed to the method.
      * There are no rules regarding the dialog construction, that is, no part is mandatory.
      * Each part can only be created once.
      *
      * @internal
      */
      setupParts({ icon, title, hasCloseButton = true, content, actionButtons }) {
        if (title) {
          this.headerView = new FormHeaderView(this.locale, {
            icon
          });
          if (hasCloseButton) {
            this.closeButtonView = this._createCloseButton();
            this.headerView.children.add(this.closeButtonView);
          }
          this.headerView.label = title;
          this.ariaLabel = title;
          this.parts.add(this.headerView, 0);
        }
        if (content) {
          if (content instanceof View) {
            content = [
              content
            ];
          }
          this.contentView = new DialogContentView(this.locale);
          this.contentView.children.addMany(content);
          this.parts.add(this.contentView);
        }
        if (actionButtons) {
          this.actionsView = new DialogActionsView(this.locale);
          this.actionsView.setButtons(actionButtons);
          this.parts.add(this.actionsView);
        }
        this._updateFocusCyclableItems();
      }
      /**
      * Focuses the first focusable element inside the dialog.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Normalizes the passed coordinates to make sure the dialog view
      * is displayed within the visible viewport and moves it there.
      *
      * @internal
      */
      moveTo(left, top) {
        const viewportRect = this._getViewportRect();
        const dialogRect = this._getDialogRect();
        if (left + dialogRect.width > viewportRect.right) {
          left = viewportRect.right - dialogRect.width;
        }
        if (left < viewportRect.left) {
          left = viewportRect.left;
        }
        if (top < viewportRect.top) {
          top = viewportRect.top;
        }
        this._moveTo(left, top);
      }
      /**
      * Moves the dialog to the specified coordinates.
      */
      _moveTo(left, top) {
        this._left = left;
        this._top = top;
      }
      /**
      * Moves the dialog by the specified offset.
      *
      * @internal
      */
      moveBy(left, top) {
        this.moveTo(this._left + left, this._top + top);
      }
      /**
      * Moves the dialog view to the off-screen position.
      * Used when there is no space to display the dialog.
      */
      _moveOffScreen() {
        this._moveTo(-9999, -9999);
      }
      /**
      * Recalculates the dialog according to the set position and viewport,
      * and moves it to the new position.
      */
      updatePosition() {
        if (!this.element || !this.element.parentNode) {
          return;
        }
        const viewportRect = this._getViewportRect();
        let configuredPosition = this.position;
        let domRootRect;
        if (!this._getCurrentDomRoot()) {
          configuredPosition = DialogViewPosition.SCREEN_CENTER;
        } else {
          domRootRect = this._getVisibleDomRootRect(viewportRect);
        }
        const defaultOffset = _DialogView.defaultOffset;
        const dialogRect = this._getDialogRect();
        switch (configuredPosition) {
          case DialogViewPosition.EDITOR_TOP_SIDE: {
            if (domRootRect) {
              const leftCoordinate = this.locale.contentLanguageDirection === "ltr" ? domRootRect.right - dialogRect.width - defaultOffset : domRootRect.left + defaultOffset;
              this.moveTo(leftCoordinate, domRootRect.top + defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), Math.round(domRootRect.top + domRootRect.height / 2 - dialogRect.height / 2));
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.SCREEN_CENTER: {
            this.moveTo(Math.round((viewportRect.width - dialogRect.width) / 2), Math.round((viewportRect.height - dialogRect.height) / 2));
            break;
          }
          case DialogViewPosition.EDITOR_TOP_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top + defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_BOTTOM_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom - dialogRect.height - defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_ABOVE_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.top - dialogRect.height - defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
          case DialogViewPosition.EDITOR_BELOW_CENTER: {
            if (domRootRect) {
              this.moveTo(Math.round(domRootRect.left + domRootRect.width / 2 - dialogRect.width / 2), domRootRect.bottom + defaultOffset);
            } else {
              this._moveOffScreen();
            }
            break;
          }
        }
      }
      /**
      * Calculates the visible DOM root part.
      */
      _getVisibleDomRootRect(viewportRect) {
        let visibleDomRootRect = new Rect(this._getCurrentDomRoot()).getVisible();
        if (!visibleDomRootRect) {
          return null;
        } else {
          visibleDomRootRect = viewportRect.getIntersection(visibleDomRootRect);
          if (!visibleDomRootRect) {
            return null;
          }
        }
        return visibleDomRootRect;
      }
      /**
      * Calculates the dialog element rect.
      */
      _getDialogRect() {
        return new Rect(this.element.firstElementChild);
      }
      /**
      * Calculates the viewport rect.
      */
      _getViewportRect() {
        return getConstrainedViewportRect(this._getViewportOffset());
      }
      /**
      * Collects all focusable elements inside the dialog parts
      * and adds them to the focus tracker and focus cycler.
      */
      _updateFocusCyclableItems() {
        const focusables = [];
        if (this.contentView) {
          for (const child of this.contentView.children) {
            if (isFocusable(child)) {
              focusables.push(child);
            }
          }
        }
        if (this.actionsView) {
          focusables.push(this.actionsView);
        }
        if (this.closeButtonView) {
          focusables.push(this.closeButtonView);
        }
        focusables.forEach((focusable) => {
          this._focusables.add(focusable);
          this.focusTracker.add(focusable.element);
          if (isViewWithFocusCycler(focusable)) {
            this.listenTo(focusable.focusCycler, "forwardCycle", (evt) => {
              this._focusCycler.focusNext();
              if (this._focusCycler.next !== this._focusCycler.focusables.get(this._focusCycler.current)) {
                evt.stop();
              }
            });
            this.listenTo(focusable.focusCycler, "backwardCycle", (evt) => {
              this._focusCycler.focusPrevious();
              if (this._focusCycler.previous !== this._focusCycler.focusables.get(this._focusCycler.current)) {
                evt.stop();
              }
            });
          }
        });
      }
      /**
      * Creates the close button view that is displayed in the header view corner.
      */
      _createCloseButton() {
        const buttonView = new ButtonView(this.locale);
        const t = this.locale.t;
        buttonView.set({
          label: t("Close"),
          tooltip: true,
          icon: icons.cancel
        });
        buttonView.on("execute", () => this.fire("close", {
          source: "closeButton"
        }));
        return buttonView;
      }
    };
    /**
    * A default dialog element offset from the reference element (e.g. editor editable area).
    */
    __publicField(_DialogView, "defaultOffset", 15);
    let DialogView = _DialogView;
    function getConstrainedViewportRect(viewportOffset) {
      viewportOffset = Object.assign({
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      }, viewportOffset);
      const viewportRect = new Rect(global$1.window);
      viewportRect.top += viewportOffset.top;
      viewportRect.height -= viewportOffset.top;
      viewportRect.bottom -= viewportOffset.bottom;
      viewportRect.height -= viewportOffset.bottom;
      viewportRect.left += viewportOffset.left;
      viewportRect.right -= viewportOffset.right;
      viewportRect.width -= viewportOffset.left + viewportOffset.right;
      return viewportRect;
    }
    const _Dialog = class _Dialog extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The currently visible dialog view instance.
        */
        __publicField(this, "view");
        /**
        * A configurable callback called when the dialog is hidden.
        */
        __publicField(this, "_onHide");
        const t = editor.t;
        this._initShowHideListeners();
        this._initFocusToggler();
        this._initMultiRootIntegration();
        this.set("id", null);
        editor.accessibility.addKeystrokeInfos({
          categoryId: "navigation",
          keystrokes: [
            {
              label: t("Move focus in and out of an active dialog window"),
              keystroke: "Ctrl+F6",
              mayRequireFn: true
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Dialog";
      }
      /**
      * Initiates listeners for the `show` and `hide` events emitted by this plugin.
      *
      * We could not simply decorate the {@link #show} and {@link #hide} methods to fire events,
      * because they would be fired in the wrong order &ndash; first would be `show` and then `hide`
      * (because showing the dialog actually starts with hiding the previously visible one).
      * Hence, we added private methods {@link #_show} and {@link #_hide} which are called on events
      * in the desired sequence.
      */
      _initShowHideListeners() {
        this.on("show", (evt, args) => {
          this._show(args);
        });
        this.on("show", (evt, args) => {
          if (args.onShow) {
            args.onShow(this);
          }
        }, {
          priority: "low"
        });
        this.on("hide", () => {
          if (_Dialog._visibleDialogPlugin) {
            _Dialog._visibleDialogPlugin._hide();
          }
        });
        this.on("hide", () => {
          if (this._onHide) {
            this._onHide(this);
            this._onHide = void 0;
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Initiates keystroke handler for toggling the focus between the editor and the dialog view.
      */
      _initFocusToggler() {
        const editor = this.editor;
        editor.keystrokes.set("Ctrl+F6", (data, cancel2) => {
          if (!this.isOpen || this.view.isModal) {
            return;
          }
          if (this.view.focusTracker.isFocused) {
            editor.editing.view.focus();
          } else {
            this.view.focus();
          }
          cancel2();
        });
      }
      /**
      * Provides an integration between the root attaching and detaching and positioning of the view.
      */
      _initMultiRootIntegration() {
        const model = this.editor.model;
        model.document.on("change:data", () => {
          if (!this.view) {
            return;
          }
          const changedRoots = model.document.differ.getChangedRoots();
          for (const changes of changedRoots) {
            if (changes.state) {
              this.view.updatePosition();
            }
          }
        });
      }
      /**
      * Displays a dialog window.
      *
      * This method requires a {@link ~DialogDefinition} that defines the dialog's content, title, icon, action buttons, etc.
      *
      * For example, the following definition will create a dialog with:
      * * A header consisting of an icon, a title, and a "Close" button (it is added by default).
      * * A content consisting of a view with a single paragraph.
      * * A footer consisting of two buttons: "Yes" and "No".
      *
      * ```js
      * // Create the view that will be used as the dialog's content.
      * const textView = new View( locale );
      *
      * textView.setTemplate( {
      * 	tag: 'div',
      * 	attributes: {
      * 		style: {
      * 			padding: 'var(--ck-spacing-large)',
      * 			whiteSpace: 'initial',
      * 			width: '100%',
      * 			maxWidth: '500px'
      * 		},
      * 		tabindex: -1
      * 	},
      * 	children: [
      * 		'Lorem ipsum dolor sit amet...'
      * 	]
      * } );
      *
      * // Show the dialog.
      * editor.plugins.get( 'Dialog' ).show( {
      *	id: 'myDialog',
      * 	icon: 'myIcon', // This should be an SVG string.
      * 	title: 'My dialog',
      * 	content: textView,
      * 	actionButtons: [
      *		{
      *			label: t( 'Yes' ),
      *			class: 'ck-button-action',
      *			withText: true,
      *			onExecute: () => dialog.hide()
      *		},
      *		{
      *			label: t( 'No' ),
      *			withText: true,
      *			onExecute: () => dialog.hide()
      *		}
      *	]
      * } );
      * ```
      *
      * By specifying the {@link ~DialogDefinition#onShow} and {@link ~DialogDefinition#onHide} callbacks
      * it is also possible to add callbacks that will be called when the dialog is shown or hidden.
      *
      * For example, the callbacks in the following definition:
      * * Disable the default behavior of the <kbd>Esc</kbd> key.
      * * Fire a custom event when the dialog gets hidden.
      *
      * ```js
      * editor.plugins.get( 'Dialog' ).show( {
      * 	// ...
      * 	onShow: dialog => {
      * 		dialog.view.on( 'close', ( evt, data ) => {
      * 			// Only prevent the event from the "Esc" key - do not affect the other ways of closing the dialog.
      * 			if ( data.source === 'escKeyPress' ) {
      * 				evt.stop();
      * 			}
      * 		} );
      * 	},
      * 	onHide: dialog => {
      * 		dialog.fire( 'dialogDestroyed' );
      * 	}
      * } );
      * ```
      *
      * Internally, calling this method:
      * 1. Hides the currently visible dialog (if any) calling the {@link #hide} method
      * (fires the {@link ~DialogHideEvent hide event}).
      * 2. Fires the {@link ~DialogShowEvent show event} which allows for adding callbacks that customize the
      * behavior of the dialog.
      * 3. Shows the dialog.
      */
      show(dialogDefinition) {
        this.hide();
        this.fire(`show:${dialogDefinition.id}`, dialogDefinition);
      }
      /**
      * Handles creating the {@link module:ui/dialog/dialogview~DialogView} instance and making it visible.
      */
      _show({ id, icon, title, hasCloseButton = true, content, actionButtons, className, isModal, position, onHide }) {
        const editor = this.editor;
        this.view = new DialogView(editor.locale, {
          getCurrentDomRoot: () => {
            return editor.editing.view.getDomRoot(editor.model.document.selection.anchor.root.rootName);
          },
          getViewportOffset: () => {
            return editor.ui.viewportOffset;
          }
        });
        const view = this.view;
        view.on("close", () => {
          this.hide();
        });
        editor.ui.view.body.add(view);
        editor.ui.focusTracker.add(view.element);
        editor.keystrokes.listenTo(view.element);
        if (!position) {
          position = isModal ? DialogViewPosition.SCREEN_CENTER : DialogViewPosition.EDITOR_CENTER;
        }
        view.set({
          position,
          _isVisible: true,
          className,
          isModal
        });
        view.setupParts({
          icon,
          title,
          hasCloseButton,
          content,
          actionButtons
        });
        this.id = id;
        if (onHide) {
          this._onHide = onHide;
        }
        this.isOpen = true;
        _Dialog._visibleDialogPlugin = this;
      }
      /**
      * Hides the dialog. This method is decorated to enable interacting on the {@link ~DialogHideEvent hide event}.
      *
      * See {@link #show}.
      */
      hide() {
        if (_Dialog._visibleDialogPlugin) {
          _Dialog._visibleDialogPlugin.fire(`hide:${_Dialog._visibleDialogPlugin.id}`);
        }
      }
      /**
      * Destroys the {@link module:ui/dialog/dialogview~DialogView} and cleans up the stored dialog state.
      */
      _hide() {
        if (!this.view) {
          return;
        }
        const editor = this.editor;
        const view = this.view;
        if (view.contentView) {
          view.contentView.reset();
        }
        editor.ui.view.body.remove(view);
        editor.ui.focusTracker.remove(view.element);
        editor.keystrokes.stopListening(view.element);
        view.destroy();
        editor.editing.view.focus();
        this.id = null;
        this.isOpen = false;
        _Dialog._visibleDialogPlugin = null;
      }
    };
    /**
    * The `Dialog` plugin instance which most recently showed the dialog.
    *
    * Only one dialog can be visible at once, even if there are many editor instances on the page.
    * If an editor wants to show a dialog, it should first hide the dialog that is already opened.
    * But only the `Dialog` instance that showed the dialog is able able to properly hide it.
    * This is why we need to store it in a globally available space (static property).
    * This way every `Dialog` plugin in every editor is able to correctly close any open dialog window.
    */
    __publicField(_Dialog, "_visibleDialogPlugin");
    let Dialog = _Dialog;
    class MenuBarMenuListItemButtonView extends ButtonView {
      /**
      * Creates an instance of the menu bar list button view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        this.set({
          withText: true,
          withKeystroke: true,
          tooltip: false,
          role: "menuitem"
        });
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__item__button"
            ]
          }
        });
      }
    }
    class LabelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * An unique id of the label. It can be used by other UI components to reference
        * the label, for instance, using the `aria-describedby` DOM attribute.
        */
        __publicField(this, "id");
        this.set("text", void 0);
        this.set("for", void 0);
        this.id = `ck-editor__label_${uid()}`;
        const bind = this.bindTemplate;
        this.setTemplate({
          tag: "label",
          attributes: {
            class: [
              "ck",
              "ck-label"
            ],
            id: this.id,
            for: bind.to("for")
          },
          children: [
            {
              text: bind.to("text")
            }
          ]
        });
      }
    }
    class AccessibilityHelpContentView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, keystrokes) {
        super(locale);
        const t = locale.t;
        const helpLabel = new LabelView();
        helpLabel.text = t("Help Contents. To close this dialog press ESC.");
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-accessibility-help-dialog__content"
            ],
            "aria-labelledby": helpLabel.id,
            role: "document",
            tabindex: -1
          },
          children: [
            createElement(document, "p", {}, t("Below, you can find a list of keyboard shortcuts that can be used in the editor.")),
            ...this._createCategories(Array.from(keystrokes.values())),
            helpLabel
          ]
        });
      }
      /**
      * @inheritDoc
      */
      focus() {
        this.element.focus();
      }
      /**
      * Creates `<section><h3>Category label</h3>...</section>` elements for each category of keystrokes.
      */
      _createCategories(categories) {
        return categories.map((categoryDefinition) => {
          const elements = [
            // Category header.
            createElement(document, "h3", {}, categoryDefinition.label),
            // Category definitions (<dl>) and their optional headers (<h4>).
            ...Array.from(categoryDefinition.groups.values()).map((groupDefinition) => this._createGroup(groupDefinition)).flat()
          ];
          if (categoryDefinition.description) {
            elements.splice(1, 0, createElement(document, "p", {}, categoryDefinition.description));
          }
          return createElement(document, "section", {}, elements);
        });
      }
      /**
      * Creates `[<h4>Optional label</h4>]<dl>...</dl>` elements for each group of keystrokes in a category.
      */
      _createGroup(groupDefinition) {
        const definitionAndDescriptionElements = groupDefinition.keystrokes.sort((a, b) => a.label.localeCompare(b.label)).map((keystrokeDefinition) => this._createGroupRow(keystrokeDefinition)).flat();
        const elements = [
          createElement(document, "dl", {}, definitionAndDescriptionElements)
        ];
        if (groupDefinition.label) {
          elements.unshift(createElement(document, "h4", {}, groupDefinition.label));
        }
        return elements;
      }
      /**
      * Creates `<dt>Keystroke label</dt><dd>Keystroke definition</dd>` elements for each keystroke in a group.
      */
      _createGroupRow(keystrokeDefinition) {
        const t = this.locale.t;
        const dt = createElement(document, "dt");
        const dd = createElement(document, "dd");
        const normalizedKeystrokeDefinition = normalizeKeystrokeDefinition(keystrokeDefinition.keystroke);
        const keystrokeAlternativeHTMLs = [];
        for (const keystrokeAlternative of normalizedKeystrokeDefinition) {
          keystrokeAlternativeHTMLs.push(keystrokeAlternative.map(keystrokeToEnvKbd).join(""));
        }
        dt.innerHTML = keystrokeDefinition.label;
        dd.innerHTML = keystrokeAlternativeHTMLs.join(", ") + (keystrokeDefinition.mayRequireFn && env.isMac ? ` ${t("(may require <kbd>Fn</kbd>)")}` : "");
        return [
          dt,
          dd
        ];
      }
    }
    function keystrokeToEnvKbd(keystroke) {
      return getEnvKeystrokeText(keystroke).split("+").map((part) => `<kbd>${part}</kbd>`).join("+");
    }
    function normalizeKeystrokeDefinition(definition) {
      if (typeof definition === "string") {
        return [
          [
            definition
          ]
        ];
      }
      if (typeof definition[0] === "string") {
        return [
          definition
        ];
      }
      return definition;
    }
    var accessibilityIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 6.628a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3Z"/><path d="M8.5 9.125a.3.3 0 0 0-.253-.296L5.11 8.327a.75.75 0 1 1 .388-1.449l4.04.716c.267.072.624.08.893.009l4.066-.724a.75.75 0 1 1 .388 1.45l-3.132.5a.3.3 0 0 0-.253.296v1.357a.3.3 0 0 0 .018.102l1.615 4.438a.75.75 0 0 1-1.41.513l-1.35-3.71a.3.3 0 0 0-.281-.197h-.209a.3.3 0 0 0-.282.198l-1.35 3.711a.75.75 0 0 1-1.41-.513l1.64-4.509a.3.3 0 0 0 .019-.103V9.125Z"/><path clip-rule="evenodd" d="M10 18.5a8.5 8.5 0 1 1 0-17 8.5 8.5 0 0 1 0 17Zm0 1.5c5.523 0 10-4.477 10-10S15.523 0 10 0 0 4.477 0 10s4.477 10 10 10Z"/></svg>';
    class AccessibilityHelp extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The view that displays the dialog content (list of keystrokes).
        * Created when the dialog is opened for the first time.
        */
        __publicField(this, "contentView", null);
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Dialog
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "AccessibilityHelp";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.locale.t;
        editor.ui.componentFactory.add("accessibilityHelp", () => {
          const button = this._createButton(ButtonView);
          button.set({
            tooltip: true,
            withText: false,
            label: t("Accessibility help")
          });
          return button;
        });
        editor.ui.componentFactory.add("menuBar:accessibilityHelp", () => {
          const button = this._createButton(MenuBarMenuListItemButtonView);
          button.label = t("Accessibility");
          return button;
        });
        editor.keystrokes.set("Alt+0", (evt, cancel2) => {
          this._showDialog();
          cancel2();
        });
        this._setupRootLabels();
      }
      /**
      * Creates a button to show accessibility help dialog, for use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const view = new ButtonClass(locale);
        view.set({
          keystroke: "Alt+0",
          icon: accessibilityIcon
        });
        view.on("execute", () => this._showDialog());
        return view;
      }
      /**
      * Injects a help text into each editing root's `aria-label` attribute allowing assistive technology users
      * to discover the availability of the Accessibility help dialog.
      */
      _setupRootLabels() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const t = editor.t;
        editor.ui.on("ready", () => {
          editingView.change((writer) => {
            for (const root2 of editingView.document.roots) {
              addAriaLabelTextToRoot(writer, root2);
            }
          });
          editor.on("addRoot", (evt, modelRoot) => {
            const viewRoot = editor.editing.view.document.getRoot(modelRoot.rootName);
            editingView.change((writer) => addAriaLabelTextToRoot(writer, viewRoot));
          }, {
            priority: "low"
          });
        });
        function addAriaLabelTextToRoot(writer, viewRoot) {
          const currentAriaLabel = viewRoot.getAttribute("aria-label");
          const newAriaLabel = `${currentAriaLabel}. ${t("Press %0 for help.", [
            getEnvKeystrokeText("Alt+0")
          ])}`;
          writer.setAttribute("aria-label", newAriaLabel, viewRoot);
        }
      }
      /**
      * Shows the accessibility help dialog. Also, creates {@link #contentView} on demand.
      */
      _showDialog() {
        const editor = this.editor;
        const dialog = editor.plugins.get("Dialog");
        const t = editor.locale.t;
        if (!this.contentView) {
          this.contentView = new AccessibilityHelpContentView(editor.locale, editor.accessibility.keystrokeInfos);
        }
        dialog.show({
          id: "accessibilityHelp",
          className: "ck-accessibility-help-dialog",
          title: t("Accessibility help"),
          icon: accessibilityIcon,
          hasCloseButton: true,
          content: this.contentView
        });
      }
    }
    class BodyCollection extends ViewCollection {
      /**
      * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
      *
      * @param locale The {@link module:core/editor/editor~Editor editor's locale} instance.
      * @param initialItems The initial items of the collection.
      */
      constructor(locale, initialItems = []) {
        super(initialItems);
        /**
        * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.
        * See the view {@link module:ui/view~View#locale locale} property.
        */
        __publicField(this, "locale");
        /**
        * The element holding elements of the body region.
        */
        __publicField(this, "_bodyCollectionContainer");
        this.locale = locale;
      }
      /**
      * The element holding elements of the body region.
      */
      get bodyCollectionContainer() {
        return this._bodyCollectionContainer;
      }
      /**
      * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
      * the body collection.
      */
      attachToDom() {
        this._bodyCollectionContainer = new Template({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset_all",
              "ck-body",
              "ck-rounded-corners"
            ],
            dir: this.locale.uiLanguageDirection
          },
          children: this
        }).render();
        let wrapper = document.querySelector(".ck-body-wrapper");
        if (!wrapper) {
          wrapper = createElement(document, "div", {
            class: "ck-body-wrapper"
          });
          document.body.appendChild(wrapper);
        }
        wrapper.appendChild(this._bodyCollectionContainer);
      }
      /**
      * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
      * anymore to clean-up the DOM structure.
      */
      detachFromDom() {
        super.destroy();
        if (this._bodyCollectionContainer) {
          this._bodyCollectionContainer.remove();
        }
        const wrapper = document.querySelector(".ck-body-wrapper");
        if (wrapper && wrapper.childElementCount == 0) {
          wrapper.remove();
        }
      }
    }
    class SwitchButtonView extends ButtonView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * The toggle switch of the button.
        */
        __publicField(this, "toggleSwitchView");
        this.isToggleable = true;
        this.toggleSwitchView = this._createToggleView();
        this.extendTemplate({
          attributes: {
            class: "ck-switchbutton"
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.toggleSwitchView);
      }
      /**
      * Creates a toggle child view.
      */
      _createToggleView() {
        const toggleSwitchView = new View();
        toggleSwitchView.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-button__toggle"
            ]
          },
          children: [
            {
              tag: "span",
              attributes: {
                class: [
                  "ck",
                  "ck-button__toggle__inner"
                ]
              }
            }
          ]
        });
        return toggleSwitchView;
      }
    }
    class FileDialogButtonView extends ButtonView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * The button view of the component.
        *
        * @deprecated
        */
        __publicField(this, "buttonView");
        /**
        * A hidden `<input>` view used to execute file dialog.
        */
        __publicField(this, "_fileInputView");
        this.buttonView = this;
        this._fileInputView = new FileInputView(locale);
        this._fileInputView.bind("acceptedType").to(this);
        this._fileInputView.bind("allowMultipleFiles").to(this);
        this._fileInputView.delegate("done").to(this);
        this.on("execute", () => {
          this._fileInputView.open();
        });
        this.extendTemplate({
          attributes: {
            class: "ck-file-dialog-button"
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this._fileInputView);
      }
    }
    class FileInputView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.set("acceptedType", void 0);
        this.set("allowMultipleFiles", false);
        const bind = this.bindTemplate;
        this.setTemplate({
          tag: "input",
          attributes: {
            class: [
              "ck-hidden"
            ],
            type: "file",
            tabindex: "-1",
            accept: bind.to("acceptedType"),
            multiple: bind.to("allowMultipleFiles")
          },
          on: {
            // Removing from code coverage since we cannot programmatically set input element files.
            change: bind.to(
              /* istanbul ignore next -- @preserve */
              () => {
                if (this.element && this.element.files && this.element.files.length) {
                  this.fire("done", this.element.files);
                }
                this.element.value = "";
              }
            )
          }
        });
      }
      /**
      * Opens file dialog.
      */
      open() {
        this.element.click();
      }
    }
    var dropdownArrowIcon = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
    class CollapsibleView extends View {
      /**
      * Creates an instance of the collapsible view.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param childViews An optional array of initial child views to be inserted into the collapsible.
      */
      constructor(locale, childViews) {
        super(locale);
        /**
        * The main button that, when clicked, collapses or expands the container with {@link #children}.
        */
        __publicField(this, "buttonView");
        /**
        * A collection of the child views that can be collapsed by clicking the {@link #buttonView}.
        */
        __publicField(this, "children");
        const bind = this.bindTemplate;
        this.set("isCollapsed", false);
        this.set("label", "");
        this.buttonView = this._createButtonView();
        this.children = this.createCollection();
        this.set("_collapsibleAriaLabelUid", void 0);
        if (childViews) {
          this.children.addMany(childViews);
        }
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-collapsible",
              bind.if("isCollapsed", "ck-collapsible_collapsed")
            ]
          },
          children: [
            this.buttonView,
            {
              tag: "div",
              attributes: {
                class: [
                  "ck",
                  "ck-collapsible__children"
                ],
                role: "region",
                hidden: bind.if("isCollapsed", "hidden"),
                "aria-labelledby": bind.to("_collapsibleAriaLabelUid")
              },
              children: this.children
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this._collapsibleAriaLabelUid = this.buttonView.labelView.element.id;
      }
      /**
      * Focuses the first focusable.
      */
      focus() {
        this.buttonView.focus();
      }
      /**
      * Creates the main {@link #buttonView} of the collapsible.
      */
      _createButtonView() {
        const buttonView = new ButtonView(this.locale);
        const bind = buttonView.bindTemplate;
        buttonView.set({
          withText: true,
          icon: dropdownArrowIcon
        });
        buttonView.extendTemplate({
          attributes: {
            "aria-expanded": bind.to("isOn", (value) => String(value))
          }
        });
        buttonView.bind("label").to(this);
        buttonView.bind("isOn").to(this, "isCollapsed", (isCollapsed) => !isCollapsed);
        buttonView.on("execute", () => {
          this.isCollapsed = !this.isCollapsed;
        });
        return buttonView;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getLocalizedColorOptions(locale, options) {
      const t = locale.t;
      const localizedColorNames = {
        Black: t("Black"),
        "Dim grey": t("Dim grey"),
        Grey: t("Grey"),
        "Light grey": t("Light grey"),
        White: t("White"),
        Red: t("Red"),
        Orange: t("Orange"),
        Yellow: t("Yellow"),
        "Light green": t("Light green"),
        Green: t("Green"),
        Aquamarine: t("Aquamarine"),
        Turquoise: t("Turquoise"),
        "Light blue": t("Light blue"),
        Blue: t("Blue"),
        Purple: t("Purple")
      };
      return options.map((colorOption) => {
        const label = localizedColorNames[colorOption.label];
        if (label && label != colorOption.label) {
          colorOption.label = label;
        }
        return colorOption;
      });
    }
    function normalizeColorOptions(options) {
      return options.map(normalizeSingleColorDefinition).filter((option) => !!option);
    }
    function normalizeSingleColorDefinition(color) {
      if (typeof color === "string") {
        return {
          model: color,
          label: color,
          hasBorder: false,
          view: {
            name: "span",
            styles: {
              color
            }
          }
        };
      } else {
        return {
          model: color.color,
          label: color.label || color.color,
          hasBorder: color.hasBorder === void 0 ? false : color.hasBorder,
          view: {
            name: "span",
            styles: {
              color: `${color.color}`
            }
          }
        };
      }
    }
    var checkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>';
    class ColorTileView extends ButtonView {
      constructor(locale) {
        super(locale);
        const bind = this.bindTemplate;
        this.set("color", void 0);
        this.set("hasBorder", false);
        this.icon = checkIcon;
        this.extendTemplate({
          attributes: {
            style: {
              // https://github.com/ckeditor/ckeditor5/issues/14907
              backgroundColor: bind.to("color", (color) => env.isMediaForcedColors ? null : color)
            },
            class: [
              "ck",
              "ck-color-grid__tile",
              bind.if("hasBorder", "ck-color-selector__color-tile_bordered")
            ]
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.iconView.fillColor = "hsl(0, 0%, 100%)";
      }
    }
    class ColorGridView extends View {
      /**
      * Creates an instance of a color grid containing {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
      *
      * @fires execute
      * @param locale The localization services instance.
      * @param options Component configuration
      * @param options.colorDefinitions Array with definitions
      * required to create the {@link module:ui/colorgrid/colortileview~ColorTileView tiles}.
      * @param options.columns A number of columns to display the tiles.
      */
      constructor(locale, options) {
        super(locale);
        /**
        * A number of columns for the tiles grid.
        */
        __publicField(this, "columns");
        /**
        * Collection of the child tile views.
        */
        __publicField(this, "items");
        /**
        * Tracks information about DOM focus in the grid.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        const colorDefinitions = options && options.colorDefinitions ? options.colorDefinitions : [];
        this.columns = options && options.columns ? options.columns : 5;
        const viewStyleAttribute = {
          gridTemplateColumns: `repeat( ${this.columns}, 1fr)`
        };
        this.set("selectedColor", void 0);
        this.items = this.createCollection();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.items.on("add", (evt, colorTile) => {
          colorTile.isOn = colorTile.color === this.selectedColor;
        });
        colorDefinitions.forEach((color) => {
          const colorTile = new ColorTileView();
          colorTile.set({
            color: color.color,
            label: color.label,
            tooltip: true,
            hasBorder: color.options.hasBorder
          });
          colorTile.on("execute", () => {
            this.fire("execute", {
              value: color.color,
              hasBorder: color.options.hasBorder,
              label: color.label
            });
          });
          this.items.add(colorTile);
        });
        this.setTemplate({
          tag: "div",
          children: this.items,
          attributes: {
            class: [
              "ck",
              "ck-color-grid"
            ],
            style: viewStyleAttribute
          }
        });
        this.on("change:selectedColor", (evt, name, selectedColor) => {
          for (const item of this.items) {
            item.isOn = item.color === selectedColor;
          }
        });
      }
      /**
      * Focuses the first focusable in {@link #items}.
      */
      focus() {
        if (this.items.length) {
          this.items.first.focus();
        }
      }
      /**
      * Focuses the last focusable in {@link #items}.
      */
      focusLast() {
        if (this.items.length) {
          this.items.last.focus();
        }
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        for (const item of this.items) {
          this.focusTracker.add(item.element);
        }
        this.items.on("add", (evt, item) => {
          this.focusTracker.add(item.element);
        });
        this.items.on("remove", (evt, item) => {
          this.focusTracker.remove(item.element);
        });
        this.keystrokes.listenTo(this.element);
        addKeyboardHandlingForGrid({
          keystrokeHandler: this.keystrokes,
          focusTracker: this.focusTracker,
          gridItems: this.items,
          numberOfColumns: this.columns,
          uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function convertColor(color, outputFormat) {
      if (!color) {
        return "";
      }
      const colorObject = parseColorString(color);
      if (!colorObject) {
        return "";
      }
      if (colorObject.space === outputFormat) {
        return color;
      }
      if (!canConvertParsedColor(colorObject)) {
        return "";
      }
      const fromColorSpace = convert$1[colorObject.space];
      const toColorSpace = fromColorSpace[outputFormat];
      if (!toColorSpace) {
        return "";
      }
      const convertedColorChannels = toColorSpace(colorObject.space === "hex" ? colorObject.hexValue : colorObject.values);
      return formatColorOutput(convertedColorChannels, outputFormat);
    }
    function convertToHex(color) {
      if (!color) {
        return "";
      }
      const colorObject = parseColorString(color);
      if (!colorObject) {
        return "#000";
      }
      if (colorObject.space === "hex") {
        return colorObject.hexValue;
      }
      return convertColor(color, "hex");
    }
    function registerCustomElement(elementName, constructor) {
      if (customElements.get(elementName) === void 0) {
        customElements.define(elementName, constructor);
      }
    }
    function formatColorOutput(values, format2) {
      switch (format2) {
        case "hex":
          return `#${values}`;
        case "rgb":
          return `rgb( ${values[0]}, ${values[1]}, ${values[2]} )`;
        case "hsl":
          return `hsl( ${values[0]}, ${values[1]}%, ${values[2]}% )`;
        case "hwb":
          return `hwb( ${values[0]}, ${values[1]}, ${values[2]} )`;
        case "lab":
          return `lab( ${values[0]}% ${values[1]} ${values[2]} )`;
        case "lch":
          return `lch( ${values[0]}% ${values[1]} ${values[2]} )`;
        default:
          return "";
      }
    }
    function parseColorString(colorString) {
      if (colorString.startsWith("#")) {
        const parsedHex = parse(colorString);
        return {
          space: "hex",
          values: parsedHex.values,
          hexValue: colorString,
          alpha: parsedHex.alpha
        };
      }
      const parsed = parse(colorString);
      if (!parsed.space) {
        return null;
      }
      return parsed;
    }
    function canConvertParsedColor(parsedColor) {
      return Object.keys(convert$1).includes(parsedColor.space);
    }
    class LabeledFieldView extends View {
      /**
      * Creates an instance of the labeled field view class using a provided creator function
      * that provides the view to be labeled.
      *
      * @param locale The locale instance.
      * @param viewCreator A function that returns a {@link module:ui/view~View}
      * that will be labeled. The following arguments are passed to the creator function:
      *
      * * an instance of the `LabeledFieldView` to allow binding observable properties,
      * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
      * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
      */
      constructor(locale, viewCreator) {
        super(locale);
        /**
        * The field view that gets labeled.
        */
        __publicField(this, "fieldView");
        /**
        * The label view instance that describes the entire view.
        */
        __publicField(this, "labelView");
        /**
        * The status view for the {@link #fieldView}. It displays {@link #errorText} and
        * {@link #infoText}.
        */
        __publicField(this, "statusView");
        /**
        * A collection of children of the internal wrapper element. Allows inserting additional DOM elements (views) next to
        * the {@link #fieldView} for easy styling (e.g. positioning).
        *
        * By default, the collection contains {@link #fieldView} and {@link #labelView}.
        */
        __publicField(this, "fieldWrapperChildren");
        const viewUid = `ck-labeled-field-view-${uid()}`;
        const statusUid = `ck-labeled-field-view-status-${uid()}`;
        this.fieldView = viewCreator(this, viewUid, statusUid);
        this.set("label", void 0);
        this.set("isEnabled", true);
        this.set("isEmpty", true);
        this.set("isFocused", false);
        this.set("errorText", null);
        this.set("infoText", null);
        this.set("class", void 0);
        this.set("placeholder", void 0);
        this.labelView = this._createLabelView(viewUid);
        this.statusView = this._createStatusView(statusUid);
        this.fieldWrapperChildren = this.createCollection([
          this.fieldView,
          this.labelView
        ]);
        this.bind("_statusText").to(this, "errorText", this, "infoText", (errorText, infoText) => errorText || infoText);
        const bind = this.bindTemplate;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view",
              bind.to("class"),
              bind.if("isEnabled", "ck-disabled", (value) => !value),
              bind.if("isEmpty", "ck-labeled-field-view_empty"),
              bind.if("isFocused", "ck-labeled-field-view_focused"),
              bind.if("placeholder", "ck-labeled-field-view_placeholder"),
              bind.if("errorText", "ck-error")
            ]
          },
          children: [
            {
              tag: "div",
              attributes: {
                class: [
                  "ck",
                  "ck-labeled-field-view__input-wrapper"
                ]
              },
              children: this.fieldWrapperChildren
            },
            this.statusView
          ]
        });
      }
      /**
      * Creates label view class instance and bind with view.
      *
      * @param id Unique id to set as labelView#for attribute.
      */
      _createLabelView(id) {
        const labelView = new LabelView(this.locale);
        labelView.for = id;
        labelView.bind("text").to(this, "label");
        return labelView;
      }
      /**
      * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
      * next to the {@link #fieldView}. See {@link #_statusText}.
      *
      * @param statusUid Unique id of the status, shared with the {@link #fieldView view's}
      * `aria-describedby` attribute.
      */
      _createStatusView(statusUid) {
        const statusView = new View(this.locale);
        const bind = this.bindTemplate;
        statusView.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-labeled-field-view__status",
              bind.if("errorText", "ck-labeled-field-view__status_error"),
              bind.if("_statusText", "ck-hidden", (value) => !value)
            ],
            id: statusUid,
            role: bind.if("errorText", "alert")
          },
          children: [
            {
              text: bind.to("_statusText")
            }
          ]
        });
        return statusView;
      }
      /**
      * Focuses the {@link #fieldView}.
      */
      focus(direction) {
        this.fieldView.focus(direction);
      }
    }
    class InputBase extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Stores information about the editor UI focus and propagates it so various plugins and components
        * are unified as a focus group.
        */
        __publicField(this, "focusTracker");
        this.set("value", void 0);
        this.set("id", void 0);
        this.set("placeholder", void 0);
        this.set("tabIndex", void 0);
        this.set("isReadOnly", false);
        this.set("hasError", false);
        this.set("ariaDescribedById", void 0);
        this.set("ariaLabel", void 0);
        this.focusTracker = new FocusTracker();
        this.bind("isFocused").to(this.focusTracker);
        this.set("isEmpty", true);
        const bind = this.bindTemplate;
        this.setTemplate({
          tag: "input",
          attributes: {
            class: [
              "ck",
              "ck-input",
              bind.if("isFocused", "ck-input_focused"),
              bind.if("isEmpty", "ck-input-text_empty"),
              bind.if("hasError", "ck-error")
            ],
            id: bind.to("id"),
            placeholder: bind.to("placeholder"),
            tabindex: bind.to("tabIndex"),
            readonly: bind.to("isReadOnly"),
            "aria-invalid": bind.if("hasError", true),
            "aria-describedby": bind.to("ariaDescribedById"),
            "aria-label": bind.to("ariaLabel")
          },
          on: {
            input: bind.to((...args) => {
              this.fire("input", ...args);
              this._updateIsEmpty();
            }),
            change: bind.to(this._updateIsEmpty.bind(this))
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.element);
        this._setDomElementValue(this.value);
        this._updateIsEmpty();
        this.on("change:value", (evt, name, value) => {
          this._setDomElementValue(value);
          this._updateIsEmpty();
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
      }
      /**
      * Moves the focus to the input and selects the value.
      */
      select() {
        this.element.select();
      }
      /**
      * Focuses the input.
      */
      focus() {
        this.element.focus();
      }
      /**
      * Resets the value of the input
      */
      reset() {
        this.value = this.element.value = "";
        this._updateIsEmpty();
      }
      /**
      * Updates the {@link #isEmpty} property value on demand.
      */
      _updateIsEmpty() {
        this.isEmpty = isInputElementEmpty(this.element);
      }
      /**
      * Sets the `value` property of the {@link #element DOM element} on demand.
      */
      _setDomElementValue(value) {
        this.element.value = !value && value !== 0 ? "" : value;
      }
    }
    function isInputElementEmpty(domElement) {
      return !domElement.value;
    }
    class InputView extends InputBase {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.set("inputMode", "text");
        const bind = this.bindTemplate;
        this.extendTemplate({
          attributes: {
            inputmode: bind.to("inputMode")
          }
        });
      }
    }
    class InputTextView extends InputView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.extendTemplate({
          attributes: {
            type: "text",
            class: [
              "ck-input-text"
            ]
          }
        });
      }
    }
    class DropdownPanelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views in this panel.
        *
        * A common child type is the {@link module:ui/list/listview~ListView} and {@link module:ui/toolbar/toolbarview~ToolbarView}.
        * See {@link module:ui/dropdown/utils~addListToDropdown} and
        * {@link module:ui/dropdown/utils~addToolbarToDropdown} to learn more about child views of dropdowns.
        */
        __publicField(this, "children");
        const bind = this.bindTemplate;
        this.set("isVisible", false);
        this.set("position", "se");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-dropdown__panel",
              bind.to("position", (value) => `ck-dropdown__panel_${value}`),
              bind.if("isVisible", "ck-dropdown__panel-visible")
            ],
            tabindex: "-1"
          },
          children: this.children,
          on: {
            // Drag and drop in the panel should not break the selection in the editor.
            // https://github.com/ckeditor/ckeditor5-ui/issues/228
            selectstart: bind.to((evt) => {
              if (evt.target.tagName.toLocaleLowerCase() === "input") {
                return;
              }
              evt.preventDefault();
            })
          }
        });
      }
      /**
      * Focuses the first view in the {@link #children} collection.
      *
      * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
      */
      focus() {
        if (this.children.length) {
          const firstChild = this.children.first;
          if (typeof firstChild.focus === "function") {
            firstChild.focus();
          } else {
            logWarning("ui-dropdown-panel-focus-child-missing-focus", {
              childView: this.children.first,
              dropdownPanel: this
            });
          }
        }
      }
      /**
      * Focuses the view element or last item in view collection on opening dropdown's panel.
      *
      * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
      */
      focusLast() {
        if (this.children.length) {
          const lastChild = this.children.last;
          if (typeof lastChild.focusLast === "function") {
            lastChild.focusLast();
          } else {
            lastChild.focus();
          }
        }
      }
    }
    const _DropdownView = class _DropdownView extends View {
      /**
      * Creates an instance of the dropdown.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      */
      constructor(locale, buttonView, panelView) {
        super(locale);
        /**
        * Button of the dropdown view. Clicking the button opens the {@link #panelView}.
        */
        __publicField(this, "buttonView");
        /**
        * Panel of the dropdown. It opens when the {@link #buttonView} is
        * {@link module:ui/button/button~Button#event:execute executed} (i.e. clicked).
        *
        * Child views can be added to the panel's `children` collection:
        *
        * ```ts
        * dropdown.panelView.children.add( childView );
        * ```
        *
        * See {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#children} and
        * {@link module:ui/viewcollection~ViewCollection#add}.
        */
        __publicField(this, "panelView");
        /**
        * Tracks information about the DOM focus in the dropdown.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
        * keystrokes of the dropdown:
        *
        * * <kbd>▼</kbd> opens the dropdown,
        * * <kbd>◀</kbd> and <kbd>Esc</kbd> closes the dropdown.
        */
        __publicField(this, "keystrokes");
        /**
        * A child {@link module:ui/list/listview~ListView list view} of the dropdown located
        * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
        *
        * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}.
        */
        __publicField(this, "listView");
        /**
        * A child toolbar of the dropdown located in the
        * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
        *
        * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addToolbarToDropdown}.
        */
        __publicField(this, "toolbarView");
        const bind = this.bindTemplate;
        this.buttonView = buttonView;
        this.panelView = panelView;
        this.set("isOpen", false);
        this.set("isEnabled", true);
        this.set("class", void 0);
        this.set("id", void 0);
        this.set("panelPosition", "auto");
        this.panelView.bind("isVisible").to(this, "isOpen");
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-dropdown",
              bind.to("class"),
              bind.if("isEnabled", "ck-disabled", (value) => !value)
            ],
            id: bind.to("id"),
            "aria-describedby": bind.to("ariaDescribedById")
          },
          children: [
            buttonView,
            panelView
          ]
        });
        buttonView.extendTemplate({
          attributes: {
            class: [
              "ck-dropdown__button"
            ],
            "data-cke-tooltip-disabled": bind.to("isOpen")
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.buttonView.element);
        this.focusTracker.add(this.panelView.element);
        this.listenTo(this.buttonView, "open", () => {
          this.isOpen = !this.isOpen;
        });
        this.on("change:isOpen", (evt, name, isOpen) => {
          if (!isOpen) {
            return;
          }
          if (this.panelPosition === "auto") {
            const optimalPanelPosition = _DropdownView._getOptimalPosition({
              element: this.panelView.element,
              target: this.buttonView.element,
              fitInViewport: true,
              positions: this._panelPositions
            });
            this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._panelPositions[0].name;
          } else {
            this.panelView.position = this.panelPosition;
          }
        });
        this.keystrokes.listenTo(this.element);
        const closeDropdown = (data, cancel2) => {
          if (this.isOpen) {
            this.isOpen = false;
            cancel2();
          }
        };
        this.keystrokes.set("arrowdown", (data, cancel2) => {
          if (this.buttonView.isEnabled && !this.isOpen) {
            this.isOpen = true;
            cancel2();
          }
        });
        this.keystrokes.set("arrowright", (data, cancel2) => {
          if (this.isOpen) {
            cancel2();
          }
        });
        this.keystrokes.set("arrowleft", closeDropdown);
        this.keystrokes.set("esc", closeDropdown);
      }
      /**
      * Focuses the {@link #buttonView}.
      */
      focus() {
        this.buttonView.focus();
      }
      /**
      * Returns {@link #panelView panel} positions to be used by the
      * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
      * utility considering the direction of the language the UI of the editor is displayed in.
      */
      get _panelPositions() {
        const { south, north, southEast, southWest, northEast, northWest, southMiddleEast, southMiddleWest, northMiddleEast, northMiddleWest } = _DropdownView.defaultPanelPositions;
        if (this.locale.uiLanguageDirection !== "rtl") {
          return [
            southEast,
            southWest,
            southMiddleEast,
            southMiddleWest,
            south,
            northEast,
            northWest,
            northMiddleEast,
            northMiddleWest,
            north
          ];
        } else {
          return [
            southWest,
            southEast,
            southMiddleWest,
            southMiddleEast,
            south,
            northWest,
            northEast,
            northMiddleWest,
            northMiddleEast,
            north
          ];
        }
      }
    };
    /**
    * A set of positioning functions used by the dropdown view to determine
    * the optimal position (i.e. fitting into the browser viewport) of its
    * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel} when
    * {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition} is set to 'auto'`.
    *
    * The available positioning functions are as follow:
    *
    * **South**
    *
    * * `south`
    *
    * ```
    *			[ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southEast`
    *
    * ```
    *		[ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southWest`
    *
    * ```
    *		         [ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southMiddleEast`
    *
    * ```
    *		  [ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * * `southMiddleWest`
    *
    * ```
    *		       [ Button ]
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    * ```
    *
    * **North**
    *
    * * `north`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		    [ Button ]
    * ```
    *
    * * `northEast`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		[ Button ]
    * ```
    *
    * * `northWest`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		         [ Button ]
    * ```
    *
    * * `northMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		  [ Button ]
    * ```
    *
    * * `northMiddleWest`
    *
    * ```
    *		+-----------------+
    *		|      Panel      |
    *		+-----------------+
    *		       [ Button ]
    * ```
    *
    * Positioning functions are compatible with {@link module:utils/dom/position~DomPoint}.
    *
    * The name that position function returns will be reflected in dropdown panel's class that
    * controls its placement. See {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition}
    * to learn more.
    */
    __publicField(_DropdownView, "defaultPanelPositions", {
      south: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
          name: "s"
        };
      },
      southEast: (buttonRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left,
          name: "se"
        };
      },
      southWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "sw"
        };
      },
      southMiddleEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
          name: "sme"
        };
      },
      southMiddleWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
          name: "smw"
        };
      },
      north: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 2,
          name: "n"
        };
      },
      northEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left,
          name: "ne"
        };
      },
      northWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "nw"
        };
      },
      northMiddleEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - (panelRect.width - buttonRect.width) / 4,
          name: "nme"
        };
      },
      northMiddleWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - (panelRect.width - buttonRect.width) * 3 / 4,
          name: "nmw"
        };
      }
    });
    /**
    * A function used to calculate the optimal position for the dropdown panel.
    */
    __publicField(_DropdownView, "_getOptimalPosition", getOptimalPosition);
    let DropdownView = _DropdownView;
    class DropdownButtonView extends ButtonView {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * An icon that displays arrow to indicate a dropdown button.
        */
        __publicField(this, "arrowView");
        this.arrowView = this._createArrowView();
        this.extendTemplate({
          attributes: {
            "aria-haspopup": true,
            "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value))
          }
        });
        this.delegate("execute").to(this, "open");
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.arrowView);
      }
      /**
      * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
      */
      _createArrowView() {
        const arrowView = new IconView();
        arrowView.content = dropdownArrowIcon;
        arrowView.extendTemplate({
          attributes: {
            class: "ck-dropdown__arrow"
          }
        });
        return arrowView;
      }
    }
    class ToolbarSeparatorView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-toolbar__separator"
            ]
          }
        });
      }
    }
    class ToolbarLineBreakView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-toolbar__line-break"
            ]
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function preventDefault(view) {
      return view.bindTemplate.to((evt) => {
        if (evt.target === view.element) {
          evt.preventDefault();
        }
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function normalizeToolbarConfig(config) {
      if (Array.isArray(config)) {
        return {
          items: config,
          removeItems: []
        };
      }
      const predefinedConfigOptions = {
        items: [],
        removeItems: []
      };
      if (!config) {
        return predefinedConfigOptions;
      }
      return {
        ...predefinedConfigOptions,
        ...config
      };
    }
    const NESTED_TOOLBAR_ICONS = /* @__PURE__ */ (() => ({
      alignLeft: icons.alignLeft,
      bold: icons.bold,
      importExport: icons.importExport,
      paragraph: icons.paragraph,
      plus: icons.plus,
      text: icons.text,
      threeVerticalDots: icons.threeVerticalDots,
      pilcrow: icons.pilcrow,
      dragIndicator: icons.dragIndicator
    }))();
    class ToolbarView extends View {
      /**
      * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      * @param options Configuration options of the toolbar.
      */
      constructor(locale, options) {
        super(locale);
        /**
        * A reference to the options object passed to the constructor.
        */
        __publicField(this, "options");
        /**
        * A collection of toolbar items (buttons, dropdowns, etc.).
        */
        __publicField(this, "items");
        /**
        * Tracks information about the DOM focus in the toolbar.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
        * to handle keyboard navigation in the toolbar.
        */
        __publicField(this, "keystrokes");
        /**
        * A (child) view containing {@link #items toolbar items}.
        */
        __publicField(this, "itemsView");
        /**
        * A top–level collection aggregating building blocks of the toolbar.
        *
        *	┌───────────────── ToolbarView ─────────────────┐
        *	| ┌──────────────── #children ────────────────┐ |
        *	| |   ┌──────────── #itemsView ───────────┐   | |
        *	| |   | [ item1 ] [ item2 ] ... [ itemN ] |   | |
        *	| |   └──────────────────────────────────-┘   | |
        *	| └───────────────────────────────────────────┘ |
        *	└───────────────────────────────────────────────┘
        *
        * By default, it contains the {@link #itemsView} but it can be extended with additional
        * UI elements when necessary.
        */
        __publicField(this, "children");
        /**
        * A collection of {@link #items} that take part in the focus cycling
        * (i.e. navigation using the keyboard). Usually, it contains a subset of {@link #items} with
        * some optional UI elements that also belong to the toolbar and should be focusable
        * by the user.
        */
        __publicField(this, "focusables");
        /**
        * Helps cycling over {@link #focusables focusable items} in the toolbar.
        */
        __publicField(this, "_focusCycler");
        /**
        * An instance of the active toolbar behavior that shapes its look and functionality.
        *
        * See {@link module:ui/toolbar/toolbarview~ToolbarBehavior} to learn more.
        */
        __publicField(this, "_behavior");
        const bind = this.bindTemplate;
        const t = this.t;
        this.options = options || {};
        this.set("ariaLabel", t("Editor toolbar"));
        this.set("maxWidth", "auto");
        this.items = this.createCollection();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.set("class", void 0);
        this.set("isCompact", false);
        this.itemsView = new ItemsView(locale);
        this.children = this.createCollection();
        this.children.add(this.itemsView);
        this.focusables = this.createCollection();
        const isRtl = locale.uiLanguageDirection === "rtl";
        this._focusCycler = new FocusCycler({
          focusables: this.focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate toolbar items backwards using the arrow[left,up] keys.
            focusPrevious: [
              isRtl ? "arrowright" : "arrowleft",
              "arrowup"
            ],
            // Navigate toolbar items forwards using the arrow[right,down] keys.
            focusNext: [
              isRtl ? "arrowleft" : "arrowright",
              "arrowdown"
            ]
          }
        });
        const classes = [
          "ck",
          "ck-toolbar",
          bind.to("class"),
          bind.if("isCompact", "ck-toolbar_compact")
        ];
        if (this.options.shouldGroupWhenFull && this.options.isFloating) {
          classes.push("ck-toolbar_floating");
        }
        this.setTemplate({
          tag: "div",
          attributes: {
            class: classes,
            role: "toolbar",
            "aria-label": bind.to("ariaLabel"),
            style: {
              maxWidth: bind.to("maxWidth")
            },
            tabindex: -1
          },
          children: this.children,
          on: {
            // https://github.com/ckeditor/ckeditor5-ui/issues/206
            mousedown: preventDefault(this)
          }
        });
        this._behavior = this.options.shouldGroupWhenFull ? new DynamicGrouping(this) : new StaticLayout(this);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.element);
        for (const item of this.items) {
          this.focusTracker.add(item.element);
        }
        this.items.on("add", (evt, item) => {
          this.focusTracker.add(item.element);
        });
        this.items.on("remove", (evt, item) => {
          this.focusTracker.remove(item.element);
        });
        this.keystrokes.listenTo(this.element);
        this._behavior.render(this);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._behavior.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
        return super.destroy();
      }
      /**
      * Focuses the first focusable in {@link #focusables}.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the last focusable in {@link #focusables}.
      */
      focusLast() {
        this._focusCycler.focusLast();
      }
      /**
      * A utility that expands the plain toolbar configuration into
      * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
      *
      * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
      * @param factory A factory producing toolbar items.
      * @param removeItems An array of items names to be removed from the configuration. When present, applies
      * to this toolbar and all nested ones as well.
      */
      fillFromConfig(itemsOrConfig, factory, removeItems) {
        this.items.addMany(this._buildItemsFromConfig(itemsOrConfig, factory, removeItems));
      }
      /**
      * A utility that expands the plain toolbar configuration into a list of view items using a given component factory.
      *
      * @param itemsOrConfig The toolbar items or the entire toolbar configuration object.
      * @param factory A factory producing toolbar items.
      * @param removeItems An array of items names to be removed from the configuration. When present, applies
      * to this toolbar and all nested ones as well.
      */
      _buildItemsFromConfig(itemsOrConfig, factory, removeItems) {
        const config = normalizeToolbarConfig(itemsOrConfig);
        const normalizedRemoveItems = removeItems || config.removeItems;
        const itemsToAdd = this._cleanItemsConfiguration(config.items, factory, normalizedRemoveItems).map((item) => {
          if (isObject$1(item)) {
            return this._createNestedToolbarDropdown(item, factory, normalizedRemoveItems);
          } else if (item === "|") {
            return new ToolbarSeparatorView();
          } else if (item === "-") {
            return new ToolbarLineBreakView();
          }
          return factory.create(item);
        }).filter((item) => !!item);
        return itemsToAdd;
      }
      /**
      * Cleans up the {@link module:ui/toolbar/toolbarview~ToolbarView#items} of the toolbar by removing unwanted items and
      * duplicated (obsolete) separators or line breaks.
      *
      * @param items The toolbar items configuration.
      * @param factory A factory producing toolbar items.
      * @param removeItems An array of items names to be removed from the configuration.
      * @returns Items after the clean-up.
      */
      _cleanItemsConfiguration(items, factory, removeItems) {
        const filteredItems = items.filter((item, idx, items2) => {
          if (item === "|") {
            return true;
          }
          if (removeItems.indexOf(item) !== -1) {
            return false;
          }
          if (item === "-") {
            if (this.options.shouldGroupWhenFull) {
              logWarning("toolbarview-line-break-ignored-when-grouping-items", items2);
              return false;
            }
            return true;
          }
          if (!isObject$1(item) && !factory.has(item)) {
            logWarning("toolbarview-item-unavailable", {
              item
            });
            return false;
          }
          return true;
        });
        return this._cleanSeparatorsAndLineBreaks(filteredItems);
      }
      /**
      * Remove leading, trailing, and duplicated separators (`-` and `|`).
      *
      * @returns Toolbar items after the separator and line break clean-up.
      */
      _cleanSeparatorsAndLineBreaks(items) {
        const nonSeparatorPredicate = (item) => item !== "-" && item !== "|";
        const count2 = items.length;
        const firstCommandItemIndex = items.findIndex(nonSeparatorPredicate);
        if (firstCommandItemIndex === -1) {
          return [];
        }
        const lastCommandItemIndex = count2 - items.slice().reverse().findIndex(nonSeparatorPredicate);
        return items.slice(firstCommandItemIndex, lastCommandItemIndex).filter((name, idx, items2) => {
          if (nonSeparatorPredicate(name)) {
            return true;
          }
          const isDuplicated = idx > 0 && items2[idx - 1] === name;
          return !isDuplicated;
        });
      }
      /**
      * Creates a user-defined dropdown containing a toolbar with items.
      *
      * @param definition A definition of the nested toolbar dropdown.
      * @param definition.label A label of the dropdown.
      * @param definition.icon An icon of the drop-down. One of 'bold', 'plus', 'text', 'importExport', 'alignLeft',
      * 'paragraph' or an SVG string. When `false` is passed, no icon will be used.
      * @param definition.withText When set `true`, the label of the dropdown will be visible. See
      * {@link module:ui/button/buttonview~ButtonView#withText} to learn more.
      * @param definition.tooltip A tooltip of the dropdown button. See
      * {@link module:ui/button/buttonview~ButtonView#tooltip} to learn more. Defaults to `true`.
      * @param componentFactory Component factory used to create items
      * of the nested toolbar.
      */
      _createNestedToolbarDropdown(definition, componentFactory, removeItems) {
        let { label, icon, items, tooltip = true, withText = false } = definition;
        items = this._cleanItemsConfiguration(items, componentFactory, removeItems);
        if (!items.length) {
          return null;
        }
        const locale = this.locale;
        const dropdownView = createDropdown(locale);
        if (!label) {
          logWarning("toolbarview-nested-toolbar-dropdown-missing-label", definition);
        }
        dropdownView.class = "ck-toolbar__nested-toolbar-dropdown";
        dropdownView.buttonView.set({
          label,
          tooltip,
          withText: !!withText
        });
        if (icon !== false) {
          dropdownView.buttonView.icon = NESTED_TOOLBAR_ICONS[icon] || icon || icons.threeVerticalDots;
        } else {
          dropdownView.buttonView.withText = true;
        }
        addToolbarToDropdown(dropdownView, () => dropdownView.toolbarView._buildItemsFromConfig(items, componentFactory, removeItems));
        return dropdownView;
      }
    }
    class ItemsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of items (buttons, dropdowns, etc.).
        */
        __publicField(this, "children");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-toolbar__items"
            ]
          },
          children: this.children
        });
      }
    }
    class StaticLayout {
      /**
      * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
      * behavior.
      *
      * @param view An instance of the toolbar that this behavior is added to.
      */
      constructor(view) {
        const bind = view.bindTemplate;
        view.set("isVertical", false);
        view.itemsView.children.bindTo(view.items).using((item) => item);
        view.focusables.bindTo(view.items).using((item) => isFocusable(item) ? item : null);
        view.extendTemplate({
          attributes: {
            class: [
              // When vertical, the toolbar has an additional CSS class.
              bind.if("isVertical", "ck-toolbar_vertical")
            ]
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
      }
      /**
      * @inheritDoc
      */
      destroy() {
      }
    }
    class DynamicGrouping {
      /**
      * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
      * behavior.
      *
      * @param view An instance of the toolbar that this behavior is added to.
      */
      constructor(view) {
        /**
        * A toolbar view this behavior belongs to.
        */
        __publicField(this, "view");
        /**
        * A collection of toolbar children.
        */
        __publicField(this, "viewChildren");
        /**
        * A collection of focusable toolbar elements.
        */
        __publicField(this, "viewFocusables");
        /**
        * A view containing toolbar items.
        */
        __publicField(this, "viewItemsView");
        /**
        * Toolbar focus tracker.
        */
        __publicField(this, "viewFocusTracker");
        /**
        * Toolbar locale.
        */
        __publicField(this, "viewLocale");
        /**
        * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
        * Aggregates items that fit into a single row of the toolbar and were not {@link #groupedItems grouped}
        * into a {@link #groupedItemsDropdown dropdown}. Items of this collection are displayed in the
        * {@link module:ui/toolbar/toolbarview~ToolbarView#itemsView}.
        *
        * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped, it
        * matches the {@link module:ui/toolbar/toolbarview~ToolbarView#items} collection in size and order.
        */
        __publicField(this, "ungroupedItems");
        /**
        * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
        * A collection of the toolbar items that do not fit into a single row of the toolbar.
        * Grouped items are displayed in a dedicated {@link #groupedItemsDropdown dropdown}.
        *
        * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped,
        * this collection is empty.
        */
        __publicField(this, "groupedItems");
        /**
        * The dropdown that aggregates {@link #groupedItems grouped items} that do not fit into a single
        * row of the toolbar. It is displayed on demand as the last of
        * {@link module:ui/toolbar/toolbarview~ToolbarView#children toolbar children} and offers another
        * (nested) toolbar which displays items that would normally overflow.
        */
        __publicField(this, "groupedItemsDropdown");
        /**
        * An instance of the resize observer that helps dynamically determine the geometry of the toolbar
        * and manage items that do not fit into a single row.
        *
        * **Note:** Created in {@link #_enableGroupingOnResize}.
        *
        * @readonly
        */
        __publicField(this, "resizeObserver", null);
        /**
        * A cached value of the horizontal padding style used by {@link #_updateGrouping}
        * to manage the {@link module:ui/toolbar/toolbarview~ToolbarView#items} that do not fit into
        * a single toolbar line. This value can be reused between updates because it is unlikely that
        * the padding will change and re–using `Window.getComputedStyle()` is expensive.
        *
        * @readonly
        */
        __publicField(this, "cachedPadding", null);
        /**
        * A flag indicating that an items grouping update has been queued (e.g. due to the toolbar being visible)
        * and should be executed immediately the next time the toolbar shows up.
        *
        * @readonly
        */
        __publicField(this, "shouldUpdateGroupingOnNextResize", false);
        /**
        * Toolbar element.
        *
        * @readonly
        */
        __publicField(this, "viewElement");
        this.view = view;
        this.viewChildren = view.children;
        this.viewFocusables = view.focusables;
        this.viewItemsView = view.itemsView;
        this.viewFocusTracker = view.focusTracker;
        this.viewLocale = view.locale;
        this.ungroupedItems = view.createCollection();
        this.groupedItems = view.createCollection();
        this.groupedItemsDropdown = this._createGroupedItemsDropdown();
        view.itemsView.children.bindTo(this.ungroupedItems).using((item) => item);
        this.ungroupedItems.on("change", this._updateFocusCyclableItems.bind(this));
        view.children.on("change", this._updateFocusCyclableItems.bind(this));
        view.items.on("change", (evt, changeData) => {
          const index2 = changeData.index;
          const added = Array.from(changeData.added);
          for (const removedItem of changeData.removed) {
            if (index2 >= this.ungroupedItems.length) {
              this.groupedItems.remove(removedItem);
            } else {
              this.ungroupedItems.remove(removedItem);
            }
          }
          for (let currentIndex = index2; currentIndex < index2 + added.length; currentIndex++) {
            const addedItem = added[currentIndex - index2];
            if (currentIndex > this.ungroupedItems.length) {
              this.groupedItems.add(addedItem, currentIndex - this.ungroupedItems.length);
            } else {
              this.ungroupedItems.add(addedItem, currentIndex);
            }
          }
          this._updateGrouping();
        });
        view.extendTemplate({
          attributes: {
            class: [
              // To group items dynamically, the toolbar needs a dedicated CSS class.
              "ck-toolbar_grouping"
            ]
          }
        });
      }
      /**
      * Enables dynamic items grouping based on the dimensions of the toolbar.
      *
      * @param view An instance of the toolbar that this behavior is added to.
      */
      render(view) {
        this.viewElement = view.element;
        this._enableGroupingOnResize();
        this._enableGroupingOnMaxWidthChange(view);
      }
      /**
      * Cleans up the internals used by this behavior.
      */
      destroy() {
        this.groupedItemsDropdown.destroy();
        this.resizeObserver.destroy();
      }
      /**
      * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
      * and it will move them to the {@link #groupedItems} when it happens.
      *
      * At the same time, it will also check if there is enough space in the toolbar for the first of the
      * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
      * without the toolbar wrapping.
      */
      _updateGrouping() {
        if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
          return;
        }
        if (!isVisible(this.viewElement)) {
          this.shouldUpdateGroupingOnNextResize = true;
          return;
        }
        const initialGroupedItemsCount = this.groupedItems.length;
        let wereItemsGrouped;
        while (this._areItemsOverflowing) {
          this._groupLastItem();
          wereItemsGrouped = true;
        }
        if (!wereItemsGrouped && this.groupedItems.length) {
          while (this.groupedItems.length && !this._areItemsOverflowing) {
            this._ungroupFirstItem();
          }
          if (this._areItemsOverflowing) {
            this._groupLastItem();
          }
        }
        if (this.groupedItems.length !== initialGroupedItemsCount) {
          this.view.fire("groupedItemsUpdate");
        }
      }
      /**
      * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
      * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
      */
      get _areItemsOverflowing() {
        if (!this.ungroupedItems.length) {
          return false;
        }
        const element = this.viewElement;
        const uiLanguageDirection = this.viewLocale.uiLanguageDirection;
        const lastChildRect = new Rect(element.lastChild);
        const toolbarRect = new Rect(element);
        if (!this.cachedPadding) {
          const computedStyle = global$1.window.getComputedStyle(element);
          const paddingProperty = uiLanguageDirection === "ltr" ? "paddingRight" : "paddingLeft";
          this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
        }
        if (uiLanguageDirection === "ltr") {
          return lastChildRect.right > toolbarRect.right - this.cachedPadding;
        } else {
          return lastChildRect.left < toolbarRect.left + this.cachedPadding;
        }
      }
      /**
      * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
      * upon resize when there is little space available. Instead, the toolbar items are moved to the
      * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
      *
      * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
      * them in the dropdown if necessary. It will also observe the browser window for size changes in
      * the future and respond to them by grouping more items or reverting already grouped back, depending
      * on the visual space available.
      */
      _enableGroupingOnResize() {
        let previousWidth;
        this.resizeObserver = new ResizeObserver(this.viewElement, (entry) => {
          if (!previousWidth || previousWidth !== entry.contentRect.width || this.shouldUpdateGroupingOnNextResize) {
            this.shouldUpdateGroupingOnNextResize = false;
            this._updateGrouping();
            previousWidth = entry.contentRect.width;
          }
        });
        this._updateGrouping();
      }
      /**
      * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
      * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
      */
      _enableGroupingOnMaxWidthChange(view) {
        view.on("change:maxWidth", () => {
          this._updateGrouping();
        });
      }
      /**
      * When called, it will remove the last item from {@link #ungroupedItems} and move it back
      * to the {@link #groupedItems} collection.
      *
      * The opposite of {@link #_ungroupFirstItem}.
      */
      _groupLastItem() {
        if (!this.groupedItems.length) {
          this.viewChildren.add(new ToolbarSeparatorView());
          this.viewChildren.add(this.groupedItemsDropdown);
          this.viewFocusTracker.add(this.groupedItemsDropdown.element);
        }
        this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
      }
      /**
      * Moves the very first item belonging to {@link #groupedItems} back
      * to the {@link #ungroupedItems} collection.
      *
      * The opposite of {@link #_groupLastItem}.
      */
      _ungroupFirstItem() {
        this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));
        if (!this.groupedItems.length) {
          this.viewChildren.remove(this.groupedItemsDropdown);
          this.viewChildren.remove(this.viewChildren.last);
          this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
        }
      }
      /**
      * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
      * collection when there is not enough space in the toolbar to display all items in a single row.
      */
      _createGroupedItemsDropdown() {
        const locale = this.viewLocale;
        const t = locale.t;
        const dropdown = createDropdown(locale);
        dropdown.class = "ck-toolbar__grouped-dropdown";
        dropdown.panelPosition = locale.uiLanguageDirection === "ltr" ? "sw" : "se";
        addToolbarToDropdown(dropdown, this.groupedItems);
        dropdown.buttonView.set({
          label: t("Show more items"),
          tooltip: true,
          tooltipPosition: locale.uiLanguageDirection === "rtl" ? "se" : "sw",
          icon: icons.threeVerticalDots
        });
        return dropdown;
      }
      /**
      * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cyclable items}
      * collection so it represents the up–to–date state of the UI from the perspective of the user.
      *
      * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
      * it must be subject to focus cycling in the toolbar.
      *
      * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
      * to learn more about the purpose of this method.
      */
      _updateFocusCyclableItems() {
        this.viewFocusables.clear();
        this.ungroupedItems.map((item) => {
          if (isFocusable(item)) {
            this.viewFocusables.add(item);
          }
        });
        if (this.groupedItems.length) {
          this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
    }
    class ListItemView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views inside of the list item {@link #element}.
        */
        __publicField(this, "children");
        const bind = this.bindTemplate;
        this.set("isVisible", true);
        this.children = this.createCollection();
        this.setTemplate({
          tag: "li",
          attributes: {
            class: [
              "ck",
              "ck-list__item",
              bind.if("isVisible", "ck-hidden", (value) => !value)
            ],
            role: "presentation"
          },
          children: this.children
        });
      }
      /**
      * Focuses the list item.
      */
      focus() {
        if (this.children.first) {
          this.children.first.focus();
        }
      }
    }
    class ListSeparatorView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "li",
          attributes: {
            class: [
              "ck",
              "ck-list__separator"
            ]
          }
        });
      }
    }
    class ListItemGroupView extends View {
      /**
      * Creates an instance of the list item group view class.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param labelView The instance of the group's label. If not provided, an instance of
      * {@link module:ui/label/labelview~LabelView} is used.
      */
      constructor(locale, labelView = new LabelView()) {
        super(locale);
        /**
        * Label of the group view. Its text is configurable using the {@link #label label attribute}.
        *
        * If a custom label view is not passed in `ListItemGroupView` constructor, the label is an instance
        * of {@link module:ui/label/labelview~LabelView}.
        */
        __publicField(this, "labelView");
        /**
        * Collection of the child list items inside this group.
        */
        __publicField(this, "items");
        /**
        * Collection of the child elements of the group.
        */
        __publicField(this, "children");
        const bind = this.bindTemplate;
        const nestedList = new ListView(locale);
        this.set({
          label: "",
          isVisible: true
        });
        this.labelView = labelView;
        this.labelView.bind("text").to(this, "label");
        this.children = this.createCollection();
        this.children.addMany([
          this.labelView,
          nestedList
        ]);
        nestedList.set({
          role: "group",
          ariaLabelledBy: labelView.id
        });
        nestedList.focusTracker.destroy();
        nestedList.keystrokes.destroy();
        this.items = nestedList.items;
        this.setTemplate({
          tag: "li",
          attributes: {
            role: "presentation",
            class: [
              "ck",
              "ck-list__group",
              bind.if("isVisible", "ck-hidden", (value) => !value)
            ]
          },
          children: this.children
        });
      }
      /**
      * Focuses the list item (which is not a separator).
      */
      focus() {
        if (this.items) {
          const firstListItem = this.items.find((item) => !(item instanceof ListSeparatorView));
          if (firstListItem) {
            firstListItem.focus();
          }
        }
      }
    }
    class ListView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * The collection of focusable views in the list. It is used to determine accessible navigation
        * between the {@link module:ui/list/listitemview~ListItemView list items} and
        * {@link module:ui/list/listitemgroupview~ListItemGroupView list groups}.
        */
        __publicField(this, "focusables");
        /**
        * Collection of the child list views.
        */
        __publicField(this, "items");
        /**
        * Tracks information about DOM focus in the list.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * Helps cycling over focusable {@link #items} in the list.
        */
        __publicField(this, "_focusCycler");
        /**
        * A cached map of {@link module:ui/list/listitemgroupview~ListItemGroupView} to `change` event listeners for their `items`.
        * Used for accessibility and keyboard navigation purposes.
        */
        __publicField(this, "_listItemGroupToChangeListeners", /* @__PURE__ */ new WeakMap());
        const bind = this.bindTemplate;
        this.focusables = new ViewCollection();
        this.items = this.createCollection();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this._focusCycler = new FocusCycler({
          focusables: this.focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate list items backwards using the arrowup key.
            focusPrevious: "arrowup",
            // Navigate toolbar items forwards using the arrowdown key.
            focusNext: "arrowdown"
          }
        });
        this.set("ariaLabel", void 0);
        this.set("ariaLabelledBy", void 0);
        this.set("role", void 0);
        this.setTemplate({
          tag: "ul",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-list"
            ],
            role: bind.to("role"),
            "aria-label": bind.to("ariaLabel"),
            "aria-labelledby": bind.to("ariaLabelledBy")
          },
          children: this.items
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        for (const item of this.items) {
          if (item instanceof ListItemGroupView) {
            this._registerFocusableItemsGroup(item);
          } else if (item instanceof ListItemView) {
            this._registerFocusableListItem(item);
          }
        }
        this.items.on("change", (evt, data) => {
          for (const removed of data.removed) {
            if (removed instanceof ListItemGroupView) {
              this._deregisterFocusableItemsGroup(removed);
            } else if (removed instanceof ListItemView) {
              this._deregisterFocusableListItem(removed);
            }
          }
          for (const added of Array.from(data.added).reverse()) {
            if (added instanceof ListItemGroupView) {
              this._registerFocusableItemsGroup(added, data.index);
            } else {
              this._registerFocusableListItem(added, data.index);
            }
          }
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the first focusable in {@link #items}.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the first focusable in {@link #items}.
      */
      focusFirst() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the last focusable in {@link #items}.
      */
      focusLast() {
        this._focusCycler.focusLast();
      }
      /**
      * Registers a list item view in the focus tracker.
      *
      * @param item The list item view to be registered.
      * @param index Index of the list item view in the {@link #items} collection. If not specified, the item will be added at the end.
      */
      _registerFocusableListItem(item, index2) {
        this.focusTracker.add(item.element);
        this.focusables.add(item, index2);
      }
      /**
      * Removes a list item view from the focus tracker.
      *
      * @param item The list item view to be removed.
      */
      _deregisterFocusableListItem(item) {
        this.focusTracker.remove(item.element);
        this.focusables.remove(item);
      }
      /**
      * Gets a callback that will be called when the `items` collection of a {@link module:ui/list/listitemgroupview~ListItemGroupView}
      * change.
      *
      * @param groupView The group view for which the callback will be created.
      * @returns The callback function to be used for the items `change` event listener in a group.
      */
      _getOnGroupItemsChangeCallback(groupView) {
        return (evt, data) => {
          for (const removed of data.removed) {
            this._deregisterFocusableListItem(removed);
          }
          for (const added of Array.from(data.added).reverse()) {
            this._registerFocusableListItem(added, this.items.getIndex(groupView) + data.index);
          }
        };
      }
      /**
      * Registers a list item group view (and its children) in the focus tracker.
      *
      * @param groupView A group view to be registered.
      * @param groupIndex Index of the group view in the {@link #items} collection. If not specified, the group will be added at the end.
      */
      _registerFocusableItemsGroup(groupView, groupIndex) {
        Array.from(groupView.items).forEach((child, childIndex) => {
          const registeredChildIndex = typeof groupIndex !== "undefined" ? groupIndex + childIndex : void 0;
          this._registerFocusableListItem(child, registeredChildIndex);
        });
        const groupItemsChangeCallback = this._getOnGroupItemsChangeCallback(groupView);
        this._listItemGroupToChangeListeners.set(groupView, groupItemsChangeCallback);
        groupView.items.on("change", groupItemsChangeCallback);
      }
      /**
      * Removes a list item group view (and its children) from the focus tracker.
      *
      * @param groupView The group view to be removed.
      */
      _deregisterFocusableItemsGroup(groupView) {
        for (const child of groupView.items) {
          this._deregisterFocusableListItem(child);
        }
        groupView.items.off("change", this._listItemGroupToChangeListeners.get(groupView));
        this._listItemGroupToChangeListeners.delete(groupView);
      }
    }
    class SplitButtonView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, actionButton) {
        super(locale);
        /**
        * Collection of the child views inside of the split button {@link #element}.
        */
        __publicField(this, "children");
        /**
        * A main button of split button.
        */
        __publicField(this, "actionView");
        /**
        * A secondary button of split button that opens dropdown.
        */
        __publicField(this, "arrowView");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
        * keystrokes of the split button:
        *
        * * <kbd>▶</kbd> moves focus to arrow view when action view is focused,
        * * <kbd>◀</kbd> moves focus to action view when arrow view is focused.
        */
        __publicField(this, "keystrokes");
        /**
        * Tracks information about DOM focus in the dropdown.
        */
        __publicField(this, "focusTracker");
        const bind = this.bindTemplate;
        this.set("class", void 0);
        this.set("labelStyle", void 0);
        this.set("icon", void 0);
        this.set("isEnabled", true);
        this.set("isOn", false);
        this.set("isToggleable", false);
        this.set("isVisible", true);
        this.set("keystroke", void 0);
        this.set("withKeystroke", false);
        this.set("label", void 0);
        this.set("tabindex", -1);
        this.set("tooltip", false);
        this.set("tooltipPosition", "s");
        this.set("type", "button");
        this.set("withText", false);
        this.children = this.createCollection();
        this.actionView = this._createActionView(actionButton);
        this.arrowView = this._createArrowView();
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-splitbutton",
              bind.to("class"),
              bind.if("isVisible", "ck-hidden", (value) => !value),
              this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")
            ]
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.actionView);
        this.children.add(this.arrowView);
        this.focusTracker.add(this.actionView.element);
        this.focusTracker.add(this.arrowView.element);
        this.keystrokes.listenTo(this.element);
        this.keystrokes.set("arrowright", (evt, cancel2) => {
          if (this.focusTracker.focusedElement === this.actionView.element) {
            this.arrowView.focus();
            cancel2();
          }
        });
        this.keystrokes.set("arrowleft", (evt, cancel2) => {
          if (this.focusTracker.focusedElement === this.arrowView.element) {
            this.actionView.focus();
            cancel2();
          }
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the {@link module:ui/button/buttonview~ButtonView#element} of the action part of split button.
      */
      focus() {
        this.actionView.focus();
      }
      /**
      * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
      * attributes.
      */
      _createActionView(actionButton) {
        const actionView = actionButton || new ButtonView();
        if (!actionButton) {
          actionView.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this);
        }
        actionView.extendTemplate({
          attributes: {
            class: "ck-splitbutton__action"
          }
        });
        actionView.delegate("execute").to(this);
        return actionView;
      }
      /**
      * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
      * attributes.
      */
      _createArrowView() {
        const arrowView = new ButtonView();
        const bind = arrowView.bindTemplate;
        arrowView.icon = dropdownArrowIcon;
        arrowView.extendTemplate({
          attributes: {
            class: [
              "ck-splitbutton__arrow"
            ],
            "data-cke-tooltip-disabled": bind.to("isOn"),
            "aria-haspopup": true,
            "aria-expanded": bind.to("isOn", (value) => String(value))
          }
        });
        arrowView.bind("isEnabled").to(this);
        arrowView.bind("label").to(this);
        arrowView.bind("tooltip").to(this);
        arrowView.delegate("execute").to(this, "open");
        return arrowView;
      }
    }
    function createDropdown(locale, ButtonClassOrInstance = DropdownButtonView) {
      const buttonView = typeof ButtonClassOrInstance == "function" ? new ButtonClassOrInstance(locale) : ButtonClassOrInstance;
      const panelView = new DropdownPanelView(locale);
      const dropdownView = new DropdownView(locale, buttonView, panelView);
      buttonView.bind("isEnabled").to(dropdownView);
      if (buttonView instanceof SplitButtonView) {
        buttonView.arrowView.bind("isOn").to(dropdownView, "isOpen");
      } else {
        buttonView.bind("isOn").to(dropdownView, "isOpen");
      }
      addDefaultBehavior(dropdownView);
      return dropdownView;
    }
    function addToolbarToDropdown(dropdownView, buttonsOrCallback, options = {}) {
      dropdownView.extendTemplate({
        attributes: {
          class: [
            "ck-toolbar-dropdown"
          ]
        }
      });
      if (dropdownView.isOpen) {
        addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options);
      } else {
        dropdownView.once("change:isOpen", () => addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options), {
          priority: "highest"
        });
      }
      if (options.enableActiveItemFocusOnDropdownOpen) {
        focusChildOnDropdownOpen(dropdownView, () => dropdownView.toolbarView.items.find((item) => item.isOn));
      }
    }
    function addToolbarToOpenDropdown(dropdownView, buttonsOrCallback, options) {
      const locale = dropdownView.locale;
      const t = locale.t;
      const toolbarView = dropdownView.toolbarView = new ToolbarView(locale);
      const buttons = typeof buttonsOrCallback == "function" ? buttonsOrCallback() : buttonsOrCallback;
      toolbarView.ariaLabel = options.ariaLabel || t("Dropdown toolbar");
      if (options.maxWidth) {
        toolbarView.maxWidth = options.maxWidth;
      }
      if (options.class) {
        toolbarView.class = options.class;
      }
      if (options.isCompact) {
        toolbarView.isCompact = options.isCompact;
      }
      if (options.isVertical) {
        toolbarView.isVertical = true;
      }
      if (buttons instanceof ViewCollection) {
        toolbarView.items.bindTo(buttons).using((item) => item);
      } else {
        toolbarView.items.addMany(buttons);
      }
      dropdownView.panelView.children.add(toolbarView);
      toolbarView.items.delegate("execute").to(dropdownView);
    }
    function addListToDropdown(dropdownView, itemsOrCallback, options = {}) {
      if (dropdownView.isOpen) {
        addListToOpenDropdown(dropdownView, itemsOrCallback, options);
      } else {
        dropdownView.once("change:isOpen", () => addListToOpenDropdown(dropdownView, itemsOrCallback, options), {
          priority: "highest"
        });
      }
      focusChildOnDropdownOpen(dropdownView, () => dropdownView.listView.items.find((item) => {
        if (item instanceof ListItemView) {
          return item.children.first.isOn;
        }
        return false;
      }));
    }
    function addListToOpenDropdown(dropdownView, itemsOrCallback, options) {
      const locale = dropdownView.locale;
      const listView = dropdownView.listView = new ListView(locale);
      const items = typeof itemsOrCallback == "function" ? itemsOrCallback() : itemsOrCallback;
      listView.ariaLabel = options.ariaLabel;
      listView.role = options.role;
      bindViewCollectionItemsToDefinitions(dropdownView, listView.items, items, locale);
      dropdownView.panelView.children.add(listView);
      listView.items.delegate("execute").to(dropdownView);
    }
    function focusChildOnDropdownOpen(dropdownView, childSelectorCallback) {
      dropdownView.on("change:isOpen", () => {
        if (!dropdownView.isOpen) {
          return;
        }
        const childToFocus = childSelectorCallback();
        if (!childToFocus) {
          return;
        }
        if (typeof childToFocus.focus === "function") {
          childToFocus.focus();
        } else {
          logWarning("ui-dropdown-focus-child-on-open-child-missing-focus", {
            view: childToFocus
          });
        }
      }, {
        priority: priorities.low - 10
      });
    }
    function addDefaultBehavior(dropdownView) {
      closeDropdownOnClickOutside(dropdownView);
      closeDropdownOnExecute(dropdownView);
      closeDropdownOnBlur(dropdownView);
      focusDropdownContentsOnArrows(dropdownView);
      focusDropdownButtonOnClose(dropdownView);
      focusDropdownPanelOnOpen(dropdownView);
    }
    function closeDropdownOnClickOutside(dropdownView) {
      dropdownView.on("render", () => {
        clickOutsideHandler({
          emitter: dropdownView,
          activator: () => dropdownView.isOpen,
          callback: () => {
            dropdownView.isOpen = false;
          },
          contextElements: () => [
            dropdownView.element,
            ...dropdownView.focusTracker._elements
          ]
        });
      });
    }
    function closeDropdownOnExecute(dropdownView) {
      dropdownView.on("execute", (evt) => {
        if (evt.source instanceof SwitchButtonView) {
          return;
        }
        dropdownView.isOpen = false;
      });
    }
    function closeDropdownOnBlur(dropdownView) {
      dropdownView.focusTracker.on("change:isFocused", (evt, name, isFocused) => {
        if (dropdownView.isOpen && !isFocused) {
          dropdownView.isOpen = false;
        }
      });
    }
    function focusDropdownContentsOnArrows(dropdownView) {
      dropdownView.keystrokes.set("arrowdown", (data, cancel2) => {
        if (dropdownView.isOpen) {
          dropdownView.panelView.focus();
          cancel2();
        }
      });
      dropdownView.keystrokes.set("arrowup", (data, cancel2) => {
        if (dropdownView.isOpen) {
          dropdownView.panelView.focusLast();
          cancel2();
        }
      });
    }
    function focusDropdownButtonOnClose(dropdownView) {
      dropdownView.on("change:isOpen", (evt, name, isOpen) => {
        if (isOpen) {
          return;
        }
        const element = dropdownView.panelView.element;
        if (element && element.contains(global$1.document.activeElement)) {
          dropdownView.buttonView.focus();
        }
      });
    }
    function focusDropdownPanelOnOpen(dropdownView) {
      dropdownView.on("change:isOpen", (evt, name, isOpen) => {
        if (!isOpen) {
          return;
        }
        dropdownView.panelView.focus();
      }, {
        priority: "low"
      });
    }
    function bindViewCollectionItemsToDefinitions(dropdownView, listItems, definitions, locale) {
      listItems.bindTo(definitions).using((def) => {
        if (def.type === "separator") {
          return new ListSeparatorView(locale);
        } else if (def.type === "group") {
          const groupView = new ListItemGroupView(locale);
          groupView.set({
            label: def.label
          });
          bindViewCollectionItemsToDefinitions(dropdownView, groupView.items, def.items, locale);
          groupView.items.delegate("execute").to(dropdownView);
          return groupView;
        } else if (def.type === "button" || def.type === "switchbutton") {
          const listItemView = new ListItemView(locale);
          let buttonView;
          if (def.type === "button") {
            buttonView = new ButtonView(locale);
            buttonView.bind("ariaChecked").to(buttonView, "isOn");
          } else {
            buttonView = new SwitchButtonView(locale);
          }
          buttonView.bind(...Object.keys(def.model)).to(def.model);
          buttonView.delegate("execute").to(listItemView);
          listItemView.children.add(buttonView);
          return listItemView;
        }
        return null;
      });
    }
    const createLabeledInputText = (labeledFieldView, viewUid, statusUid) => {
      const inputView = new InputTextView(labeledFieldView.locale);
      inputView.set({
        id: viewUid,
        ariaDescribedById: statusUid
      });
      inputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
      inputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
      inputView.on("input", () => {
        labeledFieldView.errorText = null;
      });
      labeledFieldView.bind("isEmpty", "isFocused", "placeholder").to(inputView);
      return inputView;
    };
    const createLabeledDropdown = (labeledFieldView, viewUid, statusUid) => {
      const dropdownView = createDropdown(labeledFieldView.locale);
      dropdownView.set({
        id: viewUid,
        ariaDescribedById: statusUid
      });
      dropdownView.bind("isEnabled").to(labeledFieldView);
      return dropdownView;
    };
    const waitingTime = 150;
    class ColorPickerView extends View {
      /**
      * Creates a view of color picker.
      *
      * @param locale
      * @param config
      */
      constructor(locale, config = {}) {
        super(locale);
        /**
        * Container for a `#` sign prefix and an input for displaying and defining custom colors
        * in HEX format.
        */
        __publicField(this, "hexInputRow");
        /**
        * Debounced function updating the `color` property in the component
        * and firing the `ColorPickerColorSelectedEvent`. Executed whenever color in component
        * is changed by the user interaction (through the palette or input).
        *
        * @private
        */
        __publicField(this, "_debounceColorPickerEvent");
        /**
        * A reference to the configuration of the color picker specified in the constructor.
        *
        * @private
        */
        __publicField(this, "_config");
        this.set({
          color: "",
          _hexColor: ""
        });
        this.hexInputRow = this._createInputRow();
        const children = this.createCollection();
        if (!config.hideInput) {
          children.add(this.hexInputRow);
        }
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-color-picker"
            ],
            tabindex: -1
          },
          children
        });
        this._config = config;
        this._debounceColorPickerEvent = debounce((color) => {
          this.set("color", color);
          this.fire("colorSelected", {
            color: this.color
          });
        }, waitingTime, {
          leading: true
        });
        this.on("set:color", (evt, propertyName, newValue) => {
          evt.return = convertColor(newValue, this._config.format || "hsl");
        });
        this.on("change:color", () => {
          this._hexColor = convertColorToCommonHexFormat(this.color);
        });
        this.on("change:_hexColor", () => {
          if (document.activeElement !== this.picker) {
            this.picker.setAttribute("color", this._hexColor);
          }
          if (convertColorToCommonHexFormat(this.color) != convertColorToCommonHexFormat(this._hexColor)) {
            this.color = this._hexColor;
          }
        });
      }
      /**
      * Renders color picker in the view.
      */
      render() {
        super.render();
        registerCustomElement("hex-color-picker", HexBase);
        this.picker = global$1.document.createElement("hex-color-picker");
        this.picker.setAttribute("class", "hex-color-picker");
        this.picker.setAttribute("tabindex", "-1");
        this._createSlidersView();
        if (this.element) {
          if (this.hexInputRow.element) {
            this.element.insertBefore(this.picker, this.hexInputRow.element);
          } else {
            this.element.appendChild(this.picker);
          }
          const styleSheetForFocusedColorPicker = document.createElement("style");
          styleSheetForFocusedColorPicker.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}';
          this.picker.shadowRoot.appendChild(styleSheetForFocusedColorPicker);
        }
        this.picker.addEventListener("color-changed", (event) => {
          const color = event.detail.value;
          this._debounceColorPickerEvent(color);
        });
      }
      /**
      * Focuses the first pointer in color picker.
      *
      */
      focus() {
        /* istanbul ignore next -- @preserve */
        if (!this._config.hideInput && (env.isGecko || env.isiOS || env.isSafari)) {
          const input = this.hexInputRow.children.get(1);
          input.focus();
        }
        const firstSlider = this.slidersView.first;
        firstSlider.focus();
      }
      /**
      * Creates collection of sliders in color picker.
      *
      * @private
      */
      _createSlidersView() {
        const colorPickersChildren = [
          ...this.picker.shadowRoot.children
        ];
        const sliders = colorPickersChildren.filter((item) => item.getAttribute("role") === "slider");
        const slidersView = sliders.map((slider) => {
          const view = new SliderView(slider);
          return view;
        });
        this.slidersView = this.createCollection();
        slidersView.forEach((item) => {
          this.slidersView.add(item);
        });
      }
      /**
      * Creates input row for defining custom colors in color picker.
      *
      * @private
      */
      _createInputRow() {
        const colorInput = this._createColorInput();
        return new ColorPickerInputRowView(this.locale, colorInput);
      }
      /**
      * Creates the input where user can type or paste the color in hex format.
      *
      * @private
      */
      _createColorInput() {
        const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
        const { t } = this.locale;
        labeledInput.set({
          label: t("HEX"),
          class: "color-picker-hex-input"
        });
        labeledInput.fieldView.bind("value").to(this, "_hexColor", (pickerColor) => {
          if (labeledInput.isFocused) {
            return labeledInput.fieldView.value;
          } else {
            return pickerColor.startsWith("#") ? pickerColor.substring(1) : pickerColor;
          }
        });
        labeledInput.fieldView.on("input", () => {
          const inputValue = labeledInput.fieldView.element.value;
          if (inputValue) {
            const maybeHexColor = tryParseHexColor(inputValue);
            if (maybeHexColor) {
              this._debounceColorPickerEvent(maybeHexColor);
            }
          }
        });
        return labeledInput;
      }
      /**
      * Validates the view and returns `false` when some fields are invalid.
      */
      isValid() {
        const { t } = this.locale;
        this.resetValidationStatus();
        if (!this.hexInputRow.getParsedColor()) {
          this.hexInputRow.inputView.errorText = t('Please enter a valid color (e.g. "ff0000").');
          return false;
        }
        return true;
      }
      /**
      * Cleans up the supplementary error and information text of input inside the {@link #hexInputRow}
      * bringing them back to the state when the form has been displayed for the first time.
      *
      * See {@link #isValid}.
      */
      resetValidationStatus() {
        this.hexInputRow.inputView.errorText = null;
      }
    }
    function convertColorToCommonHexFormat(inputColor) {
      let ret = convertToHex(inputColor);
      if (!ret) {
        ret = "#000";
      }
      if (ret.length === 4) {
        ret = "#" + [
          ret[1],
          ret[1],
          ret[2],
          ret[2],
          ret[3],
          ret[3]
        ].join("");
      }
      return ret.toLowerCase();
    }
    class SliderView extends View {
      /**
      * @param element HTML element of slider in color picker.
      */
      constructor(element) {
        super();
        this.element = element;
      }
      /**
      * Focuses element.
      */
      focus() {
        this.element.focus();
      }
    }
    class HashView extends View {
      constructor(locale) {
        super(locale);
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-color-picker__hash-view"
            ]
          },
          children: "#"
        });
      }
    }
    class ColorPickerInputRowView extends View {
      /**
      * Creates an instance of the form row class.
      *
      * @param locale The locale instance.
      * @param inputView Hex color input element.
      */
      constructor(locale, inputView) {
        super(locale);
        /**
        * A collection of row items (buttons, dropdowns, etc.).
        */
        __publicField(this, "children");
        /**
        * Hex input view element.
        */
        __publicField(this, "inputView");
        this.inputView = inputView;
        this.children = this.createCollection([
          new HashView(),
          this.inputView
        ]);
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-color-picker__row"
            ]
          },
          children: this.children
        });
      }
      /**
      * Returns false if color input value is not in hex format.
      */
      getParsedColor() {
        return tryParseHexColor(this.inputView.fieldView.element.value);
      }
    }
    function tryParseHexColor(color) {
      if (!color) {
        return null;
      }
      const hashLessColor = color.trim().replace(/^#/, "");
      if (![
        3,
        4,
        6,
        8
      ].includes(hashLessColor.length)) {
        return null;
      }
      if (!/^(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})$/.test(hashLessColor)) {
        return null;
      }
      return `#${hashLessColor}`;
    }
    class DocumentColorCollection extends (/* @__PURE__ */ ObservableMixin(Collection)) {
      constructor(options) {
        super(options);
        this.set("isEmpty", true);
        this.on("change", () => {
          this.set("isEmpty", this.length === 0);
        });
      }
      /**
      * Adds a color to the document color collection.
      *
      * This method ensures that no color duplicates are inserted (compared using
      * the color value of the {@link module:ui/colorgrid/colorgridview~ColorDefinition}).
      *
      * If the item does not have an ID, it will be automatically generated and set on the item.
      *
      * @param index The position of the item in the collection. The item is pushed to the collection when `index` is not specified.
      * @fires add
      * @fires change
      */
      add(item, index2) {
        if (this.find((element) => element.color === item.color)) {
          return this;
        }
        return super.add(item, index2);
      }
      /**
      * Checks if an object with given colors is present in the document color collection.
      */
      hasColor(color) {
        return !!this.find((item) => item.color === color);
      }
    }
    class ColorGridsFragmentView extends View {
      /**
      * Creates an instance of the view.
      *
      * @param locale The localization services instance.
      * @param colors An array with definitions of colors to be displayed in the table.
      * @param columns The number of columns in the color grid.
      * @param removeButtonLabel The label of the button responsible for removing the color.
      * @param colorPickerLabel The label of the button responsible for color picker appearing.
      * @param documentColorsLabel The label for the section with the document colors.
      * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
      * @param focusTracker Tracks information about the DOM focus in the list.
      * @param focusables A collection of views that can be focused in the view.
      */
      constructor(locale, { colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, focusTracker, focusables }) {
        super(locale);
        /**
        * A collection of the children of the table.
        */
        __publicField(this, "items");
        /**
        * An array with objects representing colors to be displayed in the grid.
        */
        __publicField(this, "colorDefinitions");
        /**
        * Tracks information about the DOM focus in the list.
        */
        __publicField(this, "focusTracker");
        /**
        * The number of columns in the color grid.
        */
        __publicField(this, "columns");
        /**
        * Preserves the reference to {@link module:ui/colorselector/documentcolorcollection~DocumentColorCollection} used to collect
        * definitions that store the document colors.
        *
        * @readonly
        */
        __publicField(this, "documentColors");
        /**
        * The maximum number of colors in the document colors section.
        * If it equals 0, the document colors section is not added.
        *
        * @readonly
        */
        __publicField(this, "documentColorsCount");
        /**
        * Preserves the reference to {@link module:ui/colorgrid/colorgridview~ColorGridView} used to create
        * the default (static) color set.
        *
        * The property is loaded once the the parent dropdown is opened the first time.
        *
        * @readonly
        */
        __publicField(this, "staticColorsGrid");
        /**
        * Preserves the reference to {@link module:ui/colorgrid/colorgridview~ColorGridView} used to create
        * the document colors. It remains undefined if the document colors feature is disabled.
        *
        * The property is loaded once the the parent dropdown is opened the first time.
        *
        * @readonly
        */
        __publicField(this, "documentColorsGrid");
        /**
        * The "Color picker" button view.
        */
        __publicField(this, "colorPickerButtonView");
        /**
        * The "Remove color" button view.
        */
        __publicField(this, "removeColorButtonView");
        /**
        * A collection of views that can be focused in the view.
        *
        * @readonly
        */
        __publicField(this, "_focusables");
        /**
        * Document color section's label.
        *
        * @readonly
        */
        __publicField(this, "_documentColorsLabel");
        /**
        * The label of the button responsible for removing color attributes.
        */
        __publicField(this, "_removeButtonLabel");
        /**
        * The label of the button responsible for switching to the color picker component.
        */
        __publicField(this, "_colorPickerLabel");
        const bind = this.bindTemplate;
        this.set("isVisible", true);
        this.focusTracker = focusTracker;
        this.items = this.createCollection();
        this.colorDefinitions = colors;
        this.columns = columns;
        this.documentColors = new DocumentColorCollection();
        this.documentColorsCount = documentColorsCount;
        this._focusables = focusables;
        this._removeButtonLabel = removeButtonLabel;
        this._colorPickerLabel = colorPickerLabel;
        this._documentColorsLabel = documentColorsLabel;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck-color-grids-fragment",
              bind.if("isVisible", "ck-hidden", (value) => !value)
            ]
          },
          children: this.items
        });
        this.removeColorButtonView = this._createRemoveColorButton();
        this.items.add(this.removeColorButtonView);
      }
      /**
      * Scans through the editor model and searches for text node attributes with the given attribute name.
      * Found entries are set as document colors.
      *
      * All the previously stored document colors will be lost in the process.
      *
      * @param model The model used as a source to obtain the document colors.
      * @param attributeName Determines the name of the related model's attribute for a given dropdown.
      */
      updateDocumentColors(model, attributeName) {
        const document2 = model.document;
        const maxCount = this.documentColorsCount;
        this.documentColors.clear();
        for (const root2 of document2.getRoots()) {
          const range = model.createRangeIn(root2);
          for (const node of range.getItems()) {
            if (node.is("$textProxy") && node.hasAttribute(attributeName)) {
              this._addColorToDocumentColors(node.getAttribute(attributeName));
              if (this.documentColors.length >= maxCount) {
                return;
              }
            }
          }
        }
      }
      /**
      * Refreshes the state of the selected color in one or both {@link module:ui/colorgrid/colorgridview~ColorGridView}s
      * available in the {@link module:ui/colorselector/colorselectorview~ColorSelectorView}. It guarantees that the selection will
      * occur only in one of them.
      */
      updateSelectedColors() {
        const documentColorsGrid = this.documentColorsGrid;
        const staticColorsGrid = this.staticColorsGrid;
        const selectedColor = this.selectedColor;
        staticColorsGrid.selectedColor = selectedColor;
        if (documentColorsGrid) {
          documentColorsGrid.selectedColor = selectedColor;
        }
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.staticColorsGrid = this._createStaticColorsGrid();
        this.items.add(this.staticColorsGrid);
        if (this.documentColorsCount) {
          const bind = Template.bind(this.documentColors, this.documentColors);
          const label = new LabelView(this.locale);
          label.text = this._documentColorsLabel;
          label.extendTemplate({
            attributes: {
              class: [
                "ck",
                "ck-color-grid__label",
                bind.if("isEmpty", "ck-hidden")
              ]
            }
          });
          this.items.add(label);
          this.documentColorsGrid = this._createDocumentColorsGrid();
          this.items.add(this.documentColorsGrid);
        }
        this._createColorPickerButton();
        this._addColorSelectorElementsToFocusTracker();
      }
      /**
      * Focuses the component.
      */
      focus() {
        this.removeColorButtonView.focus();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
      }
      /**
      * Handles displaying the color picker button (if it was previously created) and making it focusable.
      */
      addColorPickerButton() {
        if (this.colorPickerButtonView) {
          this.items.add(this.colorPickerButtonView);
          this.focusTracker.add(this.colorPickerButtonView.element);
          this._focusables.add(this.colorPickerButtonView);
        }
      }
      /**
      * Adds color selector elements to focus tracker.
      */
      _addColorSelectorElementsToFocusTracker() {
        this.focusTracker.add(this.removeColorButtonView.element);
        this._focusables.add(this.removeColorButtonView);
        if (this.staticColorsGrid) {
          this.focusTracker.add(this.staticColorsGrid.element);
          this._focusables.add(this.staticColorsGrid);
        }
        if (this.documentColorsGrid) {
          this.focusTracker.add(this.documentColorsGrid.element);
          this._focusables.add(this.documentColorsGrid);
        }
      }
      /**
      * Creates the button responsible for displaying the color picker component.
      */
      _createColorPickerButton() {
        this.colorPickerButtonView = new ButtonView();
        this.colorPickerButtonView.set({
          label: this._colorPickerLabel,
          withText: true,
          icon: icons.colorPalette,
          class: "ck-color-selector__color-picker"
        });
        this.colorPickerButtonView.on("execute", () => {
          this.fire("colorPicker:show");
        });
      }
      /**
      * Adds the remove color button as a child of the current view.
      */
      _createRemoveColorButton() {
        const buttonView = new ButtonView();
        buttonView.set({
          withText: true,
          icon: icons.eraser,
          label: this._removeButtonLabel
        });
        buttonView.class = "ck-color-selector__remove-color";
        buttonView.on("execute", () => {
          this.fire("execute", {
            value: null,
            source: "removeColorButton"
          });
        });
        buttonView.render();
        return buttonView;
      }
      /**
      * Creates a static color grid based on the editor configuration.
      */
      _createStaticColorsGrid() {
        const colorGrid = new ColorGridView(this.locale, {
          colorDefinitions: this.colorDefinitions,
          columns: this.columns
        });
        colorGrid.on("execute", (evt, data) => {
          this.fire("execute", {
            value: data.value,
            source: "staticColorsGrid"
          });
        });
        return colorGrid;
      }
      /**
      * Creates the document colors section view and binds it to {@link #documentColors}.
      */
      _createDocumentColorsGrid() {
        const bind = Template.bind(this.documentColors, this.documentColors);
        const documentColorsGrid = new ColorGridView(this.locale, {
          columns: this.columns
        });
        documentColorsGrid.extendTemplate({
          attributes: {
            class: bind.if("isEmpty", "ck-hidden")
          }
        });
        documentColorsGrid.items.bindTo(this.documentColors).using((colorObj) => {
          const colorTile = new ColorTileView();
          colorTile.set({
            color: colorObj.color,
            hasBorder: colorObj.options && colorObj.options.hasBorder
          });
          if (colorObj.label) {
            colorTile.set({
              label: colorObj.label,
              tooltip: true
            });
          }
          colorTile.on("execute", () => {
            this.fire("execute", {
              value: colorObj.color,
              source: "documentColorsGrid"
            });
          });
          return colorTile;
        });
        this.documentColors.on("change:isEmpty", (evt, name, val) => {
          if (val) {
            documentColorsGrid.selectedColor = null;
          }
        });
        return documentColorsGrid;
      }
      /**
      * Adds a given color to the document colors list. If possible, the method will attempt to use
      * data from the {@link #colorDefinitions} (label, color options).
      *
      * @param color A string that stores the value of the recently applied color.
      */
      _addColorToDocumentColors(color) {
        const predefinedColor = this.colorDefinitions.find((definition) => definition.color === color);
        if (!predefinedColor) {
          this.documentColors.add({
            color,
            label: color,
            options: {
              hasBorder: false
            }
          });
        } else {
          this.documentColors.add(Object.assign({}, predefinedColor));
        }
      }
    }
    class ColorPickerFragmentView extends View {
      /**
      * Creates an instance of the view.
      *
      * @param locale The localization services instance.
      * @param focusTracker Tracks information about the DOM focus in the list.
      * @param focusables A collection of views that can be focused in the view..
      * @param keystrokes An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
      * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker
      * will not be rendered.
      */
      constructor(locale, { focusTracker, focusables, keystrokes, colorPickerViewConfig }) {
        super(locale);
        /**
        * A collection of component's children.
        */
        __publicField(this, "items");
        /**
        * A view with saturation and hue sliders and color input.
        */
        __publicField(this, "colorPickerView");
        /**
        * The "Save" button view.
        */
        __publicField(this, "saveButtonView");
        /**
        * The "Cancel" button view.
        */
        __publicField(this, "cancelButtonView");
        /**
        * The action bar where are "Save" button and "Cancel" button.
        */
        __publicField(this, "actionBarView");
        /**
        * Tracks information about the DOM focus in the list.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of views that can be focused in the view.
        *
        * @readonly
        */
        __publicField(this, "_focusables");
        /**
        * A reference to the configuration of {@link #colorPickerView}. `false` when the view was
        * configured without a color picker.
        *
        * @readonly
        */
        __publicField(this, "_colorPickerViewConfig");
        this.items = this.createCollection();
        this.focusTracker = focusTracker;
        this.keystrokes = keystrokes;
        this.set("isVisible", false);
        this.set("selectedColor", void 0);
        this._focusables = focusables;
        this._colorPickerViewConfig = colorPickerViewConfig;
        const bind = this.bindTemplate;
        const { saveButtonView, cancelButtonView } = this._createActionButtons();
        this.saveButtonView = saveButtonView;
        this.cancelButtonView = cancelButtonView;
        this.actionBarView = this._createActionBarView({
          saveButtonView,
          cancelButtonView
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck-color-picker-fragment",
              bind.if("isVisible", "ck-hidden", (value) => !value)
            ]
          },
          children: this.items
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        const colorPickerView = new ColorPickerView(this.locale, {
          ...this._colorPickerViewConfig
        });
        this.colorPickerView = colorPickerView;
        this.colorPickerView.render();
        if (this.selectedColor) {
          colorPickerView.color = this.selectedColor;
        }
        this.listenTo(this, "change:selectedColor", (evt, name, value) => {
          colorPickerView.color = value;
        });
        this.items.add(this.colorPickerView);
        this.items.add(this.actionBarView);
        this._addColorPickersElementsToFocusTracker();
        this._stopPropagationOnArrowsKeys();
        this._executeOnEnterPress();
        this._executeUponColorChange();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
      }
      /**
      * Focuses the color picker.
      */
      focus() {
        this.colorPickerView.focus();
      }
      /**
      * Reset validation messages.
      */
      resetValidationStatus() {
        this.colorPickerView.resetValidationStatus();
      }
      /**
      * When color picker is focused and "enter" is pressed it executes command.
      */
      _executeOnEnterPress() {
        this.keystrokes.set("enter", (evt) => {
          if (this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && this.colorPickerView.isValid()) {
            this.fire("execute", {
              value: this.selectedColor
            });
            evt.stopPropagation();
            evt.preventDefault();
          }
        });
      }
      /**
      * Removes default behavior of arrow keys in dropdown.
      */
      _stopPropagationOnArrowsKeys() {
        const stopPropagation = (data) => data.stopPropagation();
        this.keystrokes.set("arrowright", stopPropagation);
        this.keystrokes.set("arrowleft", stopPropagation);
        this.keystrokes.set("arrowup", stopPropagation);
        this.keystrokes.set("arrowdown", stopPropagation);
      }
      /**
      * Adds color picker elements to focus tracker.
      */
      _addColorPickersElementsToFocusTracker() {
        for (const slider of this.colorPickerView.slidersView) {
          this.focusTracker.add(slider.element);
          this._focusables.add(slider);
        }
        const input = this.colorPickerView.hexInputRow.children.get(1);
        if (input.element) {
          this.focusTracker.add(input.element);
          this._focusables.add(input);
        }
        this.focusTracker.add(this.saveButtonView.element);
        this._focusables.add(this.saveButtonView);
        this.focusTracker.add(this.cancelButtonView.element);
        this._focusables.add(this.cancelButtonView);
      }
      /**
      * Creates bar containing "Save" and "Cancel" buttons.
      */
      _createActionBarView({ saveButtonView, cancelButtonView }) {
        const actionBarRow = new View();
        const children = this.createCollection();
        children.add(saveButtonView);
        children.add(cancelButtonView);
        actionBarRow.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-color-selector_action-bar"
            ]
          },
          children
        });
        return actionBarRow;
      }
      /**
      * Creates "Save" and "Cancel" buttons.
      */
      _createActionButtons() {
        const locale = this.locale;
        const t = locale.t;
        const saveButtonView = new ButtonView(locale);
        const cancelButtonView = new ButtonView(locale);
        saveButtonView.set({
          icon: icons.check,
          class: "ck-button-save",
          type: "button",
          withText: false,
          label: t("Accept")
        });
        cancelButtonView.set({
          icon: icons.cancel,
          class: "ck-button-cancel",
          type: "button",
          withText: false,
          label: t("Cancel")
        });
        saveButtonView.on("execute", () => {
          if (this.colorPickerView.isValid()) {
            this.fire("execute", {
              source: "colorPickerSaveButton",
              value: this.selectedColor
            });
          }
        });
        cancelButtonView.on("execute", () => {
          this.fire("colorPicker:cancel");
        });
        return {
          saveButtonView,
          cancelButtonView
        };
      }
      /**
      * Fires the `execute` event if color in color picker has been changed
      * by the user.
      */
      _executeUponColorChange() {
        this.colorPickerView.on("colorSelected", (evt, data) => {
          this.fire("execute", {
            value: data.color,
            source: "colorPicker"
          });
          this.set("selectedColor", data.color);
        });
      }
    }
    class ColorSelectorView extends View {
      /**
      * Creates a view to be inserted as a child of {@link module:ui/dropdown/dropdownview~DropdownView}.
      *
      * @param locale The localization services instance.
      * @param colors An array with definitions of colors to be displayed in the table.
      * @param columns The number of columns in the color grid.
      * @param removeButtonLabel The label of the button responsible for removing the color.
      * @param colorPickerLabel The label of the button responsible for color picker appearing.
      * @param documentColorsLabel The label for the section with the document colors.
      * @param documentColorsCount The number of colors in the document colors section inside the color dropdown.
      * @param colorPickerViewConfig The configuration of color picker feature. If set to `false`, the color picker will be hidden.
      */
      constructor(locale, { colors, columns, removeButtonLabel, documentColorsLabel, documentColorsCount, colorPickerLabel, colorPickerViewConfig }) {
        super(locale);
        /**
        * Tracks information about the DOM focus in the list.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of components.
        */
        __publicField(this, "items");
        /**
        * A fragment that allows users to select colors from the a predefined set and from existing document colors.
        */
        __publicField(this, "colorGridsFragmentView");
        /**
        * A fragment that allows users to select a color from a color picker.
        */
        __publicField(this, "colorPickerFragmentView");
        /**
        * Helps cycling over focusable {@link #items} in the list.
        *
        * @readonly
        */
        __publicField(this, "_focusCycler");
        /**
        * A collection of views that can be focused in the view.
        *
        * @readonly
        */
        __publicField(this, "_focusables");
        /**
        * The configuration of color picker sub-component.
        */
        __publicField(this, "_colorPickerViewConfig");
        this.items = this.createCollection();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this._focusables = new ViewCollection();
        this._colorPickerViewConfig = colorPickerViewConfig;
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate list items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
            focusPrevious: "shift + tab",
            // Navigate list items forwards using the <kbd>Tab</kbd> key.
            focusNext: "tab"
          }
        });
        this.colorGridsFragmentView = new ColorGridsFragmentView(locale, {
          colors,
          columns,
          removeButtonLabel,
          documentColorsLabel,
          documentColorsCount,
          colorPickerLabel,
          focusTracker: this.focusTracker,
          focusables: this._focusables
        });
        this.colorPickerFragmentView = new ColorPickerFragmentView(locale, {
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokes: this.keystrokes,
          colorPickerViewConfig
        });
        this.set("_isColorGridsFragmentVisible", true);
        this.set("_isColorPickerFragmentVisible", false);
        this.set("selectedColor", void 0);
        this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible");
        this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible");
        this.on("change:selectedColor", (evt, evtName, data) => {
          this.colorGridsFragmentView.set("selectedColor", data);
          this.colorPickerFragmentView.set("selectedColor", data);
        });
        this.colorGridsFragmentView.on("change:selectedColor", (evt, evtName, data) => {
          this.set("selectedColor", data);
        });
        this.colorPickerFragmentView.on("change:selectedColor", (evt, evtName, data) => {
          this.set("selectedColor", data);
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-color-selector"
            ]
          },
          children: this.items
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Renders the internals of the component on demand:
      * * {@link #colorPickerFragmentView},
      * * {@link #colorGridsFragmentView}.
      *
      * It allows for deferring component initialization to improve the performance.
      *
      * See {@link #showColorPickerFragment}, {@link #showColorGridsFragment}.
      */
      appendUI() {
        this._appendColorGridsFragment();
        if (this._colorPickerViewConfig) {
          this._appendColorPickerFragment();
        }
      }
      /**
      * Shows the {@link #colorPickerFragmentView} and hides the {@link #colorGridsFragmentView}.
      *
      * **Note**: It requires {@link #appendUI} to be called first.
      *
      * See {@link #showColorGridsFragment}, {@link ~ColorSelectorView#event:colorPicker:show}.
      */
      showColorPickerFragment() {
        if (!this.colorPickerFragmentView.colorPickerView || this._isColorPickerFragmentVisible) {
          return;
        }
        this._isColorPickerFragmentVisible = true;
        this.colorPickerFragmentView.focus();
        this.colorPickerFragmentView.resetValidationStatus();
        this._isColorGridsFragmentVisible = false;
      }
      /**
      * Shows the {@link #colorGridsFragmentView} and hides the {@link #colorPickerFragmentView}.
      *
      * See {@link #showColorPickerFragment}.
      *
      * **Note**: It requires {@link #appendUI} to be called first.
      */
      showColorGridsFragment() {
        if (this._isColorGridsFragmentVisible) {
          return;
        }
        this._isColorGridsFragmentVisible = true;
        this.colorGridsFragmentView.focus();
        this._isColorPickerFragmentVisible = false;
      }
      /**
      * Focuses the first focusable element in {@link #items}.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the last focusable element in {@link #items}.
      */
      focusLast() {
        this._focusCycler.focusLast();
      }
      /**
      * Scans through the editor model and searches for text node attributes with the given `attributeName`.
      * Found entries are set as document colors in {@link #colorGridsFragmentView}.
      *
      * All the previously stored document colors will be lost in the process.
      *
      * @param model The model used as a source to obtain the document colors.
      * @param attributeName Determines the name of the related model's attribute for a given dropdown.
      */
      updateDocumentColors(model, attributeName) {
        this.colorGridsFragmentView.updateDocumentColors(model, attributeName);
      }
      /**
      * Refreshes the state of the selected color in one or both grids located in {@link #colorGridsFragmentView}.
      *
      * It guarantees that the selection will occur only in one of them.
      */
      updateSelectedColors() {
        this.colorGridsFragmentView.updateSelectedColors();
      }
      /**
      * Appends the view containing static and document color grid views.
      */
      _appendColorGridsFragment() {
        if (this.items.length) {
          return;
        }
        this.items.add(this.colorGridsFragmentView);
        this.colorGridsFragmentView.delegate("execute").to(this);
        this.colorGridsFragmentView.delegate("colorPicker:show").to(this);
      }
      /**
      * Appends the view with the color picker.
      */
      _appendColorPickerFragment() {
        if (this.items.length === 2) {
          return;
        }
        this.items.add(this.colorPickerFragmentView);
        if (this.colorGridsFragmentView.colorPickerButtonView) {
          this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
            this.showColorPickerFragment();
          });
        }
        this.colorGridsFragmentView.addColorPickerButton();
        this.colorPickerFragmentView.delegate("execute").to(this);
        this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this);
      }
    }
    class ComponentFactory {
      /**
      * Creates an instance of the factory.
      *
      * @param editor The editor instance.
      */
      constructor(editor) {
        /**
        * The editor instance that the factory belongs to.
        */
        __publicField(this, "editor");
        /**
        * Registered component factories.
        */
        __publicField(this, "_components", /* @__PURE__ */ new Map());
        this.editor = editor;
      }
      /**
      * Returns an iterator of registered component names. Names are returned in lower case.
      */
      *names() {
        for (const value of this._components.values()) {
          yield value.originalName;
        }
      }
      /**
      * Registers a component factory function that will be used by the
      * {@link #create create} method and called with the
      * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
      * allowing localization of the {@link module:ui/view~View view}.
      *
      * @param name The name of the component.
      * @param callback The callback that returns the component.
      */
      add(name, callback) {
        this._components.set(getNormalized(name), {
          callback,
          originalName: name
        });
      }
      /**
      * Creates an instance of a component registered in the factory under a specific name.
      *
      * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
      * the previously {@link #add added} factory function, allowing localization of the
      * {@link module:ui/view~View view}.
      *
      * @param name The name of the component.
      * @returns The instantiated component view.
      */
      create(name) {
        if (!this.has(name)) {
          throw new CKEditorError("componentfactory-item-missing", this, {
            name
          });
        }
        return this._components.get(getNormalized(name)).callback(this.editor.locale);
      }
      /**
      * Checks if a component of a given name is registered in the factory.
      *
      * @param name The name of the component.
      */
      has(name) {
        return this._components.has(getNormalized(name));
      }
    }
    function getNormalized(name) {
      return String(name).toLowerCase();
    }
    const toPx$5 = /* @__PURE__ */ toUnit("px");
    const POSITION_OFF_SCREEN = {
      top: -99999,
      left: -99999,
      name: "arrowless",
      config: {
        withArrow: false
      }
    };
    const _BalloonPanelView = class _BalloonPanelView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of the child views that creates the balloon panel contents.
        */
        __publicField(this, "content");
        /**
        * A callback that starts pinning the panel when {@link #isVisible} gets
        * `true`. Used by {@link #pin}.
        *
        * @private
        */
        __publicField(this, "_pinWhenIsVisibleCallback");
        const bind = this.bindTemplate;
        this.set("top", 0);
        this.set("left", 0);
        this.set("position", "arrow_nw");
        this.set("isVisible", false);
        this.set("withArrow", true);
        this.set("class", void 0);
        this._pinWhenIsVisibleCallback = null;
        this.content = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-balloon-panel",
              bind.to("position", (value) => `ck-balloon-panel_${value}`),
              bind.if("isVisible", "ck-balloon-panel_visible"),
              bind.if("withArrow", "ck-balloon-panel_with-arrow"),
              bind.to("class")
            ],
            style: {
              top: bind.to("top", toPx$5),
              left: bind.to("left", toPx$5)
            }
          },
          children: this.content
        });
      }
      /**
      * Shows the panel.
      *
      * See {@link #isVisible}.
      */
      show() {
        this.isVisible = true;
      }
      /**
      * Hides the panel.
      *
      * See {@link #isVisible}.
      */
      hide() {
        this.isVisible = false;
      }
      /**
      * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
      * smart positioning heuristics that chooses from available positions to make sure the panel
      * is visible to the user i.e. within the limits of the viewport.
      *
      * This method accepts configuration {@link module:utils/dom/position~Options options}
      * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
      *
      * ```ts
      * const panel = new BalloonPanelView( locale );
      * const positions = BalloonPanelView.defaultPositions;
      *
      * panel.render();
      *
      * // Attach the panel to an element with the "target" id DOM.
      * panel.attachTo( {
      * 	target: document.querySelector( '#target' ),
      * 	positions: [
      * 		positions.northArrowSouth,
      * 		positions.southArrowNorth
      * 	]
      * } );
      * ```
      *
      * **Note**: Attaching the panel will also automatically {@link #show} it.
      *
      * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
      * See the {@link #pin} method for a more permanent positioning strategy.
      *
      * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
      * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
      */
      attachTo(options) {
        this.show();
        const defaultPositions = _BalloonPanelView.defaultPositions;
        const positionOptions = Object.assign({}, {
          element: this.element,
          positions: [
            defaultPositions.southArrowNorth,
            defaultPositions.southArrowNorthMiddleWest,
            defaultPositions.southArrowNorthMiddleEast,
            defaultPositions.southArrowNorthWest,
            defaultPositions.southArrowNorthEast,
            defaultPositions.northArrowSouth,
            defaultPositions.northArrowSouthMiddleWest,
            defaultPositions.northArrowSouthMiddleEast,
            defaultPositions.northArrowSouthWest,
            defaultPositions.northArrowSouthEast,
            defaultPositions.viewportStickyNorth
          ],
          limiter: global$1.document.body,
          fitInViewport: true
        }, options);
        const optimalPosition = _BalloonPanelView._getOptimalPosition(positionOptions) || POSITION_OFF_SCREEN;
        const left = parseInt(optimalPosition.left);
        const top = parseInt(optimalPosition.top);
        const position = optimalPosition.name;
        const config = optimalPosition.config || {};
        const { withArrow = true } = config;
        this.top = top;
        this.left = left;
        this.position = position;
        this.withArrow = withArrow;
      }
      /**
      * Works the same way as the {@link #attachTo} method except that the position of the panel is
      * continuously updated when:
      *
      * * any ancestor of the {@link module:utils/dom/position~Options#target}
      * or {@link module:utils/dom/position~Options#limiter} is scrolled,
      * * the browser window gets resized or scrolled.
      *
      * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
      * and is immune to the changing environment.
      *
      * ```ts
      * const panel = new BalloonPanelView( locale );
      * const positions = BalloonPanelView.defaultPositions;
      *
      * panel.render();
      *
      * // Pin the panel to an element with the "target" id DOM.
      * panel.pin( {
      * 	target: document.querySelector( '#target' ),
      * 	positions: [
      * 		positions.northArrowSouth,
      * 		positions.southArrowNorth
      * 	]
      * } );
      * ```
      *
      * To leave the pinned state, use the {@link #unpin} method.
      *
      * **Note**: Pinning the panel will also automatically {@link #show} it.
      *
      * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
      * Default `positions` array is {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
      */
      pin(options) {
        this.unpin();
        this._pinWhenIsVisibleCallback = () => {
          if (this.isVisible) {
            this._startPinning(options);
          } else {
            this._stopPinning();
          }
        };
        this._startPinning(options);
        this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
      }
      /**
      * Stops pinning the panel, as set up by {@link #pin}.
      */
      unpin() {
        if (this._pinWhenIsVisibleCallback) {
          this._stopPinning();
          this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback);
          this._pinWhenIsVisibleCallback = null;
          this.hide();
        }
      }
      /**
      * Starts managing the pinned state of the panel. See {@link #pin}.
      *
      * @param options Positioning options compatible with {@link module:utils/dom/position~getOptimalPosition}.
      */
      _startPinning(options) {
        this.attachTo(options);
        const targetElement = getDomElement(options.target);
        const limiterElement = options.limiter ? getDomElement(options.limiter) : global$1.document.body;
        this.listenTo(global$1.document, "scroll", (evt, domEvt) => {
          const scrollTarget = domEvt.target;
          const isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement);
          const isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement);
          if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
            this.attachTo(options);
          }
        }, {
          useCapture: true
        });
        this.listenTo(global$1.window, "resize", () => {
          this.attachTo(options);
        });
      }
      /**
      * Stops managing the pinned state of the panel. See {@link #pin}.
      */
      _stopPinning() {
        this.stopListening(global$1.document, "scroll");
        this.stopListening(global$1.window, "resize");
      }
      /**
      * Returns available {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView}
      * {@link module:utils/dom/position~PositioningFunction positioning functions} adjusted by the specific offsets.
      *
      * @internal
      * @param options Options to generate positions. If not specified, this helper will simply return
      * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
      * @param options.sideOffset A custom side offset (in pixels) of each position. If
      * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowSideOffset the default value}
      * will be used.
      * @param options.heightOffset A custom height offset (in pixels) of each position. If
      * not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHeightOffset the default value}
      * will be used.
      * @param options.stickyVerticalOffset A custom offset (in pixels) of the `viewportStickyNorth` positioning function.
      * If not specified, {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.stickyVerticalOffset the default value}
      * will be used.
      * @param options.config Additional configuration of the balloon balloon panel view.
      * Currently only {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#withArrow} is supported. Learn more
      * about {@link module:utils/dom/position~PositioningFunction positioning functions}.
      */
      static generatePositions(options = {}) {
        const { sideOffset = _BalloonPanelView.arrowSideOffset, heightOffset = _BalloonPanelView.arrowHeightOffset, stickyVerticalOffset = _BalloonPanelView.stickyVerticalOffset, config } = options;
        return {
          // ------- North west
          northWestArrowSouthWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - sideOffset,
            name: "arrow_sw",
            ...config && {
              config
            }
          }),
          northWestArrowSouthMiddleWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_smw",
            ...config && {
              config
            }
          }),
          northWestArrowSouth: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width / 2,
            name: "arrow_s",
            ...config && {
              config
            }
          }),
          northWestArrowSouthMiddleEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_sme",
            ...config && {
              config
            }
          }),
          northWestArrowSouthEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left - balloonRect.width + sideOffset,
            name: "arrow_se",
            ...config && {
              config
            }
          }),
          // ------- North
          northArrowSouthWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - sideOffset,
            name: "arrow_sw",
            ...config && {
              config
            }
          }),
          northArrowSouthMiddleWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_smw",
            ...config && {
              config
            }
          }),
          northArrowSouth: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
            name: "arrow_s",
            ...config && {
              config
            }
          }),
          northArrowSouthMiddleEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_sme",
            ...config && {
              config
            }
          }),
          northArrowSouthEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
            name: "arrow_se",
            ...config && {
              config
            }
          }),
          // ------- North east
          northEastArrowSouthWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - sideOffset,
            name: "arrow_sw",
            ...config && {
              config
            }
          }),
          northEastArrowSouthMiddleWest: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_smw",
            ...config && {
              config
            }
          }),
          northEastArrowSouth: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width / 2,
            name: "arrow_s",
            ...config && {
              config
            }
          }),
          northEastArrowSouthMiddleEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_sme",
            ...config && {
              config
            }
          }),
          northEastArrowSouthEast: (targetRect, balloonRect) => ({
            top: getNorthTop(targetRect, balloonRect),
            left: targetRect.right - balloonRect.width + sideOffset,
            name: "arrow_se",
            ...config && {
              config
            }
          }),
          // ------- South west
          southWestArrowNorthWest: (targetRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - sideOffset,
            name: "arrow_nw",
            ...config && {
              config
            }
          }),
          southWestArrowNorthMiddleWest: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_nmw",
            ...config && {
              config
            }
          }),
          southWestArrowNorth: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width / 2,
            name: "arrow_n",
            ...config && {
              config
            }
          }),
          southWestArrowNorthMiddleEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_nme",
            ...config && {
              config
            }
          }),
          southWestArrowNorthEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left - balloonRect.width + sideOffset,
            name: "arrow_ne",
            ...config && {
              config
            }
          }),
          // ------- South
          southArrowNorthWest: (targetRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - sideOffset,
            name: "arrow_nw",
            ...config && {
              config
            }
          }),
          southArrowNorthMiddleWest: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_nmw",
            ...config && {
              config
            }
          }),
          southArrowNorth: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
            name: "arrow_n",
            ...config && {
              config
            }
          }),
          southArrowNorthMiddleEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_nme",
            ...config && {
              config
            }
          }),
          southArrowNorthEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.left + targetRect.width / 2 - balloonRect.width + sideOffset,
            name: "arrow_ne",
            ...config && {
              config
            }
          }),
          // ------- South east
          southEastArrowNorthWest: (targetRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - sideOffset,
            name: "arrow_nw",
            ...config && {
              config
            }
          }),
          southEastArrowNorthMiddleWest: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width * 0.25 - sideOffset,
            name: "arrow_nmw",
            ...config && {
              config
            }
          }),
          southEastArrowNorth: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width / 2,
            name: "arrow_n",
            ...config && {
              config
            }
          }),
          southEastArrowNorthMiddleEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width * 0.75 + sideOffset,
            name: "arrow_nme",
            ...config && {
              config
            }
          }),
          southEastArrowNorthEast: (targetRect, balloonRect) => ({
            top: getSouthTop(targetRect),
            left: targetRect.right - balloonRect.width + sideOffset,
            name: "arrow_ne",
            ...config && {
              config
            }
          }),
          // ------- West
          westArrowEast: (targetRect, balloonRect) => ({
            top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
            left: targetRect.left - balloonRect.width - heightOffset,
            name: "arrow_e",
            ...config && {
              config
            }
          }),
          // ------- East
          eastArrowWest: (targetRect, balloonRect) => ({
            top: targetRect.top + targetRect.height / 2 - balloonRect.height / 2,
            left: targetRect.right + heightOffset,
            name: "arrow_w",
            ...config && {
              config
            }
          }),
          // ------- Sticky
          viewportStickyNorth: (targetRect, balloonRect, viewportRect, limiterRect) => {
            const boundaryRect = limiterRect || viewportRect;
            if (!targetRect.getIntersection(boundaryRect)) {
              return null;
            }
            if (boundaryRect.height - targetRect.height > stickyVerticalOffset) {
              return null;
            }
            return {
              top: boundaryRect.top + stickyVerticalOffset,
              left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
              name: "arrowless",
              config: {
                withArrow: false,
                ...config
              }
            };
          }
        };
        function getNorthTop(targetRect, balloonRect) {
          return targetRect.top - balloonRect.height - heightOffset;
        }
        function getSouthTop(targetRect) {
          return targetRect.bottom + heightOffset;
        }
      }
    };
    /**
    * A side offset of the arrow tip from the edge of the balloon. Controlled by CSS.
    *
    * ```
    *		 ┌───────────────────────┐
    *		 │                       │
    *		 │         Balloon       │
    *		 │         Content       │
    *		 │                       │
    *		 └──+    +───────────────┘
    *		 |   \  /
    *		 |    \/
    *		>┼─────┼< ─────────────────────── side offset
    *
    * ```
    *
    * @default 25
    */
    __publicField(_BalloonPanelView, "arrowSideOffset", 25);
    /**
     * A height offset of the arrow from the edge of the balloon. Controlled by CSS.
     *
     * ```
     *		 ┌───────────────────────┐
     *		 │                       │
     *		 │         Balloon       │
     *		 │         Content       │      ╱-- arrow height offset
     *		 │                       │      V
     *		 └──+    +───────────────┘ --- ─┼───────
     *		     \  /                       │
     *		      \/                        │
     *		────────────────────────────────┼───────
     *		                                ^
     *
     *
     *		>┼────┼<  arrow height offset
     *		 │    │
     *		 │    ┌────────────────────────┐
     *		 │    │                        │
     *		 │   ╱                         │
     *		 │ ╱            Balloon        │
     *		 │ ╲            Content        │
     *		 │   ╲                         │
     *		 │    │                        │
     *		 │    └────────────────────────┘
     * ```
     *
     * @default 10
    */
    __publicField(_BalloonPanelView, "arrowHeightOffset", 10);
    /**
    * A vertical offset of the balloon panel from the edge of the viewport if sticky.
    * It helps in accessing toolbar buttons underneath the balloon panel.
    *
    * ```
    *		  ┌───────────────────────────────────────────────────┐
    *		  │                      Target                       │
    *		  │                                                   │
    *		  │                            /── vertical offset    │
    *		┌─────────────────────────────V─────────────────────────┐
    *		│ Toolbar            ┌─────────────┐                    │
    *		├────────────────────│   Balloon   │────────────────────┤
    *		│ │                  └─────────────┘                  │ │
    *		│ │                                                   │ │
    *		│ │                                                   │ │
    *		│ │                                                   │ │
    *		│ └───────────────────────────────────────────────────┘ │
    *		│                        Viewport                       │
    *		└───────────────────────────────────────────────────────┘
    * ```
    *
    * @default 20
    */
    __publicField(_BalloonPanelView, "stickyVerticalOffset", 20);
    /**
    * Function used to calculate the optimal position for the balloon.
    */
    __publicField(_BalloonPanelView, "_getOptimalPosition", getOptimalPosition);
    /**
    * A default set of positioning functions used by the balloon panel view
    * when attaching using the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo} method.
    *
    * The available positioning functions are as follows:
    *
    * **North west**
    *
    * * `northWestArrowSouthWest`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		 V
    *		 [ Target ]
    * ```
    *
    * * `northWestArrowSouthMiddleWest`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		    V
    *		    [ Target ]
    * ```
    *
    * * `northWestArrowSouth`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		         V
    *		         [ Target ]
    * ```
    *
    * * `northWestArrowSouthMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		             V
    *		             [ Target ]
    * ```
    *
    * * `northWestArrowSouthEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		                 V
    *		                 [ Target ]
    * ```
    *
    * **North**
    *
    * * `northArrowSouthWest`
    *
    * ```
    *		    +-----------------+
    *		    |     Balloon     |
    *		    +-----------------+
    *		     V
    *		[ Target ]
    * ```
    *
    * * `northArrowSouthMiddleWest`
    *
    * ```
    *		 +-----------------+
    *		 |     Balloon     |
    *		 +-----------------+
    *		     V
    *		[ Target ]
    * ```
    * * `northArrowSouth`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		         V
    *		    [ Target ]
    * ```
    *
    * * `northArrowSouthMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		             V
    *		        [ Target ]
    * ```
    *
    * * `northArrowSouthEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		                V
    *		           [ Target ]
    * ```
    *
    * **North east**
    *
    * * `northEastArrowSouthWest`
    *
    * ```
    *		        +-----------------+
    *		        |     Balloon     |
    *		        +-----------------+
    *		         V
    *		[ Target ]
    * ```
    *
    * * `northEastArrowSouthMiddleWest`
    *
    * ```
    *		     +-----------------+
    *		     |     Balloon     |
    *		     +-----------------+
    *		         V
    *		[ Target ]
    * ```
    *
    * * `northEastArrowSouth`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		         V
    *		[ Target ]
    * ```
    *
    * * `northEastArrowSouthMiddleEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		             V
    *		    [ Target ]
    * ```
    *
    * * `northEastArrowSouthEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    *		                 V
    *		        [ Target ]
    * ```
    *
    * **South**
    *
    * * `southArrowNorthWest`
    *
    * ```
    *		[ Target ]
    *		     ^
    *		    +-----------------+
    *		    |     Balloon     |
    *		    +-----------------+
    * ```
    *
    * * `southArrowNorthMiddleWest`
    *
    * ```
    *		   [ Target ]
    *		        ^
    *		    +-----------------+
    *		    |     Balloon     |
    *		    +-----------------+
    * ```
    *
    * * `southArrowNorth`
    *
    * ```
    *		    [ Target ]
    *		         ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southArrowNorthMiddleEast`
    *
    * ```
    *		            [ Target ]
    *		                 ^
    *		   +-----------------+
    *		   |     Balloon     |
    *		   +-----------------+
    * ```
    *
    * * `southArrowNorthEast`
    *
    * ```
    *		            [ Target ]
    *		                 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * **South west**
    *
    * * `southWestArrowNorthWest`
    *
    *
    * ```
    *		 [ Target ]
    *		 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southWestArrowNorthMiddleWest`
    *
    * ```
    *		     [ Target ]
    *		     ^
    *		 +-----------------+
    *		 |     Balloon     |
    *		 +-----------------+
    * ```
    *
    * * `southWestArrowNorth`
    *
    * ```
    *		         [ Target ]
    *		         ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southWestArrowNorthMiddleEast`
    *
    * ```
    *		              [ Target ]
    *		              ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southWestArrowNorthEast`
    *
    * ```
    *		                 [ Target ]
    *		                 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * **South east**
    *
    * * `southEastArrowNorthWest`
    *
    * ```
    *		[ Target ]
    *		         ^
    *		        +-----------------+
    *		        |     Balloon     |
    *		        +-----------------+
    * ```
    *
    * * `southEastArrowNorthMiddleWest`
    *
    * ```
    *		   [ Target ]
    *		            ^
    *		        +-----------------+
    *		        |     Balloon     |
    *		        +-----------------+
    * ```
    *
    * * `southEastArrowNorth`
    *
    * ```
    *		[ Target ]
    *		         ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southEastArrowNorthMiddleEast`
    *
    * ```
    *		     [ Target ]
    *		              ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * * `southEastArrowNorthEast`
    *
    * ```
    *		        [ Target ]
    *		                 ^
    *		+-----------------+
    *		|     Balloon     |
    *		+-----------------+
    * ```
    *
    * **West**
    *
    * * `westArrowEast`
    *
    * ```
    *		+-----------------+
    *		|     Balloon     |>[ Target ]
    *		+-----------------+
    * ```
    *
    * **East**
    *
    * * `eastArrowWest`
    *
    * ```
    *		           +-----------------+
    *		[ Target ]<|     Balloon     |
    *		           +-----------------+
    * ```
    *
    * **Sticky**
    *
    * * `viewportStickyNorth`
    *
    * ```
    *		    +---------------------------+
    *		    |        [ Target ]         |
    *		    |                           |
    *		+-----------------------------------+
    *		|   |    +-----------------+    |   |
    *		|   |    |     Balloon     |    |   |
    *		|   |    +-----------------+    |   |
    *		|   |                           |   |
    *		|   |                           |   |
    *		|   |                           |   |
    *		|   |                           |   |
    *		|   +---------------------------+   |
    *		|             Viewport              |
    *		+-----------------------------------+
    * ```
    *
    * See {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo}.
    *
    * Positioning functions must be compatible with {@link module:utils/dom/position~DomPoint}.
    *
    * Default positioning functions with customized offsets can be generated using
    * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.generatePositions}.
    *
    * The name that the position function returns will be reflected in the balloon panel's class that
    * controls the placement of the "arrow". See {@link #position} to learn more.
    */
    __publicField(_BalloonPanelView, "defaultPositions", /* @__PURE__ */ _BalloonPanelView.generatePositions());
    let BalloonPanelView = _BalloonPanelView;
    function getDomElement(object) {
      if (isElement$1(object)) {
        return object;
      }
      if (isRange(object)) {
        return object.commonAncestorContainer;
      }
      if (typeof object == "function") {
        return getDomElement(object());
      }
      return null;
    }
    const BALLOON_CLASS = "ck-tooltip";
    const _TooltipManager = class _TooltipManager extends (/* @__PURE__ */ DomEmitterMixin()) {
      /**
      * Creates an instance of the tooltip manager.
      */
      constructor(editor) {
        super();
        /**
        * The view rendering text of the tooltip.
        */
        __publicField(this, "tooltipTextView");
        /**
        * The instance of the balloon panel that renders and positions the tooltip.
        */
        __publicField(this, "balloonPanelView");
        /**
        * Stores the reference to the DOM element the tooltip is attached to. `null` when there's no tooltip
        * in the UI.
        */
        __publicField(this, "_currentElementWithTooltip", null);
        /**
        * Stores the current tooltip position. `null` when there's no tooltip in the UI.
        */
        __publicField(this, "_currentTooltipPosition", null);
        /**
        * An instance of the resize observer that keeps track on target element visibility,
        * when it hides the tooltip should also disappear.
        *
        * {@link module:core/editor/editorconfig~EditorConfig#balloonToolbar configuration}.
        */
        __publicField(this, "_resizeObserver", null);
        /**
        * An instance of the mutation observer that keeps track on target element attributes changes.
        */
        __publicField(this, "_mutationObserver", null);
        /**
        * A debounced version of {@link #_pinTooltip}. Tooltips show with a delay to avoid flashing and
        * to improve the UX.
        */
        __publicField(this, "_pinTooltipDebounced");
        /**
        * A debounced version of {@link #_unpinTooltip}. Tooltips hide with a delay to allow hovering of their titles.
        */
        __publicField(this, "_unpinTooltipDebounced");
        __publicField(this, "_watchdogExcluded");
        _TooltipManager._editors.add(editor);
        if (_TooltipManager._instance) {
          return _TooltipManager._instance;
        }
        _TooltipManager._instance = this;
        this.tooltipTextView = new View(editor.locale);
        this.tooltipTextView.set("text", "");
        this.tooltipTextView.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-tooltip__text"
            ]
          },
          children: [
            {
              text: this.tooltipTextView.bindTemplate.to("text")
            }
          ]
        });
        this.balloonPanelView = new BalloonPanelView(editor.locale);
        this.balloonPanelView.class = BALLOON_CLASS;
        this.balloonPanelView.content.add(this.tooltipTextView);
        this._mutationObserver = createMutationObserver(() => {
          this._updateTooltipPosition();
        });
        this._pinTooltipDebounced = debounce(this._pinTooltip, 600);
        this._unpinTooltipDebounced = debounce(this._unpinTooltip, 400);
        this.listenTo(global$1.document, "keydown", this._onKeyDown.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "mouseenter", this._onEnterOrFocus.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "mouseleave", this._onLeaveOrBlur.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "focus", this._onEnterOrFocus.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "blur", this._onLeaveOrBlur.bind(this), {
          useCapture: true
        });
        this.listenTo(global$1.document, "scroll", this._onScroll.bind(this), {
          useCapture: true
        });
        this._watchdogExcluded = true;
      }
      /**
      * Destroys the tooltip manager.
      *
      * **Note**: The manager singleton cannot be destroyed until all editors that use it are destroyed.
      *
      * @param editor The editor the manager was created for.
      */
      destroy(editor) {
        const editorBodyViewCollection = editor.ui.view && editor.ui.view.body;
        _TooltipManager._editors.delete(editor);
        this.stopListening(editor.ui);
        if (editorBodyViewCollection && editorBodyViewCollection.has(this.balloonPanelView)) {
          editorBodyViewCollection.remove(this.balloonPanelView);
        }
        if (!_TooltipManager._editors.size) {
          this._unpinTooltip();
          this.balloonPanelView.destroy();
          this.stopListening();
          _TooltipManager._instance = null;
        }
      }
      /**
      * Returns {@link #balloonPanelView} {@link module:utils/dom/position~PositioningFunction positioning functions} for a given position
      * name.
      *
      * @param position Name of the position (`s`, `se`, `sw`, `n`, `e`, or `w`).
      * @returns Positioning functions to be used by the {@link #balloonPanelView}.
      */
      static getPositioningFunctions(position) {
        const defaultPositions = _TooltipManager.defaultBalloonPositions;
        return {
          // South is most popular. We can use positioning heuristics to avoid clipping by the viewport with the sane fallback.
          s: [
            defaultPositions.southArrowNorth,
            defaultPositions.southArrowNorthEast,
            defaultPositions.southArrowNorthWest
          ],
          n: [
            defaultPositions.northArrowSouth
          ],
          e: [
            defaultPositions.eastArrowWest
          ],
          w: [
            defaultPositions.westArrowEast
          ],
          sw: [
            defaultPositions.southArrowNorthEast
          ],
          se: [
            defaultPositions.southArrowNorthWest
          ]
        }[position];
      }
      /**
      * Handles hiding tooltips on `keydown` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onKeyDown(evt, domEvent) {
        if (domEvent.key === "Escape" && this._currentElementWithTooltip) {
          this._unpinTooltip();
          domEvent.stopPropagation();
        }
      }
      /**
      * Handles displaying tooltips on `mouseenter` and `focus` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onEnterOrFocus(evt, { target }) {
        const elementWithTooltipAttribute = getDescendantWithTooltip(target);
        if (!elementWithTooltipAttribute) {
          if (evt.name === "focus") {
            this._unpinTooltip();
          }
          return;
        }
        if (elementWithTooltipAttribute === this._currentElementWithTooltip) {
          return;
        }
        this._unpinTooltip();
        if (evt.name === "focus" && !elementWithTooltipAttribute.matches(":hover")) {
          this._pinTooltip(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
        } else {
          this._pinTooltipDebounced(elementWithTooltipAttribute, getTooltipData(elementWithTooltipAttribute));
        }
      }
      /**
      * Handles hiding tooltips on `mouseleave` and `blur` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onLeaveOrBlur(evt, { target, relatedTarget }) {
        if (evt.name === "mouseleave") {
          if (!isElement$1(target)) {
            return;
          }
          const balloonElement = this.balloonPanelView.element;
          const isEnteringBalloon = balloonElement && (balloonElement === relatedTarget || balloonElement.contains(relatedTarget));
          const isLeavingBalloon = !isEnteringBalloon && target === balloonElement;
          if (isEnteringBalloon) {
            this._unpinTooltipDebounced.cancel();
            return;
          }
          if (!isLeavingBalloon && this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
            return;
          }
          const descendantWithTooltip = getDescendantWithTooltip(target);
          const relatedDescendantWithTooltip = getDescendantWithTooltip(relatedTarget);
          if (isLeavingBalloon || descendantWithTooltip && descendantWithTooltip !== relatedDescendantWithTooltip) {
            this._unpinTooltipDebounced();
          }
        } else {
          if (this._currentElementWithTooltip && target !== this._currentElementWithTooltip) {
            return;
          }
          this._unpinTooltipDebounced();
        }
      }
      /**
      * Handles hiding tooltips on `scroll` in DOM.
      *
      * @param evt An object containing information about the fired event.
      * @param domEvent The DOM event.
      */
      _onScroll(evt, { target }) {
        if (!this._currentElementWithTooltip) {
          return;
        }
        if (target.contains(this.balloonPanelView.element) && target.contains(this._currentElementWithTooltip)) {
          return;
        }
        this._unpinTooltip();
      }
      /**
      * Pins the tooltip to a specific DOM element.
      *
      * @param options.text Text of the tooltip to display.
      * @param options.position The position of the tooltip.
      * @param options.cssClass Additional CSS class of the balloon with the tooltip.
      */
      _pinTooltip(targetDomElement, { text: text2, position, cssClass }) {
        this._unpinTooltip();
        const bodyViewCollection = first(_TooltipManager._editors.values()).ui.view.body;
        if (!bodyViewCollection.has(this.balloonPanelView)) {
          bodyViewCollection.add(this.balloonPanelView);
        }
        this.tooltipTextView.text = text2;
        this.balloonPanelView.class = [
          BALLOON_CLASS,
          cssClass
        ].filter((className) => className).join(" ");
        this.balloonPanelView.pin({
          target: targetDomElement,
          positions: _TooltipManager.getPositioningFunctions(position)
        });
        this._resizeObserver = new ResizeObserver(targetDomElement, () => {
          if (!isVisible(targetDomElement)) {
            this._unpinTooltip();
          }
        });
        this._mutationObserver.attach(targetDomElement);
        for (const editor of _TooltipManager._editors) {
          this.listenTo(editor.ui, "update", this._updateTooltipPosition.bind(this), {
            priority: "low"
          });
        }
        this._currentElementWithTooltip = targetDomElement;
        this._currentTooltipPosition = position;
      }
      /**
      * Unpins the tooltip and cancels all queued pinning.
      */
      _unpinTooltip() {
        this._unpinTooltipDebounced.cancel();
        this._pinTooltipDebounced.cancel();
        this.balloonPanelView.unpin();
        for (const editor of _TooltipManager._editors) {
          this.stopListening(editor.ui, "update");
        }
        this._currentElementWithTooltip = null;
        this._currentTooltipPosition = null;
        this.tooltipTextView.text = "";
        if (this._resizeObserver) {
          this._resizeObserver.destroy();
        }
        this._mutationObserver.detach();
      }
      /**
      * Updates the position of the tooltip so it stays in sync with the element it is pinned to.
      *
      * Hides the tooltip when the element is no longer visible in DOM or the tooltip text was removed.
      */
      _updateTooltipPosition() {
        if (!this._currentElementWithTooltip) {
          return;
        }
        const tooltipData = getTooltipData(this._currentElementWithTooltip);
        if (!isVisible(this._currentElementWithTooltip) || !tooltipData.text) {
          this._unpinTooltip();
          return;
        }
        this.balloonPanelView.pin({
          target: this._currentElementWithTooltip,
          positions: _TooltipManager.getPositioningFunctions(tooltipData.position)
        });
      }
    };
    /**
    * A set of default {@link module:utils/dom/position~PositioningFunction positioning functions} used by the `TooltipManager`
    * to pin tooltips in different positions.
    */
    __publicField(_TooltipManager, "defaultBalloonPositions", /* @__PURE__ */ BalloonPanelView.generatePositions({
      heightOffset: 5,
      sideOffset: 13
    }));
    /**
    * A set of editors the single tooltip manager instance must listen to.
    * This is mostly to handle `EditorUI#update` listeners from individual editors.
    */
    __publicField(_TooltipManager, "_editors", /* @__PURE__ */ new Set());
    /**
    * A reference to the `TooltipManager` instance. The class is a singleton and as such,
    * successive attempts at creating instances should return this instance.
    */
    __publicField(_TooltipManager, "_instance", null);
    let TooltipManager = _TooltipManager;
    function getDescendantWithTooltip(element) {
      if (!isElement$1(element)) {
        return null;
      }
      return element.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])");
    }
    function getTooltipData(element) {
      return {
        text: element.dataset.ckeTooltipText,
        position: element.dataset.ckeTooltipPosition || "s",
        cssClass: element.dataset.ckeTooltipClass || ""
      };
    }
    function createMutationObserver(callback) {
      const mutationObserver = new MutationObserver(() => {
        callback();
      });
      return {
        attach(element) {
          mutationObserver.observe(element, {
            attributes: true,
            attributeFilter: [
              "data-cke-tooltip-text",
              "data-cke-tooltip-position"
            ]
          });
        },
        detach() {
          mutationObserver.disconnect();
        }
      };
    }
    var poweredByIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n';
    const ICON_WIDTH = 53;
    const ICON_HEIGHT = 10;
    const NARROW_ROOT_HEIGHT_THRESHOLD = 50;
    const NARROW_ROOT_WIDTH_THRESHOLD = 350;
    const DEFAULT_LABEL = "Powered by";
    class PoweredBy extends (/* @__PURE__ */ DomEmitterMixin()) {
      /**
      * Creates a "powered by" helper for a given editor. The feature is initialized on Editor#ready
      * event.
      *
      * @param editor
      */
      constructor(editor) {
        super();
        /**
        * Editor instance the helper was created for.
        */
        __publicField(this, "editor");
        /**
        * A reference to the balloon panel hosting and positioning the "powered by" link and logo.
        */
        __publicField(this, "_balloonView");
        /**
        * A throttled version of the {@link #_showBalloon} method meant for frequent use to avoid performance loss.
        */
        __publicField(this, "_showBalloonThrottled");
        /**
        * A reference to the last editable element (root, source editing area, etc.) focused by the user.
        * Since the focus can move to other focusable elements in the UI, this reference allows positioning the balloon over the
        * right element whether the user is typing or using the UI.
        */
        __publicField(this, "_lastFocusedEditableElement");
        this.editor = editor;
        this._balloonView = null;
        this._lastFocusedEditableElement = null;
        this._showBalloonThrottled = throttle(this._showBalloon.bind(this), 50, {
          leading: true
        });
        editor.on("ready", this._handleEditorReady.bind(this));
      }
      /**
      * Destroys the "powered by" helper along with its view.
      */
      destroy() {
        const balloon = this._balloonView;
        if (balloon) {
          balloon.unpin();
          this._balloonView = null;
        }
        this._showBalloonThrottled.cancel();
        this.stopListening();
      }
      /**
      * Enables "powered by" label once the editor (ui) is ready.
      */
      _handleEditorReady() {
        const editor = this.editor;
        const forceVisible = !!editor.config.get("ui.poweredBy.forceVisible");
        /* istanbul ignore next -- @preserve */
        if (!forceVisible && verifyLicense(editor.config.get("licenseKey")) === "VALID") {
          return;
        }
        if (!editor.ui.view) {
          return;
        }
        editor.ui.focusTracker.on("change:isFocused", (evt, data, isFocused) => {
          this._updateLastFocusedEditableElement();
          if (isFocused) {
            this._showBalloon();
          } else {
            this._hideBalloon();
          }
        });
        editor.ui.focusTracker.on("change:focusedElement", (evt, data, focusedElement) => {
          this._updateLastFocusedEditableElement();
          if (focusedElement) {
            this._showBalloon();
          }
        });
        editor.ui.on("update", () => {
          this._showBalloonThrottled();
        });
      }
      /**
      * Creates an instance of the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon panel}
      * with the "powered by" view inside ready for positioning.
      */
      _createBalloonView() {
        const editor = this.editor;
        const balloon = this._balloonView = new BalloonPanelView();
        const poweredByConfig = getNormalizedConfig(editor);
        const view = new PoweredByView(editor.locale, poweredByConfig.label);
        balloon.content.add(view);
        balloon.set({
          class: "ck-powered-by-balloon"
        });
        editor.ui.view.body.add(balloon);
        editor.ui.focusTracker.add(balloon.element);
        this._balloonView = balloon;
      }
      /**
      * Attempts to display the balloon with the "powered by" view.
      */
      _showBalloon() {
        if (!this._lastFocusedEditableElement) {
          return;
        }
        const attachOptions = getBalloonAttachOptions(this.editor, this._lastFocusedEditableElement);
        if (attachOptions) {
          if (!this._balloonView) {
            this._createBalloonView();
          }
          this._balloonView.pin(attachOptions);
        }
      }
      /**
      * Hides the "powered by" balloon if already visible.
      */
      _hideBalloon() {
        if (this._balloonView) {
          this._balloonView.unpin();
        }
      }
      /**
      * Updates the {@link #_lastFocusedEditableElement} based on the state of the global focus tracker.
      */
      _updateLastFocusedEditableElement() {
        const editor = this.editor;
        const isFocused = editor.ui.focusTracker.isFocused;
        const focusedElement = editor.ui.focusTracker.focusedElement;
        if (!isFocused || !focusedElement) {
          this._lastFocusedEditableElement = null;
          return;
        }
        const editableEditorElements = Array.from(editor.ui.getEditableElementsNames()).map((name) => {
          return editor.ui.getEditableElement(name);
        });
        if (editableEditorElements.includes(focusedElement)) {
          this._lastFocusedEditableElement = focusedElement;
        } else {
          this._lastFocusedEditableElement = editableEditorElements[0];
        }
      }
    }
    class PoweredByView extends View {
      /**
      * Created an instance of the "powered by" view.
      *
      * @param locale The localization services instance.
      * @param label The label text.
      */
      constructor(locale, label) {
        super(locale);
        const iconView = new IconView();
        const bind = this.bindTemplate;
        iconView.set({
          content: poweredByIcon,
          isColorInherited: false
        });
        iconView.extendTemplate({
          attributes: {
            style: {
              width: ICON_WIDTH + "px",
              height: ICON_HEIGHT + "px"
            }
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-powered-by"
            ],
            "aria-hidden": true
          },
          children: [
            {
              tag: "a",
              attributes: {
                href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo",
                target: "_blank",
                tabindex: "-1"
              },
              children: [
                ...label ? [
                  {
                    tag: "span",
                    attributes: {
                      class: [
                        "ck",
                        "ck-powered-by__label"
                      ]
                    },
                    children: [
                      label
                    ]
                  }
                ] : [],
                iconView
              ],
              on: {
                dragstart: bind.to((evt) => evt.preventDefault())
              }
            }
          ]
        });
      }
    }
    function getBalloonAttachOptions(editor, focusedEditableElement) {
      const poweredByConfig = getNormalizedConfig(editor);
      const positioningFunction = poweredByConfig.side === "right" ? getLowerRightCornerPosition(focusedEditableElement, poweredByConfig) : getLowerLeftCornerPosition(focusedEditableElement, poweredByConfig);
      return {
        target: focusedEditableElement,
        positions: [
          positioningFunction
        ]
      };
    }
    function getLowerRightCornerPosition(focusedEditableElement, config) {
      return getLowerCornerPosition(focusedEditableElement, config, (rootRect, balloonRect) => {
        return rootRect.left + rootRect.width - balloonRect.width - config.horizontalOffset;
      });
    }
    function getLowerLeftCornerPosition(focusedEditableElement, config) {
      return getLowerCornerPosition(focusedEditableElement, config, (rootRect) => rootRect.left + config.horizontalOffset);
    }
    function getLowerCornerPosition(focusedEditableElement, config, getBalloonLeft) {
      return (visibleEditableElementRect, balloonRect) => {
        const editableElementRect = new Rect(focusedEditableElement);
        if (editableElementRect.width < NARROW_ROOT_WIDTH_THRESHOLD || editableElementRect.height < NARROW_ROOT_HEIGHT_THRESHOLD) {
          return null;
        }
        let balloonTop;
        if (config.position === "inside") {
          balloonTop = editableElementRect.bottom - balloonRect.height;
        } else {
          balloonTop = editableElementRect.bottom - balloonRect.height / 2;
        }
        balloonTop -= config.verticalOffset;
        const balloonLeft = getBalloonLeft(editableElementRect, balloonRect);
        const newBalloonPositionRect = visibleEditableElementRect.clone().moveTo(balloonLeft, balloonTop).getIntersection(balloonRect.clone().moveTo(balloonLeft, balloonTop));
        const newBalloonPositionVisibleRect = newBalloonPositionRect.getVisible();
        if (!newBalloonPositionVisibleRect || newBalloonPositionVisibleRect.getArea() < balloonRect.getArea()) {
          return null;
        }
        return {
          top: balloonTop,
          left: balloonLeft,
          name: `position_${config.position}-side_${config.side}`,
          config: {
            withArrow: false
          }
        };
      };
    }
    function getNormalizedConfig(editor) {
      const userConfig = editor.config.get("ui.poweredBy");
      const position = userConfig && userConfig.position || "border";
      return {
        position,
        label: DEFAULT_LABEL,
        verticalOffset: position === "inside" ? 5 : 0,
        horizontalOffset: 5,
        side: editor.locale.contentLanguageDirection === "ltr" ? "right" : "left",
        ...userConfig
      };
    }
    const AriaLiveAnnouncerPoliteness = {
      POLITE: "polite",
      ASSERTIVE: "assertive"
    };
    class AriaLiveAnnouncer {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        /**
        * The editor instance.
        */
        __publicField(this, "editor");
        /**
        * The view that aggregates all `aria-live` regions.
        */
        __publicField(this, "view");
        this.editor = editor;
        editor.once("ready", () => {
          for (const politeness of Object.values(AriaLiveAnnouncerPoliteness)) {
            this.announce("", politeness);
          }
        });
      }
      /**
      * Sets an announcement text to an aria region that is then announced by a screen reader to the user.
      *
      * If the aria region of a specified politeness does not exist, it will be created and can be re-used later.
      *
      * The default announcement politeness level is `'polite'`.
      *
      * ```ts
      * // Most screen readers will queue announcements from multiple aria-live regions and read them out in the order they were emitted.
       * editor.ui.ariaLiveAnnouncer.announce( 'Image uploaded.' );
       * editor.ui.ariaLiveAnnouncer.announce( 'Connection lost. Reconnecting.' );
       * ```
      */
      announce(announcement, attributes = AriaLiveAnnouncerPoliteness.POLITE) {
        const editor = this.editor;
        if (!editor.ui.view) {
          return;
        }
        if (!this.view) {
          this.view = new AriaLiveAnnouncerView(editor.locale);
          editor.ui.view.body.add(this.view);
        }
        const { politeness, isUnsafeHTML } = typeof attributes === "string" ? {
          politeness: attributes
        } : attributes;
        let politenessRegionView = this.view.regionViews.find((view) => view.politeness === politeness);
        if (!politenessRegionView) {
          politenessRegionView = new AriaLiveAnnouncerRegionView(editor, politeness);
          this.view.regionViews.add(politenessRegionView);
        }
        politenessRegionView.announce({
          announcement,
          isUnsafeHTML
        });
      }
    }
    class AriaLiveAnnouncerView extends View {
      constructor(locale) {
        super(locale);
        /**
        * A collection of all views that represent individual `aria-live` regions.
        */
        __publicField(this, "regionViews");
        this.regionViews = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-aria-live-announcer"
            ]
          },
          children: this.regionViews
        });
      }
    }
    class AriaLiveAnnouncerRegionView extends View {
      constructor(editor, politeness) {
        super(editor.locale);
        /**
        * Current politeness level of the region.
        */
        __publicField(this, "politeness");
        /**
        * DOM converter used to sanitize unsafe HTML passed to {@link #announce} method.
        */
        __publicField(this, "_domConverter");
        /**
        * Interval used to remove additions. It prevents accumulation of added nodes in region.
        */
        __publicField(this, "_pruneAnnouncementsInterval");
        this.setTemplate({
          tag: "div",
          attributes: {
            role: "region",
            "aria-live": politeness,
            "aria-relevant": "additions"
          },
          children: [
            {
              tag: "ul",
              attributes: {
                class: [
                  "ck",
                  "ck-aria-live-region-list"
                ]
              }
            }
          ]
        });
        editor.on("destroy", () => {
          if (this._pruneAnnouncementsInterval !== null) {
            clearInterval(this._pruneAnnouncementsInterval);
            this._pruneAnnouncementsInterval = null;
          }
        });
        this.politeness = politeness;
        this._domConverter = editor.data.htmlProcessor.domConverter;
        this._pruneAnnouncementsInterval = setInterval(() => {
          if (this.element && this._listElement.firstChild) {
            this._listElement.firstChild.remove();
          }
        }, 5e3);
      }
      /**
      * Appends new announcement to region.
      */
      announce({ announcement, isUnsafeHTML }) {
        if (!announcement.trim().length) {
          return;
        }
        const messageListItem = document.createElement("li");
        if (isUnsafeHTML) {
          this._domConverter.setContentOf(messageListItem, announcement);
        } else {
          messageListItem.innerText = announcement;
        }
        this._listElement.appendChild(messageListItem);
      }
      /**
      * Return current announcements list HTML element.
      */
      get _listElement() {
        return this.element.querySelector("ul");
      }
    }
    class EditorUI extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates an instance of the editor UI class.
      *
      * @param editor The editor instance.
      */
      constructor(editor) {
        super();
        /**
        * The editor that the UI belongs to.
        */
        __publicField(this, "editor");
        /**
        * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins
        * to register factories of specific UI components.
        */
        __publicField(this, "componentFactory");
        /**
        * Stores the information about the editor UI focus and propagates it so various plugins and components
        * are unified as a focus group.
        */
        __publicField(this, "focusTracker");
        /**
        * Manages the tooltips displayed on mouseover and focus across the UI.
        */
        __publicField(this, "tooltipManager");
        /**
        * A helper that enables the "powered by" feature in the editor and renders a link to the project's webpage.
        */
        __publicField(this, "poweredBy");
        /**
        * A helper that manages the content of an `aria-live` regions used by editor features to announce status changes
        * to screen readers.
        */
        __publicField(this, "ariaLiveAnnouncer");
        /**
        * Indicates the UI is ready. Set `true` after {@link #event:ready} event is fired.
        *
        * @readonly
        * @default false
        */
        __publicField(this, "isReady", false);
        /**
        * Stores all editable elements used by the editor instance.
        */
        __publicField(this, "_editableElementsMap", /* @__PURE__ */ new Map());
        /**
        * All available & focusable toolbars.
        */
        __publicField(this, "_focusableToolbarDefinitions", []);
        const editingView = editor.editing.view;
        this.editor = editor;
        this.componentFactory = new ComponentFactory(editor);
        this.focusTracker = new FocusTracker();
        this.tooltipManager = new TooltipManager(editor);
        this.poweredBy = new PoweredBy(editor);
        this.ariaLiveAnnouncer = new AriaLiveAnnouncer(editor);
        this.set("viewportOffset", this._readViewportOffsetFromConfig());
        this.once("ready", () => {
          this.isReady = true;
        });
        this.listenTo(editingView.document, "layoutChanged", this.update.bind(this));
        this.listenTo(editingView, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this));
        this._initFocusTracking();
      }
      /**
      * The main (outermost) DOM element of the editor UI.
      *
      * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
      * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
      * it is the editable element itself (as there is no other wrapper). However, in
      * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
      * come with a single "main" HTML element (its editable element and toolbar are separate).
      *
      * This property can be understood as a shorthand for retrieving the element that a specific editor integration
      * considers to be its main DOM element.
      */
      get element() {
        return null;
      }
      /**
      * Fires the {@link module:ui/editorui/editorui~EditorUI#event:update `update`} event.
      *
      * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
      * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
      */
      update() {
        this.fire("update");
      }
      /**
      * Destroys the UI.
      */
      destroy() {
        this.stopListening();
        this.focusTracker.destroy();
        this.tooltipManager.destroy(this.editor);
        this.poweredBy.destroy();
        for (const domElement of this._editableElementsMap.values()) {
          domElement.ckeditorInstance = null;
          this.editor.keystrokes.stopListening(domElement);
        }
        this._editableElementsMap = /* @__PURE__ */ new Map();
        this._focusableToolbarDefinitions = [];
      }
      /**
      * Stores the native DOM editable element used by the editor under a unique name.
      *
      * Also, registers the element in the editor to maintain the accessibility of the UI. When the user is editing text in a focusable
      * editable area, they can use the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke to navigate over editor toolbars. See {@link #addToolbar}.
      *
      * @param rootName The unique name of the editable element.
      * @param domElement The native DOM editable element.
      */
      setEditableElement(rootName, domElement) {
        this._editableElementsMap.set(rootName, domElement);
        if (!domElement.ckeditorInstance) {
          domElement.ckeditorInstance = this.editor;
        }
        this.focusTracker.add(domElement);
        const setUpKeystrokeHandler = () => {
          if (this.editor.editing.view.getDomRoot(rootName)) {
            return;
          }
          this.editor.keystrokes.listenTo(domElement);
        };
        if (this.isReady) {
          setUpKeystrokeHandler();
        } else {
          this.once("ready", setUpKeystrokeHandler);
        }
      }
      /**
      * Removes the editable from the editor UI. Removes all handlers added by {@link #setEditableElement}.
      *
      * @param rootName The name of the editable element to remove.
      */
      removeEditableElement(rootName) {
        const domElement = this._editableElementsMap.get(rootName);
        if (!domElement) {
          return;
        }
        this._editableElementsMap.delete(rootName);
        this.editor.keystrokes.stopListening(domElement);
        this.focusTracker.remove(domElement);
        domElement.ckeditorInstance = null;
      }
      /**
      * Returns the editable editor element with the given name or null if editable does not exist.
      *
      * @param rootName The editable name.
      */
      getEditableElement(rootName = "main") {
        return this._editableElementsMap.get(rootName);
      }
      /**
      * Returns array of names of all editor editable elements.
      */
      getEditableElementsNames() {
        return this._editableElementsMap.keys();
      }
      /**
      * Adds a toolbar to the editor UI. Used primarily to maintain the accessibility of the UI.
      *
      * Focusable toolbars can be accessed (focused) by users by pressing the <kbd>Alt</kbd> + <kbd>F10</kbd> keystroke.
      * Successive keystroke presses navigate over available toolbars.
      *
      * @param toolbarView A instance of the toolbar to be registered.
      */
      addToolbar(toolbarView, options = {}) {
        if (toolbarView.isRendered) {
          this.focusTracker.add(toolbarView.element);
          this.editor.keystrokes.listenTo(toolbarView.element);
        } else {
          toolbarView.once("render", () => {
            this.focusTracker.add(toolbarView.element);
            this.editor.keystrokes.listenTo(toolbarView.element);
          });
        }
        this._focusableToolbarDefinitions.push({
          toolbarView,
          options
        });
      }
      /**
      * Stores all editable elements used by the editor instance.
      *
      * @deprecated
      */
      get _editableElements() {
        console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", {
          editorUI: this
        });
        return this._editableElementsMap;
      }
      /**
      * Returns viewport offsets object:
      *
      * ```js
      * {
      * 	top: Number,
      * 	right: Number,
      * 	bottom: Number,
      * 	left: Number
      * }
      * ```
      *
      * Only top property is currently supported.
      */
      _readViewportOffsetFromConfig() {
        const editor = this.editor;
        const viewportOffsetConfig = editor.config.get("ui.viewportOffset");
        if (viewportOffsetConfig) {
          return viewportOffsetConfig;
        }
        const legacyOffsetConfig = editor.config.get("toolbar.viewportTopOffset");
        if (legacyOffsetConfig) {
          console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead.");
          return {
            top: legacyOffsetConfig
          };
        }
        return {
          top: 0
        };
      }
      /**
      * Starts listening for <kbd>Alt</kbd> + <kbd>F10</kbd> and <kbd>Esc</kbd> keystrokes in the context of focusable
      * {@link #setEditableElement editable elements} and {@link #addToolbar toolbars}
      * to allow users navigate across the UI.
      */
      _initFocusTracking() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        let lastFocusedForeignElement;
        let candidateDefinitions;
        editor.keystrokes.set("Alt+F10", (data, cancel2) => {
          const focusedElement = this.focusTracker.focusedElement;
          if (Array.from(this._editableElementsMap.values()).includes(focusedElement) && !Array.from(editingView.domRoots.values()).includes(focusedElement)) {
            lastFocusedForeignElement = focusedElement;
          }
          const currentFocusedToolbarDefinition = this._getCurrentFocusedToolbarDefinition();
          if (!currentFocusedToolbarDefinition || !candidateDefinitions) {
            candidateDefinitions = this._getFocusableCandidateToolbarDefinitions();
          }
          for (let i = 0; i < candidateDefinitions.length; i++) {
            const candidateDefinition = candidateDefinitions.shift();
            candidateDefinitions.push(candidateDefinition);
            if (candidateDefinition !== currentFocusedToolbarDefinition && this._focusFocusableCandidateToolbar(candidateDefinition)) {
              if (currentFocusedToolbarDefinition && currentFocusedToolbarDefinition.options.afterBlur) {
                currentFocusedToolbarDefinition.options.afterBlur();
              }
              break;
            }
          }
          cancel2();
        });
        editor.keystrokes.set("Esc", (data, cancel2) => {
          const focusedToolbarDef = this._getCurrentFocusedToolbarDefinition();
          if (!focusedToolbarDef) {
            return;
          }
          if (lastFocusedForeignElement) {
            lastFocusedForeignElement.focus();
            lastFocusedForeignElement = null;
          } else {
            editor.editing.view.focus();
          }
          if (focusedToolbarDef.options.afterBlur) {
            focusedToolbarDef.options.afterBlur();
          }
          cancel2();
        });
      }
      /**
      * Returns definitions of toolbars that could potentially be focused, sorted by their importance for the user.
      *
      * Focusable toolbars candidates are either:
      * * already visible,
      * * have `beforeFocus()` set in their {@link module:ui/editorui/editorui~FocusableToolbarDefinition definition} that suggests that
      * they might show up when called. Keep in mind that determining whether a toolbar will show up (and become focusable) is impossible
      * at this stage because it depends on its implementation, that in turn depends on the editing context (selection).
      *
      * **Note**: Contextual toolbars take precedence over regular toolbars.
      */
      _getFocusableCandidateToolbarDefinitions() {
        const definitions = [];
        for (const toolbarDef of this._focusableToolbarDefinitions) {
          const { toolbarView, options } = toolbarDef;
          if (isVisible(toolbarView.element) || options.beforeFocus) {
            definitions.push(toolbarDef);
          }
        }
        definitions.sort((defA, defB) => getToolbarDefinitionWeight(defA) - getToolbarDefinitionWeight(defB));
        return definitions;
      }
      /**
      * Returns a definition of the toolbar that is currently visible and focused (one of its children has focus).
      *
      * `null` is returned when no toolbar is currently focused.
      */
      _getCurrentFocusedToolbarDefinition() {
        for (const definition of this._focusableToolbarDefinitions) {
          if (definition.toolbarView.element && definition.toolbarView.element.contains(this.focusTracker.focusedElement)) {
            return definition;
          }
        }
        return null;
      }
      /**
      * Focuses a focusable toolbar candidate using its definition.
      *
      * @param candidateToolbarDefinition A definition of the toolbar to focus.
      * @returns `true` when the toolbar candidate was focused. `false` otherwise.
      */
      _focusFocusableCandidateToolbar(candidateToolbarDefinition) {
        const { toolbarView, options: { beforeFocus } } = candidateToolbarDefinition;
        if (beforeFocus) {
          beforeFocus();
        }
        if (!isVisible(toolbarView.element)) {
          return false;
        }
        toolbarView.focus();
        return true;
      }
      /**
      * Provides an integration between {@link #viewportOffset} and {@link module:utils/dom/scroll~scrollViewportToShowTarget}.
      * It allows the UI-agnostic engine method to consider user-configured viewport offsets specific for the integration.
      *
      * @param evt The `scrollToTheSelection` event info.
      * @param data The payload carried by the `scrollToTheSelection` event.
      */
      _handleScrollToTheSelection(evt, data) {
        const configuredViewportOffset = {
          top: 0,
          bottom: 0,
          left: 0,
          right: 0,
          ...this.viewportOffset
        };
        data.viewportOffset.top += configuredViewportOffset.top;
        data.viewportOffset.bottom += configuredViewportOffset.bottom;
        data.viewportOffset.left += configuredViewportOffset.left;
        data.viewportOffset.right += configuredViewportOffset.right;
      }
    }
    function getToolbarDefinitionWeight(toolbarDef) {
      const { toolbarView, options } = toolbarDef;
      let weight = 10;
      if (isVisible(toolbarView.element)) {
        weight--;
      }
      if (options.isContextual) {
        weight--;
      }
      return weight;
    }
    class EditorUIView extends View {
      /**
      * Creates an instance of the editor UI view class.
      *
      * @param locale The locale instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views, detached from the DOM
        * structure of the editor, like panels, icons etc.
        */
        __publicField(this, "body");
        this.body = new BodyCollection(locale);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.body.attachToDom();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this.body.detachFromDom();
        return super.destroy();
      }
    }
    class EditableUIView extends View {
      /**
      * Creates an instance of EditableUIView class.
      *
      * @param locale The locale instance.
      * @param editingView The editing view instance the editable is related to.
      * @param editableElement The editable element. If not specified, this view
      * should create it. Otherwise, the existing element should be used.
      */
      constructor(locale, editingView, editableElement) {
        super(locale);
        /**
        * The name of the editable UI view.
        */
        __publicField(this, "name", null);
        /**
        * The editing view instance the editable is related to. Editable uses the editing
        * view to dynamically modify its certain DOM attributes after {@link #render rendering}.
        *
        * **Note**: The DOM attributes are performed by the editing view and not UI
        * {@link module:ui/view~View#bindTemplate template bindings} because once rendered,
        * the editable DOM element must remain under the full control of the engine to work properly.
        */
        __publicField(this, "_editingView");
        /**
        * The element which is the main editable element (usually the one with `contentEditable="true"`).
        */
        __publicField(this, "_editableElement");
        /**
        * Whether an external {@link #_editableElement} was passed into the constructor, which also means
        * the view will not render its {@link #template}.
        */
        __publicField(this, "_hasExternalElement");
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-content",
              "ck-editor__editable",
              "ck-rounded-corners"
            ],
            lang: locale.contentLanguage,
            dir: locale.contentLanguageDirection
          }
        });
        this.set("isFocused", false);
        this._editableElement = editableElement;
        this._hasExternalElement = !!this._editableElement;
        this._editingView = editingView;
      }
      /**
      * Renders the view by either applying the {@link #template} to the existing
      * {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement} or assigning {@link #element}
      * as {@link module:ui/editableui/editableuiview~EditableUIView#_editableElement}.
      */
      render() {
        super.render();
        if (this._hasExternalElement) {
          this.template.apply(this.element = this._editableElement);
        } else {
          this._editableElement = this.element;
        }
        this.on("change:isFocused", () => this._updateIsFocusedClasses());
        this._updateIsFocusedClasses();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._hasExternalElement) {
          this.template.revert(this._editableElement);
        }
        super.destroy();
      }
      /**
      * Whether an external {@link #_editableElement} was passed into the constructor, which also means
      * the view will not render its {@link #template}.
      */
      get hasExternalElement() {
        return this._hasExternalElement;
      }
      /**
      * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
      * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
      */
      _updateIsFocusedClasses() {
        const editingView = this._editingView;
        if (editingView.isRenderingInProgress) {
          updateAfterRender(this);
        } else {
          update(this);
        }
        function update(view) {
          editingView.change((writer) => {
            const viewRoot = editingView.document.getRoot(view.name);
            writer.addClass(view.isFocused ? "ck-focused" : "ck-blurred", viewRoot);
            writer.removeClass(view.isFocused ? "ck-blurred" : "ck-focused", viewRoot);
          });
        }
        function updateAfterRender(view) {
          editingView.once("change:isRenderingInProgress", (evt, name, value) => {
            if (!value) {
              update(view);
            } else {
              updateAfterRender(view);
            }
          });
        }
      }
    }
    class InlineEditableUIView extends EditableUIView {
      /**
      * Creates an instance of the InlineEditableUIView class.
      *
      * @param locale The locale instance.
      * @param editingView The editing view instance the editable is related to.
      * @param editableElement The editable element. If not specified, the
      * {@link module:ui/editableui/editableuiview~EditableUIView}
      * will create it. Otherwise, the existing element will be used.
      * @param options Additional configuration of the view.
      * @param options.label A function that gets called with the instance of this view as an argument
      * and should return a string that represents the label of the editable for assistive technologies. If not provided,
      * a default label generator is used.
      */
      constructor(locale, editingView, editableElement, options = {}) {
        super(locale, editingView, editableElement);
        /**
        * A function that gets called with the instance of this view as an argument and should return a string that
        * represents the label of the editable for assistive technologies.
        */
        __publicField(this, "_generateLabel");
        const t = locale.t;
        this.extendTemplate({
          attributes: {
            role: "textbox",
            class: "ck-editor__editable_inline"
          }
        });
        this._generateLabel = options.label || (() => t("Editor editing area: %0", this.name));
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        const editingView = this._editingView;
        editingView.change((writer) => {
          const viewRoot = editingView.document.getRoot(this.name);
          writer.setAttribute("aria-label", this._generateLabel(this), viewRoot);
        });
      }
    }
    class Notification extends ContextPlugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Notification";
      }
      /**
      * @inheritDoc
      */
      init() {
        this.on("show:warning", (evt, data) => {
          window.alert(data.message);
        }, {
          priority: "lowest"
        });
      }
      /**
      * Shows a success notification.
      *
      * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended
      * using the `data.namespace` option. For example:
      *
      * ```ts
      * showSuccess( 'Image is uploaded.', {
      * 	namespace: 'upload:image'
      * } );
      * ```
      *
      * will fire the `show:success:upload:image` event.
      *
      * You can provide the title of the notification:
      *
      * ```ts
      * showSuccess( 'Image is uploaded.', {
      * 	title: 'Image upload success'
      * } );
      * ```
      *
      * @param message The content of the notification.
      * @param data Additional data.
      * @param data.namespace Additional event namespace.
      * @param data.title The title of the notification.
      */
      showSuccess(message, data = {}) {
        this._showNotification({
          message,
          type: "success",
          namespace: data.namespace,
          title: data.title
        });
      }
      /**
      * Shows an information notification.
      *
      * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended
      * using the `data.namespace` option. For example:
      *
      * ```ts
      * showInfo( 'Editor is offline.', {
      * 	namespace: 'editor:status'
      * } );
      * ```
      *
      * will fire the `show:info:editor:status` event.
      *
      * You can provide the title of the notification:
      *
      * ```ts
      * showInfo( 'Editor is offline.', {
      * 	title: 'Network information'
      * } );
      * ```
      *
      * @param message The content of the notification.
      * @param data Additional data.
      * @param data.namespace Additional event namespace.
      * @param data.title The title of the notification.
      */
      showInfo(message, data = {}) {
        this._showNotification({
          message,
          type: "info",
          namespace: data.namespace,
          title: data.title
        });
      }
      /**
      * Shows a warning notification.
      *
      * By default, it fires the {@link #event:show:warning `show:warning` event}
      * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:
      *
      * ```ts
      * showWarning( 'Image upload error.', {
      * 	namespace: 'upload:image'
      * } );
      * ```
      *
      * will fire the `show:warning:upload:image` event.
      *
      * You can provide the title of the notification:
      *
      * ```ts
      * showWarning( 'Image upload error.', {
      * 	title: 'Upload failed'
      * } );
      * ```
      *
      * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.
      * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:
      *
      * ```ts
      * notifications.on( 'show:warning', ( evt, data ) => {
      * 	// Do something with the data.
      *
      * 	// Stop this event to prevent displaying it as an alert.
      * 	evt.stop();
      * } );
      * ```
      *
      * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:
      *
      * ```ts
      * notifications.on( 'show:warning', ( evt, data ) => {
      * 	// Show the warning in the UI, but do not stop it.
      * } );
      *
      * notifications.on( 'show:warning', ( evt, data ) => {
      * 	// Log the warning to some error tracker.
      *
      * 	// Stop this event to prevent displaying it as an alert.
      * 	evt.stop();
      * }, { priority: 'low' } );
      * ```
      *
      * @param message The content of the notification.
      * @param data Additional data.
      * @param data.namespace Additional event namespace.
      * @param data.title The title of the notification.
      */
      showWarning(message, data = {}) {
        this._showNotification({
          message,
          type: "warning",
          namespace: data.namespace,
          title: data.title
        });
      }
      /**
      * Fires the `show` event with the specified type, namespace and message.
      *
      * @param data The message data.
      * @param data.message The content of the notification.
      * @param data.type The type of the message.
      * @param data.namespace Additional event namespace.
      * @param data.title The title of the notification.
      */
      _showNotification(data) {
        const event = data.namespace ? `show:${data.type}:${data.namespace}` : `show:${data.type}`;
        this.fire(event, {
          message: data.message,
          type: data.type,
          title: data.title || ""
        });
      }
    }
    class Model extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new Model instance.
      *
      * @param attributes The model state attributes to be defined during the instance creation.
      * @param properties The (out of state) properties to be appended to the instance during creation.
      */
      constructor(attributes, properties) {
        super();
        if (properties) {
          assignIn(this, properties);
        }
        if (attributes) {
          this.set(attributes);
        }
      }
    }
    const toPx$4 = /* @__PURE__ */ toUnit("px");
    class ContextualBalloon extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The {@link module:utils/dom/position~Options#limiter position limiter}
        * for the {@link #view balloon}, used when no `limiter` has been passed into {@link #add}
        * or {@link #updatePosition}.
        *
        * By default, a function that obtains the farthest DOM
        * {@link module:engine/view/rooteditableelement~RootEditableElement}
        * of the {@link module:engine/view/document~Document#selection}.
        */
        __publicField(this, "positionLimiter");
        __publicField(this, "visibleStack");
        /**
        * The map of views and their stacks.
        */
        __publicField(this, "_viewToStack", /* @__PURE__ */ new Map());
        /**
        * The map of IDs and stacks.
        */
        __publicField(this, "_idToStack", /* @__PURE__ */ new Map());
        /**
        * The common balloon panel view.
        */
        __publicField(this, "_view", null);
        /**
        * Rotator view embedded in the contextual balloon.
        * Displays the currently visible view in the balloon and provides navigation for switching stacks.
        */
        __publicField(this, "_rotatorView", null);
        /**
        * Displays fake panels under the balloon panel view when multiple stacks are added to the balloon.
        */
        __publicField(this, "_fakePanelsView", null);
        this.positionLimiter = () => {
          const view = this.editor.editing.view;
          const viewDocument = view.document;
          const editableElement = viewDocument.selection.editableElement;
          if (editableElement) {
            return view.domConverter.mapViewToDom(editableElement.root);
          }
          return null;
        };
        this.set("visibleView", null);
        this.set("_numberOfStacks", 0);
        this.set("_singleViewMode", false);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ContextualBalloon";
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this._view) {
          this._view.destroy();
        }
        if (this._rotatorView) {
          this._rotatorView.destroy();
        }
        if (this._fakePanelsView) {
          this._fakePanelsView.destroy();
        }
      }
      /**
      * The common balloon panel view.
      */
      get view() {
        if (!this._view) {
          this._createPanelView();
        }
        return this._view;
      }
      /**
      * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
      */
      hasView(view) {
        return Array.from(this._viewToStack.keys()).includes(view);
      }
      /**
      * Adds a new view to the stack and makes it visible if the current stack is visible
      * or it is the first view in the balloon.
      *
      * @param data The configuration of the view.
      * @param data.stackId The ID of the stack that the view is added to. Defaults to `'main'`.
      * @param data.view The content of the balloon.
      * @param data.position Positioning options.
      * @param data.balloonClassName An additional CSS class added to the {@link #view balloon} when visible.
      * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow. Defaults to `true`.
      * @param data.singleViewMode Whether the view should be the only visible view even if other stacks were added. Defaults to `false`.
      */
      add(data) {
        if (!this._view) {
          this._createPanelView();
        }
        if (this.hasView(data.view)) {
          throw new CKEditorError("contextualballoon-add-view-exist", [
            this,
            data
          ]);
        }
        const stackId = data.stackId || "main";
        if (!this._idToStack.has(stackId)) {
          this._idToStack.set(stackId, /* @__PURE__ */ new Map([
            [
              data.view,
              data
            ]
          ]));
          this._viewToStack.set(data.view, this._idToStack.get(stackId));
          this._numberOfStacks = this._idToStack.size;
          if (!this._visibleStack || data.singleViewMode) {
            this.showStack(stackId);
          }
          return;
        }
        const stack = this._idToStack.get(stackId);
        if (data.singleViewMode) {
          this.showStack(stackId);
        }
        stack.set(data.view, data);
        this._viewToStack.set(data.view, stack);
        if (stack === this._visibleStack) {
          this._showView(data);
        }
      }
      /**
      * Removes the given view from the stack. If the removed view was visible,
      * the view preceding it in the stack will become visible instead.
      * When there is no view in the stack, the next stack will be displayed.
      * When there are no more stacks, the balloon will hide.
      *
      * @param view A view to be removed from the balloon.
      */
      remove(view) {
        if (!this.hasView(view)) {
          throw new CKEditorError("contextualballoon-remove-view-not-exist", [
            this,
            view
          ]);
        }
        const stack = this._viewToStack.get(view);
        if (this._singleViewMode && this.visibleView === view) {
          this._singleViewMode = false;
        }
        if (this.visibleView === view) {
          if (stack.size === 1) {
            if (this._idToStack.size > 1) {
              this._showNextStack();
            } else {
              this.view.hide();
              this.visibleView = null;
              this._rotatorView.hideView();
            }
          } else {
            this._showView(Array.from(stack.values())[stack.size - 2]);
          }
        }
        if (stack.size === 1) {
          this._idToStack.delete(this._getStackId(stack));
          this._numberOfStacks = this._idToStack.size;
        } else {
          stack.delete(view);
        }
        this._viewToStack.delete(view);
      }
      /**
      * Updates the position of the balloon using the position data of the first visible view in the stack.
      * When new position data is given, the position data of the currently visible view will be updated.
      *
      * @param position Position options.
      */
      updatePosition(position) {
        if (position) {
          this._visibleStack.get(this.visibleView).position = position;
        }
        this.view.pin(this._getBalloonPosition());
        this._fakePanelsView.updatePosition();
      }
      /**
      * Shows the last view from the stack of a given ID.
      */
      showStack(id) {
        this.visibleStack = id;
        const stack = this._idToStack.get(id);
        if (!stack) {
          throw new CKEditorError("contextualballoon-showstack-stack-not-exist", this);
        }
        if (this._visibleStack === stack) {
          return;
        }
        this._showView(Array.from(stack.values()).pop());
      }
      /**
      * Initializes view instances.
      */
      _createPanelView() {
        this._view = new BalloonPanelView(this.editor.locale);
        this.editor.ui.view.body.add(this._view);
        this.editor.ui.focusTracker.add(this._view.element);
        this._rotatorView = this._createRotatorView();
        this._fakePanelsView = this._createFakePanelsView();
      }
      /**
      * Returns the stack of the currently visible view.
      */
      get _visibleStack() {
        return this._viewToStack.get(this.visibleView);
      }
      /**
      * Returns the ID of the given stack.
      */
      _getStackId(stack) {
        const entry = Array.from(this._idToStack.entries()).find((entry2) => entry2[1] === stack);
        return entry[0];
      }
      /**
      * Shows the last view from the next stack.
      */
      _showNextStack() {
        const stacks = Array.from(this._idToStack.values());
        let nextIndex = stacks.indexOf(this._visibleStack) + 1;
        if (!stacks[nextIndex]) {
          nextIndex = 0;
        }
        this.showStack(this._getStackId(stacks[nextIndex]));
      }
      /**
      * Shows the last view from the previous stack.
      */
      _showPrevStack() {
        const stacks = Array.from(this._idToStack.values());
        let nextIndex = stacks.indexOf(this._visibleStack) - 1;
        if (!stacks[nextIndex]) {
          nextIndex = stacks.length - 1;
        }
        this.showStack(this._getStackId(stacks[nextIndex]));
      }
      /**
      * Creates a rotator view.
      */
      _createRotatorView() {
        const view = new RotatorView(this.editor.locale);
        const t = this.editor.locale.t;
        this.view.content.add(view);
        view.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (value, isSingleViewMode) => {
          return !isSingleViewMode && value > 1;
        });
        view.on("change:isNavigationVisible", () => this.updatePosition(), {
          priority: "low"
        });
        view.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (visibleView, numberOfStacks) => {
          if (numberOfStacks < 2) {
            return "";
          }
          const current = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
          return t("%0 of %1", [
            current,
            numberOfStacks
          ]);
        });
        view.buttonNextView.on("execute", () => {
          if (view.focusTracker.isFocused) {
            this.editor.editing.view.focus();
          }
          this._showNextStack();
        });
        view.buttonPrevView.on("execute", () => {
          if (view.focusTracker.isFocused) {
            this.editor.editing.view.focus();
          }
          this._showPrevStack();
        });
        return view;
      }
      /**
      * Creates a fake panels view.
      */
      _createFakePanelsView() {
        const view = new FakePanelsView(this.editor.locale, this.view);
        view.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (number, isSingleViewMode) => {
          const showPanels = !isSingleViewMode && number >= 2;
          return showPanels ? Math.min(number - 1, 2) : 0;
        });
        view.listenTo(this.view, "change:top", () => view.updatePosition());
        view.listenTo(this.view, "change:left", () => view.updatePosition());
        this.editor.ui.view.body.add(view);
        return view;
      }
      /**
      * Sets the view as the content of the balloon and attaches the balloon using position
      * options of the first view.
      *
      * @param data Configuration.
      * @param data.view The view to show in the balloon.
      * @param data.balloonClassName Additional class name which will be added to the {@link #view balloon}.
      * @param data.withArrow Whether the {@link #view balloon} should be rendered with an arrow.
      */
      _showView({ view, balloonClassName = "", withArrow = true, singleViewMode = false }) {
        this.view.class = balloonClassName;
        this.view.withArrow = withArrow;
        this._rotatorView.showView(view);
        this.visibleView = view;
        this.view.pin(this._getBalloonPosition());
        this._fakePanelsView.updatePosition();
        if (singleViewMode) {
          this._singleViewMode = true;
        }
      }
      /**
      * Returns position options of the last view in the stack.
      * This keeps the balloon in the same position when the view is changed.
      */
      _getBalloonPosition() {
        let position = Array.from(this._visibleStack.values()).pop().position;
        if (position) {
          if (!position.limiter) {
            position = Object.assign({}, position, {
              limiter: this.positionLimiter
            });
          }
          position = Object.assign({}, position, {
            viewportOffsetConfig: this.editor.ui.viewportOffset
          });
        }
        return position;
      }
    }
    class RotatorView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Used for checking if a view is focused or not.
        */
        __publicField(this, "focusTracker");
        /**
        * Navigation button for switching the stack to the previous one.
        */
        __publicField(this, "buttonPrevView");
        /**
        * Navigation button for switching the stack to the next one.
        */
        __publicField(this, "buttonNextView");
        /**
        * A collection of the child views that creates the rotator content.
        */
        __publicField(this, "content");
        const t = locale.t;
        const bind = this.bindTemplate;
        this.set("isNavigationVisible", true);
        this.focusTracker = new FocusTracker();
        this.buttonPrevView = this._createButtonView(t("Previous"), icons.previousArrow);
        this.buttonNextView = this._createButtonView(t("Next"), icons.nextArrow);
        this.content = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-balloon-rotator"
            ],
            "z-index": "-1"
          },
          children: [
            {
              tag: "div",
              attributes: {
                class: [
                  "ck-balloon-rotator__navigation",
                  bind.to("isNavigationVisible", (value) => value ? "" : "ck-hidden")
                ]
              },
              children: [
                this.buttonPrevView,
                {
                  tag: "span",
                  attributes: {
                    class: [
                      "ck-balloon-rotator__counter"
                    ]
                  },
                  children: [
                    {
                      text: bind.to("counter")
                    }
                  ]
                },
                this.buttonNextView
              ]
            },
            {
              tag: "div",
              attributes: {
                class: "ck-balloon-rotator__content"
              },
              children: this.content
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
      }
      /**
      * Shows a given view.
      *
      * @param view The view to show.
      */
      showView(view) {
        this.hideView();
        this.content.add(view);
      }
      /**
      * Hides the currently displayed view.
      */
      hideView() {
        this.content.clear();
      }
      /**
      * Creates a navigation button view.
      *
      * @param label The button label.
      * @param icon The button icon.
      */
      _createButtonView(label, icon) {
        const view = new ButtonView(this.locale);
        view.set({
          label,
          icon,
          tooltip: true
        });
        return view;
      }
    }
    class FakePanelsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, balloonPanelView) {
        super(locale);
        /**
        * Collection of the child views which creates fake panel content.
        */
        __publicField(this, "content");
        /**
        * Context.
        */
        __publicField(this, "_balloonPanelView");
        const bind = this.bindTemplate;
        this.set("top", 0);
        this.set("left", 0);
        this.set("height", 0);
        this.set("width", 0);
        this.set("numberOfPanels", 0);
        this.content = this.createCollection();
        this._balloonPanelView = balloonPanelView;
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck-fake-panel",
              bind.to("numberOfPanels", (number) => number ? "" : "ck-hidden")
            ],
            style: {
              top: bind.to("top", toPx$4),
              left: bind.to("left", toPx$4),
              width: bind.to("width", toPx$4),
              height: bind.to("height", toPx$4)
            }
          },
          children: this.content
        });
        this.on("change:numberOfPanels", (evt, name, next, prev) => {
          if (next > prev) {
            this._addPanels(next - prev);
          } else {
            this._removePanels(prev - next);
          }
          this.updatePosition();
        });
      }
      _addPanels(number) {
        while (number--) {
          const view = new View();
          view.setTemplate({
            tag: "div"
          });
          this.content.add(view);
          this.registerChild(view);
        }
      }
      _removePanels(number) {
        while (number--) {
          const view = this.content.last;
          this.content.remove(view);
          this.deregisterChild(view);
          view.destroy();
        }
      }
      /**
      * Updates coordinates of fake panels.
      */
      updatePosition() {
        if (this.numberOfPanels) {
          const { top, left } = this._balloonPanelView;
          const { width, height } = new Rect(this._balloonPanelView.element);
          Object.assign(this, {
            top,
            left,
            width,
            height
          });
        }
      }
    }
    class MenuBarMenuButtonView extends ButtonView {
      /**
      * Creates an instance of the menu bar button view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * An icon that displays an arrow to indicate a direction of the menu.
        */
        __publicField(this, "arrowView");
        const bind = this.bindTemplate;
        this.set({
          withText: true,
          role: "menuitem"
        });
        this.arrowView = this._createArrowView();
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__button"
            ],
            "aria-haspopup": true,
            "aria-expanded": this.bindTemplate.to("isOn", (value) => String(value)),
            "data-cke-tooltip-disabled": bind.to("isOn")
          },
          on: {
            "mouseenter": bind.to("mouseenter")
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.children.add(this.arrowView);
      }
      /**
      * Creates the {@link #arrowView} instance.
      */
      _createArrowView() {
        const arrowView = new IconView();
        arrowView.content = dropdownArrowIcon;
        arrowView.extendTemplate({
          attributes: {
            class: "ck-menu-bar__menu__button__arrow"
          }
        });
        return arrowView;
      }
    }
    class MenuBarMenuListItemView extends ListItemView {
      /**
      * Creates an instance of the list item view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale, parentMenuView) {
        super(locale);
        const bind = this.bindTemplate;
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__item"
            ]
          },
          on: {
            "mouseenter": bind.to("mouseenter")
          }
        });
        this.delegate("mouseenter").to(parentMenuView);
      }
    }
    const NESTED_PANEL_HORIZONTAL_OFFSET = 5;
    const MenuBarBehaviors = {
      /**
      * When the bar is already open:
      * * Opens the menu when the user hovers over its button.
      * * Closes open menu when another menu's button gets hovered.
      */
      toggleMenusAndFocusItemsOnHover(menuBarView) {
        menuBarView.on("menu:mouseenter", (evt) => {
          if (!menuBarView.isOpen) {
            return;
          }
          for (const menuView of menuBarView.menus) {
            const pathLeaf = evt.path[0];
            const isListItemContainingMenu = pathLeaf instanceof MenuBarMenuListItemView && pathLeaf.children.first === menuView;
            menuView.isOpen = (evt.path.includes(menuView) || isListItemContainingMenu) && menuView.isEnabled;
          }
          evt.source.focus();
        });
      },
      /**
      * Moves between top-level menus using the arrow left and right keys.
      *
      * If the menubar has already been open, the arrow keys move focus between top-level menu buttons and open them.
      * If the menubar is closed, the arrow keys only move focus between top-level menu buttons.
      */
      focusCycleMenusOnArrows(menuBarView) {
        const isContentRTL = menuBarView.locale.uiLanguageDirection === "rtl";
        menuBarView.on("menu:arrowright", (evt) => {
          cycleTopLevelMenus(evt.source, isContentRTL ? -1 : 1);
        });
        menuBarView.on("menu:arrowleft", (evt) => {
          cycleTopLevelMenus(evt.source, isContentRTL ? 1 : -1);
        });
        function cycleTopLevelMenus(currentMenuView, step) {
          const currentIndex = menuBarView.children.getIndex(currentMenuView);
          const isCurrentMenuViewOpen = currentMenuView.isOpen;
          const menusCount = menuBarView.children.length;
          const menuViewToOpen = menuBarView.children.get((currentIndex + menusCount + step) % menusCount);
          currentMenuView.isOpen = false;
          if (isCurrentMenuViewOpen) {
            menuViewToOpen.isOpen = true;
          }
          menuViewToOpen.buttonView.focus();
        }
      },
      /**
      * Closes the entire sub-menu structure when the bar is closed. This prevents sub-menus from being open if the user
      * closes the entire bar, and then re-opens some top-level menu.
      */
      closeMenusWhenTheBarCloses(menuBarView) {
        menuBarView.on("change:isOpen", () => {
          if (!menuBarView.isOpen) {
            menuBarView.menus.forEach((menuView) => {
              menuView.isOpen = false;
            });
          }
        });
      },
      /**
      * Handles the following case:
      * 1. Hover to open a sub-menu (A). The button has focus.
      * 2. Press arrow up/down to move focus to another sub-menu (B) button.
      * 3. Press arrow right to open the sub-menu (B).
      * 4. The sub-menu (A) should close as it would with `toggleMenusAndFocusItemsOnHover()`.
      */
      closeMenuWhenAnotherOnTheSameLevelOpens(menuBarView) {
        menuBarView.on("menu:change:isOpen", (evt, name, isOpen) => {
          if (isOpen) {
            menuBarView.menus.filter((menuView) => {
              return evt.source.parentMenuView === menuView.parentMenuView && evt.source !== menuView && menuView.isOpen;
            }).forEach((menuView) => {
              menuView.isOpen = false;
            });
          }
        });
      },
      /**
      * Closes the bar when the user clicked outside of it (page body, editor root, etc.).
      */
      closeOnClickOutside(menuBarView) {
        clickOutsideHandler({
          emitter: menuBarView,
          activator: () => menuBarView.isOpen,
          callback: () => menuBarView.close(),
          contextElements: () => menuBarView.children.map((child) => child.element)
        });
      }
    };
    const MenuBarMenuBehaviors = {
      /**
      * If the button of the menu is focused, pressing the arrow down key should open the panel and focus it.
      * This is analogous to the {@link module:ui/dropdown/dropdownview~DropdownView}.
      */
      openAndFocusPanelOnArrowDownKey(menuView) {
        menuView.keystrokes.set("arrowdown", (data, cancel2) => {
          if (menuView.focusTracker.focusedElement === menuView.buttonView.element) {
            if (!menuView.isOpen) {
              menuView.isOpen = true;
            }
            menuView.panelView.focus();
            cancel2();
          }
        });
      },
      /**
      * Open the menu on the right arrow key press. This allows for navigating to sub-menus using the keyboard.
      */
      openOnArrowRightKey(menuView) {
        const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowleft" : "arrowright";
        menuView.keystrokes.set(keystroke, (data, cancel2) => {
          if (menuView.focusTracker.focusedElement !== menuView.buttonView.element || !menuView.isEnabled) {
            return;
          }
          if (!menuView.isOpen) {
            menuView.isOpen = true;
          }
          menuView.panelView.focus();
          cancel2();
        });
      },
      /**
      * Opens the menu on its button click. Note that this behavior only opens but never closes the menu (unlike
      * {@link module:ui/dropdown/dropdownview~DropdownView}).
      */
      openOnButtonClick(menuView) {
        menuView.buttonView.on("execute", () => {
          menuView.isOpen = true;
          menuView.panelView.focus();
        });
      },
      /**
      * Toggles the menu on its button click. This behavior is analogous to {@link module:ui/dropdown/dropdownview~DropdownView}.
      */
      toggleOnButtonClick(menuView) {
        menuView.buttonView.on("execute", () => {
          menuView.isOpen = !menuView.isOpen;
          if (menuView.isOpen) {
            menuView.panelView.focus();
          }
        });
      },
      /**
      * Closes the menu on the right left key press. This allows for navigating to sub-menus using the keyboard.
      */
      closeOnArrowLeftKey(menuView) {
        const keystroke = menuView.locale.uiLanguageDirection === "rtl" ? "arrowright" : "arrowleft";
        menuView.keystrokes.set(keystroke, (data, cancel2) => {
          if (menuView.isOpen) {
            menuView.isOpen = false;
            menuView.focus();
            cancel2();
          }
        });
      },
      /**
      * Closes the menu on the esc key press. This allows for navigating to sub-menus using the keyboard.
      */
      closeOnEscKey(menuView) {
        menuView.keystrokes.set("esc", (data, cancel2) => {
          if (menuView.isOpen) {
            menuView.isOpen = false;
            menuView.focus();
            cancel2();
          }
        });
      },
      /**
      * Closes the menu when its parent menu also closed. This prevents from orphaned open menus when the parent menu re-opens.
      */
      closeOnParentClose(menuView) {
        menuView.parentMenuView.on("change:isOpen", (evt, name, isOpen) => {
          if (!isOpen && evt.source === menuView.parentMenuView) {
            menuView.isOpen = false;
          }
        });
      }
    };
    const MenuBarMenuViewPanelPositioningFunctions = {
      southEast: (buttonRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left,
          name: "se"
        };
      },
      southWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.bottom,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "sw"
        };
      },
      northEast: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left,
          name: "ne"
        };
      },
      northWest: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - panelRect.width + buttonRect.width,
          name: "nw"
        };
      },
      eastSouth: (buttonRect) => {
        return {
          top: buttonRect.top,
          left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "es"
        };
      },
      eastNorth: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.right - NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "en"
        };
      },
      westSouth: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top,
          left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "ws"
        };
      },
      westNorth: (buttonRect, panelRect) => {
        return {
          top: buttonRect.top - panelRect.height,
          left: buttonRect.left - panelRect.width + NESTED_PANEL_HORIZONTAL_OFFSET,
          name: "wn"
        };
      }
    };
    const DefaultMenuBarItems = [
      {
        menuId: "file",
        label: "File",
        groups: [
          {
            groupId: "export",
            items: [
              "menuBar:exportPdf",
              "menuBar:exportWord"
            ]
          },
          {
            groupId: "import",
            items: [
              "menuBar:importWord"
            ]
          },
          {
            groupId: "revisionHistory",
            items: [
              "menuBar:revisionHistory"
            ]
          }
        ]
      },
      {
        menuId: "edit",
        label: "Edit",
        groups: [
          {
            groupId: "undo",
            items: [
              "menuBar:undo",
              "menuBar:redo"
            ]
          },
          {
            groupId: "selectAll",
            items: [
              "menuBar:selectAll"
            ]
          },
          {
            groupId: "findAndReplace",
            items: [
              "menuBar:findAndReplace"
            ]
          }
        ]
      },
      {
        menuId: "view",
        label: "View",
        groups: [
          {
            groupId: "sourceEditing",
            items: [
              "menuBar:sourceEditing"
            ]
          },
          {
            groupId: "showBlocks",
            items: [
              "menuBar:showBlocks"
            ]
          },
          {
            groupId: "restrictedEditingException",
            items: [
              "menuBar:restrictedEditingException"
            ]
          }
        ]
      },
      {
        menuId: "insert",
        label: "Insert",
        groups: [
          {
            groupId: "insertMainWidgets",
            items: [
              "menuBar:insertImage",
              "menuBar:ckbox",
              "menuBar:ckfinder",
              "menuBar:insertTable"
            ]
          },
          {
            groupId: "insertInline",
            items: [
              "menuBar:link",
              "menuBar:comment"
            ]
          },
          {
            groupId: "insertMinorWidgets",
            items: [
              "menuBar:mediaEmbed",
              "menuBar:insertTemplate",
              "menuBar:blockQuote",
              "menuBar:codeBlock",
              "menuBar:htmlEmbed"
            ]
          },
          {
            groupId: "insertStructureWidgets",
            items: [
              "menuBar:horizontalLine",
              "menuBar:pageBreak",
              "menuBar:tableOfContents"
            ]
          },
          {
            groupId: "restrictedEditing",
            items: [
              "menuBar:restrictedEditing"
            ]
          }
        ]
      },
      {
        menuId: "format",
        label: "Format",
        groups: [
          {
            groupId: "textAndFont",
            items: [
              {
                menuId: "text",
                label: "Text",
                groups: [
                  {
                    groupId: "basicStyles",
                    items: [
                      "menuBar:bold",
                      "menuBar:italic",
                      "menuBar:underline",
                      "menuBar:strikethrough",
                      "menuBar:superscript",
                      "menuBar:subscript",
                      "menuBar:code"
                    ]
                  },
                  {
                    groupId: "textPartLanguage",
                    items: [
                      "menuBar:textPartLanguage"
                    ]
                  }
                ]
              },
              {
                menuId: "font",
                label: "Font",
                groups: [
                  {
                    groupId: "fontProperties",
                    items: [
                      "menuBar:fontSize",
                      "menuBar:fontFamily"
                    ]
                  },
                  {
                    groupId: "fontColors",
                    items: [
                      "menuBar:fontColor",
                      "menuBar:fontBackgroundColor"
                    ]
                  },
                  {
                    groupId: "highlight",
                    items: [
                      "menuBar:highlight"
                    ]
                  }
                ]
              },
              "menuBar:heading"
            ]
          },
          {
            groupId: "list",
            items: [
              "menuBar:bulletedList",
              "menuBar:numberedList",
              "menuBar:multiLevelList",
              "menuBar:todoList"
            ]
          },
          {
            groupId: "indent",
            items: [
              "menuBar:alignment",
              "menuBar:indent",
              "menuBar:outdent"
            ]
          },
          {
            groupId: "caseChange",
            items: [
              "menuBar:caseChange"
            ]
          },
          {
            groupId: "removeFormat",
            items: [
              "menuBar:removeFormat"
            ]
          }
        ]
      },
      {
        menuId: "tools",
        label: "Tools",
        groups: [
          {
            groupId: "aiTools",
            items: [
              "menuBar:aiAssistant",
              "menuBar:aiCommands"
            ]
          },
          {
            groupId: "tools",
            items: [
              "menuBar:trackChanges",
              "menuBar:commentsArchive"
            ]
          }
        ]
      },
      {
        menuId: "help",
        label: "Help",
        groups: [
          {
            groupId: "help",
            items: [
              "menuBar:accessibilityHelp"
            ]
          }
        ]
      }
    ];
    function normalizeMenuBarConfig(config) {
      let configObject;
      if (!("items" in config) || !config.items) {
        configObject = {
          items: cloneDeep(DefaultMenuBarItems),
          addItems: [],
          removeItems: [],
          isVisible: true,
          isUsingDefaultConfig: true,
          ...config
        };
      } else {
        configObject = {
          items: config.items,
          removeItems: [],
          addItems: [],
          isVisible: true,
          isUsingDefaultConfig: false,
          ...config
        };
      }
      return configObject;
    }
    function processMenuBarConfig({ normalizedConfig, locale, componentFactory }) {
      const configClone = cloneDeep(normalizedConfig);
      handleRemovals(normalizedConfig, configClone);
      handleAdditions(normalizedConfig, configClone);
      purgeUnavailableComponents(normalizedConfig, configClone, componentFactory);
      purgeEmptyMenus(normalizedConfig, configClone);
      localizeMenuLabels(configClone, locale);
      return configClone;
    }
    function handleRemovals(originalConfig, config) {
      const itemsToBeRemoved = config.removeItems;
      const successfullyRemovedItems = [];
      config.items = config.items.filter(({ menuId }) => {
        if (itemsToBeRemoved.includes(menuId)) {
          successfullyRemovedItems.push(menuId);
          return false;
        }
        return true;
      });
      walkConfigMenus(config.items, (menuDefinition) => {
        menuDefinition.groups = menuDefinition.groups.filter(({ groupId }) => {
          if (itemsToBeRemoved.includes(groupId)) {
            successfullyRemovedItems.push(groupId);
            return false;
          }
          return true;
        });
        for (const groupDefinition of menuDefinition.groups) {
          groupDefinition.items = groupDefinition.items.filter((item) => {
            const itemId = getIdFromGroupItem(item);
            if (itemsToBeRemoved.includes(itemId)) {
              successfullyRemovedItems.push(itemId);
              return false;
            }
            return true;
          });
        }
      });
      for (const itemName of itemsToBeRemoved) {
        if (!successfullyRemovedItems.includes(itemName)) {
          logWarning("menu-bar-item-could-not-be-removed", {
            menuBarConfig: originalConfig,
            itemName
          });
        }
      }
    }
    function handleAdditions(originalConfig, config) {
      const itemsToBeAdded = config.addItems;
      const successFullyAddedItems = [];
      for (const itemToAdd of itemsToBeAdded) {
        const relation = getRelationFromPosition(itemToAdd.position);
        const relativeId = getRelativeIdFromPosition(itemToAdd.position);
        if (isMenuBarMenuAddition(itemToAdd)) {
          if (!relativeId) {
            if (relation === "start") {
              config.items.unshift(itemToAdd.menu);
              successFullyAddedItems.push(itemToAdd);
            } else if (relation === "end") {
              config.items.push(itemToAdd.menu);
              successFullyAddedItems.push(itemToAdd);
            }
          } else {
            const topLevelMenuDefinitionIndex = config.items.findIndex((menuDefinition) => menuDefinition.menuId === relativeId);
            if (topLevelMenuDefinitionIndex != -1) {
              if (relation === "before") {
                config.items.splice(topLevelMenuDefinitionIndex, 0, itemToAdd.menu);
                successFullyAddedItems.push(itemToAdd);
              } else if (relation === "after") {
                config.items.splice(topLevelMenuDefinitionIndex + 1, 0, itemToAdd.menu);
                successFullyAddedItems.push(itemToAdd);
              }
            } else {
              const wasAdded = addMenuOrItemToGroup(config, itemToAdd.menu, relativeId, relation);
              if (wasAdded) {
                successFullyAddedItems.push(itemToAdd);
              }
            }
          }
        } else if (isMenuBarMenuGroupAddition(itemToAdd)) {
          walkConfigMenus(config.items, (menuDefinition) => {
            if (menuDefinition.menuId === relativeId) {
              if (relation === "start") {
                menuDefinition.groups.unshift(itemToAdd.group);
                successFullyAddedItems.push(itemToAdd);
              } else if (relation === "end") {
                menuDefinition.groups.push(itemToAdd.group);
                successFullyAddedItems.push(itemToAdd);
              }
            } else {
              const relativeGroupIndex = menuDefinition.groups.findIndex((group) => group.groupId === relativeId);
              if (relativeGroupIndex !== -1) {
                if (relation === "before") {
                  menuDefinition.groups.splice(relativeGroupIndex, 0, itemToAdd.group);
                  successFullyAddedItems.push(itemToAdd);
                } else if (relation === "after") {
                  menuDefinition.groups.splice(relativeGroupIndex + 1, 0, itemToAdd.group);
                  successFullyAddedItems.push(itemToAdd);
                }
              }
            }
          });
        } else {
          const wasAdded = addMenuOrItemToGroup(config, itemToAdd.item, relativeId, relation);
          if (wasAdded) {
            successFullyAddedItems.push(itemToAdd);
          }
        }
      }
      for (const addedItemConfig of itemsToBeAdded) {
        if (!successFullyAddedItems.includes(addedItemConfig)) {
          logWarning("menu-bar-item-could-not-be-added", {
            menuBarConfig: originalConfig,
            addedItemConfig
          });
        }
      }
    }
    function addMenuOrItemToGroup(config, itemOrMenuToAdd, relativeId, relation) {
      let wasAdded = false;
      walkConfigMenus(config.items, (menuDefinition) => {
        for (const { groupId, items: groupItems } of menuDefinition.groups) {
          if (wasAdded) {
            return;
          }
          if (groupId === relativeId) {
            if (relation === "start") {
              groupItems.unshift(itemOrMenuToAdd);
              wasAdded = true;
            } else if (relation === "end") {
              groupItems.push(itemOrMenuToAdd);
              wasAdded = true;
            }
          } else {
            const relativeItemIndex = groupItems.findIndex((groupItem) => {
              return getIdFromGroupItem(groupItem) === relativeId;
            });
            if (relativeItemIndex !== -1) {
              if (relation === "before") {
                groupItems.splice(relativeItemIndex, 0, itemOrMenuToAdd);
                wasAdded = true;
              } else if (relation === "after") {
                groupItems.splice(relativeItemIndex + 1, 0, itemOrMenuToAdd);
                wasAdded = true;
              }
            }
          }
        }
      });
      return wasAdded;
    }
    function purgeUnavailableComponents(originalConfig, config, componentFactory) {
      walkConfigMenus(config.items, (menuDefinition) => {
        for (const groupDefinition of menuDefinition.groups) {
          groupDefinition.items = groupDefinition.items.filter((item) => {
            const isItemUnavailable = typeof item === "string" && !componentFactory.has(item);
            if (isItemUnavailable && !config.isUsingDefaultConfig) {
              logWarning("menu-bar-item-unavailable", {
                menuBarConfig: originalConfig,
                parentMenuConfig: cloneDeep(menuDefinition),
                componentName: item
              });
            }
            return !isItemUnavailable;
          });
        }
      });
    }
    function purgeEmptyMenus(originalConfig, config) {
      const isUsingDefaultConfig = config.isUsingDefaultConfig;
      let wasSubMenuPurged = false;
      config.items = config.items.filter((menuDefinition) => {
        if (!menuDefinition.groups.length) {
          warnAboutEmptyMenu(originalConfig, menuDefinition, isUsingDefaultConfig);
          return false;
        }
        return true;
      });
      if (!config.items.length) {
        warnAboutEmptyMenu(originalConfig, originalConfig, isUsingDefaultConfig);
        return;
      }
      walkConfigMenus(config.items, (menuDefinition) => {
        menuDefinition.groups = menuDefinition.groups.filter((groupDefinition) => {
          if (!groupDefinition.items.length) {
            wasSubMenuPurged = true;
            return false;
          }
          return true;
        });
        for (const groupDefinition of menuDefinition.groups) {
          groupDefinition.items = groupDefinition.items.filter((item) => {
            if (isMenuDefinition(item) && !item.groups.length) {
              warnAboutEmptyMenu(originalConfig, item, isUsingDefaultConfig);
              wasSubMenuPurged = true;
              return false;
            }
            return true;
          });
        }
      });
      if (wasSubMenuPurged) {
        purgeEmptyMenus(originalConfig, config);
      }
    }
    function warnAboutEmptyMenu(originalConfig, emptyMenuConfig, isUsingDefaultConfig) {
      if (isUsingDefaultConfig) {
        return;
      }
      logWarning("menu-bar-menu-empty", {
        menuBarConfig: originalConfig,
        emptyMenuConfig
      });
    }
    function localizeMenuLabels(config, locale) {
      const t = locale.t;
      const localizedCategoryLabels = {
        // Top-level categories.
        "File": t({
          string: "File",
          id: "MENU_BAR_MENU_FILE"
        }),
        "Edit": t({
          string: "Edit",
          id: "MENU_BAR_MENU_EDIT"
        }),
        "View": t({
          string: "View",
          id: "MENU_BAR_MENU_VIEW"
        }),
        "Insert": t({
          string: "Insert",
          id: "MENU_BAR_MENU_INSERT"
        }),
        "Format": t({
          string: "Format",
          id: "MENU_BAR_MENU_FORMAT"
        }),
        "Tools": t({
          string: "Tools",
          id: "MENU_BAR_MENU_TOOLS"
        }),
        "Help": t({
          string: "Help",
          id: "MENU_BAR_MENU_HELP"
        }),
        // Sub-menus.
        "Text": t({
          string: "Text",
          id: "MENU_BAR_MENU_TEXT"
        }),
        "Font": t({
          string: "Font",
          id: "MENU_BAR_MENU_FONT"
        })
      };
      walkConfigMenus(config.items, (definition) => {
        if (definition.label in localizedCategoryLabels) {
          definition.label = localizedCategoryLabels[definition.label];
        }
      });
    }
    function walkConfigMenus(definition, callback) {
      if (Array.isArray(definition)) {
        for (const topLevelMenuDefinition of definition) {
          walk(topLevelMenuDefinition);
        }
      }
      function walk(menuDefinition) {
        callback(menuDefinition);
        for (const groupDefinition of menuDefinition.groups) {
          for (const groupItem of groupDefinition.items) {
            if (isMenuDefinition(groupItem)) {
              walk(groupItem);
            }
          }
        }
      }
    }
    function isMenuBarMenuAddition(definition) {
      return typeof definition === "object" && "menu" in definition;
    }
    function isMenuBarMenuGroupAddition(definition) {
      return typeof definition === "object" && "group" in definition;
    }
    function getRelationFromPosition(position) {
      if (position.startsWith("start")) {
        return "start";
      } else if (position.startsWith("end")) {
        return "end";
      } else if (position.startsWith("after")) {
        return "after";
      } else {
        return "before";
      }
    }
    function getRelativeIdFromPosition(position) {
      const match = position.match(/^[^:]+:(.+)/);
      if (match) {
        return match[1];
      }
      return null;
    }
    function getIdFromGroupItem(item) {
      return typeof item === "string" ? item : item.menuId;
    }
    function isMenuDefinition(definition) {
      return typeof definition === "object" && "menuId" in definition;
    }
    function _initMenuBar(editor, menuBarView) {
      const menuBarViewElement = menuBarView.element;
      editor.ui.focusTracker.add(menuBarViewElement);
      editor.keystrokes.listenTo(menuBarViewElement);
      const normalizedMenuBarConfig = normalizeMenuBarConfig(editor.config.get("menuBar") || {});
      menuBarView.fillFromConfig(normalizedMenuBarConfig, editor.ui.componentFactory);
      editor.keystrokes.set("Esc", (data, cancel2) => {
        if (menuBarViewElement.contains(editor.ui.focusTracker.focusedElement)) {
          editor.editing.view.focus();
          cancel2();
        }
      });
      editor.keystrokes.set("Alt+F9", (data, cancel2) => {
        if (!menuBarViewElement.contains(editor.ui.focusTracker.focusedElement)) {
          menuBarView.focus();
          cancel2();
        }
      });
    }
    class MenuBarMenuPanelView extends View {
      /**
      * Creates an instance of the menu panel view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views in this panel.
        */
        __publicField(this, "children");
        const bind = this.bindTemplate;
        this.set("isVisible", false);
        this.set("position", "se");
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset",
              "ck-menu-bar__menu__panel",
              bind.to("position", (value) => `ck-menu-bar__menu__panel_position_${value}`),
              bind.if("isVisible", "ck-hidden", (value) => !value)
            ],
            tabindex: "-1"
          },
          children: this.children,
          on: {
            // Drag and drop in the panel should not break the selection in the editor.
            // https://github.com/ckeditor/ckeditor5-ui/issues/228
            selectstart: bind.to((evt) => {
              if (evt.target.tagName.toLocaleLowerCase() === "input") {
                return;
              }
              evt.preventDefault();
            })
          }
        });
      }
      /**
      * Focuses the first child of the panel (default) or the last one if the `direction` is `-1`.
      */
      focus(direction = 1) {
        if (this.children.length) {
          if (direction === 1) {
            this.children.first.focus();
          } else {
            this.children.last.focus();
          }
        }
      }
    }
    const _MenuBarMenuView = class _MenuBarMenuView extends View {
      /**
      * Creates an instance of the menu view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Button of the menu view.
        */
        __publicField(this, "buttonView");
        /**
        * Panel of the menu. It hosts children of the menu.
        */
        __publicField(this, "panelView");
        /**
        * Tracks information about the DOM focus in the menu.
        */
        __publicField(this, "focusTracker");
        /**
        * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
        * keystrokes of the menu.
        */
        __publicField(this, "keystrokes");
        const bind = this.bindTemplate;
        this.buttonView = new MenuBarMenuButtonView(locale);
        this.buttonView.delegate("mouseenter").to(this);
        this.buttonView.bind("isOn", "isEnabled").to(this, "isOpen", "isEnabled");
        this.panelView = new MenuBarMenuPanelView(locale);
        this.panelView.bind("isVisible").to(this, "isOpen");
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.set("isOpen", false);
        this.set("isEnabled", true);
        this.set("panelPosition", "w");
        this.set("class", void 0);
        this.set("parentMenuView", null);
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-menu-bar__menu",
              bind.to("class"),
              bind.if("isEnabled", "ck-disabled", (value) => !value),
              bind.if("parentMenuView", "ck-menu-bar__menu_top-level", (value) => !value)
            ]
          },
          children: [
            this.buttonView,
            this.panelView
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.focusTracker.add(this.buttonView.element);
        this.focusTracker.add(this.panelView.element);
        this.keystrokes.listenTo(this.element);
        MenuBarMenuBehaviors.closeOnEscKey(this);
        this._repositionPanelOnOpen();
      }
      // For now, this method cannot be called in the render process because the `parentMenuView` may be assigned
      // after the rendering process.
      //
      // TODO: We should reconsider the way we handle this logic.
      /**
      * Attach all keyboard behaviors for the menu bar view.
      *
      * @internal
      */
      _attachBehaviors() {
        if (!this.parentMenuView) {
          this._propagateArrowKeystrokeEvents();
          MenuBarMenuBehaviors.openAndFocusPanelOnArrowDownKey(this);
          MenuBarMenuBehaviors.toggleOnButtonClick(this);
        } else {
          MenuBarMenuBehaviors.openOnButtonClick(this);
          MenuBarMenuBehaviors.openOnArrowRightKey(this);
          MenuBarMenuBehaviors.closeOnArrowLeftKey(this);
          MenuBarMenuBehaviors.closeOnParentClose(this);
        }
      }
      /**
      * Fires `arrowright` and `arrowleft` events when the user pressed corresponding arrow keys.
      */
      _propagateArrowKeystrokeEvents() {
        this.keystrokes.set("arrowright", (data, cancel2) => {
          this.fire("arrowright");
          cancel2();
        });
        this.keystrokes.set("arrowleft", (data, cancel2) => {
          this.fire("arrowleft");
          cancel2();
        });
      }
      /**
      * Sets the position of the panel when the menu opens. The panel is positioned
      * so that it optimally uses the available space in the viewport.
      */
      _repositionPanelOnOpen() {
        this.on("change:isOpen", (evt, name, isOpen) => {
          if (!isOpen) {
            return;
          }
          const optimalPanelPosition = _MenuBarMenuView._getOptimalPosition({
            element: this.panelView.element,
            target: this.buttonView.element,
            fitInViewport: true,
            positions: this._panelPositions
          });
          this.panelView.position = optimalPanelPosition ? optimalPanelPosition.name : this._panelPositions[0].name;
        });
      }
      /**
      * @inheritDoc
      */
      focus() {
        this.buttonView.focus();
      }
      /**
      * Positioning functions for the {@link #panelView} . They change depending on the role of the menu (top-level vs sub-menu) in
      * the {@link module:ui/menubar/menubarview~MenuBarView menu bar} and the UI language direction.
      */
      get _panelPositions() {
        const { southEast, southWest, northEast, northWest, westSouth, eastSouth, westNorth, eastNorth } = MenuBarMenuViewPanelPositioningFunctions;
        if (this.locale.uiLanguageDirection === "ltr") {
          if (this.parentMenuView) {
            return [
              eastSouth,
              eastNorth,
              westSouth,
              westNorth
            ];
          } else {
            return [
              southEast,
              southWest,
              northEast,
              northWest
            ];
          }
        } else {
          if (this.parentMenuView) {
            return [
              westSouth,
              westNorth,
              eastSouth,
              eastNorth
            ];
          } else {
            return [
              southWest,
              southEast,
              northWest,
              northEast
            ];
          }
        }
      }
    };
    /**
    * A function used to calculate the optimal position for the dropdown panel.
    *
    * Referenced for unit testing purposes.
    */
    __publicField(_MenuBarMenuView, "_getOptimalPosition", getOptimalPosition);
    let MenuBarMenuView = _MenuBarMenuView;
    class MenuBarMenuListView extends ListView {
      /**
      * Creates an instance of the list view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        this.role = "menu";
      }
    }
    class MenuBarMenuListItemFileDialogButtonView extends FileDialogButtonView {
      /**
      * Creates an instance of the menu bar list button view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        this.set({
          withText: true,
          withKeystroke: true,
          tooltip: false,
          role: "menuitem"
        });
        this.extendTemplate({
          attributes: {
            class: [
              "ck-menu-bar__menu__item__button"
            ]
          }
        });
      }
    }
    const EVENT_NAME_DELEGATES = [
      "mouseenter",
      "arrowleft",
      "arrowright",
      "change:isOpen"
    ];
    class MenuBarView extends View {
      /**
      * Creates an instance of the menu bar view.
      *
      * @param locale The localization services instance.
      */
      constructor(locale) {
        super(locale);
        /**
        * Collection of the child views inside the {@link #element}.
        */
        __publicField(this, "children");
        /**
        * A list of {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instances registered in the menu bar.
        *
        * @observable
        */
        __publicField(this, "menus", []);
        const t = locale.t;
        this.set("isOpen", false);
        this._setupIsOpenUpdater();
        this.children = this.createCollection();
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-menu-bar"
            ],
            "aria-label": t("Editor menu bar"),
            role: "menubar"
          },
          children: this.children
        });
      }
      /**
      * A utility that expands a plain menu bar configuration into a structure of menus (also: sub-menus)
      * and items using a given {@link module:ui/componentfactory~ComponentFactory component factory}.
      *
      * See the {@link module:core/editor/editorconfig~EditorConfig#menuBar menu bar} in the editor
      * configuration reference to learn how to configure the menu bar.
      */
      fillFromConfig(config, componentFactory) {
        const locale = this.locale;
        const processedConfig = processMenuBarConfig({
          normalizedConfig: config,
          locale,
          componentFactory
        });
        const topLevelCategoryMenuViews = processedConfig.items.map((menuDefinition) => this._createMenu({
          componentFactory,
          menuDefinition
        }));
        this.children.addMany(topLevelCategoryMenuViews);
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        MenuBarBehaviors.toggleMenusAndFocusItemsOnHover(this);
        MenuBarBehaviors.closeMenusWhenTheBarCloses(this);
        MenuBarBehaviors.closeMenuWhenAnotherOnTheSameLevelOpens(this);
        MenuBarBehaviors.focusCycleMenusOnArrows(this);
        MenuBarBehaviors.closeOnClickOutside(this);
      }
      /**
      * Focuses the menu bar.
      */
      focus() {
        if (this.children.first) {
          this.children.first.focus();
        }
      }
      /**
      * Closes all menus in the bar.
      */
      close() {
        for (const topLevelCategoryMenuView of this.children) {
          topLevelCategoryMenuView.isOpen = false;
        }
      }
      /**
      * Registers a menu view in the menu bar. Every {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} instance must be registered
      * in the menu bar to be properly managed.
      */
      registerMenu(menuView, parentMenuView = null) {
        if (parentMenuView) {
          menuView.delegate(...EVENT_NAME_DELEGATES).to(parentMenuView);
          menuView.parentMenuView = parentMenuView;
        } else {
          menuView.delegate(...EVENT_NAME_DELEGATES).to(this, (name) => "menu:" + name);
        }
        menuView._attachBehaviors();
        this.menus.push(menuView);
      }
      /**
      * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} based on the given definition.
      */
      _createMenu({ componentFactory, menuDefinition, parentMenuView }) {
        const locale = this.locale;
        const menuView = new MenuBarMenuView(locale);
        this.registerMenu(menuView, parentMenuView);
        menuView.buttonView.set({
          label: menuDefinition.label
        });
        menuView.once("change:isOpen", () => {
          const listView = new MenuBarMenuListView(locale);
          listView.ariaLabel = menuDefinition.label;
          menuView.panelView.children.add(listView);
          listView.items.addMany(this._createMenuItems({
            menuDefinition,
            parentMenuView: menuView,
            componentFactory
          }));
        });
        return menuView;
      }
      /**
      * Creates a {@link module:ui/menubar/menubarmenuview~MenuBarMenuView} items based on the given definition.
      */
      _createMenuItems({ menuDefinition, parentMenuView, componentFactory }) {
        const locale = this.locale;
        const items = [];
        for (const menuGroupDefinition of menuDefinition.groups) {
          for (const itemDefinition of menuGroupDefinition.items) {
            const menuItemView = new MenuBarMenuListItemView(locale, parentMenuView);
            if (isObject$1(itemDefinition)) {
              menuItemView.children.add(this._createMenu({
                componentFactory,
                menuDefinition: itemDefinition,
                parentMenuView
              }));
            } else {
              const componentView = this._createMenuItemContentFromFactory({
                componentName: itemDefinition,
                componentFactory,
                parentMenuView
              });
              if (!componentView) {
                continue;
              }
              menuItemView.children.add(componentView);
            }
            items.push(menuItemView);
          }
          if (menuGroupDefinition !== menuDefinition.groups[menuDefinition.groups.length - 1]) {
            items.push(new ListSeparatorView(locale));
          }
        }
        return items;
      }
      /**
      * Uses the component factory to create a content of the menu item (a button or a sub-menu).
      */
      _createMenuItemContentFromFactory({ componentName, parentMenuView, componentFactory }) {
        const componentView = componentFactory.create(componentName);
        if (!(componentView instanceof MenuBarMenuView || componentView instanceof MenuBarMenuListItemButtonView || componentView instanceof MenuBarMenuListItemFileDialogButtonView)) {
          logWarning("menu-bar-component-unsupported", {
            componentName,
            componentView
          });
          return null;
        }
        this._registerMenuTree(componentView, parentMenuView);
        componentView.on("execute", () => {
          this.close();
        });
        return componentView;
      }
      /**
      * Checks component and its children recursively and calls {@link #registerMenu}
      * for each item that is {@link module:ui/menubar/menubarmenuview~MenuBarMenuView}.
      *
      * @internal
      */
      _registerMenuTree(componentView, parentMenuView) {
        if (!(componentView instanceof MenuBarMenuView)) {
          componentView.delegate("mouseenter").to(parentMenuView);
          return;
        }
        this.registerMenu(componentView, parentMenuView);
        const menuBarItemsList = componentView.panelView.children.filter((child) => child instanceof MenuBarMenuListView)[0];
        if (!menuBarItemsList) {
          componentView.delegate("mouseenter").to(parentMenuView);
          return;
        }
        const nonSeparatorItems = menuBarItemsList.items.filter((item) => item instanceof ListItemView);
        for (const item of nonSeparatorItems) {
          this._registerMenuTree(item.children.get(0), componentView);
        }
      }
      /**
      * Manages the state of the {@link #isOpen} property of the menu bar. Because the state is a sum of individual
      * top-level menus' states, it's necessary to listen to their changes and update the state accordingly.
      *
      * Additionally, it prevents from unnecessary changes of `isOpen` when one top-level menu opens and another closes
      * (regardless of in which order), maintaining a stable `isOpen === true` in that situation.
      */
      _setupIsOpenUpdater() {
        let closeTimeout;
        this.on("menu:change:isOpen", (evt, name, isOpen) => {
          clearTimeout(closeTimeout);
          if (isOpen) {
            this.isOpen = true;
          } else {
            closeTimeout = setTimeout(() => {
              this.isOpen = Array.from(this.children).some((menuView) => menuView.isOpen);
            }, 0);
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ChangeBuffer {
      /**
      * Creates a new instance of the change buffer.
      *
      * @param limit The maximum number of atomic changes which can be contained in one batch.
      */
      constructor(model, limit = 20) {
        /**
        * The model instance.
        */
        __publicField(this, "model");
        /**
        * The maximum number of atomic changes which can be contained in one batch.
        */
        __publicField(this, "limit");
        /**
        * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
        */
        __publicField(this, "_isLocked");
        /**
        * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
        * the {@link #batch batch} is set to a new one.
        */
        __publicField(this, "_size");
        /**
        * The current batch instance.
        */
        __publicField(this, "_batch", null);
        /**
        * The callback to document the change event which later needs to be removed.
        */
        __publicField(this, "_changeCallback");
        /**
        * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.
        */
        __publicField(this, "_selectionChangeCallback");
        this.model = model;
        this._size = 0;
        this.limit = limit;
        this._isLocked = false;
        this._changeCallback = (evt, batch) => {
          if (batch.isLocal && batch.isUndoable && batch !== this._batch) {
            this._reset(true);
          }
        };
        this._selectionChangeCallback = () => {
          this._reset();
        };
        this.model.document.on("change", this._changeCallback);
        this.model.document.selection.on("change:range", this._selectionChangeCallback);
        this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
      }
      /**
      * The current batch to which a feature should add its operations. Once the {@link #size}
      * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
      */
      get batch() {
        if (!this._batch) {
          this._batch = this.model.createBatch({
            isTyping: true
          });
        }
        return this._batch;
      }
      /**
      * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
      * the {@link #batch batch} is set to a new one.
      */
      get size() {
        return this._size;
      }
      /**
      * The input number of changes into the buffer. Once the {@link #size} is
      * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
      *
      * @param changeCount The number of atomic changes to input.
      */
      input(changeCount) {
        this._size += changeCount;
        if (this._size >= this.limit) {
          this._reset(true);
        }
      }
      /**
      * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
      */
      get isLocked() {
        return this._isLocked;
      }
      /**
      * Locks the buffer.
      */
      lock() {
        this._isLocked = true;
      }
      /**
      * Unlocks the buffer.
      */
      unlock() {
        this._isLocked = false;
      }
      /**
      * Destroys the buffer.
      */
      destroy() {
        this.model.document.off("change", this._changeCallback);
        this.model.document.selection.off("change:range", this._selectionChangeCallback);
        this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
      }
      /**
      * Resets the change buffer.
      *
      * @param ignoreLock Whether internal lock {@link #isLocked} should be ignored.
      */
      _reset(ignoreLock = false) {
        if (!this.isLocked || ignoreLock) {
          this._batch = null;
          this._size = 0;
        }
      }
    }
    class InsertTextCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param undoStepSize The maximum number of atomic changes
      * which can be contained in one batch in the command buffer.
      */
      constructor(editor, undoStepSize) {
        super(editor);
        /**
        * Typing's change buffer used to group subsequent changes into batches.
        */
        __publicField(this, "_buffer");
        this._buffer = new ChangeBuffer(editor.model, undoStepSize);
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * The current change buffer.
      */
      get buffer() {
        return this._buffer;
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._buffer.destroy();
      }
      /**
      * Executes the input command. It replaces the content within the given range with the given text.
      * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
      * at the beginning of the range (which after the removal is a collapsed range).
      *
      * @fires execute
      * @param options The command options.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const text2 = options.text || "";
        const textInsertions = text2.length;
        let selection = doc.selection;
        if (options.selection) {
          selection = options.selection;
        } else if (options.range) {
          selection = model.createSelection(options.range);
        }
        if (!model.canEditAt(selection)) {
          return;
        }
        const resultRange = options.resultRange;
        model.enqueueChange(this._buffer.batch, (writer) => {
          this._buffer.lock();
          const selectionAttributes = Array.from(doc.selection.getAttributes());
          model.deleteContent(selection);
          if (text2) {
            model.insertContent(writer.createText(text2, selectionAttributes), selection);
          }
          if (resultRange) {
            writer.setSelection(resultRange);
          } else if (!selection.is("documentSelection")) {
            writer.setSelection(selection);
          }
          this._buffer.unlock();
          this._buffer.input(textInsertions);
        });
      }
    }
    const TYPING_INPUT_TYPES = [
      // For collapsed range:
      //	- This one is a regular typing (all browsers, all systems).
      //	- This one is used by Chrome when typing accented letter – 2nd step when the user selects the accent (Mac).
      // For non-collapsed range:
      //	- This one is used by Chrome when typing accented letter – when the selection box first appears (Mac).
      //	- This one is used by Safari when accepting spell check suggestions from the context menu (Mac).
      "insertText",
      // This one is used by Safari when typing accented letter (Mac).
      // This one is used by Safari when accepting spell check suggestions from the autocorrection pop-up (Mac).
      "insertReplacementText"
    ];
    class InsertTextObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        /**
        * Instance of the focus observer. Insert text observer calls
        * {@link module:engine/view/observer/focusobserver~FocusObserver#flush} to mark the latest focus change as complete.
        */
        __publicField(this, "focusObserver");
        this.focusObserver = view.getObserver(FocusObserver);
        if (env.isAndroid) {
          TYPING_INPUT_TYPES.push("insertCompositionText");
        }
        const viewDocument = view.document;
        viewDocument.on("beforeinput", (evt, data) => {
          if (!this.isEnabled) {
            return;
          }
          const { data: text2, targetRanges, inputType, domEvent } = data;
          if (!TYPING_INPUT_TYPES.includes(inputType)) {
            return;
          }
          this.focusObserver.flush();
          const eventInfo = new EventInfo(viewDocument, "insertText");
          viewDocument.fire(eventInfo, new DomEventData(view, domEvent, {
            text: text2,
            selection: view.createSelection(targetRanges)
          }));
          if (eventInfo.stop.called) {
            evt.stop();
          }
        });
        viewDocument.on("compositionend", (evt, { data, domEvent }) => {
          if (!this.isEnabled || env.isAndroid) {
            return;
          }
          if (!data) {
            return;
          }
          viewDocument.fire("insertText", new DomEventData(view, domEvent, {
            text: data,
            selection: viewDocument.selection
          }));
        }, {
          priority: "lowest"
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    class Input extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Input";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const modelSelection = model.document.selection;
        view.addObserver(InsertTextObserver);
        const insertTextCommand = new InsertTextCommand(editor, editor.config.get("typing.undoStep") || 20);
        editor.commands.add("insertText", insertTextCommand);
        editor.commands.add("input", insertTextCommand);
        this.listenTo(view.document, "insertText", (evt, data) => {
          if (!view.document.isComposing) {
            data.preventDefault();
          }
          const { text: text2, selection: viewSelection, resultRange: viewResultRange } = data;
          const modelRanges = Array.from(viewSelection.getRanges()).map((viewRange) => {
            return editor.editing.mapper.toModelRange(viewRange);
          });
          let insertText2 = text2;
          if (env.isAndroid) {
            const selectedText = Array.from(modelRanges[0].getItems()).reduce((rangeText, node) => {
              return rangeText + (node.is("$textProxy") ? node.data : "");
            }, "");
            if (selectedText) {
              if (selectedText.length <= insertText2.length) {
                if (insertText2.startsWith(selectedText)) {
                  insertText2 = insertText2.substring(selectedText.length);
                  modelRanges[0].start = modelRanges[0].start.getShiftedBy(selectedText.length);
                }
              } else {
                if (selectedText.startsWith(insertText2)) {
                  modelRanges[0].start = modelRanges[0].start.getShiftedBy(insertText2.length);
                  insertText2 = "";
                }
              }
            }
          }
          const insertTextCommandData = {
            text: insertText2,
            selection: model.createSelection(modelRanges)
          };
          if (viewResultRange) {
            insertTextCommandData.resultRange = editor.editing.mapper.toModelRange(viewResultRange);
          }
          editor.execute("insertText", insertTextCommandData);
          view.scrollToTheSelection();
        });
        if (env.isAndroid) {
          this.listenTo(view.document, "keydown", (evt, data) => {
            if (modelSelection.isCollapsed || data.keyCode != 229 || !view.document.isComposing) {
              return;
            }
            deleteSelectionContent(model, insertTextCommand);
          });
        } else {
          this.listenTo(view.document, "compositionstart", () => {
            if (modelSelection.isCollapsed) {
              return;
            }
            deleteSelectionContent(model, insertTextCommand);
          });
        }
      }
    }
    function deleteSelectionContent(model, insertTextCommand) {
      if (!insertTextCommand.isEnabled) {
        return;
      }
      const buffer = insertTextCommand.buffer;
      buffer.lock();
      model.enqueueChange(buffer.batch, () => {
        model.deleteContent(model.document.selection);
      });
      buffer.unlock();
    }
    class DeleteCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param direction The directionality of the delete describing in what direction it
      * should consume the content when the selection is collapsed.
      */
      constructor(editor, direction) {
        super(editor);
        /**
        * The directionality of the delete describing in what direction it should
        * consume the content when the selection is collapsed.
        */
        __publicField(this, "direction");
        /**
        * Delete's change buffer used to group subsequent changes into batches.
        */
        __publicField(this, "_buffer");
        this.direction = direction;
        this._buffer = new ChangeBuffer(editor.model, editor.config.get("typing.undoStep"));
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * The current change buffer.
      */
      get buffer() {
        return this._buffer;
      }
      /**
      * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
      * or a piece of content in the {@link #direction defined direction}.
      *
      * @fires execute
      * @param options The command options.
      * @param options.unit See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
      * @param options.sequence A number describing which subsequent delete event it is without the key being released.
      * See the {@link module:engine/view/document~Document#event:delete} event data.
      * @param options.selection Selection to remove. If not set, current model selection will be used.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        model.enqueueChange(this._buffer.batch, (writer) => {
          this._buffer.lock();
          const selection = writer.createSelection(options.selection || doc.selection);
          if (!model.canEditAt(selection)) {
            return;
          }
          const sequence = options.sequence || 1;
          const doNotResetEntireContent = selection.isCollapsed;
          if (selection.isCollapsed) {
            model.modifySelection(selection, {
              direction: this.direction,
              unit: options.unit,
              treatEmojiAsSingleUnit: true
            });
          }
          if (this._shouldEntireContentBeReplacedWithParagraph(sequence)) {
            this._replaceEntireContentWithParagraph(writer);
            return;
          }
          if (this._shouldReplaceFirstBlockWithParagraph(selection, sequence)) {
            this.editor.execute("paragraph", {
              selection
            });
            return;
          }
          if (selection.isCollapsed) {
            return;
          }
          let changeCount = 0;
          selection.getFirstRange().getMinimalFlatRanges().forEach((range) => {
            changeCount += count(range.getWalker({
              singleCharacters: true,
              ignoreElementEnd: true,
              shallow: true
            }));
          });
          model.deleteContent(selection, {
            doNotResetEntireContent,
            direction: this.direction
          });
          this._buffer.input(changeCount);
          writer.setSelection(selection);
          this._buffer.unlock();
        });
      }
      /**
      * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
      * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
      * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
      *
      * But, if the user pressed the key in an empty editable for the first time,
      * we want to replace the entire content with a paragraph if:
      *
      * * the current limit element is empty,
      * * the paragraph is allowed in the limit element,
      * * the limit doesn't already have a paragraph inside.
      *
      * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
      *
      * @param sequence A number describing which subsequent delete event it is without the key being released.
      */
      _shouldEntireContentBeReplacedWithParagraph(sequence) {
        if (sequence > 1) {
          return false;
        }
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const limitElement = model.schema.getLimitElement(selection);
        const limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);
        if (!limitElementIsEmpty) {
          return false;
        }
        if (!model.schema.checkChild(limitElement, "paragraph")) {
          return false;
        }
        const limitElementFirstChild = limitElement.getChild(0);
        if (limitElementFirstChild && limitElementFirstChild.is("element", "paragraph")) {
          return false;
        }
        return true;
      }
      /**
      * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
      *
      * @param writer The model writer.
      */
      _replaceEntireContentWithParagraph(writer) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const limitElement = model.schema.getLimitElement(selection);
        const paragraph2 = writer.createElement("paragraph");
        writer.remove(writer.createRangeIn(limitElement));
        writer.insert(paragraph2, limitElement);
        writer.setSelection(paragraph2, 0);
      }
      /**
      * Checks if the selection is inside an empty element that is the first child of the limit element
      * and should be replaced with a paragraph.
      *
      * @param selection The selection.
      * @param sequence A number describing which subsequent delete event it is without the key being released.
      */
      _shouldReplaceFirstBlockWithParagraph(selection, sequence) {
        const model = this.editor.model;
        if (sequence > 1 || this.direction != "backward") {
          return false;
        }
        if (!selection.isCollapsed) {
          return false;
        }
        const position = selection.getFirstPosition();
        const limitElement = model.schema.getLimitElement(position);
        const limitElementFirstChild = limitElement.getChild(0);
        if (position.parent != limitElementFirstChild) {
          return false;
        }
        if (!selection.containsEntireContent(limitElementFirstChild)) {
          return false;
        }
        if (!model.schema.checkChild(limitElement, "paragraph")) {
          return false;
        }
        if (limitElementFirstChild.name == "paragraph") {
          return false;
        }
        return true;
      }
    }
    const DELETE_CHARACTER = "character";
    const DELETE_WORD = "word";
    const DELETE_CODE_POINT = "codePoint";
    const DELETE_SELECTION = "selection";
    const DELETE_BACKWARD = "backward";
    const DELETE_FORWARD = "forward";
    const DELETE_EVENT_TYPES = {
      // --------------------------------------- Backward delete types -----------------------------------------------------
      // This happens in Safari on Mac when some content is selected and Ctrl + K is pressed.
      deleteContent: {
        unit: DELETE_SELECTION,
        // According to the Input Events Level 2 spec, this delete type has no direction
        // but to keep things simple, let's default to backward.
        direction: DELETE_BACKWARD
      },
      // Chrome and Safari on Mac: Backspace or Ctrl + H
      deleteContentBackward: {
        // This kind of deletions must be done on the code point-level instead of target range provided by the DOM beforeinput event.
        // Take for instance "👨‍👩‍👧‍👧", it equals:
        //
        //	* [ "👨", "ZERO WIDTH JOINER", "👩", "ZERO WIDTH JOINER", "👧", "ZERO WIDTH JOINER", "👧" ]
        //	* or simply "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}"
        //
        // The range provided by the browser would cause the entire multi-byte grapheme to disappear while the user
        // intention when deleting backwards ("👨‍👩‍👧‍👧[]", then backspace) is gradual "decomposition" (first to "👨‍👩‍👧‍[]",
        // then to "👨‍👩‍[]", etc.).
        //
        //	* "👨‍👩‍👧‍👧[]" + backward delete (by code point)  -> results in "👨‍👩‍👧[]", removed the last "👧" 👍
        //	* "👨‍👩‍👧‍👧[]" + backward delete (by character)  -> results in "[]", removed the whole grapheme 👎
        //
        // Deleting by code-point is simply a better UX. See "deleteContentForward" to learn more.
        unit: DELETE_CODE_POINT,
        direction: DELETE_BACKWARD
      },
      // On Mac: Option + Backspace.
      // On iOS: Hold the backspace for a while and the whole words will start to disappear.
      deleteWordBackward: {
        unit: DELETE_WORD,
        direction: DELETE_BACKWARD
      },
      // Safari on Mac: Cmd + Backspace
      deleteHardLineBackward: {
        unit: DELETE_SELECTION,
        direction: DELETE_BACKWARD
      },
      // Chrome on Mac: Cmd + Backspace.
      deleteSoftLineBackward: {
        unit: DELETE_SELECTION,
        direction: DELETE_BACKWARD
      },
      // --------------------------------------- Forward delete types -----------------------------------------------------
      // Chrome on Mac: Fn + Backspace or Ctrl + D
      // Safari on Mac: Ctrl + K or Ctrl + D
      deleteContentForward: {
        // Unlike backward delete, this delete must be performed by character instead of by code point, which
        // provides the best UX for working with accented letters.
        // Take, for example "b̂" ("\u0062\u0302", or [ "LATIN SMALL LETTER B", "COMBINING CIRCUMFLEX ACCENT" ]):
        //
        //	* "b̂[]" + backward delete (by code point)  -> results in "b[]", removed the combining mark 👍
        //	* "[]b̂" + forward delete (by code point)   -> results in "[]^", a bare combining mark does that not make sense when alone 👎
        //	* "[]b̂" + forward delete (by character)    -> results in "[]", removed both "b" and the combining mark 👍
        //
        // See: "deleteContentBackward" to learn more.
        unit: DELETE_CHARACTER,
        direction: DELETE_FORWARD
      },
      // On Mac: Fn + Option + Backspace.
      deleteWordForward: {
        unit: DELETE_WORD,
        direction: DELETE_FORWARD
      },
      // Chrome on Mac: Ctrl + K (you have to disable the Link plugin first, though, because it uses the same keystroke)
      // This is weird that it does not work in Safari on Mac despite being listed in the official shortcuts listing
      // on Apple's webpage.
      deleteHardLineForward: {
        unit: DELETE_SELECTION,
        direction: DELETE_FORWARD
      },
      // At this moment there is no known way to trigger this event type but let's keep it for the symmetry with
      // deleteSoftLineBackward.
      deleteSoftLineForward: {
        unit: DELETE_SELECTION,
        direction: DELETE_FORWARD
      }
    };
    class DeleteObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        const document2 = view.document;
        let sequence = 0;
        document2.on("keydown", () => {
          sequence++;
        });
        document2.on("keyup", () => {
          sequence = 0;
        });
        document2.on("beforeinput", (evt, data) => {
          if (!this.isEnabled) {
            return;
          }
          const { targetRanges, domEvent, inputType } = data;
          const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
          if (!deleteEventSpec) {
            return;
          }
          const deleteData = {
            direction: deleteEventSpec.direction,
            unit: deleteEventSpec.unit,
            sequence
          };
          if (deleteData.unit == DELETE_SELECTION) {
            deleteData.selectionToRemove = view.createSelection(targetRanges[0]);
          }
          if (inputType === "deleteContentBackward") {
            if (env.isAndroid) {
              deleteData.sequence = 1;
            }
            if (shouldUseTargetRanges(targetRanges)) {
              deleteData.unit = DELETE_SELECTION;
              deleteData.selectionToRemove = view.createSelection(targetRanges);
            }
          }
          const eventInfo = new BubblingEventInfo(document2, "delete", targetRanges[0]);
          document2.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
          if (eventInfo.stop.called) {
            evt.stop();
          }
        });
        if (env.isBlink) {
          enableChromeWorkaround(this);
        }
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    function enableChromeWorkaround(observer) {
      const view = observer.view;
      const document2 = view.document;
      let pressedKeyCode = null;
      let beforeInputReceived = false;
      document2.on("keydown", (evt, { keyCode }) => {
        pressedKeyCode = keyCode;
        beforeInputReceived = false;
      });
      document2.on("keyup", (evt, { keyCode, domEvent }) => {
        const selection = document2.selection;
        const shouldFireDeleteEvent = observer.isEnabled && keyCode == pressedKeyCode && isDeleteKeyCode(keyCode) && !selection.isCollapsed && !beforeInputReceived;
        pressedKeyCode = null;
        if (shouldFireDeleteEvent) {
          const targetRange = selection.getFirstRange();
          const eventInfo = new BubblingEventInfo(document2, "delete", targetRange);
          const deleteData = {
            unit: DELETE_SELECTION,
            direction: getDeleteDirection(keyCode),
            selectionToRemove: selection
          };
          document2.fire(eventInfo, new DomEventData(view, domEvent, deleteData));
        }
      });
      document2.on("beforeinput", (evt, { inputType }) => {
        const deleteEventSpec = DELETE_EVENT_TYPES[inputType];
        const isMatchingBeforeInput = isDeleteKeyCode(pressedKeyCode) && deleteEventSpec && deleteEventSpec.direction == getDeleteDirection(pressedKeyCode);
        if (isMatchingBeforeInput) {
          beforeInputReceived = true;
        }
      }, {
        priority: "high"
      });
      document2.on("beforeinput", (evt, { inputType, data }) => {
        const shouldIgnoreBeforeInput = pressedKeyCode == keyCodes.delete && inputType == "insertText" && data == "";
        if (shouldIgnoreBeforeInput) {
          evt.stop();
        }
      }, {
        priority: "high"
      });
      function isDeleteKeyCode(keyCode) {
        return keyCode == keyCodes.backspace || keyCode == keyCodes.delete;
      }
      function getDeleteDirection(keyCode) {
        return keyCode == keyCodes.backspace ? DELETE_BACKWARD : DELETE_FORWARD;
      }
    }
    function shouldUseTargetRanges(targetRanges) {
      if (targetRanges.length != 1 || targetRanges[0].isCollapsed) {
        return false;
      }
      const walker = targetRanges[0].getWalker({
        direction: "backward",
        singleCharacters: true,
        ignoreElementEnd: true
      });
      let count2 = 0;
      for (const { nextPosition, item } of walker) {
        if (nextPosition.parent.is("$text")) {
          const data = nextPosition.parent.data;
          const offset = nextPosition.offset;
          if (isInsideSurrogatePair(data, offset) || isInsideCombinedSymbol(data, offset) || isInsideEmojiSequence(data, offset)) {
            continue;
          }
          count2++;
        } else if (item.is("containerElement") || item.is("emptyElement")) {
          count2++;
        }
        if (count2 > 1) {
          return true;
        }
      }
      return false;
    }
    class Delete extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Whether pressing backspace should trigger undo action
        */
        __publicField(this, "_undoOnBackspace");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Delete";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const modelDocument = editor.model.document;
        view.addObserver(DeleteObserver);
        this._undoOnBackspace = false;
        const deleteForwardCommand = new DeleteCommand(editor, "forward");
        editor.commands.add("deleteForward", deleteForwardCommand);
        editor.commands.add("forwardDelete", deleteForwardCommand);
        editor.commands.add("delete", new DeleteCommand(editor, "backward"));
        this.listenTo(viewDocument, "delete", (evt, data) => {
          if (!viewDocument.isComposing) {
            data.preventDefault();
          }
          const { direction, sequence, selectionToRemove, unit } = data;
          const commandName = direction === "forward" ? "deleteForward" : "delete";
          const commandData = {
            sequence
          };
          if (unit == "selection") {
            const modelRanges = Array.from(selectionToRemove.getRanges()).map((viewRange) => {
              return editor.editing.mapper.toModelRange(viewRange);
            });
            commandData.selection = editor.model.createSelection(modelRanges);
          } else {
            commandData.unit = unit;
          }
          editor.execute(commandName, commandData);
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        if (this.editor.plugins.has("UndoEditing")) {
          this.listenTo(viewDocument, "delete", (evt, data) => {
            if (this._undoOnBackspace && data.direction == "backward" && data.sequence == 1 && data.unit == "codePoint") {
              this._undoOnBackspace = false;
              editor.execute("undo");
              data.preventDefault();
              evt.stop();
            }
          }, {
            context: "$capture"
          });
          this.listenTo(modelDocument, "change", () => {
            this._undoOnBackspace = false;
          });
        }
      }
      /**
      * If the next user action after calling this method is pressing backspace, it would undo the last change.
      *
      * Requires {@link module:undo/undoediting~UndoEditing} plugin. If not loaded, does nothing.
      */
      requestUndoOnBackspace() {
        if (this.editor.plugins.has("UndoEditing")) {
          this._undoOnBackspace = true;
        }
      }
    }
    class Typing extends Plugin {
      static get requires() {
        return [
          Input,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Typing";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getLastTextLine(range, model) {
      let start = range.start;
      const text2 = Array.from(range.getWalker({
        ignoreElementEnd: false
      })).reduce((rangeText, { item }) => {
        if (!(item.is("$text") || item.is("$textProxy"))) {
          start = model.createPositionAfter(item);
          return "";
        }
        return rangeText + item.data;
      }, "");
      return {
        text: text2,
        range: model.createRange(start, range.end)
      };
    }
    class TextWatcher extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a text watcher instance.
      *
      * @param testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
      */
      constructor(model, testCallback) {
        super();
        /**
        * The editor's model.
        */
        __publicField(this, "model");
        /**
        * The function used to match the text.
        *
        * The test callback can return 3 values:
        *
        * * `false` if there is no match,
        * * `true` if there is a match,
        * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.
        */
        __publicField(this, "testCallback");
        /**
        * Whether there is a match currently.
        */
        __publicField(this, "_hasMatch");
        this.model = model;
        this.testCallback = testCallback;
        this._hasMatch = false;
        this.set("isEnabled", true);
        this.on("change:isEnabled", () => {
          if (this.isEnabled) {
            this._startListening();
          } else {
            this.stopListening(model.document.selection);
            this.stopListening(model.document);
          }
        });
        this._startListening();
      }
      /**
      * Flag indicating whether there is a match currently.
      */
      get hasMatch() {
        return this._hasMatch;
      }
      /**
      * Starts listening to the editor for typing and selection events.
      */
      _startListening() {
        const model = this.model;
        const document2 = model.document;
        this.listenTo(document2.selection, "change:range", (evt, { directChange }) => {
          if (!directChange) {
            return;
          }
          if (!document2.selection.isCollapsed) {
            if (this.hasMatch) {
              this.fire("unmatched");
              this._hasMatch = false;
            }
            return;
          }
          this._evaluateTextBeforeSelection("selection");
        });
        this.listenTo(document2, "change:data", (evt, batch) => {
          if (batch.isUndo || !batch.isLocal) {
            return;
          }
          this._evaluateTextBeforeSelection("data", {
            batch
          });
        });
      }
      /**
      * Checks the editor content for matched text.
      *
      * @fires matched:data
      * @fires matched:selection
      * @fires unmatched
      *
      * @param suffix A suffix used for generating the event name.
      * @param data Data object for event.
      */
      _evaluateTextBeforeSelection(suffix, data = {}) {
        const model = this.model;
        const document2 = model.document;
        const selection = document2.selection;
        const rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);
        const { text: text2, range } = getLastTextLine(rangeBeforeSelection, model);
        const testResult = this.testCallback(text2);
        if (!testResult && this.hasMatch) {
          this.fire("unmatched");
        }
        this._hasMatch = !!testResult;
        if (testResult) {
          const eventData = Object.assign(data, {
            text: text2,
            range
          });
          if (typeof testResult == "object") {
            Object.assign(eventData, testResult);
          }
          this.fire(`matched:${suffix}`, eventData);
        }
      }
    }
    class TwoStepCaretMovement extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * A set of attributes to handle.
        */
        __publicField(this, "attributes");
        /**
        * The current UID of the overridden gravity, as returned by
        * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
        */
        __publicField(this, "_overrideUid");
        /**
        * A flag indicating that the automatic gravity restoration should not happen upon the next
        * gravity restoration.
        * {@link module:engine/model/selection~Selection#event:change:range} event.
        */
        __publicField(this, "_isNextGravityRestorationSkipped", false);
        this.attributes = /* @__PURE__ */ new Set();
        this._overrideUid = null;
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TwoStepCaretMovement";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const locale = editor.locale;
        const modelSelection = model.document.selection;
        this.listenTo(view.document, "arrowKey", (evt, data) => {
          if (!modelSelection.isCollapsed) {
            return;
          }
          if (data.shiftKey || data.altKey || data.ctrlKey) {
            return;
          }
          const arrowRightPressed = data.keyCode == keyCodes.arrowright;
          const arrowLeftPressed = data.keyCode == keyCodes.arrowleft;
          if (!arrowRightPressed && !arrowLeftPressed) {
            return;
          }
          const contentDirection = locale.contentLanguageDirection;
          let isMovementHandled = false;
          if (contentDirection === "ltr" && arrowRightPressed || contentDirection === "rtl" && arrowLeftPressed) {
            isMovementHandled = this._handleForwardMovement(data);
          } else {
            isMovementHandled = this._handleBackwardMovement(data);
          }
          if (isMovementHandled === true) {
            evt.stop();
          }
        }, {
          context: "$text",
          priority: "highest"
        });
        this.listenTo(modelSelection, "change:range", (evt, data) => {
          if (this._isNextGravityRestorationSkipped) {
            this._isNextGravityRestorationSkipped = false;
            return;
          }
          if (!this._isGravityOverridden) {
            return;
          }
          if (!data.directChange && isBetweenDifferentAttributes(modelSelection.getFirstPosition(), this.attributes)) {
            return;
          }
          this._restoreGravity();
        });
        this._enableClickingAfterNode();
        this._enableInsertContentSelectionAttributesFixer();
        this._handleDeleteContentAfterNode();
      }
      /**
      * Registers a given attribute for the two-step caret movement.
      *
      * @param attribute Name of the attribute to handle.
      */
      registerAttribute(attribute) {
        this.attributes.add(attribute);
      }
      /**
      * Updates the document selection and the view according to the two–step caret movement state
      * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
      *
      * @param data Data of the key press.
      * @returns `true` when the handler prevented caret movement.
      */
      _handleForwardMovement(data) {
        const attributes = this.attributes;
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = selection.getFirstPosition();
        if (this._isGravityOverridden) {
          return false;
        }
        if (position.isAtStart && hasAnyAttribute$1(selection, attributes)) {
          return false;
        }
        if (isBetweenDifferentAttributes(position, attributes)) {
          preventCaretMovement(data);
          if (hasAnyAttribute$1(selection, attributes) && isBetweenDifferentAttributes(position, attributes, true)) {
            clearSelectionAttributes(model, attributes);
          } else {
            this._overrideGravity();
          }
          return true;
        }
        return false;
      }
      /**
      * Updates the document selection and the view according to the two–step caret movement state
      * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
      *
      * @param data Data of the key press.
      * @returns `true` when the handler prevented caret movement
      */
      _handleBackwardMovement(data) {
        const attributes = this.attributes;
        const model = this.editor.model;
        const selection = model.document.selection;
        const position = selection.getFirstPosition();
        if (this._isGravityOverridden) {
          preventCaretMovement(data);
          this._restoreGravity();
          if (isBetweenDifferentAttributes(position, attributes, true)) {
            clearSelectionAttributes(model, attributes);
          } else {
            setSelectionAttributesFromTheNodeBefore(model, attributes, position);
          }
          return true;
        } else {
          if (position.isAtStart) {
            if (hasAnyAttribute$1(selection, attributes)) {
              preventCaretMovement(data);
              setSelectionAttributesFromTheNodeBefore(model, attributes, position);
              return true;
            }
            return false;
          }
          if (!hasAnyAttribute$1(selection, attributes) && isBetweenDifferentAttributes(position, attributes, true)) {
            preventCaretMovement(data);
            setSelectionAttributesFromTheNodeBefore(model, attributes, position);
            return true;
          }
          if (isStepAfterAnyAttributeBoundary(position, attributes)) {
            if (position.isAtEnd && !hasAnyAttribute$1(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
              preventCaretMovement(data);
              setSelectionAttributesFromTheNodeBefore(model, attributes, position);
              return true;
            }
            this._isNextGravityRestorationSkipped = true;
            this._overrideGravity();
            return false;
          }
        }
        return false;
      }
      /**
      * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
      * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a 2-step node
      * if clicked at the beginning/ending of the 2-step node.
      *
      * The purpose of this action is to allow typing around the 2-step node directly after a click.
      *
      * See https://github.com/ckeditor/ckeditor5/issues/1016.
      */
      _enableClickingAfterNode() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const document2 = editor.editing.view.document;
        editor.editing.view.addObserver(MouseObserver);
        let clicked = false;
        this.listenTo(document2, "mousedown", () => {
          clicked = true;
        });
        this.listenTo(document2, "selectionChange", () => {
          const attributes = this.attributes;
          if (!clicked) {
            return;
          }
          clicked = false;
          if (!selection.isCollapsed) {
            return;
          }
          if (!hasAnyAttribute$1(selection, attributes)) {
            return;
          }
          const position = selection.getFirstPosition();
          if (!isBetweenDifferentAttributes(position, attributes)) {
            return;
          }
          if (position.isAtStart || isBetweenDifferentAttributes(position, attributes, true)) {
            clearSelectionAttributes(model, attributes);
          } else if (!this._isGravityOverridden) {
            this._overrideGravity();
          }
        });
      }
      /**
      * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
      * selection attributes if the selection is at the end of a two-step node after inserting the content.
      *
      * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
      * two-step attribute of the selection, and they can type a "clean" (`linkHref`–less) text right away.
      *
      * See https://github.com/ckeditor/ckeditor5/issues/6053.
      */
      _enableInsertContentSelectionAttributesFixer() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const attributes = this.attributes;
        this.listenTo(model, "insertContent", () => {
          const position = selection.getFirstPosition();
          if (hasAnyAttribute$1(selection, attributes) && isBetweenDifferentAttributes(position, attributes)) {
            clearSelectionAttributes(model, attributes);
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Starts listening to {@link module:engine/model/model~Model#deleteContent} and checks whether
      * removing a content right after the tow-step attribute.
      *
      * If so, the selection should not preserve the two-step attribute. However, if
      * the {@link module:typing/twostepcaretmovement~TwoStepCaretMovement} plugin is active and
      * the selection has the two-step attribute due to overridden gravity (at the end), the two-step attribute should stay untouched.
      *
      * The purpose of this action is to allow removing the link text and keep the selection outside the link.
      *
      * See https://github.com/ckeditor/ckeditor5/issues/7521.
      */
      _handleDeleteContentAfterNode() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const view = editor.editing.view;
        let isBackspace = false;
        let shouldPreserveAttributes = false;
        this.listenTo(view.document, "delete", (evt, data) => {
          isBackspace = data.direction === "backward";
        }, {
          priority: "high"
        });
        this.listenTo(model, "deleteContent", () => {
          if (!isBackspace) {
            return;
          }
          const position = selection.getFirstPosition();
          shouldPreserveAttributes = hasAnyAttribute$1(selection, this.attributes) && !isStepAfterAnyAttributeBoundary(position, this.attributes);
        }, {
          priority: "high"
        });
        this.listenTo(model, "deleteContent", () => {
          if (!isBackspace) {
            return;
          }
          isBackspace = false;
          if (shouldPreserveAttributes) {
            return;
          }
          editor.model.enqueueChange(() => {
            const position = selection.getFirstPosition();
            if (hasAnyAttribute$1(selection, this.attributes) && isBetweenDifferentAttributes(position, this.attributes)) {
              if (position.isAtStart || isBetweenDifferentAttributes(position, this.attributes, true)) {
                clearSelectionAttributes(model, this.attributes);
              } else if (!this._isGravityOverridden) {
                this._overrideGravity();
              }
            }
          });
        }, {
          priority: "low"
        });
      }
      /**
      * `true` when the gravity is overridden for the plugin.
      */
      get _isGravityOverridden() {
        return !!this._overrideUid;
      }
      /**
      * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
      * and stores the information about this fact in the {@link #_overrideUid}.
      *
      * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
      */
      _overrideGravity() {
        this._overrideUid = this.editor.model.change((writer) => {
          return writer.overrideSelectionGravity();
        });
      }
      /**
      * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
      *
      * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
      */
      _restoreGravity() {
        this.editor.model.change((writer) => {
          writer.restoreSelectionGravity(this._overrideUid);
          this._overrideUid = null;
        });
      }
    }
    function hasAnyAttribute$1(selection, attributes) {
      for (const observedAttribute of attributes) {
        if (selection.hasAttribute(observedAttribute)) {
          return true;
        }
      }
      return false;
    }
    function setSelectionAttributesFromTheNodeBefore(model, attributes, position) {
      const nodeBefore = position.nodeBefore;
      model.change((writer) => {
        if (nodeBefore) {
          const attributes2 = [];
          const isInlineObject = model.schema.isObject(nodeBefore) && model.schema.isInline(nodeBefore);
          for (const [key, value] of nodeBefore.getAttributes()) {
            if (model.schema.checkAttribute("$text", key) && (!isInlineObject || model.schema.getAttributeProperties(key).copyFromObject !== false)) {
              attributes2.push([
                key,
                value
              ]);
            }
          }
          writer.setSelectionAttribute(attributes2);
        } else {
          writer.removeSelectionAttribute(attributes);
        }
      });
    }
    function clearSelectionAttributes(model, attributes) {
      model.change((writer) => {
        writer.removeSelectionAttribute(attributes);
      });
    }
    function preventCaretMovement(data) {
      data.preventDefault();
    }
    function isStepAfterAnyAttributeBoundary(position, attributes) {
      const positionBefore = position.getShiftedBy(-1);
      return isBetweenDifferentAttributes(positionBefore, attributes);
    }
    function isBetweenDifferentAttributes(position, attributes, isStrict = false) {
      const { nodeBefore, nodeAfter } = position;
      for (const observedAttribute of attributes) {
        const attrBefore = nodeBefore ? nodeBefore.getAttribute(observedAttribute) : void 0;
        const attrAfter = nodeAfter ? nodeAfter.getAttribute(observedAttribute) : void 0;
        if (isStrict && (attrBefore === void 0 || attrAfter === void 0)) {
          continue;
        }
        if (attrAfter !== attrBefore) {
          return true;
        }
      }
      return false;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function findAttributeRange(position, attributeName, value, model) {
      return model.createRange(findAttributeRangeBound(position, attributeName, value, true, model), findAttributeRangeBound(position, attributeName, value, false, model));
    }
    function findAttributeRangeBound(position, attributeName, value, lookBack, model) {
      let node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);
      let lastNode = null;
      while (node && node.getAttribute(attributeName) == value) {
        lastNode = node;
        node = lookBack ? node.previousSibling : node.nextSibling;
      }
      return lastNode ? model.createPositionAt(lastNode, lookBack ? "before" : "after") : position;
    }
    function inlineHighlight(editor, attributeName, tagName, className) {
      const view = editor.editing.view;
      const highlightedElements = /* @__PURE__ */ new Set();
      view.document.registerPostFixer((writer) => {
        const selection = editor.model.document.selection;
        let changed = false;
        if (selection.hasAttribute(attributeName)) {
          const modelRange = findAttributeRange(selection.getFirstPosition(), attributeName, selection.getAttribute(attributeName), editor.model);
          const viewRange = editor.editing.mapper.toViewRange(modelRange);
          for (const item of viewRange.getItems()) {
            if (item.is("element", tagName) && !item.hasClass(className)) {
              writer.addClass(className, item);
              highlightedElements.add(item);
              changed = true;
            }
          }
        }
        return changed;
      });
      editor.conversion.for("editingDowncast").add((dispatcher) => {
        dispatcher.on("insert", removeHighlight2, {
          priority: "highest"
        });
        dispatcher.on("remove", removeHighlight2, {
          priority: "highest"
        });
        dispatcher.on("attribute", removeHighlight2, {
          priority: "highest"
        });
        dispatcher.on("selection", removeHighlight2, {
          priority: "highest"
        });
        function removeHighlight2() {
          view.change((writer) => {
            for (const item of highlightedElements.values()) {
              writer.removeClass(className, item);
              highlightedElements.delete(item);
            }
          });
        }
      });
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class AttributeCommand extends Command {
      /**
      * @param attributeKey Attribute that will be set by the command.
      */
      constructor(editor, attributeKey) {
        super(editor);
        /**
        * The attribute that will be set by the command.
        */
        __publicField(this, "attributeKey");
        this.attributeKey = attributeKey;
      }
      /**
      * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
      */
      refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = this._getValueFromFirstAllowedNode();
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
      }
      /**
      * Executes the command &ndash; applies the attribute to the selection or removes it from the selection.
      *
      * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
      *
      * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
      *
      * * If the selection is on a range, the command applies the attribute to all nodes in that range
      * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
      * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
      * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
      * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
      * that the selection inherits all attributes from a node if it is in an empty node).
      *
      * @fires execute
      * @param options Command options.
      * @param options.forceValue If set, it will force the command behavior. If `true`,
      * the command will apply the attribute, otherwise the command will remove the attribute.
      * If not set, the command will look for its current value to decide what it should do.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const doc = model.document;
        const selection = doc.selection;
        const value = options.forceValue === void 0 ? !this.value : options.forceValue;
        model.change((writer) => {
          if (selection.isCollapsed) {
            if (value) {
              writer.setSelectionAttribute(this.attributeKey, true);
            } else {
              writer.removeSelectionAttribute(this.attributeKey);
            }
          } else {
            const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
            for (const range of ranges) {
              if (value) {
                writer.setAttribute(this.attributeKey, value, range);
              } else {
                writer.removeAttribute(this.attributeKey, range);
              }
            }
          }
        });
      }
      /**
      * Checks the attribute value of the first node in the selection that allows the attribute.
      * For the collapsed selection returns the selection attribute.
      *
      * @returns The attribute value.
      */
      _getValueFromFirstAllowedNode() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        if (selection.isCollapsed) {
          return selection.hasAttribute(this.attributeKey);
        }
        for (const range of selection.getRanges()) {
          for (const item of range.getItems()) {
            if (schema.checkAttribute(item, this.attributeKey)) {
              return item.hasAttribute(this.attributeKey);
            }
          }
        }
        return false;
      }
    }
    const BOLD$1 = "bold";
    class BoldEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BoldEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.model.schema.extend("$text", {
          allowAttributes: BOLD$1
        });
        editor.model.schema.setAttributeProperties(BOLD$1, {
          isFormatting: true,
          copyOnEnter: true
        });
        editor.conversion.attributeToElement({
          model: BOLD$1,
          view: "strong",
          upcastAlso: [
            "b",
            (viewElement) => {
              const fontWeight = viewElement.getStyle("font-weight");
              if (!fontWeight) {
                return null;
              }
              if (fontWeight == "bold" || Number(fontWeight) >= 600) {
                return {
                  name: true,
                  styles: [
                    "font-weight"
                  ]
                };
              }
              return null;
            }
          ]
        });
        editor.commands.add(BOLD$1, new AttributeCommand(editor, BOLD$1));
        editor.keystrokes.set("CTRL+B", BOLD$1);
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Bold text"),
              keystroke: "CTRL+B"
            }
          ]
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getButtonCreator({ editor, commandName, plugin, icon, label, keystroke }) {
      return (ButtonClass) => {
        const command = editor.commands.get(commandName);
        const view = new ButtonClass(editor.locale);
        view.set({
          label,
          icon,
          keystroke,
          isToggleable: true
        });
        view.bind("isEnabled").to(command, "isEnabled");
        plugin.listenTo(view, "execute", () => {
          editor.execute(commandName);
          editor.editing.view.focus();
        });
        return view;
      };
    }
    const BOLD = "bold";
    class BoldUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BoldUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const command = editor.commands.get(BOLD);
        const createButton = getButtonCreator({
          editor,
          commandName: BOLD,
          plugin: this,
          icon: icons.bold,
          label: t("Bold"),
          keystroke: "CTRL+B"
        });
        editor.ui.componentFactory.add(BOLD, () => {
          const buttonView = createButton(ButtonView);
          buttonView.set({
            tooltip: true
          });
          buttonView.bind("isOn").to(command, "value");
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:" + BOLD, () => {
          return createButton(MenuBarMenuListItemButtonView);
        });
      }
    }
    class Bold extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          BoldEditing,
          BoldUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Bold";
      }
    }
    const CODE$1 = "code";
    const HIGHLIGHT_CLASS$1 = "ck-code_selected";
    class CodeEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CodeEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TwoStepCaretMovement
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.model.schema.extend("$text", {
          allowAttributes: CODE$1
        });
        editor.model.schema.setAttributeProperties(CODE$1, {
          isFormatting: true,
          copyOnEnter: false
        });
        editor.conversion.attributeToElement({
          model: CODE$1,
          view: "code",
          upcastAlso: {
            styles: {
              "word-wrap": "break-word"
            }
          }
        });
        editor.commands.add(CODE$1, new AttributeCommand(editor, CODE$1));
        editor.plugins.get(TwoStepCaretMovement).registerAttribute(CODE$1);
        inlineHighlight(editor, CODE$1, "code", HIGHLIGHT_CLASS$1);
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Move out of an inline code style"),
              keystroke: [
                [
                  "arrowleft",
                  "arrowleft"
                ],
                [
                  "arrowright",
                  "arrowright"
                ]
              ]
            }
          ]
        });
      }
    }
    var codeIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>';
    const CODE = "code";
    class CodeUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CodeUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
          editor,
          commandName: CODE,
          plugin: this,
          icon: codeIcon,
          label: t("Code")
        });
        editor.ui.componentFactory.add(CODE, () => {
          const buttonView = createButton(ButtonView);
          const command = editor.commands.get(CODE);
          buttonView.set({
            tooltip: true
          });
          buttonView.bind("isOn").to(command, "value");
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:" + CODE, () => {
          return createButton(MenuBarMenuListItemButtonView);
        });
      }
    }
    class Code extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          CodeEditing,
          CodeUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Code";
      }
    }
    const ITALIC$1 = "italic";
    class ItalicEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ItalicEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.model.schema.extend("$text", {
          allowAttributes: ITALIC$1
        });
        editor.model.schema.setAttributeProperties(ITALIC$1, {
          isFormatting: true,
          copyOnEnter: true
        });
        editor.conversion.attributeToElement({
          model: ITALIC$1,
          view: "i",
          upcastAlso: [
            "em",
            {
              styles: {
                "font-style": "italic"
              }
            }
          ]
        });
        editor.commands.add(ITALIC$1, new AttributeCommand(editor, ITALIC$1));
        editor.keystrokes.set("CTRL+I", ITALIC$1);
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Italic text"),
              keystroke: "CTRL+I"
            }
          ]
        });
      }
    }
    var italicIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>';
    const ITALIC = "italic";
    class ItalicUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ItalicUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const command = editor.commands.get(ITALIC);
        const t = editor.locale.t;
        const createButton = getButtonCreator({
          editor,
          commandName: ITALIC,
          plugin: this,
          icon: italicIcon,
          keystroke: "CTRL+I",
          label: t("Italic")
        });
        editor.ui.componentFactory.add(ITALIC, () => {
          const buttonView = createButton(ButtonView);
          buttonView.set({
            tooltip: true
          });
          buttonView.bind("isOn").to(command, "value");
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:" + ITALIC, () => {
          return createButton(MenuBarMenuListItemButtonView);
        });
      }
    }
    class Italic extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ItalicEditing,
          ItalicUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Italic";
      }
    }
    const STRIKETHROUGH$1 = "strikethrough";
    class StrikethroughEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "StrikethroughEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.model.schema.extend("$text", {
          allowAttributes: STRIKETHROUGH$1
        });
        editor.model.schema.setAttributeProperties(STRIKETHROUGH$1, {
          isFormatting: true,
          copyOnEnter: true
        });
        editor.conversion.attributeToElement({
          model: STRIKETHROUGH$1,
          view: "s",
          upcastAlso: [
            "del",
            "strike",
            {
              styles: {
                "text-decoration": "line-through"
              }
            }
          ]
        });
        editor.commands.add(STRIKETHROUGH$1, new AttributeCommand(editor, STRIKETHROUGH$1));
        editor.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Strikethrough text"),
              keystroke: "CTRL+SHIFT+X"
            }
          ]
        });
      }
    }
    var strikethroughIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
    const STRIKETHROUGH = "strikethrough";
    class StrikethroughUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "StrikethroughUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.locale.t;
        const createButton = getButtonCreator({
          editor,
          commandName: STRIKETHROUGH,
          plugin: this,
          icon: strikethroughIcon,
          keystroke: "CTRL+SHIFT+X",
          label: t("Strikethrough")
        });
        editor.ui.componentFactory.add(STRIKETHROUGH, () => {
          const buttonView = createButton(ButtonView);
          const command = editor.commands.get(STRIKETHROUGH);
          buttonView.set({
            tooltip: true
          });
          buttonView.bind("isOn").to(command, "value");
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:" + STRIKETHROUGH, () => {
          return createButton(MenuBarMenuListItemButtonView);
        });
      }
    }
    class Strikethrough extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          StrikethroughEditing,
          StrikethroughUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Strikethrough";
      }
    }
    const UNDERLINE$1 = "underline";
    class UnderlineEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "UnderlineEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.model.schema.extend("$text", {
          allowAttributes: UNDERLINE$1
        });
        editor.model.schema.setAttributeProperties(UNDERLINE$1, {
          isFormatting: true,
          copyOnEnter: true
        });
        editor.conversion.attributeToElement({
          model: UNDERLINE$1,
          view: "u",
          upcastAlso: {
            styles: {
              "text-decoration": "underline"
            }
          }
        });
        editor.commands.add(UNDERLINE$1, new AttributeCommand(editor, UNDERLINE$1));
        editor.keystrokes.set("CTRL+U", "underline");
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Underline text"),
              keystroke: "CTRL+U"
            }
          ]
        });
      }
    }
    var underlineIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
    const UNDERLINE = "underline";
    class UnderlineUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "UnderlineUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const command = editor.commands.get(UNDERLINE);
        const t = editor.locale.t;
        const createButton = getButtonCreator({
          editor,
          commandName: UNDERLINE,
          plugin: this,
          icon: underlineIcon,
          label: t("Underline"),
          keystroke: "CTRL+U"
        });
        editor.ui.componentFactory.add(UNDERLINE, () => {
          const buttonView = createButton(ButtonView);
          buttonView.set({
            tooltip: true
          });
          buttonView.bind("isOn").to(command, "value");
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:" + UNDERLINE, () => {
          return createButton(MenuBarMenuListItemButtonView);
        });
      }
    }
    class Underline extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          UnderlineEditing,
          UnderlineUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Underline";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function* getCopyOnEnterAttributes(schema, allAttributes) {
      for (const attribute of allAttributes) {
        if (attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter) {
          yield attribute;
        }
      }
    }
    class EnterCommand extends Command {
      /**
      * @inheritDoc
      */
      execute() {
        this.editor.model.change((writer) => {
          this.enterBlock(writer);
          this.fire("afterExecute", {
            writer
          });
        });
      }
      /**
      * Splits a block where the document selection is placed, in the way how the <kbd>Enter</kbd> key is expected to work:
      *
      * ```
      * <p>Foo[]bar</p>   ->   <p>Foo</p><p>[]bar</p>
      * <p>Foobar[]</p>   ->   <p>Foobar</p><p>[]</p>
      * <p>Fo[ob]ar</p>   ->   <p>Fo</p><p>[]ar</p>
      * ```
      *
      * In some cases, the split will not happen:
      *
      * ```
      * // The selection parent is a limit element:
      * <figcaption>A[bc]d</figcaption>   ->   <figcaption>A[]d</figcaption>
      *
      * // The selection spans over multiple elements:
      * <h>x[x</h><p>y]y<p>   ->   <h>x</h><p>[]y</p>
      * ```
      *
      * @param writer Writer to use when performing the enter action.
      * @returns Boolean indicating if the block was split.
      */
      enterBlock(writer) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const schema = model.schema;
        const isSelectionEmpty = selection.isCollapsed;
        const range = selection.getFirstRange();
        const startElement = range.start.parent;
        const endElement = range.end.parent;
        if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
          if (!isSelectionEmpty && startElement == endElement) {
            model.deleteContent(selection);
          }
          return false;
        }
        if (isSelectionEmpty) {
          const attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());
          splitBlock(writer, range.start);
          writer.setSelectionAttribute(attributesToCopy);
          return true;
        } else {
          const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
          const isContainedWithinOneElement = startElement == endElement;
          model.deleteContent(selection, {
            leaveUnmerged
          });
          if (leaveUnmerged) {
            if (isContainedWithinOneElement) {
              splitBlock(writer, selection.focus);
              return true;
            } else {
              writer.setSelection(endElement, 0);
            }
          }
        }
        return false;
      }
    }
    function splitBlock(writer, splitPos) {
      writer.split(splitPos);
      writer.setSelection(splitPos.parent.nextSibling, 0);
    }
    const ENTER_EVENT_TYPES = {
      insertParagraph: {
        isSoft: false
      },
      insertLineBreak: {
        isSoft: true
      }
    };
    class EnterObserver extends Observer {
      /**
      * @inheritDoc
      */
      constructor(view) {
        super(view);
        const doc = this.document;
        let shiftPressed = false;
        doc.on("keydown", (evt, data) => {
          shiftPressed = data.shiftKey;
        });
        doc.on("beforeinput", (evt, data) => {
          if (!this.isEnabled) {
            return;
          }
          let inputType = data.inputType;
          if (env.isSafari && shiftPressed && inputType == "insertParagraph") {
            inputType = "insertLineBreak";
          }
          const domEvent = data.domEvent;
          const enterEventSpec = ENTER_EVENT_TYPES[inputType];
          if (!enterEventSpec) {
            return;
          }
          const event = new BubblingEventInfo(doc, "enter", data.targetRanges[0]);
          doc.fire(event, new DomEventData(view, domEvent, {
            isSoft: enterEventSpec.isSoft
          }));
          if (event.stop.called) {
            evt.stop();
          }
        });
      }
      /**
      * @inheritDoc
      */
      observe() {
      }
      /**
      * @inheritDoc
      */
      stopObserving() {
      }
    }
    class Enter extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Enter";
      }
      init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const t = this.editor.t;
        view.addObserver(EnterObserver);
        editor.commands.add("enter", new EnterCommand(editor));
        this.listenTo(viewDocument, "enter", (evt, data) => {
          if (!viewDocument.isComposing) {
            data.preventDefault();
          }
          if (data.isSoft) {
            return;
          }
          editor.execute("enter");
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Insert a hard break (a new paragraph)"),
              keystroke: "Enter"
            }
          ]
        });
      }
    }
    class ShiftEnterCommand extends Command {
      /**
      * @inheritDoc
      */
      execute() {
        const model = this.editor.model;
        const doc = model.document;
        model.change((writer) => {
          softBreakAction(model, writer, doc.selection);
          this.fire("afterExecute", {
            writer
          });
        });
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.isEnabled = isEnabled(model.schema, doc.selection);
      }
    }
    function isEnabled(schema, selection) {
      if (selection.rangeCount > 1) {
        return false;
      }
      const anchorPos = selection.anchor;
      if (!anchorPos || !schema.checkChild(anchorPos, "softBreak")) {
        return false;
      }
      const range = selection.getFirstRange();
      const startElement = range.start.parent;
      const endElement = range.end.parent;
      if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
        return false;
      }
      return true;
    }
    function softBreakAction(model, writer, selection) {
      const isSelectionEmpty = selection.isCollapsed;
      const range = selection.getFirstRange();
      const startElement = range.start.parent;
      const endElement = range.end.parent;
      const isContainedWithinOneElement = startElement == endElement;
      if (isSelectionEmpty) {
        const attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());
        insertBreak(model, writer, range.end);
        writer.removeSelectionAttribute(selection.getAttributeKeys());
        writer.setSelectionAttribute(attributesToCopy);
      } else {
        const leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
        model.deleteContent(selection, {
          leaveUnmerged
        });
        if (isContainedWithinOneElement) {
          insertBreak(model, writer, selection.focus);
        } else {
          if (leaveUnmerged) {
            writer.setSelection(endElement, 0);
          }
        }
      }
    }
    function insertBreak(model, writer, position) {
      const breakLineElement = writer.createElement("softBreak");
      model.insertContent(breakLineElement, position);
      writer.setSelection(breakLineElement, "after");
    }
    function isInsideLimitElement(element, schema) {
      if (element.is("rootElement")) {
        return false;
      }
      return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);
    }
    class ShiftEnter extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ShiftEnter";
      }
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const t = this.editor.t;
        schema.register("softBreak", {
          allowWhere: "$text",
          isInline: true
        });
        conversion.for("upcast").elementToElement({
          model: "softBreak",
          view: "br"
        });
        conversion.for("downcast").elementToElement({
          model: "softBreak",
          view: (modelElement, { writer }) => writer.createEmptyElement("br")
        });
        view.addObserver(EnterObserver);
        editor.commands.add("shiftEnter", new ShiftEnterCommand(editor));
        this.listenTo(viewDocument, "enter", (evt, data) => {
          if (!viewDocument.isComposing) {
            data.preventDefault();
          }
          if (!data.isSoft) {
            return;
          }
          editor.execute("shiftEnter");
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Insert a soft break (a <code>&lt;br&gt;</code> element)"),
              keystroke: "Shift+Enter"
            }
          ]
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class BlockQuoteCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Executes the command. When the command {@link #value is on}, all top-most block quotes within
      * the selection will be removed. If it is off, all selected blocks will be wrapped with
      * a block quote.
      *
      * @fires execute
      * @param options Command options.
      * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a block quote,
      * otherwise the command will remove the block quote. If not set, the command will act basing on its current value.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        const value = options.forceValue === void 0 ? !this.value : options.forceValue;
        model.change((writer) => {
          if (!value) {
            this._removeQuote(writer, blocks.filter(findQuote));
          } else {
            const blocksToQuote = blocks.filter((block2) => {
              return findQuote(block2) || checkCanBeQuoted(schema, block2);
            });
            this._applyQuote(writer, blocksToQuote);
          }
        });
      }
      /**
      * Checks the command's {@link #value}.
      */
      _getValue() {
        const selection = this.editor.model.document.selection;
        const firstBlock = first(selection.getSelectedBlocks());
        return !!(firstBlock && findQuote(firstBlock));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        if (this.value) {
          return true;
        }
        const selection = this.editor.model.document.selection;
        const schema = this.editor.model.schema;
        const firstBlock = first(selection.getSelectedBlocks());
        if (!firstBlock) {
          return false;
        }
        return checkCanBeQuoted(schema, firstBlock);
      }
      /**
      * Removes the quote from given blocks.
      *
      * If blocks which are supposed to be "unquoted" are in the middle of a quote,
      * start it or end it, then the quote will be split (if needed) and the blocks
      * will be moved out of it, so other quoted blocks remained quoted.
      */
      _removeQuote(writer, blocks) {
        getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange) => {
          if (groupRange.start.isAtStart && groupRange.end.isAtEnd) {
            writer.unwrap(groupRange.start.parent);
            return;
          }
          if (groupRange.start.isAtStart) {
            const positionBefore = writer.createPositionBefore(groupRange.start.parent);
            writer.move(groupRange, positionBefore);
            return;
          }
          if (!groupRange.end.isAtEnd) {
            writer.split(groupRange.end);
          }
          const positionAfter = writer.createPositionAfter(groupRange.end.parent);
          writer.move(groupRange, positionAfter);
        });
      }
      /**
      * Applies the quote to given blocks.
      */
      _applyQuote(writer, blocks) {
        const quotesToMerge = [];
        getRangesOfBlockGroups(writer, blocks).reverse().forEach((groupRange) => {
          let quote2 = findQuote(groupRange.start);
          if (!quote2) {
            quote2 = writer.createElement("blockQuote");
            writer.wrap(groupRange, quote2);
          }
          quotesToMerge.push(quote2);
        });
        quotesToMerge.reverse().reduce((currentQuote, nextQuote) => {
          if (currentQuote.nextSibling == nextQuote) {
            writer.merge(writer.createPositionAfter(currentQuote));
            return currentQuote;
          }
          return nextQuote;
        });
      }
    }
    function findQuote(elementOrPosition) {
      return elementOrPosition.parent.name == "blockQuote" ? elementOrPosition.parent : null;
    }
    function getRangesOfBlockGroups(writer, blocks) {
      let startPosition;
      let i = 0;
      const ranges = [];
      while (i < blocks.length) {
        const block2 = blocks[i];
        const nextBlock = blocks[i + 1];
        if (!startPosition) {
          startPosition = writer.createPositionBefore(block2);
        }
        if (!nextBlock || block2.nextSibling != nextBlock) {
          ranges.push(writer.createRange(startPosition, writer.createPositionAfter(block2)));
          startPosition = null;
        }
        i++;
      }
      return ranges;
    }
    function checkCanBeQuoted(schema, block2) {
      const isBQAllowed = schema.checkChild(block2.parent, "blockQuote");
      const isBlockAllowedInBQ = schema.checkChild([
        "$root",
        "blockQuote"
      ], block2);
      return isBQAllowed && isBlockAllowedInBQ;
    }
    class BlockQuoteEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BlockQuoteEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Enter,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        editor.commands.add("blockQuote", new BlockQuoteCommand(editor));
        schema.register("blockQuote", {
          inheritAllFrom: "$container"
        });
        editor.conversion.elementToElement({
          model: "blockQuote",
          view: "blockquote"
        });
        editor.model.document.registerPostFixer((writer) => {
          const changes = editor.model.document.differ.getChanges();
          for (const entry of changes) {
            if (entry.type == "insert") {
              const element = entry.position.nodeAfter;
              if (!element) {
                continue;
              }
              if (element.is("element", "blockQuote") && element.isEmpty) {
                writer.remove(element);
                return true;
              } else if (element.is("element", "blockQuote") && !schema.checkChild(entry.position, element)) {
                writer.unwrap(element);
                return true;
              } else if (element.is("element")) {
                const range = writer.createRangeIn(element);
                for (const child of range.getItems()) {
                  if (child.is("element", "blockQuote") && !schema.checkChild(writer.createPositionBefore(child), child)) {
                    writer.unwrap(child);
                    return true;
                  }
                }
              }
            } else if (entry.type == "remove") {
              const parent2 = entry.position.parent;
              if (parent2.is("element", "blockQuote") && parent2.isEmpty) {
                writer.remove(parent2);
                return true;
              }
            }
          }
          return false;
        });
        const viewDocument = this.editor.editing.view.document;
        const selection = editor.model.document.selection;
        const blockQuoteCommand = editor.commands.get("blockQuote");
        this.listenTo(viewDocument, "enter", (evt, data) => {
          if (!selection.isCollapsed || !blockQuoteCommand.value) {
            return;
          }
          const positionParent = selection.getLastPosition().parent;
          if (positionParent.isEmpty) {
            editor.execute("blockQuote");
            editor.editing.view.scrollToTheSelection();
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: "blockquote"
        });
        this.listenTo(viewDocument, "delete", (evt, data) => {
          if (data.direction != "backward" || !selection.isCollapsed || !blockQuoteCommand.value) {
            return;
          }
          const positionParent = selection.getLastPosition().parent;
          if (positionParent.isEmpty && !positionParent.previousSibling) {
            editor.execute("blockQuote");
            editor.editing.view.scrollToTheSelection();
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: "blockquote"
        });
      }
    }
    class BlockQuoteUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BlockQuoteUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const command = editor.commands.get("blockQuote");
        editor.ui.componentFactory.add("blockQuote", () => {
          const buttonView = this._createButton(ButtonView);
          buttonView.set({
            tooltip: true
          });
          buttonView.bind("isOn").to(command, "value");
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:blockQuote", () => this._createButton(MenuBarMenuListItemButtonView));
      }
      /**
      * Creates a button for block quote command to use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get("blockQuote");
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
          label: t("Block quote"),
          icon: icons.quote,
          isToggleable: true
        });
        view.bind("isEnabled").to(command, "isEnabled");
        this.listenTo(view, "execute", () => {
          editor.execute("blockQuote");
          editor.editing.view.focus();
        });
        return view;
      }
    }
    class BlockQuote extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          BlockQuoteEditing,
          BlockQuoteUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "BlockQuote";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class HighlightStack extends (/* @__PURE__ */ EmitterMixin()) {
      constructor() {
        super(...arguments);
        __publicField(this, "_stack", []);
      }
      /**
      * Adds highlight descriptor to the stack.
      *
      * @fires change:top
      */
      add(descriptor, writer) {
        const stack = this._stack;
        const oldTop = stack[0];
        this._insertDescriptor(descriptor);
        const newTop = stack[0];
        if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
          this.fire("change:top", {
            oldDescriptor: oldTop,
            newDescriptor: newTop,
            writer
          });
        }
      }
      /**
      * Removes highlight descriptor from the stack.
      *
      * @fires change:top
      * @param id Id of the descriptor to remove.
      */
      remove(id, writer) {
        const stack = this._stack;
        const oldTop = stack[0];
        this._removeDescriptor(id);
        const newTop = stack[0];
        if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
          this.fire("change:top", {
            oldDescriptor: oldTop,
            newDescriptor: newTop,
            writer
          });
        }
      }
      /**
      * Inserts a given descriptor in correct place in the stack. It also takes care about updating information
      * when descriptor with same id is already present.
      */
      _insertDescriptor(descriptor) {
        const stack = this._stack;
        const index2 = stack.findIndex((item) => item.id === descriptor.id);
        if (compareDescriptors(descriptor, stack[index2])) {
          return;
        }
        if (index2 > -1) {
          stack.splice(index2, 1);
        }
        let i = 0;
        while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {
          i++;
        }
        stack.splice(i, 0, descriptor);
      }
      /**
      * Removes descriptor with given id from the stack.
      *
      * @param id Descriptor's id.
      */
      _removeDescriptor(id) {
        const stack = this._stack;
        const index2 = stack.findIndex((item) => item.id === id);
        if (index2 > -1) {
          stack.splice(index2, 1);
        }
      }
    }
    function compareDescriptors(a, b) {
      return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);
    }
    function shouldABeBeforeB(a, b) {
      if (a.priority > b.priority) {
        return true;
      } else if (a.priority < b.priority) {
        return false;
      }
      return classesToString(a.classes) > classesToString(b.classes);
    }
    function classesToString(classes) {
      return Array.isArray(classes) ? classes.sort().join(",") : classes;
    }
    var dragHandleIcon = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
    const WIDGET_CLASS_NAME = "ck-widget";
    const WIDGET_SELECTED_CLASS_NAME = "ck-widget_selected";
    function isWidget(node) {
      if (!node.is("element")) {
        return false;
      }
      return !!node.getCustomProperty("widget");
    }
    function toWidget(element, writer, options = {}) {
      if (!element.is("containerElement")) {
        throw new CKEditorError("widget-to-widget-wrong-element-type", null, {
          element
        });
      }
      writer.setAttribute("contenteditable", "false", element);
      writer.addClass(WIDGET_CLASS_NAME, element);
      writer.setCustomProperty("widget", true, element);
      element.getFillerOffset = getFillerOffset;
      writer.setCustomProperty("widgetLabel", [], element);
      if (options.label) {
        setLabel(element, options.label);
      }
      if (options.hasSelectionHandle) {
        addSelectionHandle(element, writer);
      }
      setHighlightHandling(element, writer);
      return element;
    }
    function addHighlight(element, descriptor, writer) {
      if (descriptor.classes) {
        writer.addClass(toArray$1(descriptor.classes), element);
      }
      if (descriptor.attributes) {
        for (const key in descriptor.attributes) {
          writer.setAttribute(key, descriptor.attributes[key], element);
        }
      }
    }
    function removeHighlight(element, descriptor, writer) {
      if (descriptor.classes) {
        writer.removeClass(toArray$1(descriptor.classes), element);
      }
      if (descriptor.attributes) {
        for (const key in descriptor.attributes) {
          writer.removeAttribute(key, element);
        }
      }
    }
    function setHighlightHandling(element, writer, add = addHighlight, remove2 = removeHighlight) {
      const stack = new HighlightStack();
      stack.on("change:top", (evt, data) => {
        if (data.oldDescriptor) {
          remove2(element, data.oldDescriptor, data.writer);
        }
        if (data.newDescriptor) {
          add(element, data.newDescriptor, data.writer);
        }
      });
      const addHighlightCallback = (element2, descriptor, writer2) => stack.add(descriptor, writer2);
      const removeHighlightCallback = (element2, id, writer2) => stack.remove(id, writer2);
      writer.setCustomProperty("addHighlight", addHighlightCallback, element);
      writer.setCustomProperty("removeHighlight", removeHighlightCallback, element);
    }
    function setLabel(element, labelOrCreator) {
      const widgetLabel = element.getCustomProperty("widgetLabel");
      widgetLabel.push(labelOrCreator);
    }
    function getLabel(element) {
      const widgetLabel = element.getCustomProperty("widgetLabel");
      return widgetLabel.reduce((prev, current) => {
        if (typeof current === "function") {
          return prev ? prev + ". " + current() : current();
        } else {
          return prev ? prev + ". " + current : current;
        }
      }, "");
    }
    function toWidgetEditable(editable, writer, options = {}) {
      writer.addClass([
        "ck-editor__editable",
        "ck-editor__nested-editable"
      ], editable);
      writer.setAttribute("role", "textbox", editable);
      writer.setAttribute("tabindex", "-1", editable);
      if (options.label) {
        writer.setAttribute("aria-label", options.label, editable);
      }
      writer.setAttribute("contenteditable", editable.isReadOnly ? "false" : "true", editable);
      editable.on("change:isReadOnly", (evt, property2, is) => {
        writer.setAttribute("contenteditable", is ? "false" : "true", editable);
      });
      editable.on("change:isFocused", (evt, property2, is) => {
        if (is) {
          writer.addClass("ck-editor__nested-editable_focused", editable);
        } else {
          writer.removeClass("ck-editor__nested-editable_focused", editable);
        }
      });
      setHighlightHandling(editable, writer);
      return editable;
    }
    function findOptimalInsertionRange(selection, model) {
      const selectedElement = selection.getSelectedElement();
      if (selectedElement) {
        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection);
        if (typeAroundFakeCaretPosition) {
          return model.createRange(model.createPositionAt(selectedElement, typeAroundFakeCaretPosition));
        }
      }
      return model.schema.findOptimalInsertionRange(selection);
    }
    function getFillerOffset() {
      return null;
    }
    function addSelectionHandle(widgetElement, writer) {
      const selectionHandle = writer.createUIElement("div", {
        class: "ck ck-widget__selection-handle"
      }, function(domDocument) {
        const domElement = this.toDomElement(domDocument);
        const icon = new IconView();
        icon.set("content", dragHandleIcon);
        icon.render();
        domElement.appendChild(icon.element);
        return domElement;
      });
      writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);
      writer.addClass([
        "ck-widget_with-selection-handle"
      ], widgetElement);
    }
    const TYPE_AROUND_SELECTION_ATTRIBUTE = "widget-type-around";
    function isTypeAroundWidget(viewElement, modelElement, schema) {
      return !!viewElement && isWidget(viewElement) && !schema.isInline(modelElement);
    }
    function getClosestTypeAroundDomButton(domElement) {
      return domElement.closest(".ck-widget__type-around__button");
    }
    function getTypeAroundButtonPosition(domElement) {
      return domElement.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
    }
    function getClosestWidgetViewElement(domElement, domConverter) {
      const widgetDomElement = domElement.closest(".ck-widget");
      return domConverter.mapDomToView(widgetDomElement);
    }
    function getTypeAroundFakeCaretPosition(selection) {
      return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
    }
    var returnIcon = '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>';
    const POSSIBLE_INSERTION_POSITIONS = [
      "before",
      "after"
    ];
    const RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(returnIcon, "image/svg+xml").firstChild;
    const PLUGIN_DISABLED_EDITING_ROOT_CLASS = "ck-widget__type-around_disabled";
    class WidgetTypeAround extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * A reference to the model widget element that has the fake caret active
        * on either side of it. It is later used to remove CSS classes associated with the fake caret
        * when the widget no longer needs it.
        */
        __publicField(this, "_currentFakeCaretModelElement", null);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "WidgetTypeAround";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Enter,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        this.on("change:isEnabled", (evt, data, isEnabled2) => {
          editingView.change((writer) => {
            for (const root2 of editingView.document.roots) {
              if (isEnabled2) {
                writer.removeClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root2);
              } else {
                writer.addClass(PLUGIN_DISABLED_EDITING_ROOT_CLASS, root2);
              }
            }
          });
          if (!isEnabled2) {
            editor.model.change((writer) => {
              writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
            });
          }
        });
        this._enableTypeAroundUIInjection();
        this._enableInsertingParagraphsOnButtonClick();
        this._enableInsertingParagraphsOnEnterKeypress();
        this._enableInsertingParagraphsOnTypingKeystroke();
        this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
        this._enableDeleteIntegration();
        this._enableInsertContentIntegration();
        this._enableInsertObjectIntegration();
        this._enableDeleteContentIntegration();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this._currentFakeCaretModelElement = null;
      }
      /**
      * Inserts a new paragraph next to a widget element with the selection anchored in it.
      *
      * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
      * the viewport to the selection in the inserted paragraph.
      *
      * @param widgetModelElement The model widget element next to which a paragraph is inserted.
      * @param position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
      */
      _insertParagraph(widgetModelElement, position) {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const attributesToCopy = editor.model.schema.getAttributesWithProperty(widgetModelElement, "copyOnReplace", true);
        editor.execute("insertParagraph", {
          position: editor.model.createPositionAt(widgetModelElement, position),
          attributes: attributesToCopy
        });
        editingView.focus();
        editingView.scrollToTheSelection();
      }
      /**
      * A wrapper for the {@link module:utils/emittermixin~Emitter#listenTo} method that executes the callbacks only
      * when the plugin {@link #isEnabled is enabled}.
      *
      * @param emitter The object that fires the event.
      * @param event The name of the event.
      * @param callback The function to be called on event.
      * @param options Additional options.
      * @param options.priority The priority of this event callback. The higher the priority value the sooner
      * the callback will be fired. Events having the same priority are called in the order they were added.
      */
      _listenToIfEnabled(emitter, event, callback, options) {
        this.listenTo(emitter, event, (...args) => {
          if (this.isEnabled) {
            callback(...args);
          }
        }, options);
      }
      /**
      * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
      * does not expect a position. Instead, it performs the insertion next to a selected widget
      * according to the `widget-type-around` model selection attribute value (fake caret position).
      *
      * Because this method requires the `widget-type-around` attribute to be set,
      * the insertion can only happen when the widget's fake caret is active (e.g. activated
      * using the keyboard).
      *
      * @returns Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
      */
      _insertParagraphAccordingToFakeCaretPosition() {
        const editor = this.editor;
        const model = editor.model;
        const modelSelection = model.document.selection;
        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
        if (!typeAroundFakeCaretPosition) {
          return false;
        }
        const selectedModelElement = modelSelection.getSelectedElement();
        this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);
        return true;
      }
      /**
      * Creates a listener in the editing conversion pipeline that injects the widget type around
      * UI into every single widget instance created in the editor.
      *
      * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
      * wrapper which renders DOM buttons that users can use to insert paragraphs.
      */
      _enableTypeAroundUIInjection() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const t = editor.locale.t;
        const buttonTitles = {
          before: t("Insert paragraph before block"),
          after: t("Insert paragraph after block")
        };
        editor.editing.downcastDispatcher.on("insert", (evt, data, conversionApi) => {
          const viewElement = conversionApi.mapper.toViewElement(data.item);
          if (!viewElement) {
            return;
          }
          if (isTypeAroundWidget(viewElement, data.item, schema)) {
            injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);
            const widgetLabel = viewElement.getCustomProperty("widgetLabel");
            widgetLabel.push(() => {
              return this.isEnabled ? t("Press Enter to type after or press Shift + Enter to type before the widget") : "";
            });
          }
        }, {
          priority: "low"
        });
      }
      /**
      * Brings support for the fake caret that appears when either:
      *
      * * the selection moves to a widget from a position next to it using arrow keys,
      * * the arrow key is pressed when the widget is already selected.
      *
      * The fake caret lets the user know that they can start typing or just press
      * <kbd>Enter</kbd> to insert a paragraph at the position next to a widget as suggested by the fake caret.
      *
      * The fake caret disappears when the user changes the selection or the editor
      * gets blurred.
      *
      * The whole idea is as follows:
      *
      * 1. A user does one of the 2 scenarios described at the beginning.
      * 2. The "keydown" listener is executed and the decision is made whether to show or hide the fake caret.
      * 3. If it should show up, the `widget-type-around` model selection attribute is set indicating
      *    on which side of the widget it should appear.
      * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
      *    fake caret on the view widget.
      * 5. If the fake caret should disappear, the selection attribute is removed and the dispatcher
      *    does the CSS class clean-up in the view.
      * 6. Additionally, `change:range` and `FocusTracker#isFocused` listeners also remove the selection
      *    attribute (the former also removes widget CSS classes).
      */
      _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
        const editor = this.editor;
        const model = editor.model;
        const modelSelection = model.document.selection;
        const schema = model.schema;
        const editingView = editor.editing.view;
        this._listenToIfEnabled(editingView.document, "arrowKey", (evt, domEventData) => {
          this._handleArrowKeyPress(evt, domEventData);
        }, {
          context: [
            isWidget,
            "$text"
          ],
          priority: "high"
        });
        this._listenToIfEnabled(modelSelection, "change:range", (evt, data) => {
          if (!data.directChange) {
            return;
          }
          editor.model.change((writer) => {
            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          });
        });
        this._listenToIfEnabled(model.document, "change:data", () => {
          const selectedModelElement = modelSelection.getSelectedElement();
          if (selectedModelElement) {
            const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
            if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
              return;
            }
          }
          editor.model.change((writer) => {
            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          });
        });
        this._listenToIfEnabled(editor.editing.downcastDispatcher, "selection", (evt, data, conversionApi) => {
          const writer = conversionApi.writer;
          if (this._currentFakeCaretModelElement) {
            const selectedViewElement2 = conversionApi.mapper.toViewElement(this._currentFakeCaretModelElement);
            if (selectedViewElement2) {
              writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), selectedViewElement2);
              this._currentFakeCaretModelElement = null;
            }
          }
          const selectedModelElement = data.selection.getSelectedElement();
          if (!selectedModelElement) {
            return;
          }
          const selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);
          if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement);
          this._currentFakeCaretModelElement = selectedModelElement;
        });
        this._listenToIfEnabled(editor.ui.focusTracker, "change:isFocused", (evt, name, isFocused) => {
          if (!isFocused) {
            editor.model.change((writer) => {
              writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
            });
          }
        });
        function positionToWidgetCssClass(position) {
          return `ck-widget_type-around_show-fake-caret_${position}`;
        }
      }
      /**
      * A listener executed on each "keydown" in the view document, a part of
      * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
      *
      * It decides whether the arrow keypress should activate the fake caret or not (also whether it should
      * be deactivated).
      *
      * The fake caret activation is done by setting the `widget-type-around` model selection attribute
      * in this listener, and stopping and preventing the event that would normally be handled by the widget
      * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
      * includes inline widgets, which are ignored by the widget type around plugin).
      */
      _handleArrowKeyPress(evt, domEventData) {
        const editor = this.editor;
        const model = editor.model;
        const modelSelection = model.document.selection;
        const schema = model.schema;
        const editingView = editor.editing.view;
        const keyCode = domEventData.keyCode;
        const isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);
        const selectedViewElement = editingView.document.selection.getSelectedElement();
        const selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);
        let shouldStopAndPreventDefault;
        if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);
        } else if (modelSelection.isCollapsed) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);
        } else if (!domEventData.shiftKey) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressWhenNonCollapsedSelection(isForward);
        }
        if (shouldStopAndPreventDefault) {
          domEventData.preventDefault();
          evt.stop();
        }
      }
      /**
      * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
      * the fake caret for that widget, depending on the current value of the `widget-type-around` model
      * selection attribute and the direction of the pressed arrow key.
      *
      * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
      * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
      * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
      * process the event any further. Returns `false` otherwise.
      */
      _handleArrowKeyPressOnSelectedWidget(isForward) {
        const editor = this.editor;
        const model = editor.model;
        const modelSelection = model.document.selection;
        const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
        return model.change((writer) => {
          if (typeAroundFakeCaretPosition) {
            const isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? "after" : "before");
            if (!isLeavingWidget) {
              writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
              return true;
            }
          } else {
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
            return true;
          }
          return false;
        });
      }
      /**
      * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
      * to one and upon the fake caret should become active for this widget upon arrow keypress
      * (AKA entering/selecting the widget).
      *
      * **Note**: This code mirrors the implementation from the widget plugin but also adds the selection attribute.
      * Unfortunately, there is no safe way to let the widget plugin do the selection part first and then just set the
      * selection attribute here in the widget type around plugin. This is why this code must duplicate some from the widget plugin.
      *
      * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
      * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
      * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
      * process the event any further. Returns `false` otherwise.
      */
      _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {
        const editor = this.editor;
        const model = editor.model;
        const schema = model.schema;
        const widgetPlugin = editor.plugins.get("Widget");
        const modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);
        const viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);
        if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {
          model.change((writer) => {
            widgetPlugin._setSelectionOverElement(modelElementNextToSelection);
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "before" : "after");
          });
          return true;
        }
        return false;
      }
      /**
      * Handles the keyboard navigation on "keydown" when a widget is currently selected (together with some other content)
      * and the widget is the first or last element in the selection. It activates or deactivates the fake caret for that widget.
      *
      * @param isForward `true` when the pressed arrow key was responsible for the forward model selection movement
      * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
      * @returns Returns `true` when the keypress was handled and no other keydown listener of the editor should
      * process the event any further. Returns `false` otherwise.
      */
      _handleArrowKeyPressWhenNonCollapsedSelection(isForward) {
        const editor = this.editor;
        const model = editor.model;
        const schema = model.schema;
        const mapper = editor.editing.mapper;
        const modelSelection = model.document.selection;
        const selectedModelNode = isForward ? modelSelection.getLastPosition().nodeBefore : modelSelection.getFirstPosition().nodeAfter;
        const selectedViewNode = mapper.toViewElement(selectedModelNode);
        if (isTypeAroundWidget(selectedViewNode, selectedModelNode, schema)) {
          model.change((writer) => {
            writer.setSelection(selectedModelNode, "on");
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? "after" : "before");
          });
          return true;
        }
        return false;
      }
      /**
      * Registers a `mousedown` listener for the view document which intercepts events
      * coming from the widget type around UI, which happens when a user clicks one of the buttons
      * that insert a paragraph next to a widget.
      */
      _enableInsertingParagraphsOnButtonClick() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        this._listenToIfEnabled(editingView.document, "mousedown", (evt, domEventData) => {
          const button = getClosestTypeAroundDomButton(domEventData.domTarget);
          if (!button) {
            return;
          }
          const buttonPosition = getTypeAroundButtonPosition(button);
          const widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);
          const widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);
          this._insertParagraph(widgetModelElement, buttonPosition);
          domEventData.preventDefault();
          evt.stop();
        });
      }
      /**
      * Creates the <kbd>Enter</kbd> key listener on the view document that allows the user to insert a paragraph
      * near the widget when either:
      *
      * * The fake caret was first activated using the arrow keys,
      * * The entire widget is selected in the model.
      *
      * In the first case, the new paragraph is inserted according to the `widget-type-around` selection
      * attribute (see {@link #_handleArrowKeyPress}).
      *
      * In the second case, the new paragraph is inserted based on whether a soft (<kbd>Shift</kbd>+<kbd>Enter</kbd>) keystroke
      * was pressed or not.
      */
      _enableInsertingParagraphsOnEnterKeypress() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        const editingView = editor.editing.view;
        this._listenToIfEnabled(editingView.document, "enter", (evt, domEventData) => {
          if (evt.eventPhase != "atTarget") {
            return;
          }
          const selectedModelElement = selection.getSelectedElement();
          const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
          const schema = editor.model.schema;
          let wasHandled;
          if (this._insertParagraphAccordingToFakeCaretPosition()) {
            wasHandled = true;
          } else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
            this._insertParagraph(selectedModelElement, domEventData.isSoft ? "before" : "after");
            wasHandled = true;
          }
          if (wasHandled) {
            domEventData.preventDefault();
            evt.stop();
          }
        }, {
          context: isWidget
        });
      }
      /**
      * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
      * to insert a paragraph next to a widget when the fake caret was activated using arrow
      * keys but it responds to typing instead of <kbd>Enter</kbd>.
      *
      * Listener enabled by this method will insert a new paragraph according to the `widget-type-around`
      * model selection attribute as the user simply starts typing, which creates the impression that the fake caret
      * behaves like a real one rendered by the browser (AKA your text appears where the caret was).
      *
      * **Note**: At the moment this listener creates 2 undo steps: one for the `insertParagraph` command
      * and another one for actual typing. It is not a disaster but this may need to be fixed
      * sooner or later.
      */
      _enableInsertingParagraphsOnTypingKeystroke() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        this._listenToIfEnabled(viewDocument, "insertText", (evt, data) => {
          if (this._insertParagraphAccordingToFakeCaretPosition()) {
            data.selection = viewDocument.selection;
          }
        }, {
          priority: "high"
        });
        if (env.isAndroid) {
          this._listenToIfEnabled(viewDocument, "keydown", (evt, data) => {
            if (data.keyCode == 229) {
              this._insertParagraphAccordingToFakeCaretPosition();
            }
          });
        } else {
          this._listenToIfEnabled(viewDocument, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition();
          }, {
            priority: "high"
          });
        }
      }
      /**
      * It creates a "delete" event listener on the view document to handle cases when the <kbd>Delete</kbd> or <kbd>Backspace</kbd>
      * is pressed and the fake caret is currently active.
      *
      * The fake caret should create an illusion of a real browser caret so that when it appears before or after
      * a widget, pressing <kbd>Delete</kbd> or <kbd>Backspace</kbd> should remove a widget or delete the content
      * before or after a widget (depending on the content surrounding the widget).
      */
      _enableDeleteIntegration() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const model = editor.model;
        const schema = model.schema;
        this._listenToIfEnabled(editingView.document, "delete", (evt, domEventData) => {
          if (evt.eventPhase != "atTarget") {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          const direction = domEventData.direction;
          const selectedModelWidget = model.document.selection.getSelectedElement();
          const isFakeCaretBefore = typeAroundFakeCaretPosition === "before";
          const isDeleteForward = direction == "forward";
          const shouldDeleteEntireWidget = isFakeCaretBefore === isDeleteForward;
          if (shouldDeleteEntireWidget) {
            editor.execute("delete", {
              selection: model.createSelection(selectedModelWidget, "on")
            });
          } else {
            const range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction);
            if (range) {
              if (!range.isCollapsed) {
                model.change((writer) => {
                  writer.setSelection(range);
                  editor.execute(isDeleteForward ? "deleteForward" : "delete");
                });
              } else {
                const probe = model.createSelection(range.start);
                model.modifySelection(probe, {
                  direction
                });
                if (!probe.focus.isEqual(range.start)) {
                  model.change((writer) => {
                    writer.setSelection(range);
                    editor.execute(isDeleteForward ? "deleteForward" : "delete");
                  });
                } else {
                  const deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);
                  model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, "on"), {
                    doNotAutoparagraph: true
                  });
                }
              }
            }
          }
          domEventData.preventDefault();
          evt.stop();
        }, {
          context: isWidget
        });
      }
      /**
      * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
      * content near a widget when the fake caret is first activated using the arrow keys.
      *
      * The content is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
      */
      _enableInsertContentIntegration() {
        const editor = this.editor;
        const model = this.editor.model;
        const documentSelection = model.document.selection;
        this._listenToIfEnabled(editor.model, "insertContent", (evt, [content, selectable]) => {
          if (selectable && !selectable.is("documentSelection")) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          evt.stop();
          return model.change((writer) => {
            const selectedElement = documentSelection.getSelectedElement();
            const position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
            const selection = writer.createSelection(position);
            const result = model.insertContent(content, selection);
            writer.setSelection(selection);
            return result;
          });
        }, {
          priority: "high"
        });
      }
      /**
      * Attaches the {@link module:engine/model/model~Model#event:insertObject} event listener that modifies the
      * `options.findOptimalPosition`parameter to position of fake caret in relation to selected element
      * to reflect user's intent of desired insertion position.
      *
      * The object is inserted according to the `widget-type-around` selection attribute (see {@link #_handleArrowKeyPress}).
      */
      _enableInsertObjectIntegration() {
        const editor = this.editor;
        const model = this.editor.model;
        const documentSelection = model.document.selection;
        this._listenToIfEnabled(editor.model, "insertObject", (evt, args) => {
          const [, selectable, options = {}] = args;
          if (selectable && !selectable.is("documentSelection")) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
          if (!typeAroundFakeCaretPosition) {
            return;
          }
          options.findOptimalPosition = typeAroundFakeCaretPosition;
          args[3] = options;
        }, {
          priority: "high"
        });
      }
      /**
      * Attaches the {@link module:engine/model/model~Model#event:deleteContent} event listener to block the event when the fake
      * caret is active.
      *
      * This is required for cases that trigger {@link module:engine/model/model~Model#deleteContent `model.deleteContent()`}
      * before calling {@link module:engine/model/model~Model#insertContent `model.insertContent()`} like, for instance,
      * plain text pasting.
      */
      _enableDeleteContentIntegration() {
        const editor = this.editor;
        const model = this.editor.model;
        const documentSelection = model.document.selection;
        this._listenToIfEnabled(editor.model, "deleteContent", (evt, [selection]) => {
          if (selection && !selection.is("documentSelection")) {
            return;
          }
          const typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);
          if (typeAroundFakeCaretPosition) {
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
    }
    function injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {
      const typeAroundWrapper = viewWriter.createUIElement("div", {
        class: "ck ck-reset_all ck-widget__type-around"
      }, function(domDocument) {
        const wrapperDomElement = this.toDomElement(domDocument);
        injectButtons(wrapperDomElement, buttonTitles);
        injectFakeCaret(wrapperDomElement);
        return wrapperDomElement;
      });
      viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, "end"), typeAroundWrapper);
    }
    function injectButtons(wrapperDomElement, buttonTitles) {
      for (const position of POSSIBLE_INSERTION_POSITIONS) {
        const buttonTemplate = new Template({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-widget__type-around__button",
              `ck-widget__type-around__button_${position}`
            ],
            title: buttonTitles[position],
            "aria-hidden": "true"
          },
          children: [
            wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)
          ]
        });
        wrapperDomElement.appendChild(buttonTemplate.render());
      }
    }
    function injectFakeCaret(wrapperDomElement) {
      const caretTemplate = new Template({
        tag: "div",
        attributes: {
          class: [
            "ck",
            "ck-widget__type-around__fake-caret"
          ]
        }
      });
      wrapperDomElement.appendChild(caretTemplate.render());
    }
    function getDeepestEmptyElementAncestor(schema, element) {
      let deepestEmptyAncestor = element;
      for (const ancestor of element.getAncestors({
        parentFirst: true
      })) {
        if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {
          break;
        }
        deepestEmptyAncestor = ancestor;
      }
      return deepestEmptyAncestor;
    }
    function verticalNavigationHandler(editing) {
      const model = editing.model;
      return (evt, data) => {
        const arrowUpPressed = data.keyCode == keyCodes.arrowup;
        const arrowDownPressed = data.keyCode == keyCodes.arrowdown;
        const expandSelection = data.shiftKey;
        const selection = model.document.selection;
        if (!arrowUpPressed && !arrowDownPressed) {
          return;
        }
        const isForward = arrowDownPressed;
        if (expandSelection && selectionWillShrink(selection, isForward)) {
          return;
        }
        const range = findTextRangeFromSelection(editing, selection, isForward);
        if (!range) {
          return;
        }
        if (range.isCollapsed) {
          if (selection.isCollapsed) {
            return;
          } else if (expandSelection) {
            return;
          }
        }
        if (range.isCollapsed || isSingleLineRange(editing, range, isForward)) {
          model.change((writer) => {
            const newPosition = isForward ? range.end : range.start;
            if (expandSelection) {
              const newSelection = model.createSelection(selection.anchor);
              newSelection.setFocus(newPosition);
              writer.setSelection(newSelection);
            } else {
              writer.setSelection(newPosition);
            }
          });
          evt.stop();
          data.preventDefault();
          data.stopPropagation();
        }
      };
    }
    function findTextRangeFromSelection(editing, selection, isForward) {
      const model = editing.model;
      if (isForward) {
        const startPosition = selection.isCollapsed ? selection.focus : selection.getLastPosition();
        const endPosition = getNearestNonInlineLimit(model, startPosition, "forward");
        if (!endPosition) {
          return null;
        }
        const range = model.createRange(startPosition, endPosition);
        const lastRangePosition = getNearestTextPosition(model.schema, range, "backward");
        if (lastRangePosition) {
          return model.createRange(startPosition, lastRangePosition);
        }
        return null;
      } else {
        const endPosition = selection.isCollapsed ? selection.focus : selection.getFirstPosition();
        const startPosition = getNearestNonInlineLimit(model, endPosition, "backward");
        if (!startPosition) {
          return null;
        }
        const range = model.createRange(startPosition, endPosition);
        const firstRangePosition = getNearestTextPosition(model.schema, range, "forward");
        if (firstRangePosition) {
          return model.createRange(firstRangePosition, endPosition);
        }
        return null;
      }
    }
    function getNearestNonInlineLimit(model, startPosition, direction) {
      const schema = model.schema;
      const range = model.createRangeIn(startPosition.root);
      const walkerValueType = direction == "forward" ? "elementStart" : "elementEnd";
      for (const { previousPosition, item, type } of range.getWalker({
        startPosition,
        direction
      })) {
        if (schema.isLimit(item) && !schema.isInline(item)) {
          return previousPosition;
        }
        if (type == walkerValueType && schema.isBlock(item)) {
          return null;
        }
      }
      return null;
    }
    function getNearestTextPosition(schema, range, direction) {
      const position = direction == "backward" ? range.end : range.start;
      if (schema.checkChild(position, "$text")) {
        return position;
      }
      for (const { nextPosition } of range.getWalker({
        direction
      })) {
        if (schema.checkChild(nextPosition, "$text")) {
          return nextPosition;
        }
      }
      return null;
    }
    function isSingleLineRange(editing, modelRange, isForward) {
      const model = editing.model;
      const domConverter = editing.view.domConverter;
      if (isForward) {
        const probe = model.createSelection(modelRange.start);
        model.modifySelection(probe);
        if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {
          modelRange = model.createRange(probe.focus, modelRange.end);
        }
      }
      const viewRange = editing.mapper.toViewRange(modelRange);
      const domRange = domConverter.viewRangeToDom(viewRange);
      const rects = Rect.getDomRangeRects(domRange);
      let boundaryVerticalPosition;
      for (const rect of rects) {
        if (boundaryVerticalPosition === void 0) {
          boundaryVerticalPosition = Math.round(rect.bottom);
          continue;
        }
        if (Math.round(rect.top) >= boundaryVerticalPosition) {
          return false;
        }
        boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));
      }
      return true;
    }
    function selectionWillShrink(selection, isForward) {
      return !selection.isCollapsed && selection.isBackward == isForward;
    }
    class Widget extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Holds previously selected widgets.
        */
        __publicField(this, "_previouslySelected", /* @__PURE__ */ new Set());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Widget";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          WidgetTypeAround,
          Delete
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const t = editor.t;
        this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
          const viewWriter = conversionApi.writer;
          const modelSelection = data.selection;
          if (modelSelection.isCollapsed) {
            return;
          }
          const selectedModelElement = modelSelection.getSelectedElement();
          if (!selectedModelElement) {
            return;
          }
          const selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);
          if (!isWidget(selectedViewElement)) {
            return;
          }
          if (!conversionApi.consumable.consume(modelSelection, "selection")) {
            return;
          }
          viewWriter.setSelection(viewWriter.createRangeOn(selectedViewElement), {
            fake: true,
            label: getLabel(selectedViewElement)
          });
        });
        this.editor.editing.downcastDispatcher.on("selection", (evt, data, conversionApi) => {
          this._clearPreviouslySelectedWidgets(conversionApi.writer);
          const viewWriter = conversionApi.writer;
          const viewSelection = viewWriter.document.selection;
          let lastMarked = null;
          for (const range of viewSelection.getRanges()) {
            for (const value of range) {
              const node = value.item;
              if (isWidget(node) && !isChild(node, lastMarked)) {
                viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);
                this._previouslySelected.add(node);
                lastMarked = node;
              }
            }
          }
        }, {
          priority: "low"
        });
        view.addObserver(MouseObserver);
        this.listenTo(viewDocument, "mousedown", (...args) => this._onMousedown(...args));
        this.listenTo(viewDocument, "arrowKey", (...args) => {
          this._handleSelectionChangeOnArrowKeyPress(...args);
        }, {
          context: [
            isWidget,
            "$text"
          ]
        });
        this.listenTo(viewDocument, "arrowKey", (...args) => {
          this._preventDefaultOnArrowKeyPress(...args);
        }, {
          context: "$root"
        });
        this.listenTo(viewDocument, "arrowKey", verticalNavigationHandler(this.editor.editing), {
          context: "$text"
        });
        this.listenTo(viewDocument, "delete", (evt, data) => {
          if (this._handleDelete(data.direction == "forward")) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: "$root"
        });
        this.listenTo(viewDocument, "tab", (evt, data) => {
          if (evt.eventPhase != "atTarget") {
            return;
          }
          if (data.shiftKey) {
            return;
          }
          if (this._selectFirstNestedEditable()) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: isWidget,
          priority: "low"
        });
        this.listenTo(viewDocument, "tab", (evt, data) => {
          if (!data.shiftKey) {
            return;
          }
          if (this._selectAncestorWidget()) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          priority: "low"
        });
        this.listenTo(viewDocument, "keydown", (evt, data) => {
          if (data.keystroke != keyCodes.esc) {
            return;
          }
          if (this._selectAncestorWidget()) {
            data.preventDefault();
            evt.stop();
          }
        }, {
          priority: "low"
        });
        editor.accessibility.addKeystrokeInfoGroup({
          id: "widget",
          label: t("Keystrokes that can be used when a widget is selected (for example: image, table, etc.)"),
          keystrokes: [
            {
              label: t("Move focus from an editable area back to the parent widget"),
              keystroke: "Esc"
            },
            {
              label: t("Insert a new paragraph directly after a widget"),
              keystroke: "Enter"
            },
            {
              label: t("Insert a new paragraph directly before a widget"),
              keystroke: "Shift+Enter"
            },
            {
              label: t("Move the caret to allow typing directly before a widget"),
              keystroke: [
                [
                  "arrowup"
                ],
                [
                  "arrowleft"
                ]
              ]
            },
            {
              label: t("Move the caret to allow typing directly after a widget"),
              keystroke: [
                [
                  "arrowdown"
                ],
                [
                  "arrowright"
                ]
              ]
            }
          ]
        });
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
      */
      _onMousedown(eventInfo, domEventData) {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        let element = domEventData.target;
        if (domEventData.domEvent.detail >= 3) {
          if (this._selectBlockContent(element)) {
            domEventData.preventDefault();
          }
          return;
        }
        if (isInsideNestedEditable(element)) {
          return;
        }
        if (!isWidget(element)) {
          element = element.findAncestor(isWidget);
          if (!element) {
            return;
          }
        }
        if (env.isAndroid) {
          domEventData.preventDefault();
        }
        if (!viewDocument.isFocused) {
          view.focus();
        }
        const modelElement = editor.editing.mapper.toModelElement(element);
        this._setSelectionOverElement(modelElement);
      }
      /**
      * Selects entire block content, e.g. on triple click it selects entire paragraph.
      */
      _selectBlockContent(element) {
        const editor = this.editor;
        const model = editor.model;
        const mapper = editor.editing.mapper;
        const schema = model.schema;
        const viewElement = mapper.findMappedViewAncestor(this.editor.editing.view.createPositionAt(element, 0));
        const modelElement = findTextBlockAncestor(mapper.toModelElement(viewElement), model.schema);
        if (!modelElement) {
          return false;
        }
        model.change((writer) => {
          const nextTextBlock = !schema.isLimit(modelElement) ? findNextTextBlock(writer.createPositionAfter(modelElement), schema) : null;
          const start = writer.createPositionAt(modelElement, 0);
          const end = nextTextBlock ? writer.createPositionAt(nextTextBlock, 0) : writer.createPositionAt(modelElement, "end");
          writer.setSelection(writer.createRange(start, end));
        });
        return true;
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
      * the model selection when:
      *
      * * arrow key is pressed when the widget is selected,
      * * the selection is next to a widget and the widget should become selected upon the arrow key press.
      *
      * See {@link #_preventDefaultOnArrowKeyPress}.
      */
      _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {
        const keyCode = domEventData.keyCode;
        const model = this.editor.model;
        const schema = model.schema;
        const modelSelection = model.document.selection;
        const objectElement = modelSelection.getSelectedElement();
        const direction = getLocalizedArrowKeyCodeDirection(keyCode, this.editor.locale.contentLanguageDirection);
        const isForward = direction == "down" || direction == "right";
        const isVerticalNavigation = direction == "up" || direction == "down";
        if (objectElement && schema.isObject(objectElement)) {
          const position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
          const newRange = schema.getNearestSelectionRange(position, isForward ? "forward" : "backward");
          if (newRange) {
            model.change((writer) => {
              writer.setSelection(newRange);
            });
            domEventData.preventDefault();
            eventInfo.stop();
          }
          return;
        }
        if (!modelSelection.isCollapsed && !domEventData.shiftKey) {
          const firstPosition = modelSelection.getFirstPosition();
          const lastPosition = modelSelection.getLastPosition();
          const firstSelectedNode = firstPosition.nodeAfter;
          const lastSelectedNode = lastPosition.nodeBefore;
          if (firstSelectedNode && schema.isObject(firstSelectedNode) || lastSelectedNode && schema.isObject(lastSelectedNode)) {
            model.change((writer) => {
              writer.setSelection(isForward ? lastPosition : firstPosition);
            });
            domEventData.preventDefault();
            eventInfo.stop();
          }
          return;
        }
        if (!modelSelection.isCollapsed) {
          return;
        }
        const objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);
        if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {
          if (schema.isInline(objectElementNextToSelection) && isVerticalNavigation) {
            return;
          }
          this._setSelectionOverElement(objectElementNextToSelection);
          domEventData.preventDefault();
          eventInfo.stop();
        }
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
      * the default browser behavior to make sure the fake selection is not being moved from a fake selection
      * container.
      *
      * See {@link #_handleSelectionChangeOnArrowKeyPress}.
      */
      _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {
        const model = this.editor.model;
        const schema = model.schema;
        const objectElement = model.document.selection.getSelectedElement();
        if (objectElement && schema.isObject(objectElement)) {
          domEventData.preventDefault();
          eventInfo.stop();
        }
      }
      /**
      * Handles delete keys: backspace and delete.
      *
      * @param isForward Set to true if delete was performed in forward direction.
      * @returns Returns `true` if keys were handled correctly.
      */
      _handleDelete(isForward) {
        const modelDocument = this.editor.model.document;
        const modelSelection = modelDocument.selection;
        if (!this.editor.model.canEditAt(modelSelection)) {
          return;
        }
        if (!modelSelection.isCollapsed) {
          return;
        }
        const objectElement = this._getObjectElementNextToSelection(isForward);
        if (objectElement) {
          this.editor.model.change((writer) => {
            let previousNode = modelSelection.anchor.parent;
            while (previousNode.isEmpty) {
              const nodeToRemove = previousNode;
              previousNode = nodeToRemove.parent;
              writer.remove(nodeToRemove);
            }
            this._setSelectionOverElement(objectElement);
          });
          return true;
        }
      }
      /**
      * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
      *
      * @internal
      */
      _setSelectionOverElement(element) {
        this.editor.model.change((writer) => {
          writer.setSelection(writer.createRangeOn(element));
        });
      }
      /**
      * Checks if {@link module:engine/model/element~Element element} placed next to the current
      * {@link module:engine/model/selection~Selection model selection} exists and is marked in
      * {@link module:engine/model/schema~Schema schema} as `object`.
      *
      * @internal
      * @param forward Direction of checking.
      */
      _getObjectElementNextToSelection(forward) {
        const model = this.editor.model;
        const schema = model.schema;
        const modelSelection = model.document.selection;
        const probe = model.createSelection(modelSelection);
        model.modifySelection(probe, {
          direction: forward ? "forward" : "backward"
        });
        if (probe.isEqual(modelSelection)) {
          return null;
        }
        const objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;
        if (!!objectElement && schema.isObject(objectElement)) {
          return objectElement;
        }
        return null;
      }
      /**
      * Removes CSS class from previously selected widgets.
      */
      _clearPreviouslySelectedWidgets(writer) {
        for (const widget of this._previouslySelected) {
          writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);
        }
        this._previouslySelected.clear();
      }
      /**
      * Moves the document selection into the first nested editable.
      */
      _selectFirstNestedEditable() {
        const editor = this.editor;
        const view = this.editor.editing.view;
        const viewDocument = view.document;
        for (const item of viewDocument.selection.getFirstRange().getItems()) {
          if (item.is("editableElement")) {
            const modelElement = editor.editing.mapper.toModelElement(item);
            /* istanbul ignore next -- @preserve */
            if (!modelElement) {
              continue;
            }
            const position = editor.model.createPositionAt(modelElement, 0);
            const newRange = editor.model.schema.getNearestSelectionRange(position, "forward");
            editor.model.change((writer) => {
              writer.setSelection(newRange);
            });
            return true;
          }
        }
        return false;
      }
      /**
      * Updates the document selection so that it selects first ancestor widget.
      */
      _selectAncestorWidget() {
        const editor = this.editor;
        const mapper = editor.editing.mapper;
        const selection = editor.editing.view.document.selection;
        const positionParent = selection.getFirstPosition().parent;
        const positionParentElement = positionParent.is("$text") ? positionParent.parent : positionParent;
        const viewElement = positionParentElement.findAncestor(isWidget);
        if (!viewElement) {
          return false;
        }
        const modelElement = mapper.toModelElement(viewElement);
        /* istanbul ignore next -- @preserve */
        if (!modelElement) {
          return false;
        }
        editor.model.change((writer) => {
          writer.setSelection(modelElement, "on");
        });
        return true;
      }
    }
    function isInsideNestedEditable(element) {
      let currentElement = element;
      while (currentElement) {
        if (currentElement.is("editableElement") && !currentElement.is("rootElement")) {
          return true;
        }
        if (isWidget(currentElement)) {
          return false;
        }
        currentElement = currentElement.parent;
      }
      return false;
    }
    function isChild(element, parent2) {
      if (!parent2) {
        return false;
      }
      return Array.from(element.getAncestors()).includes(parent2);
    }
    function findTextBlockAncestor(modelElement, schema) {
      for (const element of modelElement.getAncestors({
        includeSelf: true,
        parentFirst: true
      })) {
        if (schema.checkChild(element, "$text")) {
          return element;
        }
        if (schema.isLimit(element) && !schema.isObject(element)) {
          break;
        }
      }
      return null;
    }
    function findNextTextBlock(position, schema) {
      const treeWalker = new TreeWalker({
        startPosition: position
      });
      for (const { item } of treeWalker) {
        if (schema.isLimit(item) || !item.is("element")) {
          return null;
        }
        if (schema.checkChild(item, "$text")) {
          return item;
        }
      }
      return null;
    }
    class WidgetToolbarRepository extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * A map of toolbar definitions.
        */
        __publicField(this, "_toolbarDefinitions", /* @__PURE__ */ new Map());
        __publicField(this, "_balloon");
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ContextualBalloon
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "WidgetToolbarRepository";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (editor.plugins.has("BalloonToolbar")) {
          const balloonToolbar = editor.plugins.get("BalloonToolbar");
          this.listenTo(balloonToolbar, "show", (evt) => {
            if (isWidgetSelected(editor.editing.view.document.selection)) {
              evt.stop();
            }
          }, {
            priority: "high"
          });
        }
        this._balloon = this.editor.plugins.get("ContextualBalloon");
        this.on("change:isEnabled", () => {
          this._updateToolbarsVisibility();
        });
        this.listenTo(editor.ui, "update", () => {
          this._updateToolbarsVisibility();
        });
        this.listenTo(editor.ui.focusTracker, "change:isFocused", () => {
          this._updateToolbarsVisibility();
        }, {
          priority: "low"
        });
      }
      destroy() {
        super.destroy();
        for (const toolbarConfig of this._toolbarDefinitions.values()) {
          toolbarConfig.view.destroy();
        }
      }
      /**
      * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
      * `getRelatedElement` function. Toolbar items are gathered from `items` array.
      * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
      *
      * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
      * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
      *
      * @param toolbarId An id for the toolbar. Used to
      * @param options.ariaLabel Label used by assistive technologies to describe this toolbar element.
      * @param options.items Array of toolbar items.
      * @param options.getRelatedElement Callback which returns an element the toolbar should be attached to.
      * @param options.balloonClassName CSS class for the widget balloon.
      */
      register(toolbarId, { ariaLabel, items, getRelatedElement, balloonClassName = "ck-toolbar-container" }) {
        if (!items.length) {
          logWarning("widget-toolbar-no-items", {
            toolbarId
          });
          return;
        }
        const editor = this.editor;
        const t = editor.t;
        const toolbarView = new ToolbarView(editor.locale);
        toolbarView.ariaLabel = ariaLabel || t("Widget toolbar");
        if (this._toolbarDefinitions.has(toolbarId)) {
          throw new CKEditorError("widget-toolbar-duplicated", this, {
            toolbarId
          });
        }
        const toolbarDefinition = {
          view: toolbarView,
          getRelatedElement,
          balloonClassName,
          itemsConfig: items,
          initialized: false
        };
        editor.ui.addToolbar(toolbarView, {
          isContextual: true,
          beforeFocus: () => {
            const relatedElement = getRelatedElement(editor.editing.view.document.selection);
            if (relatedElement) {
              this._showToolbar(toolbarDefinition, relatedElement);
            }
          },
          afterBlur: () => {
            this._hideToolbar(toolbarDefinition);
          }
        });
        this._toolbarDefinitions.set(toolbarId, toolbarDefinition);
      }
      /**
      * Iterates over stored toolbars and makes them visible or hidden.
      */
      _updateToolbarsVisibility() {
        let maxRelatedElementDepth = 0;
        let deepestRelatedElement = null;
        let deepestToolbarDefinition = null;
        for (const definition of this._toolbarDefinitions.values()) {
          const relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);
          if (!this.isEnabled || !relatedElement) {
            if (this._isToolbarInBalloon(definition)) {
              this._hideToolbar(definition);
            }
          } else if (!this.editor.ui.focusTracker.isFocused) {
            if (this._isToolbarVisible(definition)) {
              this._hideToolbar(definition);
            }
          } else {
            const relatedElementDepth = relatedElement.getAncestors().length;
            if (relatedElementDepth > maxRelatedElementDepth) {
              maxRelatedElementDepth = relatedElementDepth;
              deepestRelatedElement = relatedElement;
              deepestToolbarDefinition = definition;
            }
          }
        }
        if (deepestToolbarDefinition) {
          this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);
        }
      }
      /**
      * Hides the given toolbar.
      */
      _hideToolbar(toolbarDefinition) {
        this._balloon.remove(toolbarDefinition.view);
        this.stopListening(this._balloon, "change:visibleView");
      }
      /**
      * Shows up the toolbar if the toolbar is not visible.
      * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
      *
      * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
      * should be still visible after the {@link module:ui/editorui/editorui~EditorUI#event:update}.
      */
      _showToolbar(toolbarDefinition, relatedElement) {
        if (this._isToolbarVisible(toolbarDefinition)) {
          repositionContextualBalloon$2(this.editor, relatedElement);
        } else if (!this._isToolbarInBalloon(toolbarDefinition)) {
          if (!toolbarDefinition.initialized) {
            toolbarDefinition.initialized = true;
            toolbarDefinition.view.fillFromConfig(toolbarDefinition.itemsConfig, this.editor.ui.componentFactory);
          }
          this._balloon.add({
            view: toolbarDefinition.view,
            position: getBalloonPositionData$1(this.editor, relatedElement),
            balloonClassName: toolbarDefinition.balloonClassName
          });
          this.listenTo(this._balloon, "change:visibleView", () => {
            for (const definition of this._toolbarDefinitions.values()) {
              if (this._isToolbarVisible(definition)) {
                const relatedElement2 = definition.getRelatedElement(this.editor.editing.view.document.selection);
                repositionContextualBalloon$2(this.editor, relatedElement2);
              }
            }
          });
        }
      }
      _isToolbarVisible(toolbar) {
        return this._balloon.visibleView === toolbar.view;
      }
      _isToolbarInBalloon(toolbar) {
        return this._balloon.hasView(toolbar.view);
      }
    }
    function repositionContextualBalloon$2(editor, relatedElement) {
      const balloon = editor.plugins.get("ContextualBalloon");
      const position = getBalloonPositionData$1(editor, relatedElement);
      balloon.updatePosition(position);
    }
    function getBalloonPositionData$1(editor, relatedElement) {
      const editingView = editor.editing.view;
      const defaultPositions = BalloonPanelView.defaultPositions;
      return {
        target: editingView.domConverter.mapViewToDom(relatedElement),
        positions: [
          defaultPositions.northArrowSouth,
          defaultPositions.northArrowSouthWest,
          defaultPositions.northArrowSouthEast,
          defaultPositions.southArrowNorth,
          defaultPositions.southArrowNorthWest,
          defaultPositions.southArrowNorthEast,
          defaultPositions.viewportStickyNorth
        ]
      };
    }
    function isWidgetSelected(selection) {
      const viewElement = selection.getSelectedElement();
      return !!(viewElement && isWidget(viewElement));
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ClipboardObserver extends DomEventObserver {
      constructor(view) {
        super(view);
        __publicField(this, "domEventType", [
          "paste",
          "copy",
          "cut",
          "drop",
          "dragover",
          "dragstart",
          "dragend",
          "dragenter",
          "dragleave"
        ]);
        const viewDocument = this.document;
        this.listenTo(viewDocument, "paste", handleInput("clipboardInput"), {
          priority: "low"
        });
        this.listenTo(viewDocument, "drop", handleInput("clipboardInput"), {
          priority: "low"
        });
        this.listenTo(viewDocument, "dragover", handleInput("dragging"), {
          priority: "low"
        });
        function handleInput(type) {
          return (evt, data) => {
            data.preventDefault();
            const targetRanges = data.dropRange ? [
              data.dropRange
            ] : null;
            const eventInfo = new EventInfo(viewDocument, type);
            viewDocument.fire(eventInfo, {
              dataTransfer: data.dataTransfer,
              method: evt.name,
              targetRanges,
              target: data.target,
              domEvent: data.domEvent
            });
            if (eventInfo.stop.called) {
              data.stopPropagation();
            }
          };
        }
      }
      onDomEvent(domEvent) {
        const nativeDataTransfer = "clipboardData" in domEvent ? domEvent.clipboardData : domEvent.dataTransfer;
        const cacheFiles = domEvent.type == "drop" || domEvent.type == "paste";
        const evtData = {
          dataTransfer: new DataTransfer(nativeDataTransfer, {
            cacheFiles
          })
        };
        if (domEvent.type == "drop" || domEvent.type == "dragover") {
          evtData.dropRange = getDropViewRange(this.view, domEvent);
        }
        this.fire(domEvent.type, domEvent, evtData);
      }
    }
    function getDropViewRange(view, domEvent) {
      const domDoc = domEvent.target.ownerDocument;
      const x = domEvent.clientX;
      const y = domEvent.clientY;
      let domRange;
      if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {
        domRange = domDoc.caretRangeFromPoint(x, y);
      } else if (domEvent.rangeParent) {
        domRange = domDoc.createRange();
        domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
        domRange.collapse(true);
      }
      if (domRange) {
        return view.domConverter.domRangeToView(domRange);
      }
      return null;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function plainTextToHtml(text2) {
      text2 = text2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;");
      if (text2.includes("</p><p>") || text2.includes("<br>")) {
        text2 = `<p>${text2}</p>`;
      }
      return text2;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function normalizeClipboardData(data) {
      return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
        if (spaces.length == 1) {
          return " ";
        }
        return spaces;
      }).replace(/<!--[\s\S]*?-->/g, "");
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const smallPaddingElements = [
      "figcaption",
      "li"
    ];
    const listElements = [
      "ol",
      "ul"
    ];
    function viewToPlainText(viewItem) {
      if (viewItem.is("$text") || viewItem.is("$textProxy")) {
        return viewItem.data;
      }
      if (viewItem.is("element", "img") && viewItem.hasAttribute("alt")) {
        return viewItem.getAttribute("alt");
      }
      if (viewItem.is("element", "br")) {
        return "\n";
      }
      let text2 = "";
      let prev = null;
      for (const child of viewItem.getChildren()) {
        text2 += newLinePadding(child, prev) + viewToPlainText(child);
        prev = child;
      }
      return text2;
    }
    function newLinePadding(element, previous) {
      if (!previous) {
        return "";
      }
      if (element.is("element", "li") && !element.isEmpty && element.getChild(0).is("containerElement")) {
        return "\n\n";
      }
      if (listElements.includes(element.name) && listElements.includes(previous.name)) {
        return "\n\n";
      }
      if (!element.is("containerElement") && !previous.is("containerElement")) {
        return "";
      }
      if (smallPaddingElements.includes(element.name) || smallPaddingElements.includes(previous.name)) {
        return "\n";
      }
      return "\n\n";
    }
    class ClipboardMarkersUtils extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Map of marker names that can be copied.
        *
        * @internal
        */
        __publicField(this, "_markersToCopy", /* @__PURE__ */ new Map());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ClipboardMarkersUtils";
      }
      /**
      * Registers marker name as copyable in clipboard pipeline.
      *
      * @param markerName Name of marker that can be copied.
      * @param config Configuration that describes what can be performed on specified marker.
      * @internal
      */
      _registerMarkerToCopy(markerName, config) {
        this._markersToCopy.set(markerName, config);
      }
      /**
      * Performs copy markers on provided selection and paste it to fragment returned from `getCopiedFragment`.
      *
      * 	1. Picks all markers in provided selection.
      * 	2. Inserts fake markers to document.
      * 	3. Gets copied selection fragment from document.
      * 	4. Removes fake elements from fragment and document.
      * 	5. Inserts markers in the place of removed fake markers.
      *
      * Due to selection modification, when inserting items, `getCopiedFragment` must *always* operate on `writer.model.document.selection'.
      * Do not use any other custom selection object within callback, as this will lead to out-of-bounds exceptions in rare scenarios.
      *
      * @param action Type of clipboard action.
      * @param writer An instance of the model writer.
      * @param selection Selection to be checked.
      * @param getCopiedFragment	Callback that performs copy of selection and returns it as fragment.
      * @internal
      */
      _copySelectedFragmentWithMarkers(action, selection, getCopiedFragment = (writer) => writer.model.getSelectedContent(writer.model.document.selection)) {
        return this.editor.model.change((writer) => {
          const oldSelection = writer.model.document.selection;
          writer.setSelection(selection);
          const sourceSelectionInsertedMarkers = this._insertFakeMarkersIntoSelection(writer, writer.model.document.selection, action);
          const fragment = getCopiedFragment(writer);
          const fakeMarkersRangesInsideRange = this._removeFakeMarkersInsideElement(writer, fragment);
          for (const [markerName, elements] of Object.entries(sourceSelectionInsertedMarkers)) {
            fakeMarkersRangesInsideRange[markerName] || (fakeMarkersRangesInsideRange[markerName] = writer.createRangeIn(fragment));
            for (const element of elements) {
              writer.remove(element);
            }
          }
          fragment.markers.clear();
          for (const [markerName, range] of Object.entries(fakeMarkersRangesInsideRange)) {
            fragment.markers.set(markerName, range);
          }
          writer.setSelection(oldSelection);
          return fragment;
        });
      }
      /**
      * Performs paste of markers on already pasted element.
      *
      * 	1. Inserts fake markers that are present in fragment element (such fragment will be processed in `getPastedDocumentElement`).
      * 	2. Calls `getPastedDocumentElement` and gets element that is inserted into root model.
      * 	3. Removes all fake markers present in transformed element.
      * 	4. Inserts new markers with removed fake markers ranges into pasted fragment.
      *
      * There are multiple edge cases that have to be considered before calling this function:
      *
      * 	* `markers` are inserted into the same element that must be later transformed inside `getPastedDocumentElement`.
      * 	* Fake marker elements inside `getPastedDocumentElement` can be cloned, but their ranges cannot overlap.
      * 	* If `duplicateOnPaste` is `true` in marker config then associated marker ID is regenerated before pasting.
      *
      * @param action Type of clipboard action.
      * @param markers Object that maps marker name to corresponding range.
      * @param getPastedDocumentElement Getter used to get target markers element.
      * @internal
      */
      _pasteMarkersIntoTransformedElement(markers, getPastedDocumentElement) {
        const pasteMarkers = this._getPasteMarkersFromRangeMap(markers);
        return this.editor.model.change((writer) => {
          const sourceFragmentFakeMarkers = this._insertFakeMarkersElements(writer, pasteMarkers);
          const transformedElement = getPastedDocumentElement(writer);
          const removedFakeMarkers = this._removeFakeMarkersInsideElement(writer, transformedElement);
          for (const element of Object.values(sourceFragmentFakeMarkers).flat()) {
            writer.remove(element);
          }
          for (const [markerName, range] of Object.entries(removedFakeMarkers)) {
            if (!writer.model.markers.has(markerName)) {
              writer.addMarker(markerName, {
                usingOperation: true,
                affectsData: true,
                range
              });
            }
          }
          return transformedElement;
        });
      }
      /**
      * Pastes document fragment with markers to document.
      * If `duplicateOnPaste` is `true` in marker config then associated markers IDs
      * are regenerated before pasting to avoid markers duplications in content.
      *
      * @param fragment Document fragment that should contain already processed by pipeline markers.
      * @internal
      */
      _pasteFragmentWithMarkers(fragment) {
        const pasteMarkers = this._getPasteMarkersFromRangeMap(fragment.markers);
        fragment.markers.clear();
        for (const copyableMarker of pasteMarkers) {
          fragment.markers.set(copyableMarker.name, copyableMarker.range);
        }
        return this.editor.model.insertContent(fragment);
      }
      /**
      * In some situations we have to perform copy on selected fragment with certain markers. This function allows to temporarily bypass
      * restrictions on markers that we want to copy.
      *
      * This function executes `executor()` callback. For the duration of the callback, if the clipboard pipeline is used to copy
      * content, markers with the specified name will be copied to the clipboard as well.
      *
      * @param markerName Which markers should be copied.
      * @param executor Callback executed.
      * @param config Optional configuration flags used to copy (such like partial copy flag).
      * @internal
      */
      _forceMarkersCopy(markerName, executor, config = {
        allowedActions: "all",
        copyPartiallySelected: true,
        duplicateOnPaste: true
      }) {
        const before = this._markersToCopy.get(markerName);
        this._markersToCopy.set(markerName, config);
        executor();
        if (before) {
          this._markersToCopy.set(markerName, before);
        } else {
          this._markersToCopy.delete(markerName);
        }
      }
      /**
      * Checks if marker can be copied.
      *
      * @param markerName Name of checked marker.
      * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
      * @internal
      */
      _isMarkerCopyable(markerName, action) {
        const config = this._getMarkerClipboardConfig(markerName);
        if (!config) {
          return false;
        }
        if (!action) {
          return true;
        }
        const { allowedActions } = config;
        return allowedActions === "all" || allowedActions.includes(action);
      }
      /**
      * Checks if marker has any clipboard copy behavior configuration.
      *
      * @param markerName Name of checked marker.
      */
      _hasMarkerConfiguration(markerName) {
        return !!this._getMarkerClipboardConfig(markerName);
      }
      /**
      * Returns marker's configuration flags passed during registration.
      *
      * @param markerName Name of marker that should be returned.
      * @internal
      */
      _getMarkerClipboardConfig(markerName) {
        const [markerNamePrefix] = markerName.split(":");
        return this._markersToCopy.get(markerNamePrefix) || null;
      }
      /**
      * First step of copying markers. It looks for markers intersecting with given selection and inserts `$marker` elements
      * at positions where document markers start or end. This way `$marker` elements can be easily copied together with
      * the rest of the content of the selection.
      *
      * @param writer An instance of the model writer.
      * @param selection Selection to be checked.
      * @param action Type of clipboard action.
      */
      _insertFakeMarkersIntoSelection(writer, selection, action) {
        const copyableMarkers = this._getCopyableMarkersFromSelection(writer, selection, action);
        return this._insertFakeMarkersElements(writer, copyableMarkers);
      }
      /**
      * Returns array of markers that can be copied in specified selection.
      *
      * If marker cannot be copied partially (according to `copyPartiallySelected` configuration flag) and
      * is not present entirely in any selection range then it will be skipped.
      *
      * @param writer An instance of the model writer.
      * @param selection  Selection which will be checked.
      * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
      */
      _getCopyableMarkersFromSelection(writer, selection, action) {
        const selectionRanges = Array.from(selection.getRanges());
        const markersInRanges = new Set(selectionRanges.flatMap((selectionRange) => Array.from(writer.model.markers.getMarkersIntersectingRange(selectionRange))));
        const isSelectionMarkerCopyable = (marker) => {
          const isCopyable = this._isMarkerCopyable(marker.name, action);
          if (!isCopyable) {
            return false;
          }
          const { copyPartiallySelected } = this._getMarkerClipboardConfig(marker.name);
          if (!copyPartiallySelected) {
            const markerRange = marker.getRange();
            return selectionRanges.some((selectionRange) => selectionRange.containsRange(markerRange, true));
          }
          return true;
        };
        return Array.from(markersInRanges).filter(isSelectionMarkerCopyable).map((copyableMarker) => {
          const name = action === "dragstart" ? this._getUniqueMarkerName(copyableMarker.name) : copyableMarker.name;
          return {
            name,
            range: copyableMarker.getRange()
          };
        });
      }
      /**
      * Picks all markers from markers map that can be pasted.
      * If `duplicateOnPaste` is `true`, it regenerates their IDs to ensure uniqueness.
      * If marker is not registered, it will be kept in the array anyway.
      *
      * @param markers Object that maps marker name to corresponding range.
      * @param action Type of clipboard action. If null then checks only if marker is registered as copyable.
      */
      _getPasteMarkersFromRangeMap(markers, action = null) {
        const { model } = this.editor;
        const entries = markers instanceof Map ? Array.from(markers.entries()) : Object.entries(markers);
        return entries.flatMap(([markerName, range]) => {
          if (!this._hasMarkerConfiguration(markerName)) {
            return [
              {
                name: markerName,
                range
              }
            ];
          }
          if (this._isMarkerCopyable(markerName, action)) {
            const copyMarkerConfig = this._getMarkerClipboardConfig(markerName);
            const isInGraveyard = model.markers.has(markerName) && model.markers.get(markerName).getRange().root.rootName === "$graveyard";
            if (copyMarkerConfig.duplicateOnPaste || isInGraveyard) {
              markerName = this._getUniqueMarkerName(markerName);
            }
            return [
              {
                name: markerName,
                range
              }
            ];
          }
          return [];
        });
      }
      /**
      * Inserts specified array of fake markers elements to document and assigns them `type` and `name` attributes.
      * Fake markers elements are used to calculate position of markers on pasted fragment that were transformed during
      * steps between copy and paste.
      *
      * @param writer An instance of the model writer.
      * @param markers Array of markers that will be inserted.
      */
      _insertFakeMarkersElements(writer, markers) {
        const mappedMarkers = {};
        const sortedMarkers = markers.flatMap((marker) => {
          const { start, end } = marker.range;
          return [
            {
              position: start,
              marker,
              type: "start"
            },
            {
              position: end,
              marker,
              type: "end"
            }
          ];
        }).sort(({ position: posA }, { position: posB }) => posA.isBefore(posB) ? 1 : -1);
        for (const { position, marker, type } of sortedMarkers) {
          const fakeMarker = writer.createElement("$marker", {
            "data-name": marker.name,
            "data-type": type
          });
          if (!mappedMarkers[marker.name]) {
            mappedMarkers[marker.name] = [];
          }
          mappedMarkers[marker.name].push(fakeMarker);
          writer.insert(fakeMarker, position);
        }
        return mappedMarkers;
      }
      /**
      * Removes all `$marker` elements from the given document fragment.
      *
      * Returns an object where keys are marker names, and values are ranges corresponding to positions
      * where `$marker` elements were inserted.
      *
      * If the document fragment had only one `$marker` element for given marker (start or end) the other boundary is set automatically
      * (to the end or start of the document fragment, respectively).
      *
      * @param writer An instance of the model writer.
      * @param rootElement The element to be checked.
      */
      _removeFakeMarkersInsideElement(writer, rootElement) {
        const fakeMarkersElements = this._getAllFakeMarkersFromElement(writer, rootElement);
        const fakeMarkersRanges = fakeMarkersElements.reduce((acc, fakeMarker) => {
          const position = fakeMarker.markerElement && writer.createPositionBefore(fakeMarker.markerElement);
          let prevFakeMarker = acc[fakeMarker.name];
          let skipAssign = false;
          if (prevFakeMarker && prevFakeMarker.start && prevFakeMarker.end) {
            const config = this._getMarkerClipboardConfig(fakeMarker.name);
            if (config.duplicateOnPaste) {
              acc[this._getUniqueMarkerName(fakeMarker.name)] = acc[fakeMarker.name];
            } else {
              skipAssign = true;
            }
            prevFakeMarker = null;
          }
          if (!skipAssign) {
            acc[fakeMarker.name] = {
              ...prevFakeMarker,
              [fakeMarker.type]: position
            };
          }
          if (fakeMarker.markerElement) {
            writer.remove(fakeMarker.markerElement);
          }
          return acc;
        }, {});
        return mapValues(fakeMarkersRanges, (range) => new Range(range.start || writer.createPositionFromPath(rootElement, [
          0
        ]), range.end || writer.createPositionAt(rootElement, "end")));
      }
      /**
      * Returns array that contains list of fake markers with corresponding `$marker` elements.
      *
      * For each marker, there can be two `$marker` elements or only one (if the document fragment contained
      * only the beginning or only the end of a marker).
      *
      * @param writer An instance of the model writer.
      * @param rootElement The element to be checked.
      */
      _getAllFakeMarkersFromElement(writer, rootElement) {
        const foundFakeMarkers = Array.from(writer.createRangeIn(rootElement)).flatMap(({ item }) => {
          if (!item.is("element", "$marker")) {
            return [];
          }
          const name = item.getAttribute("data-name");
          const type = item.getAttribute("data-type");
          return [
            {
              markerElement: item,
              name,
              type
            }
          ];
        });
        const prependFakeMarkers = [];
        const appendFakeMarkers = [];
        for (const fakeMarker of foundFakeMarkers) {
          if (fakeMarker.type === "end") {
            const hasMatchingStartMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "start");
            if (!hasMatchingStartMarker) {
              prependFakeMarkers.push({
                markerElement: null,
                name: fakeMarker.name,
                type: "start"
              });
            }
          }
          if (fakeMarker.type === "start") {
            const hasMatchingEndMarker = foundFakeMarkers.some((otherFakeMarker) => otherFakeMarker.name === fakeMarker.name && otherFakeMarker.type === "end");
            if (!hasMatchingEndMarker) {
              appendFakeMarkers.unshift({
                markerElement: null,
                name: fakeMarker.name,
                type: "end"
              });
            }
          }
        }
        return [
          ...prependFakeMarkers,
          ...foundFakeMarkers,
          ...appendFakeMarkers
        ];
      }
      /**
      * When copy of markers occurs we have to make sure that pasted markers have different names
      * than source markers. This functions helps with assigning unique part to marker name to
      * prevent duplicated markers error.
      *
      * @param name Name of marker
      */
      _getUniqueMarkerName(name) {
        const parts = name.split(":");
        const newId = uid().substring(1, 6);
        if (parts.length === 3) {
          return `${parts.slice(0, 2).join(":")}:${newId}`;
        }
        return `${parts.join(":")}:${newId}`;
      }
    }
    class ClipboardPipeline extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ClipboardPipeline";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardMarkersUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const view = editor.editing.view;
        view.addObserver(ClipboardObserver);
        this._setupPasteDrop();
        this._setupCopyCut();
      }
      /**
      * Fires Clipboard `'outputTransformation'` event for given parameters.
      *
      * @internal
      */
      _fireOutputTransformationEvent(dataTransfer, selection, method) {
        const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
        this.editor.model.enqueueChange({
          isUndoable: method === "cut"
        }, () => {
          const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(method, selection);
          this.fire("outputTransformation", {
            dataTransfer,
            content: documentFragment,
            method
          });
        });
      }
      /**
      * The clipboard paste pipeline.
      */
      _setupPasteDrop() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const clipboardMarkersUtils = this.editor.plugins.get("ClipboardMarkersUtils");
        this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
          if (data.method == "paste" && !editor.model.canEditAt(editor.model.document.selection)) {
            evt.stop();
          }
        }, {
          priority: "highest"
        });
        this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
          const dataTransfer = data.dataTransfer;
          let content;
          if (data.content) {
            content = data.content;
          } else {
            let contentData = "";
            if (dataTransfer.getData("text/html")) {
              contentData = normalizeClipboardData(dataTransfer.getData("text/html"));
            } else if (dataTransfer.getData("text/plain")) {
              contentData = plainTextToHtml(dataTransfer.getData("text/plain"));
            }
            content = this.editor.data.htmlProcessor.toView(contentData);
          }
          const eventInfo = new EventInfo(this, "inputTransformation");
          this.fire(eventInfo, {
            content,
            dataTransfer,
            targetRanges: data.targetRanges,
            method: data.method
          });
          if (eventInfo.stop.called) {
            evt.stop();
          }
          view.scrollToTheSelection();
        }, {
          priority: "low"
        });
        this.listenTo(this, "inputTransformation", (evt, data) => {
          if (data.content.isEmpty) {
            return;
          }
          const dataController = this.editor.data;
          const modelFragment = dataController.toModel(data.content, "$clipboardHolder");
          if (modelFragment.childCount == 0) {
            return;
          }
          evt.stop();
          model.change(() => {
            this.fire("contentInsertion", {
              content: modelFragment,
              method: data.method,
              dataTransfer: data.dataTransfer,
              targetRanges: data.targetRanges
            });
          });
        }, {
          priority: "low"
        });
        this.listenTo(this, "contentInsertion", (evt, data) => {
          data.resultRange = clipboardMarkersUtils._pasteFragmentWithMarkers(data.content);
        }, {
          priority: "low"
        });
      }
      /**
      * The clipboard copy/cut pipeline.
      */
      _setupCopyCut() {
        const editor = this.editor;
        const modelDocument = editor.model.document;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const onCopyCut = (evt, data) => {
          const dataTransfer = data.dataTransfer;
          data.preventDefault();
          this._fireOutputTransformationEvent(dataTransfer, modelDocument.selection, evt.name);
        };
        this.listenTo(viewDocument, "copy", onCopyCut, {
          priority: "low"
        });
        this.listenTo(viewDocument, "cut", (evt, data) => {
          if (!editor.model.canEditAt(editor.model.document.selection)) {
            data.preventDefault();
          } else {
            onCopyCut(evt, data);
          }
        }, {
          priority: "low"
        });
        this.listenTo(this, "outputTransformation", (evt, data) => {
          const content = editor.data.toView(data.content);
          viewDocument.fire("clipboardOutput", {
            dataTransfer: data.dataTransfer,
            content,
            method: data.method
          });
        }, {
          priority: "low"
        });
        this.listenTo(viewDocument, "clipboardOutput", (evt, data) => {
          if (!data.content.isEmpty) {
            data.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(data.content));
            data.dataTransfer.setData("text/plain", viewToPlainText(data.content));
          }
          if (data.method == "cut") {
            editor.model.deleteContent(modelDocument.selection);
          }
        }, {
          priority: "low"
        });
      }
    }
    const toPx$1 = /* @__PURE__ */ toUnit("px");
    class LineView extends View {
      /**
      * @inheritDoc
      */
      constructor() {
        super();
        const bind = this.bindTemplate;
        this.set({
          isVisible: false,
          left: null,
          top: null,
          width: null
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-clipboard-drop-target-line",
              bind.if("isVisible", "ck-hidden", (value) => !value)
            ],
            style: {
              left: bind.to("left", (left) => toPx$1(left)),
              top: bind.to("top", (top) => toPx$1(top)),
              width: bind.to("width", (width) => toPx$1(width))
            }
          }
        });
      }
    }
    class DragDropTarget extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * A delayed callback removing the drop marker.
        *
        * @internal
        */
        __publicField(this, "removeDropMarkerDelayed", delay(() => this.removeDropMarker(), 40));
        /**
        * A throttled callback updating the drop marker.
        */
        __publicField(this, "_updateDropMarkerThrottled", throttle((targetRange) => this._updateDropMarker(targetRange), 40));
        /**
        * A throttled callback reconverting the drop parker.
        */
        __publicField(this, "_reconvertMarkerThrottled", throttle(() => {
          if (this.editor.model.markers.has("drop-target")) {
            this.editor.editing.reconvertMarker("drop-target");
          }
        }, 0));
        /**
        * The horizontal drop target line view.
        */
        __publicField(this, "_dropTargetLineView", new LineView());
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
        /**
        * Map of document scrollable elements.
        */
        __publicField(this, "_scrollables", /* @__PURE__ */ new Map());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DragDropTarget";
      }
      /**
      * @inheritDoc
      */
      init() {
        this._setupDropMarker();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._domEmitter.stopListening();
        for (const { resizeObserver } of this._scrollables.values()) {
          resizeObserver.destroy();
        }
        this._updateDropMarkerThrottled.cancel();
        this.removeDropMarkerDelayed.cancel();
        this._reconvertMarkerThrottled.cancel();
        return super.destroy();
      }
      /**
      * Finds the drop target range and updates the drop marker.
      *
      * @internal
      */
      updateDropMarker(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        this.removeDropMarkerDelayed.cancel();
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        /* istanbul ignore next -- @preserve */
        if (!targetRange) {
          return;
        }
        if (draggedRange && draggedRange.containsRange(targetRange)) {
          return this.removeDropMarker();
        }
        this._updateDropMarkerThrottled(targetRange);
      }
      /**
      * Finds the final drop target range.
      *
      * @internal
      */
      getFinalDropRange(targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
        const targetRange = findDropTargetRange(this.editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange);
        this.removeDropMarker();
        return targetRange;
      }
      /**
      * Removes the drop target marker.
      *
      * @internal
      */
      removeDropMarker() {
        const model = this.editor.model;
        this.removeDropMarkerDelayed.cancel();
        this._updateDropMarkerThrottled.cancel();
        this._dropTargetLineView.isVisible = false;
        if (model.markers.has("drop-target")) {
          model.change((writer) => {
            writer.removeMarker("drop-target");
          });
        }
      }
      /**
      * Creates downcast conversion for the drop target marker.
      */
      _setupDropMarker() {
        const editor = this.editor;
        editor.ui.view.body.add(this._dropTargetLineView);
        editor.conversion.for("editingDowncast").markerToHighlight({
          model: "drop-target",
          view: {
            classes: [
              "ck-clipboard-drop-target-range"
            ]
          }
        });
        editor.conversion.for("editingDowncast").markerToElement({
          model: "drop-target",
          view: (data, { writer }) => {
            if (editor.model.schema.checkChild(data.markerRange.start, "$text")) {
              this._dropTargetLineView.isVisible = false;
              return this._createDropTargetPosition(writer);
            } else {
              if (data.markerRange.isCollapsed) {
                this._updateDropTargetLine(data.markerRange);
              } else {
                this._dropTargetLineView.isVisible = false;
              }
            }
          }
        });
      }
      /**
      * Updates the drop target marker to the provided range.
      *
      * @param targetRange The range to set the marker to.
      */
      _updateDropMarker(targetRange) {
        const editor = this.editor;
        const markers = editor.model.markers;
        editor.model.change((writer) => {
          if (markers.has("drop-target")) {
            if (!markers.get("drop-target").getRange().isEqual(targetRange)) {
              writer.updateMarker("drop-target", {
                range: targetRange
              });
            }
          } else {
            writer.addMarker("drop-target", {
              range: targetRange,
              usingOperation: false,
              affectsData: false
            });
          }
        });
      }
      /**
      * Creates the UI element for vertical (in-line) drop target.
      */
      _createDropTargetPosition(writer) {
        return writer.createUIElement("span", {
          class: "ck ck-clipboard-drop-target-position"
        }, function(domDocument) {
          const domElement = this.toDomElement(domDocument);
          domElement.append("⁠", domDocument.createElement("span"), "⁠");
          return domElement;
        });
      }
      /**
      * Updates the horizontal drop target line.
      */
      _updateDropTargetLine(range) {
        const editing = this.editor.editing;
        const nodeBefore = range.start.nodeBefore;
        const nodeAfter = range.start.nodeAfter;
        const nodeParent = range.start.parent;
        const viewElementBefore = nodeBefore ? editing.mapper.toViewElement(nodeBefore) : null;
        const domElementBefore = viewElementBefore ? editing.view.domConverter.mapViewToDom(viewElementBefore) : null;
        const viewElementAfter = nodeAfter ? editing.mapper.toViewElement(nodeAfter) : null;
        const domElementAfter = viewElementAfter ? editing.view.domConverter.mapViewToDom(viewElementAfter) : null;
        const viewElementParent = editing.mapper.toViewElement(nodeParent);
        if (!viewElementParent) {
          return;
        }
        const domElementParent = editing.view.domConverter.mapViewToDom(viewElementParent);
        const domScrollableRect = this._getScrollableRect(viewElementParent);
        const { scrollX, scrollY } = global$1.window;
        const rectBefore = domElementBefore ? new Rect(domElementBefore) : null;
        const rectAfter = domElementAfter ? new Rect(domElementAfter) : null;
        const rectParent = new Rect(domElementParent).excludeScrollbarsAndBorders();
        const above = rectBefore ? rectBefore.bottom : rectParent.top;
        const below = rectAfter ? rectAfter.top : rectParent.bottom;
        const parentStyle = global$1.window.getComputedStyle(domElementParent);
        const top = above <= below ? (above + below) / 2 : below;
        if (domScrollableRect.top < top && top < domScrollableRect.bottom) {
          const left = rectParent.left + parseFloat(parentStyle.paddingLeft);
          const right = rectParent.right - parseFloat(parentStyle.paddingRight);
          const leftClamped = Math.max(left + scrollX, domScrollableRect.left);
          const rightClamped = Math.min(right + scrollX, domScrollableRect.right);
          this._dropTargetLineView.set({
            isVisible: true,
            left: leftClamped,
            top: top + scrollY,
            width: rightClamped - leftClamped
          });
        } else {
          this._dropTargetLineView.isVisible = false;
        }
      }
      /**
      * Finds the closest scrollable element rect for the given view element.
      */
      _getScrollableRect(viewElement) {
        const rootName = viewElement.root.rootName;
        let domScrollable;
        if (this._scrollables.has(rootName)) {
          domScrollable = this._scrollables.get(rootName).domElement;
        } else {
          const domElement = this.editor.editing.view.domConverter.mapViewToDom(viewElement);
          domScrollable = findScrollableElement(domElement);
          this._domEmitter.listenTo(domScrollable, "scroll", this._reconvertMarkerThrottled, {
            usePassive: true
          });
          const resizeObserver = new ResizeObserver(domScrollable, this._reconvertMarkerThrottled);
          this._scrollables.set(rootName, {
            domElement: domScrollable,
            resizeObserver
          });
        }
        return new Rect(domScrollable).excludeScrollbarsAndBorders();
      }
    }
    function findDropTargetRange(editor, targetViewElement, targetViewRanges, clientX, clientY, blockMode, draggedRange) {
      const model = editor.model;
      const mapper = editor.editing.mapper;
      const targetModelElement = getClosestMappedModelElement(editor, targetViewElement);
      let modelElement = targetModelElement;
      while (modelElement) {
        if (!blockMode) {
          if (model.schema.checkChild(modelElement, "$text")) {
            if (targetViewRanges) {
              const targetViewPosition = targetViewRanges[0].start;
              const targetModelPosition = mapper.toModelPosition(targetViewPosition);
              const canDropOnPosition = !draggedRange || Array.from(draggedRange.getItems()).every((item) => model.schema.checkChild(targetModelPosition, item));
              if (canDropOnPosition) {
                if (model.schema.checkChild(targetModelPosition, "$text")) {
                  return model.createRange(targetModelPosition);
                } else if (targetViewPosition) {
                  return findDropTargetRangeForElement(editor, getClosestMappedModelElement(editor, targetViewPosition.parent), clientX, clientY);
                }
              }
            }
          } else if (model.schema.isInline(modelElement)) {
            return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
          }
        }
        if (model.schema.isBlock(modelElement)) {
          return findDropTargetRangeForElement(editor, modelElement, clientX, clientY);
        } else if (model.schema.checkChild(modelElement, "$block")) {
          const childNodes = Array.from(modelElement.getChildren()).filter((node) => node.is("element") && !shouldIgnoreElement(editor, node));
          let startIndex = 0;
          let endIndex = childNodes.length;
          if (endIndex == 0) {
            return model.createRange(model.createPositionAt(modelElement, "end"));
          }
          while (startIndex < endIndex - 1) {
            const middleIndex = Math.floor((startIndex + endIndex) / 2);
            const side = findElementSide(editor, childNodes[middleIndex], clientX, clientY);
            if (side == "before") {
              endIndex = middleIndex;
            } else {
              startIndex = middleIndex;
            }
          }
          return findDropTargetRangeForElement(editor, childNodes[startIndex], clientX, clientY);
        }
        modelElement = modelElement.parent;
      }
      return null;
    }
    function shouldIgnoreElement(editor, modelElement) {
      const mapper = editor.editing.mapper;
      const domConverter = editor.editing.view.domConverter;
      const viewElement = mapper.toViewElement(modelElement);
      if (!viewElement) {
        return true;
      }
      const domElement = domConverter.mapViewToDom(viewElement);
      return global$1.window.getComputedStyle(domElement).float != "none";
    }
    function findDropTargetRangeForElement(editor, modelElement, clientX, clientY) {
      const model = editor.model;
      return model.createRange(model.createPositionAt(modelElement, findElementSide(editor, modelElement, clientX, clientY)));
    }
    function findElementSide(editor, modelElement, clientX, clientY) {
      const mapper = editor.editing.mapper;
      const domConverter = editor.editing.view.domConverter;
      const viewElement = mapper.toViewElement(modelElement);
      const domElement = domConverter.mapViewToDom(viewElement);
      const rect = new Rect(domElement);
      if (editor.model.schema.isInline(modelElement)) {
        return clientX < (rect.left + rect.right) / 2 ? "before" : "after";
      } else {
        return clientY < (rect.top + rect.bottom) / 2 ? "before" : "after";
      }
    }
    function getClosestMappedModelElement(editor, element) {
      const mapper = editor.editing.mapper;
      const view = editor.editing.view;
      const targetModelElement = mapper.toModelElement(element);
      if (targetModelElement) {
        return targetModelElement;
      }
      const viewPosition = view.createPositionBefore(element);
      const viewElement = mapper.findMappedViewAncestor(viewPosition);
      return mapper.toModelElement(viewElement);
    }
    function findScrollableElement(domNode) {
      let domElement = domNode;
      do {
        domElement = domElement.parentElement;
        const overflow = global$1.window.getComputedStyle(domElement).overflowY;
        if (overflow == "auto" || overflow == "scroll") {
          break;
        }
      } while (domElement.tagName != "BODY");
      return domElement;
    }
    class DragDropBlockToolbar extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * Whether current dragging is started by block toolbar button dragging.
        */
        __publicField(this, "_isBlockDragging", false);
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DragDropBlockToolbar";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
          if (isReadOnly) {
            this.forceDisabled("readOnlyMode");
            this._isBlockDragging = false;
          } else {
            this.clearForceDisabled("readOnlyMode");
          }
        });
        if (env.isAndroid) {
          this.forceDisabled("noAndroidSupport");
        }
        if (editor.plugins.has("BlockToolbar")) {
          const blockToolbar = editor.plugins.get("BlockToolbar");
          const element = blockToolbar.buttonView.element;
          this._domEmitter.listenTo(element, "dragstart", (evt, data) => this._handleBlockDragStart(data));
          this._domEmitter.listenTo(global$1.document, "dragover", (evt, data) => this._handleBlockDragging(data));
          this._domEmitter.listenTo(global$1.document, "drop", (evt, data) => this._handleBlockDragging(data));
          this._domEmitter.listenTo(global$1.document, "dragend", () => this._handleBlockDragEnd(), {
            useCapture: true
          });
          if (this.isEnabled) {
            element.setAttribute("draggable", "true");
          }
          this.on("change:isEnabled", (evt, name, isEnabled2) => {
            element.setAttribute("draggable", isEnabled2 ? "true" : "false");
          });
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._domEmitter.stopListening();
        return super.destroy();
      }
      /**
      * The `dragstart` event handler.
      */
      _handleBlockDragStart(domEvent) {
        if (!this.isEnabled) {
          return;
        }
        const model = this.editor.model;
        const selection = model.document.selection;
        const view = this.editor.editing.view;
        const blocks = Array.from(selection.getSelectedBlocks());
        const draggedRange = model.createRange(model.createPositionBefore(blocks[0]), model.createPositionAfter(blocks[blocks.length - 1]));
        model.change((writer) => writer.setSelection(draggedRange));
        this._isBlockDragging = true;
        view.focus();
        view.getObserver(ClipboardObserver).onDomEvent(domEvent);
      }
      /**
      * The `dragover` and `drop` event handler.
      */
      _handleBlockDragging(domEvent) {
        if (!this.isEnabled || !this._isBlockDragging) {
          return;
        }
        const clientX = domEvent.clientX + (this.editor.locale.contentLanguageDirection == "ltr" ? 100 : -100);
        const clientY = domEvent.clientY;
        const target = document.elementFromPoint(clientX, clientY);
        const view = this.editor.editing.view;
        if (!target || !target.closest(".ck-editor__editable")) {
          return;
        }
        view.getObserver(ClipboardObserver).onDomEvent({
          ...domEvent,
          type: domEvent.type,
          dataTransfer: domEvent.dataTransfer,
          target,
          clientX,
          clientY,
          preventDefault: () => domEvent.preventDefault(),
          stopPropagation: () => domEvent.stopPropagation()
        });
      }
      /**
      * The `dragend` event handler.
      */
      _handleBlockDragEnd() {
        this._isBlockDragging = false;
      }
    }
    class DragDrop extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The live range over the original content that is being dragged.
        */
        __publicField(this, "_draggedRange");
        /**
        * The UID of current dragging that is used to verify if the drop started in the same editor as the drag start.
        *
        * **Note**: This is a workaround for broken 'dragend' events (they are not fired if the source text node got removed).
        */
        __publicField(this, "_draggingUid");
        /**
        * The reference to the model element that currently has a `draggable` attribute set (it is set while dragging).
        */
        __publicField(this, "_draggableElement");
        /**
        * A delayed callback removing draggable attributes.
        */
        __publicField(this, "_clearDraggableAttributesDelayed", delay(() => this._clearDraggableAttributes(), 40));
        /**
        * Whether the dragged content can be dropped only in block context.
        */
        // TODO handle drag from other editor instance
        // TODO configure to use block, inline or both
        __publicField(this, "_blockMode", false);
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
        /**
        * The DOM element used to generate dragged preview image.
        */
        __publicField(this, "_previewContainer");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DragDrop";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardPipeline,
          Widget,
          DragDropTarget,
          DragDropBlockToolbar
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const view = editor.editing.view;
        this._draggedRange = null;
        this._draggingUid = "";
        this._draggableElement = null;
        view.addObserver(ClipboardObserver);
        view.addObserver(MouseObserver);
        this._setupDragging();
        this._setupContentInsertionIntegration();
        this._setupClipboardInputIntegration();
        this._setupDraggableAttributeHandling();
        this.listenTo(editor, "change:isReadOnly", (evt, name, isReadOnly) => {
          if (isReadOnly) {
            this.forceDisabled("readOnlyMode");
          } else {
            this.clearForceDisabled("readOnlyMode");
          }
        });
        this.on("change:isEnabled", (evt, name, isEnabled2) => {
          if (!isEnabled2) {
            this._finalizeDragging(false);
          }
        });
        if (env.isAndroid) {
          this.forceDisabled("noAndroidSupport");
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        if (this._draggedRange) {
          this._draggedRange.detach();
          this._draggedRange = null;
        }
        if (this._previewContainer) {
          this._previewContainer.remove();
        }
        this._domEmitter.stopListening();
        this._clearDraggableAttributesDelayed.cancel();
        return super.destroy();
      }
      /**
      * Drag and drop events handling.
      */
      _setupDragging() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const dragDropTarget = editor.plugins.get(DragDropTarget);
        this.listenTo(viewDocument, "dragstart", (evt, data) => {
          if (data.target && data.target.is("editableElement")) {
            data.preventDefault();
            return;
          }
          this._prepareDraggedRange(data.target);
          if (!this._draggedRange) {
            data.preventDefault();
            return;
          }
          this._draggingUid = uid();
          data.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy";
          data.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
          const draggedSelection = model.createSelection(this._draggedRange.toRange());
          const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
          clipboardPipeline._fireOutputTransformationEvent(data.dataTransfer, draggedSelection, "dragstart");
          const { dataTransfer, domTarget, domEvent } = data;
          const { clientX } = domEvent;
          this._updatePreview({
            dataTransfer,
            domTarget,
            clientX
          });
          data.stopPropagation();
          if (!this.isEnabled) {
            this._draggedRange.detach();
            this._draggedRange = null;
            this._draggingUid = "";
          }
        }, {
          priority: "low"
        });
        this.listenTo(viewDocument, "dragend", (evt, data) => {
          this._finalizeDragging(!data.dataTransfer.isCanceled && data.dataTransfer.dropEffect == "move");
        }, {
          priority: "low"
        });
        this._domEmitter.listenTo(global$1.document, "dragend", () => {
          this._blockMode = false;
        }, {
          useCapture: true
        });
        this.listenTo(viewDocument, "dragenter", () => {
          if (!this.isEnabled) {
            return;
          }
          view.focus();
        });
        this.listenTo(viewDocument, "dragleave", () => {
          dragDropTarget.removeDropMarkerDelayed();
        });
        this.listenTo(viewDocument, "dragging", (evt, data) => {
          if (!this.isEnabled) {
            data.dataTransfer.dropEffect = "none";
            return;
          }
          const { clientX, clientY } = data.domEvent;
          dragDropTarget.updateDropMarker(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
          if (!this._draggedRange) {
            data.dataTransfer.dropEffect = "copy";
          }
          if (!env.isGecko) {
            if (data.dataTransfer.effectAllowed == "copy") {
              data.dataTransfer.dropEffect = "copy";
            } else if ([
              "all",
              "copyMove"
            ].includes(data.dataTransfer.effectAllowed)) {
              data.dataTransfer.dropEffect = "move";
            }
          }
          evt.stop();
        }, {
          priority: "low"
        });
      }
      /**
      * Integration with the `clipboardInput` event.
      */
      _setupClipboardInputIntegration() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const dragDropTarget = editor.plugins.get(DragDropTarget);
        this.listenTo(viewDocument, "clipboardInput", (evt, data) => {
          if (data.method != "drop") {
            return;
          }
          const { clientX, clientY } = data.domEvent;
          const targetRange = dragDropTarget.getFinalDropRange(data.target, data.targetRanges, clientX, clientY, this._blockMode, this._draggedRange);
          if (!targetRange) {
            this._finalizeDragging(false);
            evt.stop();
            return;
          }
          if (this._draggedRange && this._draggingUid != data.dataTransfer.getData("application/ckeditor5-dragging-uid")) {
            this._draggedRange.detach();
            this._draggedRange = null;
            this._draggingUid = "";
          }
          const isMove = getFinalDropEffect(data.dataTransfer) == "move";
          if (isMove && this._draggedRange && this._draggedRange.containsRange(targetRange, true)) {
            this._finalizeDragging(false);
            evt.stop();
            return;
          }
          data.targetRanges = [
            editor.editing.mapper.toViewRange(targetRange)
          ];
        }, {
          priority: "high"
        });
      }
      /**
      * Integration with the `contentInsertion` event of the clipboard pipeline.
      */
      _setupContentInsertionIntegration() {
        const clipboardPipeline = this.editor.plugins.get(ClipboardPipeline);
        clipboardPipeline.on("contentInsertion", (evt, data) => {
          if (!this.isEnabled || data.method !== "drop") {
            return;
          }
          const ranges = data.targetRanges.map((viewRange) => this.editor.editing.mapper.toModelRange(viewRange));
          this.editor.model.change((writer) => writer.setSelection(ranges));
        }, {
          priority: "high"
        });
        clipboardPipeline.on("contentInsertion", (evt, data) => {
          if (!this.isEnabled || data.method !== "drop") {
            return;
          }
          const isMove = getFinalDropEffect(data.dataTransfer) == "move";
          const isSuccess = !data.resultRange || !data.resultRange.isCollapsed;
          this._finalizeDragging(isSuccess && isMove);
        }, {
          priority: "lowest"
        });
      }
      /**
      * Adds listeners that add the `draggable` attribute to the elements while the mouse button is down so the dragging could start.
      */
      _setupDraggableAttributeHandling() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        this.listenTo(viewDocument, "mousedown", (evt, data) => {
          if (env.isAndroid || !data) {
            return;
          }
          this._clearDraggableAttributesDelayed.cancel();
          let draggableElement = findDraggableWidget(data.target);
          if (env.isBlink && !editor.isReadOnly && !draggableElement && !viewDocument.selection.isCollapsed) {
            const selectedElement = viewDocument.selection.getSelectedElement();
            if (!selectedElement || !isWidget(selectedElement)) {
              draggableElement = viewDocument.selection.editableElement;
            }
          }
          if (draggableElement) {
            view.change((writer) => {
              writer.setAttribute("draggable", "true", draggableElement);
            });
            this._draggableElement = editor.editing.mapper.toModelElement(draggableElement);
          }
        });
        this.listenTo(viewDocument, "mouseup", () => {
          if (!env.isAndroid) {
            this._clearDraggableAttributesDelayed();
          }
        });
      }
      /**
      * Removes the `draggable` attribute from the element that was used for dragging.
      */
      _clearDraggableAttributes() {
        const editing = this.editor.editing;
        editing.view.change((writer) => {
          if (this._draggableElement && this._draggableElement.root.rootName != "$graveyard") {
            writer.removeAttribute("draggable", editing.mapper.toViewElement(this._draggableElement));
          }
          this._draggableElement = null;
        });
      }
      /**
      * Deletes the dragged content from its original range and clears the dragging state.
      *
      * @param moved Whether the move succeeded.
      */
      _finalizeDragging(moved) {
        const editor = this.editor;
        const model = editor.model;
        const dragDropTarget = editor.plugins.get(DragDropTarget);
        dragDropTarget.removeDropMarker();
        this._clearDraggableAttributes();
        if (editor.plugins.has("WidgetToolbarRepository")) {
          const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
          widgetToolbarRepository.clearForceDisabled("dragDrop");
        }
        this._draggingUid = "";
        if (this._previewContainer) {
          this._previewContainer.remove();
          this._previewContainer = void 0;
        }
        if (!this._draggedRange) {
          return;
        }
        if (moved && this.isEnabled) {
          model.change((writer) => {
            const selection = model.createSelection(this._draggedRange);
            model.deleteContent(selection, {
              doNotAutoparagraph: true
            });
            const selectionParent = selection.getFirstPosition().parent;
            if (selectionParent.isEmpty && !model.schema.checkChild(selectionParent, "$text") && model.schema.checkChild(selectionParent, "paragraph")) {
              writer.insertElement("paragraph", selectionParent, 0);
            }
          });
        }
        this._draggedRange.detach();
        this._draggedRange = null;
      }
      /**
      * Sets the dragged source range based on event target and document selection.
      */
      _prepareDraggedRange(target) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const draggableWidget = target ? findDraggableWidget(target) : null;
        if (draggableWidget) {
          const modelElement = editor.editing.mapper.toModelElement(draggableWidget);
          this._draggedRange = LiveRange.fromRange(model.createRangeOn(modelElement));
          this._blockMode = model.schema.isBlock(modelElement);
          if (editor.plugins.has("WidgetToolbarRepository")) {
            const widgetToolbarRepository = editor.plugins.get("WidgetToolbarRepository");
            widgetToolbarRepository.forceDisabled("dragDrop");
          }
          return;
        }
        if (selection.isCollapsed && !selection.getFirstPosition().parent.isEmpty) {
          return;
        }
        const blocks = Array.from(selection.getSelectedBlocks());
        const draggedRange = selection.getFirstRange();
        if (blocks.length == 0) {
          this._draggedRange = LiveRange.fromRange(draggedRange);
          return;
        }
        const blockRange = getRangeIncludingFullySelectedParents(model, blocks);
        if (blocks.length > 1) {
          this._draggedRange = LiveRange.fromRange(blockRange);
          this._blockMode = true;
        } else if (blocks.length == 1) {
          const touchesBlockEdges = draggedRange.start.isTouching(blockRange.start) && draggedRange.end.isTouching(blockRange.end);
          this._draggedRange = LiveRange.fromRange(touchesBlockEdges ? blockRange : draggedRange);
          this._blockMode = touchesBlockEdges;
        }
        model.change((writer) => writer.setSelection(this._draggedRange.toRange()));
      }
      /**
      * Updates the dragged preview image.
      */
      _updatePreview({ dataTransfer, domTarget, clientX }) {
        const view = this.editor.editing.view;
        const editable = view.document.selection.editableElement;
        const domEditable = view.domConverter.mapViewToDom(editable);
        const computedStyle = global$1.window.getComputedStyle(domEditable);
        if (!this._previewContainer) {
          this._previewContainer = createElement(global$1.document, "div", {
            style: "position: fixed; left: -999999px;"
          });
          global$1.document.body.appendChild(this._previewContainer);
        } else if (this._previewContainer.firstElementChild) {
          this._previewContainer.removeChild(this._previewContainer.firstElementChild);
        }
        const domRect = new Rect(domEditable);
        if (domEditable.contains(domTarget)) {
          return;
        }
        const domEditablePaddingLeft = parseFloat(computedStyle.paddingLeft);
        const preview = createElement(global$1.document, "div");
        preview.className = "ck ck-content";
        preview.style.width = computedStyle.width;
        preview.style.paddingLeft = `${domRect.left - clientX + domEditablePaddingLeft}px`;
        if (env.isiOS) {
          preview.style.backgroundColor = "white";
        }
        preview.innerHTML = dataTransfer.getData("text/html");
        dataTransfer.setDragImage(preview, 0, 0);
        this._previewContainer.appendChild(preview);
      }
    }
    function getFinalDropEffect(dataTransfer) {
      if (env.isGecko) {
        return dataTransfer.dropEffect;
      }
      return [
        "all",
        "copyMove"
      ].includes(dataTransfer.effectAllowed) ? "move" : "copy";
    }
    function findDraggableWidget(target) {
      if (target.is("editableElement")) {
        return null;
      }
      if (target.hasClass("ck-widget__selection-handle")) {
        return target.findAncestor(isWidget);
      }
      if (isWidget(target)) {
        return target;
      }
      const ancestor = target.findAncestor((node) => isWidget(node) || node.is("editableElement"));
      if (isWidget(ancestor)) {
        return ancestor;
      }
      return null;
    }
    function getRangeIncludingFullySelectedParents(model, elements) {
      const firstElement = elements[0];
      const lastElement = elements[elements.length - 1];
      const parent2 = firstElement.getCommonAncestor(lastElement);
      const startPosition = model.createPositionBefore(firstElement);
      const endPosition = model.createPositionAfter(lastElement);
      if (parent2 && parent2.is("element") && !model.schema.isLimit(parent2)) {
        const parentRange = model.createRangeOn(parent2);
        const touchesStart = startPosition.isTouching(parentRange.start);
        const touchesEnd = endPosition.isTouching(parentRange.end);
        if (touchesStart && touchesEnd) {
          return getRangeIncludingFullySelectedParents(model, [
            parent2
          ]);
        }
      }
      return model.createRange(startPosition, endPosition);
    }
    class PastePlainText extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "PastePlainText";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const selection = model.document.selection;
        let shiftPressed = false;
        view.addObserver(ClipboardObserver);
        this.listenTo(viewDocument, "keydown", (evt, data) => {
          shiftPressed = data.shiftKey;
        });
        editor.plugins.get(ClipboardPipeline).on("contentInsertion", (evt, data) => {
          if (!shiftPressed && !isPlainTextFragment(data.content, model.schema)) {
            return;
          }
          model.change((writer) => {
            const textAttributes = Array.from(selection.getAttributes()).filter(([key]) => model.schema.getAttributeProperties(key).isFormatting);
            if (!selection.isCollapsed) {
              model.deleteContent(selection, {
                doNotAutoparagraph: true
              });
            }
            textAttributes.push(...selection.getAttributes());
            const range = writer.createRangeIn(data.content);
            for (const item of range.getItems()) {
              if (item.is("$textProxy")) {
                writer.setAttributes(textAttributes, item);
              }
            }
          });
        });
      }
    }
    function isPlainTextFragment(documentFragment, schema) {
      if (documentFragment.childCount > 1) {
        return false;
      }
      const child = documentFragment.getChild(0);
      if (schema.isObject(child)) {
        return false;
      }
      return Array.from(child.getAttributeKeys()).length == 0;
    }
    class Clipboard extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Clipboard";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardMarkersUtils,
          ClipboardPipeline,
          DragDrop,
          PastePlainText
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Copy selected content"),
              keystroke: "CTRL+C"
            },
            {
              label: t("Paste content"),
              keystroke: "CTRL+V"
            },
            {
              label: t("Paste content as plain text"),
              keystroke: "CTRL+SHIFT+V"
            }
          ]
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getNormalizedAndLocalizedLanguageDefinitions(editor) {
      const t = editor.t;
      const languageDefs = editor.config.get("codeBlock.languages");
      for (const def of languageDefs) {
        if (def.label === "Plain text") {
          def.label = t("Plain text");
        }
        if (def.class === void 0) {
          def.class = `language-${def.language}`;
        }
      }
      return languageDefs;
    }
    function getPropertyAssociation(languageDefs, key, value) {
      const association = {};
      for (const def of languageDefs) {
        if (key === "class") {
          const newKey = def[key].split(" ").shift();
          association[newKey] = def[value];
        } else {
          association[def[key]] = def[value];
        }
      }
      return association;
    }
    function getLeadingWhiteSpaces(textNode) {
      return textNode.data.match(/^(\s*)/)[0];
    }
    function rawSnippetTextToViewDocumentFragment(writer, text2) {
      const fragment = writer.createDocumentFragment();
      const textLines = text2.split("\n");
      const items = textLines.reduce((nodes, line, lineIndex) => {
        nodes.push(line);
        if (lineIndex < textLines.length - 1) {
          nodes.push(writer.createElement("br"));
        }
        return nodes;
      }, []);
      writer.appendChild(items, fragment);
      return fragment;
    }
    function getIndentOutdentPositions(model) {
      const selection = model.document.selection;
      const positions = [];
      if (selection.isCollapsed) {
        return [
          selection.anchor
        ];
      }
      const walker = selection.getFirstRange().getWalker({
        ignoreElementEnd: true,
        direction: "backward"
      });
      for (const { item } of walker) {
        if (!item.is("$textProxy")) {
          continue;
        }
        const { parent: parent2, startOffset } = item.textNode;
        if (!parent2.is("element", "codeBlock")) {
          continue;
        }
        const leadingWhiteSpaces = getLeadingWhiteSpaces(item.textNode);
        const position = model.createPositionAt(parent2, startOffset + leadingWhiteSpaces.length);
        positions.push(position);
      }
      return positions;
    }
    function isModelSelectionInCodeBlock(selection) {
      const firstBlock = first(selection.getSelectedBlocks());
      return !!firstBlock && firstBlock.is("element", "codeBlock");
    }
    function canBeCodeBlock(schema, element) {
      if (element.is("rootElement") || schema.isLimit(element)) {
        return false;
      }
      return schema.checkChild(element.parent, "codeBlock");
    }
    function getCodeBlockAriaAnnouncement(t, languageDefs, element, direction) {
      const languagesToLabels = getPropertyAssociation(languageDefs, "language", "label");
      const codeBlockLanguage = element.getAttribute("language");
      if (codeBlockLanguage in languagesToLabels) {
        const language = languagesToLabels[codeBlockLanguage];
        if (direction === "enter") {
          return t("Entering %0 code snippet", language);
        }
        return t("Leaving %0 code snippet", language);
      }
      if (direction === "enter") {
        return t("Entering code snippet");
      }
      return t("Leaving code snippet");
    }
    class CodeBlockCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * Contains the last used language.
        */
        __publicField(this, "_lastLanguage");
        this._lastLanguage = null;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Executes the command. When the command {@link #value is on}, all topmost code blocks within
      * the selection will be removed. If it is off, all selected blocks will be flattened and
      * wrapped by a code block.
      *
      * @fires execute
      * @param options Command options.
      * @param options.language The code block language.
      * @param options.forceValue If set, it will force the command behavior. If `true`, the command will apply a code block,
      * otherwise the command will remove the code block. If not set, the command will act basing on its current value.
      * @param options.usePreviousLanguageChoice If set on `true` and the `options.language` is not specified, the command
      * will apply the previous language (if the command was already executed) when inserting the `codeBlock` element.
      */
      execute(options = {}) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
        const firstLanguageInConfig = normalizedLanguagesDefs[0];
        const blocks = Array.from(selection.getSelectedBlocks());
        const value = options.forceValue == void 0 ? !this.value : options.forceValue;
        const language = getLanguage(options, this._lastLanguage, firstLanguageInConfig.language);
        model.change((writer) => {
          if (value) {
            this._applyCodeBlock(writer, blocks, language);
          } else {
            this._removeCodeBlock(writer, blocks);
          }
        });
      }
      /**
      * Checks the command's {@link #value}.
      *
      * @returns The current value.
      */
      _getValue() {
        const selection = this.editor.model.document.selection;
        const firstBlock = first(selection.getSelectedBlocks());
        const isCodeBlock = !!(firstBlock && firstBlock.is("element", "codeBlock"));
        return isCodeBlock ? firstBlock.getAttribute("language") : false;
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        if (this.value) {
          return true;
        }
        const selection = this.editor.model.document.selection;
        const schema = this.editor.model.schema;
        const firstBlock = first(selection.getSelectedBlocks());
        if (!firstBlock) {
          return false;
        }
        return canBeCodeBlock(schema, firstBlock);
      }
      _applyCodeBlock(writer, blocks, language) {
        this._lastLanguage = language;
        const schema = this.editor.model.schema;
        const allowedBlocks = blocks.filter((block2) => canBeCodeBlock(schema, block2));
        for (const block2 of allowedBlocks) {
          writer.rename(block2, "codeBlock");
          writer.setAttribute("language", language, block2);
          schema.removeDisallowedAttributes([
            block2
          ], writer);
          Array.from(block2.getChildren()).filter((child) => !schema.checkChild(block2, child)).forEach((child) => writer.remove(child));
        }
        allowedBlocks.reverse().forEach((currentBlock, i) => {
          const nextBlock = allowedBlocks[i + 1];
          if (currentBlock.previousSibling === nextBlock) {
            writer.appendElement("softBreak", nextBlock);
            writer.merge(writer.createPositionBefore(currentBlock));
          }
        });
      }
      _removeCodeBlock(writer, blocks) {
        const codeBlocks = blocks.filter((block2) => block2.is("element", "codeBlock"));
        for (const block2 of codeBlocks) {
          const range = writer.createRangeOn(block2);
          for (const item of Array.from(range.getItems()).reverse()) {
            if (item.is("element", "softBreak") && item.parent.is("element", "codeBlock")) {
              const { position } = writer.split(writer.createPositionBefore(item));
              const elementAfter = position.nodeAfter;
              writer.rename(elementAfter, "paragraph");
              writer.removeAttribute("language", elementAfter);
              writer.remove(item);
            }
          }
          writer.rename(block2, "paragraph");
          writer.removeAttribute("language", block2);
        }
      }
    }
    function getLanguage(options, lastLanguage, defaultLanguage) {
      if (options.language) {
        return options.language;
      }
      if (options.usePreviousLanguageChoice && lastLanguage) {
        return lastLanguage;
      }
      return defaultLanguage;
    }
    class IndentCodeBlockCommand extends Command {
      constructor(editor) {
        super(editor);
        /**
        * A sequence of characters added to the line when the command is executed.
        */
        __publicField(this, "_indentSequence");
        this._indentSequence = editor.config.get("codeBlock.indentSequence");
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
      * code lines in the selection will be increased.
      *
      * @fires execute
      */
      execute() {
        const editor = this.editor;
        const model = editor.model;
        model.change((writer) => {
          const positions = getIndentOutdentPositions(model);
          for (const position of positions) {
            const indentSequenceTextElement = writer.createText(this._indentSequence);
            model.insertContent(indentSequenceTextElement, position);
          }
        });
      }
      /**
      * Checks whether the command can be enabled in the current context.
      */
      _checkEnabled() {
        if (!this._indentSequence) {
          return false;
        }
        return isModelSelectionInCodeBlock(this.editor.model.document.selection);
      }
    }
    class OutdentCodeBlockCommand extends Command {
      constructor(editor) {
        super(editor);
        /**
        * A sequence of characters removed from the line when the command is executed.
        */
        __publicField(this, "_indentSequence");
        this._indentSequence = editor.config.get("codeBlock.indentSequence");
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Executes the command. When the command {@link #isEnabled is enabled}, the indentation of the
      * code lines in the selection will be decreased.
      *
      * @fires execute
      */
      execute() {
        const editor = this.editor;
        const model = editor.model;
        model.change(() => {
          const positions = getIndentOutdentPositions(model);
          for (const position of positions) {
            const range = getLastOutdentableSequenceRange(model, position, this._indentSequence);
            if (range) {
              model.deleteContent(model.createSelection(range));
            }
          }
        });
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @private
      * @returns {Boolean} Whether the command should be enabled.
      */
      _checkEnabled() {
        if (!this._indentSequence) {
          return false;
        }
        const model = this.editor.model;
        if (!isModelSelectionInCodeBlock(model.document.selection)) {
          return false;
        }
        return getIndentOutdentPositions(model).some((position) => {
          return getLastOutdentableSequenceRange(model, position, this._indentSequence);
        });
      }
    }
    function getLastOutdentableSequenceRange(model, position, sequence) {
      const nodeAtPosition = getCodeLineTextNodeAtPosition(position);
      if (!nodeAtPosition) {
        return null;
      }
      const leadingWhiteSpaces = getLeadingWhiteSpaces(nodeAtPosition);
      const lastIndexOfSequence = leadingWhiteSpaces.lastIndexOf(sequence);
      if (lastIndexOfSequence + sequence.length !== leadingWhiteSpaces.length) {
        return null;
      }
      if (lastIndexOfSequence === -1) {
        return null;
      }
      const { parent: parent2, startOffset } = nodeAtPosition;
      return model.createRange(model.createPositionAt(parent2, startOffset + lastIndexOfSequence), model.createPositionAt(parent2, startOffset + lastIndexOfSequence + sequence.length));
    }
    function getCodeLineTextNodeAtPosition(position) {
      let nodeAtPosition = position.parent.getChild(position.index);
      if (!nodeAtPosition || nodeAtPosition.is("element", "softBreak")) {
        nodeAtPosition = position.nodeBefore;
      }
      if (!nodeAtPosition || nodeAtPosition.is("element", "softBreak")) {
        return null;
      }
      return nodeAtPosition;
    }
    function modelToViewCodeBlockInsertion(model, languageDefs, useLabels = false) {
      const languagesToClasses = getPropertyAssociation(languageDefs, "language", "class");
      const languagesToLabels = getPropertyAssociation(languageDefs, "language", "label");
      return (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, "insert")) {
          return;
        }
        const codeBlockLanguage = data.item.getAttribute("language");
        const targetViewPosition = mapper.toViewPosition(model.createPositionBefore(data.item));
        const preAttributes = {};
        if (useLabels) {
          preAttributes["data-language"] = languagesToLabels[codeBlockLanguage];
          preAttributes.spellcheck = "false";
        }
        const codeAttributes = languagesToClasses[codeBlockLanguage] ? {
          class: languagesToClasses[codeBlockLanguage]
        } : void 0;
        const code = writer.createContainerElement("code", codeAttributes);
        const pre = writer.createContainerElement("pre", preAttributes, code);
        writer.insert(targetViewPosition, pre);
        mapper.bindElements(data.item, code);
      };
    }
    function modelToDataViewSoftBreakInsertion(model) {
      return (evt, data, conversionApi) => {
        if (data.item.parent.name !== "codeBlock") {
          return;
        }
        const { writer, mapper, consumable } = conversionApi;
        if (!consumable.consume(data.item, "insert")) {
          return;
        }
        const position = mapper.toViewPosition(model.createPositionBefore(data.item));
        writer.insert(position, writer.createText("\n"));
      };
    }
    function dataViewToModelCodeBlockInsertion(editingView, languageDefs) {
      const classesToLanguages = getPropertyAssociation(languageDefs, "class", "language");
      const defaultLanguageName = languageDefs[0].language;
      return (evt, data, conversionApi) => {
        const viewCodeElement = data.viewItem;
        const viewPreElement = viewCodeElement.parent;
        if (!viewPreElement || !viewPreElement.is("element", "pre")) {
          return;
        }
        if (data.modelCursor.findAncestor("codeBlock")) {
          return;
        }
        const { consumable, writer } = conversionApi;
        if (!consumable.test(viewCodeElement, {
          name: true
        })) {
          return;
        }
        const codeBlock2 = writer.createElement("codeBlock");
        const viewChildClasses = [
          ...viewCodeElement.getClassNames()
        ];
        if (!viewChildClasses.length) {
          viewChildClasses.push("");
        }
        for (const className of viewChildClasses) {
          const language = classesToLanguages[className];
          if (language) {
            writer.setAttribute("language", language, codeBlock2);
            break;
          }
        }
        if (!codeBlock2.hasAttribute("language")) {
          writer.setAttribute("language", defaultLanguageName, codeBlock2);
        }
        conversionApi.convertChildren(viewCodeElement, codeBlock2);
        if (!conversionApi.safeInsert(codeBlock2, data.modelCursor)) {
          return;
        }
        consumable.consume(viewCodeElement, {
          name: true
        });
        conversionApi.updateConversionResult(codeBlock2, data);
      };
    }
    function dataViewToModelTextNewlinesInsertion() {
      return (evt, data, { consumable, writer }) => {
        let position = data.modelCursor;
        if (!consumable.test(data.viewItem)) {
          return;
        }
        if (!position.findAncestor("codeBlock")) {
          return;
        }
        consumable.consume(data.viewItem);
        const text2 = data.viewItem.data;
        const textLines = text2.split("\n").map((data2) => writer.createText(data2));
        const lastLine = textLines[textLines.length - 1];
        for (const node of textLines) {
          writer.insert(node, position);
          position = position.getShiftedBy(node.offsetSize);
          if (node !== lastLine) {
            const softBreak = writer.createElement("softBreak");
            writer.insert(softBreak, position);
            position = writer.createPositionAfter(softBreak);
          }
        }
        data.modelRange = writer.createRange(data.modelCursor, position);
        data.modelCursor = position;
      };
    }
    function dataViewToModelOrphanNodeConsumer() {
      return (evt, data, { consumable }) => {
        const preElement = data.viewItem;
        if (preElement.findAncestor("pre")) {
          return;
        }
        const preChildren = Array.from(preElement.getChildren());
        const childCodeElement = preChildren.find((node) => node.is("element", "code"));
        if (!childCodeElement) {
          return;
        }
        for (const child of preChildren) {
          if (child === childCodeElement || !child.is("$text")) {
            continue;
          }
          consumable.consume(child, {
            name: true
          });
        }
      };
    }
    const DEFAULT_ELEMENT = "paragraph";
    class CodeBlockEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CodeBlockEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ShiftEnter
        ];
      }
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        editor.config.define("codeBlock", {
          languages: [
            {
              language: "plaintext",
              label: "Plain text"
            },
            {
              language: "c",
              label: "C"
            },
            {
              language: "cs",
              label: "C#"
            },
            {
              language: "cpp",
              label: "C++"
            },
            {
              language: "css",
              label: "CSS"
            },
            {
              language: "diff",
              label: "Diff"
            },
            {
              language: "html",
              label: "HTML"
            },
            {
              language: "java",
              label: "Java"
            },
            {
              language: "javascript",
              label: "JavaScript"
            },
            {
              language: "php",
              label: "PHP"
            },
            {
              language: "python",
              label: "Python"
            },
            {
              language: "ruby",
              label: "Ruby"
            },
            {
              language: "typescript",
              label: "TypeScript"
            },
            {
              language: "xml",
              label: "XML"
            }
          ],
          // A single tab.
          indentSequence: "	"
        });
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const model = editor.model;
        const view = editor.editing.view;
        const normalizedLanguagesDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
        editor.commands.add("codeBlock", new CodeBlockCommand(editor));
        editor.commands.add("indentCodeBlock", new IndentCodeBlockCommand(editor));
        editor.commands.add("outdentCodeBlock", new OutdentCodeBlockCommand(editor));
        this.listenTo(view.document, "tab", (evt, data) => {
          const commandName = data.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
          const command = editor.commands.get(commandName);
          if (!command.isEnabled) {
            return;
          }
          editor.execute(commandName);
          data.stopPropagation();
          data.preventDefault();
          evt.stop();
        }, {
          context: "pre"
        });
        schema.register("codeBlock", {
          allowWhere: "$block",
          allowChildren: "$text",
          // Disallow `$inlineObject` and its derivatives like `inlineWidget` inside `codeBlock` to ensure that only text,
          // not other inline elements like inline images, are allowed. This maintains the semantic integrity of code blocks.
          disallowChildren: "$inlineObject",
          allowAttributes: [
            "language"
          ],
          allowAttributesOf: "$listItem",
          isBlock: true
        });
        schema.addAttributeCheck((context) => {
          if (context.endsWith("codeBlock $text")) {
            return false;
          }
        });
        editor.editing.downcastDispatcher.on("insert:codeBlock", modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs, true));
        editor.data.downcastDispatcher.on("insert:codeBlock", modelToViewCodeBlockInsertion(model, normalizedLanguagesDefs));
        editor.data.downcastDispatcher.on("insert:softBreak", modelToDataViewSoftBreakInsertion(model), {
          priority: "high"
        });
        editor.data.upcastDispatcher.on("element:code", dataViewToModelCodeBlockInsertion(view, normalizedLanguagesDefs));
        editor.data.upcastDispatcher.on("text", dataViewToModelTextNewlinesInsertion());
        editor.data.upcastDispatcher.on("element:pre", dataViewToModelOrphanNodeConsumer(), {
          priority: "high"
        });
        this.listenTo(editor.editing.view.document, "clipboardInput", (evt, data) => {
          let insertionRange = model.createRange(model.document.selection.anchor);
          if (data.targetRanges) {
            insertionRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
          }
          if (!insertionRange.start.parent.is("element", "codeBlock")) {
            return;
          }
          const text2 = data.dataTransfer.getData("text/plain");
          const writer = new UpcastWriter(editor.editing.view.document);
          data.content = rawSnippetTextToViewDocumentFragment(writer, text2);
        });
        this.listenTo(model, "getSelectedContent", (evt, [selection]) => {
          const anchor = selection.anchor;
          if (selection.isCollapsed || !anchor.parent.is("element", "codeBlock") || !anchor.hasSameParentAs(selection.focus)) {
            return;
          }
          model.change((writer) => {
            const docFragment = evt.return;
            if (anchor.parent.is("element") && (docFragment.childCount > 1 || selection.containsEntireContent(anchor.parent))) {
              const codeBlock2 = writer.createElement("codeBlock", anchor.parent.getAttributes());
              writer.append(docFragment, codeBlock2);
              const newDocumentFragment = writer.createDocumentFragment();
              writer.append(codeBlock2, newDocumentFragment);
              evt.return = newDocumentFragment;
              return;
            }
            const textNode = docFragment.getChild(0);
            if (schema.checkAttribute(textNode, "code")) {
              writer.setAttribute("code", true, textNode);
            }
          });
        });
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor = this.editor;
        const commands = editor.commands;
        const indent2 = commands.get("indent");
        const outdent2 = commands.get("outdent");
        if (indent2) {
          indent2.registerChildCommand(commands.get("indentCodeBlock"), {
            priority: "highest"
          });
        }
        if (outdent2) {
          outdent2.registerChildCommand(commands.get("outdentCodeBlock"));
        }
        this.listenTo(editor.editing.view.document, "enter", (evt, data) => {
          const positionParent = editor.model.document.selection.getLastPosition().parent;
          if (!positionParent.is("element", "codeBlock")) {
            return;
          }
          if (!leaveBlockStartOnEnter(editor, data.isSoft) && !leaveBlockEndOnEnter(editor, data.isSoft)) {
            breakLineOnEnter(editor);
          }
          data.preventDefault();
          evt.stop();
        }, {
          context: "pre"
        });
        this._initAriaAnnouncements();
      }
      /**
      * Observe when user enters or leaves code block and set proper aria value in global live announcer.
      * This allows screen readers to indicate when the user has entered and left the specified code block.
      *
      * @internal
      */
      _initAriaAnnouncements() {
        const { model, ui, t } = this.editor;
        const languageDefs = getNormalizedAndLocalizedLanguageDefinitions(this.editor);
        let lastFocusedCodeBlock = null;
        model.document.selection.on("change:range", () => {
          const focusParent = model.document.selection.focus.parent;
          if (!ui || lastFocusedCodeBlock === focusParent || !focusParent.is("element")) {
            return;
          }
          if (lastFocusedCodeBlock && lastFocusedCodeBlock.is("element", "codeBlock")) {
            ui.ariaLiveAnnouncer.announce(getCodeBlockAriaAnnouncement(t, languageDefs, lastFocusedCodeBlock, "leave"));
          }
          if (focusParent.is("element", "codeBlock")) {
            ui.ariaLiveAnnouncer.announce(getCodeBlockAriaAnnouncement(t, languageDefs, focusParent, "enter"));
          }
          lastFocusedCodeBlock = focusParent;
        });
      }
    }
    function breakLineOnEnter(editor) {
      const model = editor.model;
      const modelDoc = model.document;
      const lastSelectionPosition = modelDoc.selection.getLastPosition();
      const node = lastSelectionPosition.nodeBefore || lastSelectionPosition.textNode;
      let leadingWhiteSpaces;
      if (node && node.is("$text")) {
        leadingWhiteSpaces = getLeadingWhiteSpaces(node);
      }
      editor.model.change((writer) => {
        editor.execute("shiftEnter");
        if (leadingWhiteSpaces) {
          writer.insertText(leadingWhiteSpaces, modelDoc.selection.anchor);
        }
      });
    }
    function leaveBlockStartOnEnter(editor, isSoftEnter) {
      const model = editor.model;
      const modelDoc = model.document;
      const view = editor.editing.view;
      const lastSelectionPosition = modelDoc.selection.getLastPosition();
      const nodeAfter = lastSelectionPosition.nodeAfter;
      if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtStart) {
        return false;
      }
      if (!isSoftBreakNode(nodeAfter)) {
        return false;
      }
      editor.model.change((writer) => {
        editor.execute("enter");
        const newBlock = modelDoc.selection.anchor.parent.previousSibling;
        writer.rename(newBlock, DEFAULT_ELEMENT);
        writer.setSelection(newBlock, "in");
        editor.model.schema.removeDisallowedAttributes([
          newBlock
        ], writer);
        writer.remove(nodeAfter);
      });
      view.scrollToTheSelection();
      return true;
    }
    function leaveBlockEndOnEnter(editor, isSoftEnter) {
      const model = editor.model;
      const modelDoc = model.document;
      const view = editor.editing.view;
      const lastSelectionPosition = modelDoc.selection.getLastPosition();
      const nodeBefore = lastSelectionPosition.nodeBefore;
      let emptyLineRangeToRemoveOnEnter;
      if (isSoftEnter || !modelDoc.selection.isCollapsed || !lastSelectionPosition.isAtEnd || !nodeBefore || !nodeBefore.previousSibling) {
        return false;
      }
      if (isSoftBreakNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling)) {
        emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling), model.createPositionAfter(nodeBefore));
      } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isSoftBreakNode(nodeBefore.previousSibling.previousSibling)) {
        emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
      } else if (isEmptyishTextNode(nodeBefore) && isSoftBreakNode(nodeBefore.previousSibling) && isEmptyishTextNode(nodeBefore.previousSibling.previousSibling) && nodeBefore.previousSibling.previousSibling && isSoftBreakNode(nodeBefore.previousSibling.previousSibling.previousSibling)) {
        emptyLineRangeToRemoveOnEnter = model.createRange(model.createPositionBefore(nodeBefore.previousSibling.previousSibling.previousSibling), model.createPositionAfter(nodeBefore));
      } else {
        return false;
      }
      editor.model.change((writer) => {
        writer.remove(emptyLineRangeToRemoveOnEnter);
        editor.execute("enter");
        const newBlock = modelDoc.selection.anchor.parent;
        writer.rename(newBlock, DEFAULT_ELEMENT);
        editor.model.schema.removeDisallowedAttributes([
          newBlock
        ], writer);
      });
      view.scrollToTheSelection();
      return true;
    }
    function isEmptyishTextNode(node) {
      return node && node.is("$text") && !node.data.match(/\S/);
    }
    function isSoftBreakNode(node) {
      return node && node.is("element", "softBreak");
    }
    class CodeBlockUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CodeBlockUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        const componentFactory = editor.ui.componentFactory;
        const normalizedLanguageDefs = getNormalizedAndLocalizedLanguageDefinitions(editor);
        const itemDefinitions = this._getLanguageListItemDefinitions(normalizedLanguageDefs);
        const command = editor.commands.get("codeBlock");
        componentFactory.add("codeBlock", (locale) => {
          const dropdownView = createDropdown(locale, SplitButtonView);
          const splitButtonView = dropdownView.buttonView;
          const accessibleLabel = t("Insert code block");
          splitButtonView.set({
            label: accessibleLabel,
            tooltip: true,
            icon: icons.codeBlock,
            isToggleable: true
          });
          splitButtonView.bind("isOn").to(command, "value", (value) => !!value);
          splitButtonView.on("execute", () => {
            editor.execute("codeBlock", {
              usePreviousLanguageChoice: true
            });
            editor.editing.view.focus();
          });
          dropdownView.on("execute", (evt) => {
            editor.execute("codeBlock", {
              language: evt.source._codeBlockLanguage,
              forceValue: true
            });
            editor.editing.view.focus();
          });
          dropdownView.class = "ck-code-block-dropdown";
          dropdownView.bind("isEnabled").to(command);
          addListToDropdown(dropdownView, itemDefinitions, {
            role: "menu",
            ariaLabel: accessibleLabel
          });
          return dropdownView;
        });
        componentFactory.add("menuBar:codeBlock", (locale) => {
          const menuView = new MenuBarMenuView(locale);
          menuView.buttonView.set({
            label: t("Code block"),
            icon: icons.codeBlock
          });
          menuView.bind("isEnabled").to(command);
          const listView = new MenuBarMenuListView(locale);
          listView.set({
            ariaLabel: t("Insert code block")
          });
          for (const definition of itemDefinitions) {
            const listItemView = new MenuBarMenuListItemView(locale, menuView);
            const buttonView = new MenuBarMenuListItemButtonView(locale);
            buttonView.bind(...Object.keys(definition.model)).to(definition.model);
            buttonView.bind("ariaChecked").to(buttonView, "isOn");
            buttonView.delegate("execute").to(menuView);
            buttonView.on("execute", () => {
              editor.execute("codeBlock", {
                language: definition.model._codeBlockLanguage,
                forceValue: command.value == definition.model._codeBlockLanguage ? false : true
              });
              editor.editing.view.focus();
            });
            listItemView.children.add(buttonView);
            listView.items.add(listItemView);
          }
          menuView.panelView.children.add(listView);
          return menuView;
        });
      }
      /**
      * A helper returning a collection of the `codeBlock` dropdown items representing languages
      * available for the user to choose from.
      */
      _getLanguageListItemDefinitions(normalizedLanguageDefs) {
        const editor = this.editor;
        const command = editor.commands.get("codeBlock");
        const itemDefinitions = new Collection();
        for (const languageDef of normalizedLanguageDefs) {
          const definition = {
            type: "button",
            model: new Model({
              _codeBlockLanguage: languageDef.language,
              label: languageDef.label,
              role: "menuitemradio",
              withText: true
            })
          };
          definition.model.bind("isOn").to(command, "value", (value) => {
            return value === definition.model._codeBlockLanguage;
          });
          itemDefinitions.add(definition);
        }
        return itemDefinitions;
      }
    }
    class CodeBlock extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          CodeBlockEditing,
          CodeBlockUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CodeBlock";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class DecoupledEditorUI extends EditorUI {
      /**
      * Creates an instance of the decoupled editor UI class.
      *
      * @param editor The editor instance.
      * @param view The view of the UI.
      */
      constructor(editor, view) {
        super(editor);
        /**
        * The main (top–most) view of the editor UI.
        */
        __publicField(this, "view");
        this.view = view;
      }
      /**
      * Initializes the UI.
      */
      init() {
        const editor = this.editor;
        const view = this.view;
        const editingView = editor.editing.view;
        const editable = view.editable;
        const editingRoot = editingView.document.getRoot();
        editable.name = editingRoot.rootName;
        view.render();
        const editableElement = editable.element;
        this.setEditableElement(editable.name, editableElement);
        view.editable.bind("isFocused").to(this.focusTracker);
        editingView.attachDomRoot(editableElement);
        this._initPlaceholder();
        this._initToolbar();
        _initMenuBar(editor, this.view.menuBarView);
        this.fire("ready");
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        const view = this.view;
        const editingView = this.editor.editing.view;
        editingView.detachDomRoot(view.editable.name);
        view.destroy();
      }
      /**
      * Initializes the inline editor toolbar and its panel.
      */
      _initToolbar() {
        const editor = this.editor;
        const view = this.view;
        const toolbar = view.toolbar;
        toolbar.fillFromConfig(editor.config.get("toolbar"), this.componentFactory);
        this.addToolbar(view.toolbar);
      }
      /**
      * Enable the placeholder text on the editing root.
      */
      _initPlaceholder() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const editingRoot = editingView.document.getRoot();
        const placeholder = editor.config.get("placeholder");
        if (placeholder) {
          const placeholderText = typeof placeholder === "string" ? placeholder : placeholder[editingRoot.rootName];
          if (placeholderText) {
            editingRoot.placeholder = placeholderText;
          }
        }
        enablePlaceholder({
          view: editingView,
          element: editingRoot,
          isDirectHost: false,
          keepOnFocus: true
        });
      }
    }
    class DecoupledEditorUIView extends EditorUIView {
      /**
      * Creates an instance of the decoupled editor UI view.
      *
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param editingView The editing view instance this view is related to.
      * @param options Configuration options for the view instance.
      * @param options.editableElement The editable element. If not specified, it will be automatically created by
      * {@link module:ui/editableui/editableuiview~EditableUIView}. Otherwise, the given element will be used.
      * @param options.shouldToolbarGroupWhenFull When set `true` enables automatic items grouping
      * in the main {@link module:editor-decoupled/decouplededitoruiview~DecoupledEditorUIView#toolbar toolbar}.
      * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
      */
      constructor(locale, editingView, options = {}) {
        super(locale);
        /**
        * The main toolbar of the decoupled editor UI.
        */
        __publicField(this, "toolbar");
        /**
        * Menu bar view instance.
        */
        __publicField(this, "menuBarView");
        /**
        * The editable of the decoupled editor UI.
        */
        __publicField(this, "editable");
        const t = locale.t;
        this.toolbar = new ToolbarView(locale, {
          shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
        });
        this.menuBarView = new MenuBarView(locale);
        this.editable = new InlineEditableUIView(locale, editingView, options.editableElement, {
          label: (editableView) => {
            return t("Rich Text Editor. Editing area: %0", editableView.name);
          }
        });
        this.toolbar.extendTemplate({
          attributes: {
            class: [
              "ck-reset_all",
              "ck-rounded-corners"
            ],
            dir: locale.uiLanguageDirection
          }
        });
        this.menuBarView.extendTemplate({
          attributes: {
            class: [
              "ck-reset_all",
              "ck-rounded-corners"
            ],
            dir: locale.uiLanguageDirection
          }
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.registerChild([
          this.menuBarView,
          this.toolbar,
          this.editable
        ]);
      }
    }
    class DecoupledEditor extends (/* @__PURE__ */ ElementApiMixin(Editor)) {
      /**
      * Creates an instance of the decoupled editor.
      *
      * **Note:** Do not use the constructor to create editor instances. Use the static
      * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`} method instead.
      *
      * @param sourceElementOrData The DOM element that will be the source for the created editor
      * (on which the editor will be initialized) or initial data for the editor. For more information see
      * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}.
      * @param config The editor configuration.
      */
      constructor(sourceElementOrData, config = {}) {
        if (!isElement(sourceElementOrData) && config.initialData !== void 0) {
          throw new CKEditorError("editor-create-initial-data", null);
        }
        super(config);
        /**
        * @inheritDoc
        */
        __publicField(this, "ui");
        if (this.config.get("initialData") === void 0) {
          this.config.set("initialData", getInitialData(sourceElementOrData));
        }
        if (isElement(sourceElementOrData)) {
          this.sourceElement = sourceElementOrData;
          secureSourceElement(this, sourceElementOrData);
        }
        this.model.document.createRoot();
        const shouldToolbarGroupWhenFull = !this.config.get("toolbar.shouldNotGroupWhenFull");
        const view = new DecoupledEditorUIView(this.locale, this.editing.view, {
          editableElement: this.sourceElement,
          shouldToolbarGroupWhenFull
        });
        this.ui = new DecoupledEditorUI(this, view);
      }
      /**
      * Destroys the editor instance, releasing all resources used by it.
      *
      * Updates the original editor element with the data if the
      * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy `updateSourceElementOnDestroy`}
      * configuration option is set to `true`.
      *
      * **Note**: The decoupled editor does not remove the toolbar and editable when destroyed. You can
      * do that yourself in the destruction chain:
      *
      * ```ts
      * editor.destroy()
      * 	.then( () => {
      * 		// Remove the toolbar from DOM.
      * 		editor.ui.view.toolbar.element.remove();
      *
      * 		// Remove the editable from DOM.
      * 		editor.ui.view.editable.element.remove();
      *
      * 		console.log( 'Editor was destroyed' );
      * 	} );
      * ```
      */
      destroy() {
        const data = this.getData();
        this.ui.destroy();
        return super.destroy().then(() => {
          if (this.sourceElement) {
            this.updateSourceElement(data);
          }
        });
      }
      /**
      * Creates a new decoupled editor instance.
      *
      * **Note:** remember that `DecoupledEditor` does not append the toolbar element to your web page, so you have to do it manually
      * after the editor has been initialized.
      *
      * There are two ways how the editor can be initialized.
      *
      * # Using an existing DOM element (and loading data from it)
      *
      * You can initialize the editor using an existing DOM element:
      *
      * ```ts
      * DecoupledEditor
      * 	.create( document.querySelector( '#editor' ) )
      * 	.then( editor => {
      * 		console.log( 'Editor was initialized', editor );
      *
      * 		// Append the toolbar to the <body> element.
      * 		document.body.appendChild( editor.ui.view.toolbar.element );
      * 	} )
      * 	.catch( err => {
      * 		console.error( err.stack );
      * 	} );
      * ```
      *
      * The element's content will be used as the editor data and the element will become the editable element.
      *
      * # Creating a detached editor
      *
      * Alternatively, you can initialize the editor by passing the initial data directly as a string.
      * In this case, you will have to manually append both the toolbar element and the editable element to your web page.
      *
      * ```ts
      * DecoupledEditor
      * 	.create( '<p>Hello world!</p>' )
      * 	.then( editor => {
      * 		console.log( 'Editor was initialized', editor );
      *
      * 		// Append the toolbar to the <body> element.
      * 		document.body.appendChild( editor.ui.view.toolbar.element );
      *
      * 		// Initial data was provided so the editor UI element needs to be added manually to the DOM.
      * 		document.body.appendChild( editor.ui.getEditableElement() );
      * 	} )
      * 	.catch( err => {
      * 		console.error( err.stack );
      * 	} );
      * ```
      *
      * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
      * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
      *
      * # Using an existing DOM element (and data provided in `config.initialData`)
      *
      * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
      *
      * ```ts
      * DecoupledEditor
      * 	.create( document.querySelector( '#editor' ), {
      * 		initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
      * 	} )
      * 	.then( editor => {
      * 		console.log( 'Editor was initialized', editor );
      *
      * 		// Append the toolbar to the <body> element.
      * 		document.body.appendChild( editor.ui.view.toolbar.element );
      * 	} )
      * 	.catch( err => {
      * 		console.error( err.stack );
      * 	} );
      * ```
      *
      * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
      * makes it difficult to set the content of the source element.
      *
      * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
      *
      * # Configuring the editor
      *
      * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
      * customizing plugins, toolbar and more.
      *
      * @param sourceElementOrData The DOM element that will be the source for the created editor
      * or the editor's initial data.
      *
      * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization.
      * The editor data will be set back to the original element once the editor is destroyed only if the
      * {@link module:core/editor/editorconfig~EditorConfig#updateSourceElementOnDestroy updateSourceElementOnDestroy}
      * option is set to `true`.
      *
      * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
      * It is available via
      * {@link module:editor-decoupled/decouplededitorui~DecoupledEditorUI#getEditableElement `editor.ui.getEditableElement()`}.
      *
      * @param config The editor configuration.
      * @returns A promise resolved once the editor is ready. The promise resolves with the created editor instance.
      */
      static create(sourceElementOrData, config = {}) {
        return new Promise((resolve) => {
          if (isElement(sourceElementOrData) && sourceElementOrData.tagName === "TEXTAREA") {
            throw new CKEditorError("editor-wrong-element", null);
          }
          const editor = new this(sourceElementOrData, config);
          resolve(editor.initPlugins().then(() => editor.ui.init()).then(() => editor.data.init(editor.config.get("initialData"))).then(() => editor.fire("ready")).then(() => editor));
        });
      }
    }
    function getInitialData(sourceElementOrData) {
      return isElement(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
    }
    function isElement(value) {
      return isElement$1(value);
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class SelectAllCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        this.affectsData = false;
      }
      /**
      * @inheritDoc
      */
      execute() {
        const model = this.editor.model;
        const selection = model.document.selection;
        let scopeElement = model.schema.getLimitElement(selection);
        if (selection.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {
          do {
            scopeElement = scopeElement.parent;
            if (!scopeElement) {
              return;
            }
          } while (!isSelectAllScope(model.schema, scopeElement));
        }
        model.change((writer) => {
          writer.setSelection(scopeElement, "in");
        });
      }
    }
    function isSelectAllScope(schema, element) {
      return schema.isLimit(element) && (schema.checkChild(element, "$text") || schema.checkChild(element, "paragraph"));
    }
    const SELECT_ALL_KEYSTROKE = /* @__PURE__ */ parseKeystroke("Ctrl+A");
    class SelectAllEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "SelectAllEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        const view = editor.editing.view;
        const viewDocument = view.document;
        editor.commands.add("selectAll", new SelectAllCommand(editor));
        this.listenTo(viewDocument, "keydown", (eventInfo, domEventData) => {
          if (getCode(domEventData) === SELECT_ALL_KEYSTROKE) {
            editor.execute("selectAll");
            domEventData.preventDefault();
          }
        });
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Select all"),
              keystroke: "CTRL+A"
            }
          ]
        });
      }
    }
    var selectAllIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
    class SelectAllUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "SelectAllUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        editor.ui.componentFactory.add("selectAll", () => {
          const buttonView = this._createButton(ButtonView);
          buttonView.set({
            tooltip: true
          });
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:selectAll", () => {
          return this._createButton(MenuBarMenuListItemButtonView);
        });
      }
      /**
      * Creates a button for select all command to use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get("selectAll");
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
          label: t("Select all"),
          icon: selectAllIcon,
          keystroke: "Ctrl+A"
        });
        view.bind("isEnabled").to(command, "isEnabled");
        this.listenTo(view, "execute", () => {
          editor.execute("selectAll");
          editor.editing.view.focus();
        });
        return view;
      }
    }
    class SelectAll extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          SelectAllEditing,
          SelectAllUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "SelectAll";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class BaseCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * Stack of items stored by the command. These are pairs of:
        *
        * * {@link module:engine/model/batch~Batch batch} saved by the command,
        * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.
        */
        __publicField(this, "_stack", []);
        /**
        * Stores all batches that were created by this command.
        *
        * @internal
        */
        __publicField(this, "_createdBatches", /* @__PURE__ */ new WeakSet());
        this.refresh();
        this._isEnabledBasedOnSelection = false;
        this.listenTo(editor.data, "set", (evt, data) => {
          data[1] = {
            ...data[1]
          };
          const options = data[1];
          if (!options.batchType) {
            options.batchType = {
              isUndoable: false
            };
          }
        }, {
          priority: "high"
        });
        this.listenTo(editor.data, "set", (evt, data) => {
          const options = data[1];
          if (!options.batchType.isUndoable) {
            this.clearStack();
          }
        });
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._stack.length > 0;
      }
      /**
      * Returns all batches created by this command.
      */
      get createdBatches() {
        return this._createdBatches;
      }
      /**
      * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
      * created by the editor which this command is registered to.
      *
      * @param batch The batch to add.
      */
      addBatch(batch) {
        const docSelection = this.editor.model.document.selection;
        const selection = {
          ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
          isBackward: docSelection.isBackward
        };
        this._stack.push({
          batch,
          selection
        });
        this.refresh();
      }
      /**
      * Removes all items from the stack.
      */
      clearStack() {
        this._stack = [];
        this.refresh();
      }
      /**
      * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
      *
      * @param ranges Ranges to be restored.
      * @param isBackward A flag describing whether the restored range was selected forward or backward.
      * @param operations Operations which has been applied since selection has been stored.
      */
      _restoreSelection(ranges, isBackward, operations2) {
        const model = this.editor.model;
        const document2 = model.document;
        const selectionRanges = [];
        const transformedRangeGroups = ranges.map((range) => range.getTransformedByOperations(operations2));
        const allRanges = transformedRangeGroups.flat();
        for (const rangeGroup of transformedRangeGroups) {
          const transformed = rangeGroup.filter((range) => range.root != document2.graveyard).filter((range) => !isRangeContainedByAnyOtherRange(range, allRanges));
          if (!transformed.length) {
            continue;
          }
          normalizeRanges$1(transformed);
          selectionRanges.push(transformed[0]);
        }
        if (selectionRanges.length) {
          model.change((writer) => {
            writer.setSelection(selectionRanges, {
              backward: isBackward
            });
          });
        }
      }
      /**
      * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
      * This is a helper method for {@link #execute}.
      *
      * @param batchToUndo The batch to be undone.
      * @param undoingBatch The batch that will contain undoing changes.
      */
      _undo(batchToUndo, undoingBatch) {
        const model = this.editor.model;
        const document2 = model.document;
        this._createdBatches.add(undoingBatch);
        const operationsToUndo = batchToUndo.operations.slice().filter((operation) => operation.isDocumentOperation);
        operationsToUndo.reverse();
        for (const operationToUndo of operationsToUndo) {
          const nextBaseVersion = operationToUndo.baseVersion + 1;
          const historyOperations = Array.from(document2.history.getOperations(nextBaseVersion));
          const transformedSets = transformSets([
            operationToUndo.getReversed()
          ], historyOperations, {
            useRelations: true,
            document: this.editor.model.document,
            padWithNoOps: false,
            forceWeakRemove: true
          });
          const reversedOperations = transformedSets.operationsA;
          for (let operation of reversedOperations) {
            const affectedSelectable = operation.affectedSelectable;
            if (affectedSelectable && !model.canEditAt(affectedSelectable)) {
              operation = new NoOperation(operation.baseVersion);
            }
            undoingBatch.addOperation(operation);
            model.applyOperation(operation);
            document2.history.setOperationAsUndone(operationToUndo, operation);
          }
        }
      }
    }
    function normalizeRanges$1(ranges) {
      ranges.sort((a, b) => a.start.isBefore(b.start) ? -1 : 1);
      for (let i = 1; i < ranges.length; i++) {
        const previousRange = ranges[i - 1];
        const joinedRange = previousRange.getJoined(ranges[i], true);
        if (joinedRange) {
          i--;
          ranges.splice(i, 2, joinedRange);
        }
      }
    }
    function isRangeContainedByAnyOtherRange(range, ranges) {
      return ranges.some((otherRange) => otherRange !== range && otherRange.containsRange(range, true));
    }
    class UndoCommand extends BaseCommand {
      /**
      * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
      * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
      * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
      *
      * @fires execute
      * @fires revert
      * @param batch A batch that should be undone. If not set, the last added batch will be undone.
      */
      execute(batch = null) {
        const batchIndex = batch ? this._stack.findIndex((a) => a.batch == batch) : this._stack.length - 1;
        const item = this._stack.splice(batchIndex, 1)[0];
        const undoingBatch = this.editor.model.createBatch({
          isUndo: true
        });
        this.editor.model.enqueueChange(undoingBatch, () => {
          this._undo(item.batch, undoingBatch);
          const operations2 = this.editor.model.document.history.getOperations(item.batch.baseVersion);
          this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations2);
        });
        this.fire("revert", item.batch, undoingBatch);
        this.refresh();
      }
    }
    class RedoCommand extends BaseCommand {
      /**
      * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
      * the command's stack, applies the reverted and transformed version on the
      * {@link module:engine/model/document~Document document} and removes the batch from the stack.
      * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
      *
      * @fires execute
      */
      execute() {
        const item = this._stack.pop();
        const redoingBatch = this.editor.model.createBatch({
          isUndo: true
        });
        this.editor.model.enqueueChange(redoingBatch, () => {
          const lastOperation = item.batch.operations[item.batch.operations.length - 1];
          const nextBaseVersion = lastOperation.baseVersion + 1;
          const operations2 = this.editor.model.document.history.getOperations(nextBaseVersion);
          this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations2);
          this._undo(item.batch, redoingBatch);
        });
        this.refresh();
      }
    }
    class UndoEditing extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The command that manages the undo {@link module:engine/model/batch~Batch batches} stack (history).
        * Created and registered during the {@link #init feature initialization}.
        */
        __publicField(this, "_undoCommand");
        /**
        * The command that manages the redo {@link module:engine/model/batch~Batch batches} stack (history).
        * Created and registered during the {@link #init feature initialization}.
        */
        __publicField(this, "_redoCommand");
        /**
        * Keeps track of which batches were registered in undo.
        */
        __publicField(this, "_batchRegistry", /* @__PURE__ */ new WeakSet());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "UndoEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        this._undoCommand = new UndoCommand(editor);
        this._redoCommand = new RedoCommand(editor);
        editor.commands.add("undo", this._undoCommand);
        editor.commands.add("redo", this._redoCommand);
        this.listenTo(editor.model, "applyOperation", (evt, args) => {
          const operation = args[0];
          if (!operation.isDocumentOperation) {
            return;
          }
          const batch = operation.batch;
          const isRedoBatch = this._redoCommand.createdBatches.has(batch);
          const isUndoBatch = this._undoCommand.createdBatches.has(batch);
          const wasProcessed = this._batchRegistry.has(batch);
          if (wasProcessed) {
            return;
          }
          this._batchRegistry.add(batch);
          if (!batch.isUndoable) {
            return;
          }
          if (isRedoBatch) {
            this._undoCommand.addBatch(batch);
          } else if (!isUndoBatch) {
            this._undoCommand.addBatch(batch);
            this._redoCommand.clearStack();
          }
        }, {
          priority: "highest"
        });
        this.listenTo(this._undoCommand, "revert", (evt, undoneBatch, undoingBatch) => {
          this._redoCommand.addBatch(undoingBatch);
        });
        editor.keystrokes.set("CTRL+Z", "undo");
        editor.keystrokes.set("CTRL+Y", "redo");
        editor.keystrokes.set("CTRL+SHIFT+Z", "redo");
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Undo"),
              keystroke: "CTRL+Z"
            },
            {
              label: t("Redo"),
              keystroke: [
                [
                  "CTRL+Y"
                ],
                [
                  "CTRL+SHIFT+Z"
                ]
              ]
            }
          ]
        });
      }
    }
    class UndoUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "UndoUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const locale = editor.locale;
        const t = editor.t;
        const localizedUndoIcon = locale.uiLanguageDirection == "ltr" ? icons.undo : icons.redo;
        const localizedRedoIcon = locale.uiLanguageDirection == "ltr" ? icons.redo : icons.undo;
        this._addButtonsToFactory("undo", t("Undo"), "CTRL+Z", localizedUndoIcon);
        this._addButtonsToFactory("redo", t("Redo"), "CTRL+Y", localizedRedoIcon);
      }
      /**
      * Creates a button for the specified command.
      *
      * @param name Command name.
      * @param label Button label.
      * @param keystroke Command keystroke.
      * @param Icon Source of the icon.
      */
      _addButtonsToFactory(name, label, keystroke, Icon) {
        const editor = this.editor;
        editor.ui.componentFactory.add(name, () => {
          const buttonView = this._createButton(ButtonView, name, label, keystroke, Icon);
          buttonView.set({
            tooltip: true
          });
          return buttonView;
        });
        editor.ui.componentFactory.add("menuBar:" + name, () => {
          return this._createButton(MenuBarMenuListItemButtonView, name, label, keystroke, Icon);
        });
      }
      /**
      * TODO
      */
      _createButton(ButtonClass, name, label, keystroke, Icon) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get(name);
        const view = new ButtonClass(locale);
        view.set({
          label,
          icon: Icon,
          keystroke
        });
        view.bind("isEnabled").to(command, "isEnabled");
        this.listenTo(view, "execute", () => {
          editor.execute(name);
          editor.editing.view.focus();
        });
        return view;
      }
    }
    class Undo extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          UndoEditing,
          UndoUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Undo";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class Essentials extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          AccessibilityHelp,
          Clipboard,
          Enter,
          SelectAll,
          ShiftEnter,
          Typing,
          Undo
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Essentials";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class FontCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor Editor instance.
      * @param attributeKey The name of a model attribute on which this command operates.
      */
      constructor(editor, attributeKey) {
        super(editor);
        /**
        * A model attribute on which this command operates.
        */
        __publicField(this, "attributeKey");
        this.attributeKey = attributeKey;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const doc = model.document;
        this.value = doc.selection.getAttribute(this.attributeKey);
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
      }
      /**
      * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
      * If no `value` is passed, it removes the attribute from the selection.
      *
      * @param options Options for the executed command.
      * @param options.value The value to apply.
      * @fires execute
      */
      execute(options = {}) {
        const model = this.editor.model;
        const document2 = model.document;
        const selection = document2.selection;
        const value = options.value;
        const batch = options.batch;
        const updateAttribute = (writer) => {
          if (selection.isCollapsed) {
            if (value) {
              writer.setSelectionAttribute(this.attributeKey, value);
            } else {
              writer.removeSelectionAttribute(this.attributeKey);
            }
          } else {
            const ranges = model.schema.getValidRanges(selection.getRanges(), this.attributeKey);
            for (const range of ranges) {
              if (value) {
                writer.setAttribute(this.attributeKey, value, range);
              } else {
                writer.removeAttribute(this.attributeKey, range);
              }
            }
          }
        };
        if (batch) {
          model.enqueueChange(batch, (writer) => {
            updateAttribute(writer);
          });
        } else {
          model.change((writer) => {
            updateAttribute(writer);
          });
        }
      }
    }
    const FONT_SIZE = "fontSize";
    const FONT_COLOR = "fontColor";
    const FONT_BACKGROUND_COLOR = "fontBackgroundColor";
    function buildDefinition(modelAttributeKey, options) {
      const definition = {
        model: {
          key: modelAttributeKey,
          values: []
        },
        view: {},
        upcastAlso: {}
      };
      for (const option of options) {
        definition.model.values.push(option.model);
        definition.view[option.model] = option.view;
        if (option.upcastAlso) {
          definition.upcastAlso[option.model] = option.upcastAlso;
        }
      }
      return definition;
    }
    function renderUpcastAttribute(styleAttr) {
      return (viewElement) => normalizeColorCode(viewElement.getStyle(styleAttr));
    }
    function renderDowncastElement(styleAttr) {
      return (modelAttributeValue, { writer }) => writer.createAttributeElement("span", {
        style: `${styleAttr}:${modelAttributeValue}`
      }, {
        priority: 7
      });
    }
    function addColorSelectorToDropdown({ dropdownView, colors, columns, removeButtonLabel, colorPickerLabel, documentColorsLabel, documentColorsCount, colorPickerViewConfig }) {
      const locale = dropdownView.locale;
      const colorSelectorView = new ColorSelectorView(locale, {
        colors,
        columns,
        removeButtonLabel,
        colorPickerLabel,
        documentColorsLabel,
        documentColorsCount,
        colorPickerViewConfig
      });
      dropdownView.colorSelectorView = colorSelectorView;
      dropdownView.panelView.children.add(colorSelectorView);
      return colorSelectorView;
    }
    function normalizeColorCode(value) {
      return value.replace(/\s/g, "");
    }
    class FontSizeCommand extends FontCommand {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor, FONT_SIZE);
      }
    }
    function normalizeOptions(configuredOptions) {
      return configuredOptions.map((item) => getOptionDefinition(item)).filter((option) => option !== void 0);
    }
    const namedPresets = {
      get tiny() {
        return {
          title: "Tiny",
          model: "tiny",
          view: {
            name: "span",
            classes: "text-tiny",
            priority: 7
          }
        };
      },
      get small() {
        return {
          title: "Small",
          model: "small",
          view: {
            name: "span",
            classes: "text-small",
            priority: 7
          }
        };
      },
      get big() {
        return {
          title: "Big",
          model: "big",
          view: {
            name: "span",
            classes: "text-big",
            priority: 7
          }
        };
      },
      get huge() {
        return {
          title: "Huge",
          model: "huge",
          view: {
            name: "span",
            classes: "text-huge",
            priority: 7
          }
        };
      }
    };
    function getOptionDefinition(option) {
      if (typeof option === "number") {
        option = String(option);
      }
      if (typeof option === "object" && isFullItemDefinition(option)) {
        return attachPriority(option);
      }
      const preset = findPreset(option);
      if (preset) {
        return attachPriority(preset);
      }
      if (option === "default") {
        return {
          model: void 0,
          title: "Default"
        };
      }
      if (isNumericalDefinition(option)) {
        return void 0;
      }
      return generatePixelPreset(option);
    }
    function generatePixelPreset(definition) {
      if (typeof definition === "string") {
        definition = {
          title: definition,
          model: `${parseFloat(definition)}px`
        };
      }
      definition.view = {
        name: "span",
        styles: {
          "font-size": definition.model
        }
      };
      return attachPriority(definition);
    }
    function attachPriority(definition) {
      if (definition.view && typeof definition.view !== "string" && !definition.view.priority) {
        definition.view.priority = 7;
      }
      return definition;
    }
    function findPreset(definition) {
      return typeof definition === "string" ? namedPresets[definition] : namedPresets[definition.model];
    }
    function isFullItemDefinition(definition) {
      return definition.title && definition.model && definition.view;
    }
    function isNumericalDefinition(definition) {
      let numberValue;
      if (typeof definition === "object") {
        if (!definition.model) {
          throw new CKEditorError("font-size-invalid-definition", null, definition);
        } else {
          numberValue = parseFloat(definition.model);
        }
      } else {
        numberValue = parseFloat(definition);
      }
      return isNaN(numberValue);
    }
    const styleFontSize = [
      "x-small",
      "x-small",
      "small",
      "medium",
      "large",
      "x-large",
      "xx-large",
      "xxx-large"
    ];
    class FontSizeEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontSizeEditing";
      }
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        editor.config.define(FONT_SIZE, {
          options: [
            "tiny",
            "small",
            "default",
            "big",
            "huge"
          ],
          supportAllValues: false
        });
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        editor.model.schema.extend("$text", {
          allowAttributes: FONT_SIZE
        });
        editor.model.schema.setAttributeProperties(FONT_SIZE, {
          isFormatting: true,
          copyOnEnter: true
        });
        const supportAllValues = editor.config.get("fontSize.supportAllValues");
        const options = normalizeOptions(this.editor.config.get("fontSize.options")).filter((item) => item.model);
        const definition = buildDefinition(FONT_SIZE, options);
        if (supportAllValues) {
          this._prepareAnyValueConverters(definition);
          this._prepareCompatibilityConverter();
        } else {
          editor.conversion.attributeToElement(definition);
        }
        editor.commands.add(FONT_SIZE, new FontSizeCommand(editor));
      }
      /**
      * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
      * if it is not defined in the plugin configuration.
      *
      * @param definition Converter definition out of input data.
      */
      _prepareAnyValueConverters(definition) {
        const editor = this.editor;
        const presets = definition.model.values.filter((value) => {
          return !isLength(String(value)) && !isPercentage(String(value));
        });
        if (presets.length) {
          throw new CKEditorError("font-size-invalid-use-of-named-presets", null, {
            presets
          });
        }
        editor.conversion.for("downcast").attributeToElement({
          model: FONT_SIZE,
          view: (attributeValue, { writer }) => {
            if (!attributeValue) {
              return;
            }
            return writer.createAttributeElement("span", {
              style: "font-size:" + attributeValue
            }, {
              priority: 7
            });
          }
        });
        editor.conversion.for("upcast").elementToAttribute({
          model: {
            key: FONT_SIZE,
            value: (viewElement) => viewElement.getStyle("font-size")
          },
          view: {
            name: "span",
            styles: {
              "font-size": /.*/
            }
          }
        });
      }
      /**
      * Adds support for legacy `<font size="..">` formatting.
      */
      _prepareCompatibilityConverter() {
        const editor = this.editor;
        editor.conversion.for("upcast").elementToAttribute({
          view: {
            name: "font",
            attributes: {
              // Documentation mentions sizes from 1 to 7. To handle old content we support all values
              // up to 999 but clamp it to the valid range. Why 999? It should cover accidental values
              // similar to percentage, e.g. 100%, 200% which could be the usual mistake for font size.
              "size": /^[+-]?\d{1,3}$/
            }
          },
          model: {
            key: FONT_SIZE,
            value: (viewElement) => {
              const value = viewElement.getAttribute("size");
              const isRelative = value[0] === "-" || value[0] === "+";
              let size = parseInt(value, 10);
              if (isRelative) {
                size = 3 + size;
              }
              const maxSize = styleFontSize.length - 1;
              const clampedSize = Math.min(Math.max(size, 0), maxSize);
              return styleFontSize[clampedSize];
            }
          }
        });
      }
    }
    var fontSizeIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z"/></svg>';
    class FontSizeUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontSizeUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        const options = this._getLocalizedOptions();
        const command = editor.commands.get(FONT_SIZE);
        const accessibleLabel = t("Font Size");
        const listOptions = _prepareListOptions(options, command);
        editor.ui.componentFactory.add(FONT_SIZE, (locale) => {
          const dropdownView = createDropdown(locale);
          addListToDropdown(dropdownView, listOptions, {
            role: "menu",
            ariaLabel: accessibleLabel
          });
          dropdownView.buttonView.set({
            label: accessibleLabel,
            icon: fontSizeIcon,
            tooltip: true
          });
          dropdownView.extendTemplate({
            attributes: {
              class: [
                "ck-font-size-dropdown"
              ]
            }
          });
          dropdownView.bind("isEnabled").to(command);
          this.listenTo(dropdownView, "execute", (evt) => {
            editor.execute(evt.source.commandName, {
              value: evt.source.commandParam
            });
            editor.editing.view.focus();
          });
          return dropdownView;
        });
        editor.ui.componentFactory.add(`menuBar:${FONT_SIZE}`, (locale) => {
          const menuView = new MenuBarMenuView(locale);
          menuView.buttonView.set({
            label: accessibleLabel,
            icon: fontSizeIcon
          });
          menuView.bind("isEnabled").to(command);
          const listView = new MenuBarMenuListView(locale);
          for (const definition of listOptions) {
            const listItemView = new MenuBarMenuListItemView(locale, menuView);
            const buttonView = new MenuBarMenuListItemButtonView(locale);
            buttonView.bind(...Object.keys(definition.model)).to(definition.model);
            buttonView.bind("ariaChecked").to(buttonView, "isOn");
            buttonView.delegate("execute").to(menuView);
            buttonView.on("execute", () => {
              editor.execute(definition.model.commandName, {
                value: definition.model.commandParam
              });
              editor.editing.view.focus();
            });
            listItemView.children.add(buttonView);
            listView.items.add(listItemView);
          }
          menuView.panelView.children.add(listView);
          return menuView;
        });
      }
      /**
      * Returns options as defined in `config.fontSize.options` but processed to account for
      * editor localization, i.e. to display {@link module:font/fontconfig~FontSizeOption}
      * in the correct language.
      *
      * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
      * when the user configuration is defined because the editor does not exist yet.
      */
      _getLocalizedOptions() {
        const editor = this.editor;
        const t = editor.t;
        const localizedTitles = {
          Default: t("Default"),
          Tiny: t("Tiny"),
          Small: t("Small"),
          Big: t("Big"),
          Huge: t("Huge")
        };
        const options = normalizeOptions(editor.config.get(FONT_SIZE).options);
        return options.map((option) => {
          const title = localizedTitles[option.title];
          if (title && title != option.title) {
            option = Object.assign({}, option, {
              title
            });
          }
          return option;
        });
      }
    }
    function _prepareListOptions(options, command) {
      const itemDefinitions = new Collection();
      for (const option of options) {
        const def = {
          type: "button",
          model: new Model({
            commandName: FONT_SIZE,
            commandParam: option.model,
            label: option.title,
            class: "ck-fontsize-option",
            role: "menuitemradio",
            withText: true
          })
        };
        if (option.view && typeof option.view !== "string") {
          if (option.view.styles) {
            def.model.set("labelStyle", `font-size:${option.view.styles["font-size"]}`);
          }
          if (option.view.classes) {
            def.model.set("class", `${def.model.class} ${option.view.classes}`);
          }
        }
        def.model.bind("isOn").to(command, "value", (value) => value === option.model);
        itemDefinitions.add(def);
      }
      return itemDefinitions;
    }
    class FontSize extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          FontSizeEditing,
          FontSizeUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontSize";
      }
      /**
      * Normalizes and translates the {@link module:font/fontconfig~FontSizeConfig#options configuration options}
      * to the {@link module:font/fontconfig~FontSizeOption} format.
      *
      * @param configuredOptions An array of options taken from the configuration.
      */
      normalizeSizeOptions(options) {
        return normalizeOptions(options);
      }
    }
    class FontColorCommand extends FontCommand {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor, FONT_COLOR);
      }
    }
    class FontColorEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontColorEditing";
      }
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        editor.config.define(FONT_COLOR, {
          colors: [
            {
              color: "hsl(0, 0%, 0%)",
              label: "Black"
            },
            {
              color: "hsl(0, 0%, 30%)",
              label: "Dim grey"
            },
            {
              color: "hsl(0, 0%, 60%)",
              label: "Grey"
            },
            {
              color: "hsl(0, 0%, 90%)",
              label: "Light grey"
            },
            {
              color: "hsl(0, 0%, 100%)",
              label: "White",
              hasBorder: true
            },
            {
              color: "hsl(0, 75%, 60%)",
              label: "Red"
            },
            {
              color: "hsl(30, 75%, 60%)",
              label: "Orange"
            },
            {
              color: "hsl(60, 75%, 60%)",
              label: "Yellow"
            },
            {
              color: "hsl(90, 75%, 60%)",
              label: "Light green"
            },
            {
              color: "hsl(120, 75%, 60%)",
              label: "Green"
            },
            {
              color: "hsl(150, 75%, 60%)",
              label: "Aquamarine"
            },
            {
              color: "hsl(180, 75%, 60%)",
              label: "Turquoise"
            },
            {
              color: "hsl(210, 75%, 60%)",
              label: "Light blue"
            },
            {
              color: "hsl(240, 75%, 60%)",
              label: "Blue"
            },
            {
              color: "hsl(270, 75%, 60%)",
              label: "Purple"
            }
          ],
          columns: 5
        });
        editor.conversion.for("upcast").elementToAttribute({
          view: {
            name: "span",
            styles: {
              "color": /[\s\S]+/
            }
          },
          model: {
            key: FONT_COLOR,
            value: renderUpcastAttribute("color")
          }
        });
        editor.conversion.for("upcast").elementToAttribute({
          view: {
            name: "font",
            attributes: {
              "color": /^#?\w+$/
            }
          },
          model: {
            key: FONT_COLOR,
            value: (viewElement) => viewElement.getAttribute("color")
          }
        });
        editor.conversion.for("downcast").attributeToElement({
          model: FONT_COLOR,
          view: renderDowncastElement("color")
        });
        editor.commands.add(FONT_COLOR, new FontColorCommand(editor));
        editor.model.schema.extend("$text", {
          allowAttributes: FONT_COLOR
        });
        editor.model.schema.setAttributeProperties(FONT_COLOR, {
          isFormatting: true,
          copyOnEnter: true
        });
      }
    }
    class ColorUI extends Plugin {
      /**
      * Creates a plugin which introduces a dropdown with a pre–configured
      * {@link module:ui/colorselector/colorselectorview~ColorSelectorView}.
      *
      * @param config The configuration object.
      * @param config.commandName The name of the command which will be executed when a color tile is clicked.
      * @param config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
      * and the configuration scope name in `editor.config`.
      * @param config.icon The SVG icon used by the dropdown.
      * @param config.dropdownLabel The label used by the dropdown.
      */
      constructor(editor, { commandName, componentName, icon, dropdownLabel }) {
        super(editor);
        /**
        * The name of the command which will be executed when a color tile is clicked.
        */
        __publicField(this, "commandName");
        /**
        * The name of this component in the {@link module:ui/componentfactory~ComponentFactory}.
        * Also the configuration scope name in `editor.config`.
        */
        __publicField(this, "componentName");
        /**
        * The SVG icon used by the dropdown.
        */
        __publicField(this, "icon");
        /**
        * The label used by the dropdown.
        */
        __publicField(this, "dropdownLabel");
        /**
        * The number of columns in the color grid.
        */
        __publicField(this, "columns");
        this.commandName = commandName;
        this.componentName = componentName;
        this.icon = icon;
        this.dropdownLabel = dropdownLabel;
        this.columns = editor.config.get(`${this.componentName}.columns`);
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const locale = editor.locale;
        const t = locale.t;
        const command = editor.commands.get(this.commandName);
        const componentConfig = editor.config.get(this.componentName);
        const colorsConfig = normalizeColorOptions(componentConfig.colors);
        const localizedColors = getLocalizedColorOptions(locale, colorsConfig);
        const documentColorsCount = componentConfig.documentColors;
        const hasColorPicker = componentConfig.colorPicker !== false;
        editor.ui.componentFactory.add(this.componentName, (locale2) => {
          const dropdownView = createDropdown(locale2);
          let dropdownContentRendered = false;
          const colorSelectorView = addColorSelectorToDropdown({
            dropdownView,
            colors: localizedColors.map((option) => ({
              label: option.label,
              color: option.model,
              options: {
                hasBorder: option.hasBorder
              }
            })),
            columns: this.columns,
            removeButtonLabel: t("Remove color"),
            colorPickerLabel: t("Color picker"),
            documentColorsLabel: documentColorsCount !== 0 ? t("Document colors") : "",
            documentColorsCount: documentColorsCount === void 0 ? this.columns : documentColorsCount,
            colorPickerViewConfig: hasColorPicker ? componentConfig.colorPicker || {} : false
          });
          colorSelectorView.bind("selectedColor").to(command, "value");
          dropdownView.buttonView.set({
            label: this.dropdownLabel,
            icon: this.icon,
            tooltip: true
          });
          dropdownView.extendTemplate({
            attributes: {
              class: "ck-color-ui-dropdown"
            }
          });
          dropdownView.bind("isEnabled").to(command);
          colorSelectorView.on("execute", (evt, data) => {
            if (dropdownView.isOpen) {
              editor.execute(this.commandName, {
                value: data.value,
                batch: this._undoStepBatch
              });
            }
            if (data.source !== "colorPicker") {
              editor.editing.view.focus();
            }
            if (data.source === "colorPickerSaveButton") {
              dropdownView.isOpen = false;
            }
          });
          colorSelectorView.on("colorPicker:show", () => {
            this._undoStepBatch = editor.model.createBatch();
          });
          colorSelectorView.on("colorPicker:cancel", () => {
            if (this._undoStepBatch.operations.length) {
              dropdownView.isOpen = false;
              editor.execute("undo", this._undoStepBatch);
            }
            editor.editing.view.focus();
          });
          dropdownView.on("change:isOpen", (evt, name, isVisible2) => {
            if (!dropdownContentRendered) {
              dropdownContentRendered = true;
              dropdownView.colorSelectorView.appendUI();
            }
            if (isVisible2) {
              if (documentColorsCount !== 0) {
                colorSelectorView.updateDocumentColors(editor.model, this.componentName);
              }
              colorSelectorView.updateSelectedColors();
              colorSelectorView.showColorGridsFragment();
            }
          });
          focusChildOnDropdownOpen(dropdownView, () => dropdownView.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((item) => item.isOn));
          return dropdownView;
        });
        editor.ui.componentFactory.add(`menuBar:${this.componentName}`, (locale2) => {
          const menuView = new MenuBarMenuView(locale2);
          menuView.buttonView.set({
            label: this.dropdownLabel,
            icon: this.icon
          });
          menuView.bind("isEnabled").to(command);
          let contentRendered = false;
          const colorSelectorView = new ColorSelectorView(locale2, {
            colors: localizedColors.map((option) => ({
              label: option.label,
              color: option.model,
              options: {
                hasBorder: option.hasBorder
              }
            })),
            columns: this.columns,
            removeButtonLabel: t("Remove color"),
            colorPickerLabel: t("Color picker"),
            documentColorsLabel: documentColorsCount !== 0 ? t("Document colors") : "",
            documentColorsCount: documentColorsCount === void 0 ? this.columns : documentColorsCount,
            colorPickerViewConfig: false
          });
          colorSelectorView.bind("selectedColor").to(command, "value");
          colorSelectorView.delegate("execute").to(menuView);
          colorSelectorView.on("execute", (evt, data) => {
            editor.execute(this.commandName, {
              value: data.value,
              batch: this._undoStepBatch
            });
            editor.editing.view.focus();
          });
          menuView.on("change:isOpen", (evt, name, isVisible2) => {
            if (!contentRendered) {
              contentRendered = true;
              colorSelectorView.appendUI();
            }
            if (isVisible2) {
              if (documentColorsCount !== 0) {
                colorSelectorView.updateDocumentColors(editor.model, this.componentName);
              }
              colorSelectorView.updateSelectedColors();
              colorSelectorView.showColorGridsFragment();
            }
          });
          menuView.panelView.children.add(colorSelectorView);
          return menuView;
        });
      }
    }
    var fontColorIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>';
    class FontColorUI extends ColorUI {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        const t = editor.locale.t;
        super(editor, {
          commandName: FONT_COLOR,
          componentName: FONT_COLOR,
          icon: fontColorIcon,
          dropdownLabel: t("Font Color")
        });
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontColorUI";
      }
    }
    class FontColor extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          FontColorEditing,
          FontColorUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontColor";
      }
    }
    class FontBackgroundColorCommand extends FontCommand {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor, FONT_BACKGROUND_COLOR);
      }
    }
    class FontBackgroundColorEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontBackgroundColorEditing";
      }
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        editor.config.define(FONT_BACKGROUND_COLOR, {
          colors: [
            {
              color: "hsl(0, 0%, 0%)",
              label: "Black"
            },
            {
              color: "hsl(0, 0%, 30%)",
              label: "Dim grey"
            },
            {
              color: "hsl(0, 0%, 60%)",
              label: "Grey"
            },
            {
              color: "hsl(0, 0%, 90%)",
              label: "Light grey"
            },
            {
              color: "hsl(0, 0%, 100%)",
              label: "White",
              hasBorder: true
            },
            {
              color: "hsl(0, 75%, 60%)",
              label: "Red"
            },
            {
              color: "hsl(30, 75%, 60%)",
              label: "Orange"
            },
            {
              color: "hsl(60, 75%, 60%)",
              label: "Yellow"
            },
            {
              color: "hsl(90, 75%, 60%)",
              label: "Light green"
            },
            {
              color: "hsl(120, 75%, 60%)",
              label: "Green"
            },
            {
              color: "hsl(150, 75%, 60%)",
              label: "Aquamarine"
            },
            {
              color: "hsl(180, 75%, 60%)",
              label: "Turquoise"
            },
            {
              color: "hsl(210, 75%, 60%)",
              label: "Light blue"
            },
            {
              color: "hsl(240, 75%, 60%)",
              label: "Blue"
            },
            {
              color: "hsl(270, 75%, 60%)",
              label: "Purple"
            }
          ],
          columns: 5
        });
        editor.data.addStyleProcessorRules(addBackgroundRules);
        editor.conversion.for("upcast").elementToAttribute({
          view: {
            name: "span",
            styles: {
              "background-color": /[\s\S]+/
            }
          },
          model: {
            key: FONT_BACKGROUND_COLOR,
            value: renderUpcastAttribute("background-color")
          }
        });
        editor.conversion.for("downcast").attributeToElement({
          model: FONT_BACKGROUND_COLOR,
          view: renderDowncastElement("background-color")
        });
        editor.commands.add(FONT_BACKGROUND_COLOR, new FontBackgroundColorCommand(editor));
        editor.model.schema.extend("$text", {
          allowAttributes: FONT_BACKGROUND_COLOR
        });
        editor.model.schema.setAttributeProperties(FONT_BACKGROUND_COLOR, {
          isFormatting: true,
          copyOnEnter: true
        });
      }
    }
    var fontBackgroundColorIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>';
    class FontBackgroundColorUI extends ColorUI {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        const t = editor.locale.t;
        super(editor, {
          commandName: FONT_BACKGROUND_COLOR,
          componentName: FONT_BACKGROUND_COLOR,
          icon: fontBackgroundColorIcon,
          dropdownLabel: t("Font Background Color")
        });
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontBackgroundColorUI";
      }
    }
    class FontBackgroundColor extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          FontBackgroundColorEditing,
          FontBackgroundColorUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "FontBackgroundColor";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ParagraphCommand extends Command {
      constructor(editor) {
        super(editor);
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const document2 = model.document;
        const block2 = first(document2.selection.getSelectedBlocks());
        this.value = !!block2 && block2.is("element", "paragraph");
        this.isEnabled = !!block2 && checkCanBecomeParagraph(block2, model.schema);
      }
      /**
      * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
      * will be turned to paragraphs.
      *
      * @fires execute
      * @param options Options for the executed command.
      * @param options.selection The selection that the command should be applied to. By default,
      * if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const document2 = model.document;
        const selection = options.selection || document2.selection;
        if (!model.canEditAt(selection)) {
          return;
        }
        model.change((writer) => {
          const blocks = selection.getSelectedBlocks();
          for (const block2 of blocks) {
            if (!block2.is("element", "paragraph") && checkCanBecomeParagraph(block2, model.schema)) {
              writer.rename(block2, "paragraph");
            }
          }
        });
      }
    }
    function checkCanBecomeParagraph(block2, schema) {
      return schema.checkChild(block2.parent, "paragraph") && !schema.isObject(block2);
    }
    class InsertParagraphCommand extends Command {
      constructor(editor) {
        super(editor);
        this._isEnabledBasedOnSelection = false;
      }
      /**
      * Executes the command.
      *
      * @param options Options for the executed command.
      * @param options.position The model position at which the new paragraph will be inserted.
      * @param options.attributes Attributes keys and values to set on a inserted paragraph.
      * @fires execute
      */
      execute(options) {
        const model = this.editor.model;
        const attributes = options.attributes;
        let position = options.position;
        if (!model.canEditAt(position)) {
          return;
        }
        model.change((writer) => {
          position = this._findPositionToInsertParagraph(position, writer);
          if (!position) {
            return;
          }
          const paragraph2 = writer.createElement("paragraph");
          if (attributes) {
            model.schema.setAllowedAttributes(paragraph2, attributes, writer);
          }
          model.insertContent(paragraph2, position);
          writer.setSelection(paragraph2, "in");
        });
      }
      /**
      * Returns the best position to insert a new paragraph.
      */
      _findPositionToInsertParagraph(position, writer) {
        const model = this.editor.model;
        if (model.schema.checkChild(position, "paragraph")) {
          return position;
        }
        const allowedParent = model.schema.findAllowedParent(position, "paragraph");
        if (!allowedParent) {
          return null;
        }
        const positionParent = position.parent;
        const isTextAllowed = model.schema.checkChild(positionParent, "$text");
        if (positionParent.isEmpty || isTextAllowed && position.isAtEnd) {
          return model.createPositionAfter(positionParent);
        }
        if (!positionParent.isEmpty && isTextAllowed && position.isAtStart) {
          return model.createPositionBefore(positionParent);
        }
        return writer.split(position, allowedParent).position;
      }
    }
    const _Paragraph = class _Paragraph extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Paragraph";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        editor.commands.add("paragraph", new ParagraphCommand(editor));
        editor.commands.add("insertParagraph", new InsertParagraphCommand(editor));
        model.schema.register("paragraph", {
          inheritAllFrom: "$block"
        });
        editor.conversion.elementToElement({
          model: "paragraph",
          view: "p"
        });
        editor.conversion.for("upcast").elementToElement({
          model: (viewElement, { writer }) => {
            if (!_Paragraph.paragraphLikeElements.has(viewElement.name)) {
              return null;
            }
            if (viewElement.isEmpty) {
              return null;
            }
            return writer.createElement("paragraph");
          },
          view: /.+/,
          converterPriority: "low"
        });
      }
    };
    /**
    * A list of element names which should be treated by the autoparagraphing algorithms as
    * paragraph-like. This means that e.g. the following content:
    *
    * ```html
    * <h1>Foo</h1>
    * <table>
    *   <tr>
    *     <td>X</td>
    *     <td>
    *       <ul>
    *         <li>Y</li>
    *         <li>Z</li>
    *       </ul>
    *     </td>
    *   </tr>
    * </table>
    * ```
    *
    * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.
    * Hence, if none of the features is going to convert those elements the above content will be automatically handled
    * by the paragraph feature and converted to:
    *
    * ```html
    * <p>Foo</p>
    * <p>X</p>
    * <p>Y</p>
    * <p>Z</p>
    * ```
    *
    * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements
    * have a priority upon conversion.
    */
    __publicField(_Paragraph, "paragraphLikeElements", /* @__PURE__ */ new Set([
      "blockquote",
      "dd",
      "div",
      "dt",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "li",
      "p",
      "td",
      "th"
    ]));
    let Paragraph = _Paragraph;
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class HeadingCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor Editor instance.
      * @param modelElements Names of the element which this command can apply in the model.
      */
      constructor(editor, modelElements) {
        super(editor);
        /**
        * Set of defined model's elements names that this command support.
        * See {@link module:heading/headingconfig~HeadingOption}.
        */
        __publicField(this, "modelElements");
        this.modelElements = modelElements;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const block2 = first(this.editor.model.document.selection.getSelectedBlocks());
        this.value = !!block2 && this.modelElements.includes(block2.name) && block2.name;
        this.isEnabled = !!block2 && this.modelElements.some((heading) => checkCanBecomeHeading(block2, heading, this.editor.model.schema));
      }
      /**
      * Executes the command. Applies the heading to the selected blocks or, if the first selected
      * block is a heading already, turns selected headings (of this level only) to paragraphs.
      *
      * @param options.value Name of the element which this command will apply in the model.
      * @fires execute
      */
      execute(options) {
        const model = this.editor.model;
        const document2 = model.document;
        const modelElement = options.value;
        model.change((writer) => {
          const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => {
            return checkCanBecomeHeading(block2, modelElement, model.schema);
          });
          for (const block2 of blocks) {
            if (!block2.is("element", modelElement)) {
              writer.rename(block2, modelElement);
            }
          }
        });
      }
    }
    function checkCanBecomeHeading(block2, heading, schema) {
      return schema.checkChild(block2.parent, heading) && !schema.isObject(block2);
    }
    const defaultModelElement = "paragraph";
    class HeadingEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "HeadingEditing";
      }
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        editor.config.define("heading", {
          options: [
            {
              model: "paragraph",
              title: "Paragraph",
              class: "ck-heading_paragraph"
            },
            {
              model: "heading1",
              view: "h2",
              title: "Heading 1",
              class: "ck-heading_heading1"
            },
            {
              model: "heading2",
              view: "h3",
              title: "Heading 2",
              class: "ck-heading_heading2"
            },
            {
              model: "heading3",
              view: "h4",
              title: "Heading 3",
              class: "ck-heading_heading3"
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Paragraph
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const options = editor.config.get("heading.options");
        const modelElements = [];
        for (const option of options) {
          if (option.model === "paragraph") {
            continue;
          }
          editor.model.schema.register(option.model, {
            inheritAllFrom: "$block"
          });
          editor.conversion.elementToElement(option);
          modelElements.push(option.model);
        }
        this._addDefaultH1Conversion(editor);
        editor.commands.add("heading", new HeadingCommand(editor, modelElements));
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor = this.editor;
        const enterCommand = editor.commands.get("enter");
        const options = editor.config.get("heading.options");
        if (enterCommand) {
          this.listenTo(enterCommand, "afterExecute", (evt, data) => {
            const positionParent = editor.model.document.selection.getFirstPosition().parent;
            const isHeading = options.some((option) => positionParent.is("element", option.model));
            if (isHeading && !positionParent.is("element", defaultModelElement) && positionParent.childCount === 0) {
              data.writer.rename(positionParent, defaultModelElement);
            }
          });
        }
      }
      /**
      * Adds default conversion for `h1` -> `heading1` with a low priority.
      *
      * @param editor Editor instance on which to add the `h1` conversion.
      */
      _addDefaultH1Conversion(editor) {
        editor.conversion.for("upcast").elementToElement({
          model: "heading1",
          view: "h1",
          // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
          // this listener is called before it. If not, `h1` will be transformed into a paragraph.
          converterPriority: priorities.low + 1
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getLocalizedOptions(editor) {
      const t = editor.t;
      const localizedTitles = {
        "Paragraph": t("Paragraph"),
        "Heading 1": t("Heading 1"),
        "Heading 2": t("Heading 2"),
        "Heading 3": t("Heading 3"),
        "Heading 4": t("Heading 4"),
        "Heading 5": t("Heading 5"),
        "Heading 6": t("Heading 6")
      };
      return editor.config.get("heading.options").map((option) => {
        const title = localizedTitles[option.title];
        if (title && title != option.title) {
          option.title = title;
        }
        return option;
      });
    }
    class HeadingUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "HeadingUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        const options = getLocalizedOptions(editor);
        const defaultTitle = t("Choose heading");
        const accessibleLabel = t("Heading");
        editor.ui.componentFactory.add("heading", (locale) => {
          const titles = {};
          const itemDefinitions = new Collection();
          const headingCommand = editor.commands.get("heading");
          const paragraphCommand = editor.commands.get("paragraph");
          const commands = [
            headingCommand
          ];
          for (const option of options) {
            const def = {
              type: "button",
              model: new Model({
                label: option.title,
                class: option.class,
                role: "menuitemradio",
                withText: true
              })
            };
            if (option.model === "paragraph") {
              def.model.bind("isOn").to(paragraphCommand, "value");
              def.model.set("commandName", "paragraph");
              commands.push(paragraphCommand);
            } else {
              def.model.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
              def.model.set({
                commandName: "heading",
                commandValue: option.model
              });
            }
            itemDefinitions.add(def);
            titles[option.model] = option.title;
          }
          const dropdownView = createDropdown(locale);
          addListToDropdown(dropdownView, itemDefinitions, {
            ariaLabel: accessibleLabel,
            role: "menu"
          });
          dropdownView.buttonView.set({
            ariaLabel: accessibleLabel,
            ariaLabelledBy: void 0,
            isOn: false,
            withText: true,
            tooltip: accessibleLabel
          });
          dropdownView.extendTemplate({
            attributes: {
              class: [
                "ck-heading-dropdown"
              ]
            }
          });
          dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
            return areEnabled.some((isEnabled2) => isEnabled2);
          });
          dropdownView.buttonView.bind("label").to(headingCommand, "value", paragraphCommand, "value", (heading, paragraph2) => {
            const whichModel = paragraph2 ? "paragraph" : heading;
            if (typeof whichModel === "boolean") {
              return defaultTitle;
            }
            if (!titles[whichModel]) {
              return defaultTitle;
            }
            return titles[whichModel];
          });
          dropdownView.buttonView.bind("ariaLabel").to(headingCommand, "value", paragraphCommand, "value", (heading, paragraph2) => {
            const whichModel = paragraph2 ? "paragraph" : heading;
            if (typeof whichModel === "boolean") {
              return accessibleLabel;
            }
            if (!titles[whichModel]) {
              return accessibleLabel;
            }
            return `${titles[whichModel]}, ${accessibleLabel}`;
          });
          this.listenTo(dropdownView, "execute", (evt) => {
            const { commandName, commandValue } = evt.source;
            editor.execute(commandName, commandValue ? {
              value: commandValue
            } : void 0);
            editor.editing.view.focus();
          });
          return dropdownView;
        });
        editor.ui.componentFactory.add("menuBar:heading", (locale) => {
          const menuView = new MenuBarMenuView(locale);
          const headingCommand = editor.commands.get("heading");
          const paragraphCommand = editor.commands.get("paragraph");
          const commands = [
            headingCommand
          ];
          const listView = new MenuBarMenuListView(locale);
          menuView.set({
            class: "ck-heading-dropdown"
          });
          listView.set({
            ariaLabel: t("Heading"),
            role: "menu"
          });
          menuView.buttonView.set({
            label: t("Heading")
          });
          menuView.panelView.children.add(listView);
          for (const option of options) {
            const listItemView = new MenuBarMenuListItemView(locale, menuView);
            const buttonView = new MenuBarMenuListItemButtonView(locale);
            listItemView.children.add(buttonView);
            listView.items.add(listItemView);
            buttonView.set({
              label: option.title,
              role: "menuitemradio",
              class: option.class
            });
            buttonView.bind("ariaChecked").to(buttonView, "isOn");
            buttonView.delegate("execute").to(menuView);
            buttonView.on("execute", () => {
              const commandName = option.model === "paragraph" ? "paragraph" : "heading";
              editor.execute(commandName, {
                value: option.model
              });
              editor.editing.view.focus();
            });
            if (option.model === "paragraph") {
              buttonView.bind("isOn").to(paragraphCommand, "value");
              commands.push(paragraphCommand);
            } else {
              buttonView.bind("isOn").to(headingCommand, "value", (value) => value === option.model);
            }
          }
          menuView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
            return areEnabled.some((isEnabled2) => isEnabled2);
          });
          return menuView;
        });
      }
    }
    class Heading extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          HeadingEditing,
          HeadingUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Heading";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function updateViewAttributes(writer, oldViewAttributes, newViewAttributes, viewElement) {
      if (oldViewAttributes) {
        removeViewAttributes(writer, oldViewAttributes, viewElement);
      }
      if (newViewAttributes) {
        setViewAttributes(writer, newViewAttributes, viewElement);
      }
    }
    function setViewAttributes(writer, viewAttributes, viewElement) {
      if (viewAttributes.attributes) {
        for (const [key, value] of Object.entries(viewAttributes.attributes)) {
          writer.setAttribute(key, value, viewElement);
        }
      }
      if (viewAttributes.styles) {
        writer.setStyle(viewAttributes.styles, viewElement);
      }
      if (viewAttributes.classes) {
        writer.addClass(viewAttributes.classes, viewElement);
      }
    }
    function removeViewAttributes(writer, viewAttributes, viewElement) {
      if (viewAttributes.attributes) {
        for (const [key] of Object.entries(viewAttributes.attributes)) {
          writer.removeAttribute(key, viewElement);
        }
      }
      if (viewAttributes.styles) {
        for (const style of Object.keys(viewAttributes.styles)) {
          writer.removeStyle(style, viewElement);
        }
      }
      if (viewAttributes.classes) {
        writer.removeClass(viewAttributes.classes, viewElement);
      }
    }
    function mergeViewElementAttributes(target, source) {
      const result = cloneDeep(target);
      let key = "attributes";
      for (key in source) {
        if (key == "classes") {
          result[key] = Array.from(/* @__PURE__ */ new Set([
            ...target[key] || [],
            ...source[key]
          ]));
        } else {
          result[key] = {
            ...target[key],
            ...source[key]
          };
        }
      }
      return result;
    }
    function modifyGhsAttribute(writer, item, ghsAttributeName, subject, callback) {
      const oldValue = item.getAttribute(ghsAttributeName);
      const newValue = {};
      for (const kind of [
        "attributes",
        "styles",
        "classes"
      ]) {
        if (kind != subject) {
          if (oldValue && oldValue[kind]) {
            newValue[kind] = oldValue[kind];
          }
          continue;
        }
        if (subject == "classes") {
          const values2 = new Set(oldValue && oldValue.classes || []);
          callback(values2);
          if (values2.size) {
            newValue[kind] = Array.from(values2);
          }
          continue;
        }
        const values = new Map(Object.entries(oldValue && oldValue[kind] || {}));
        callback(values);
        if (values.size) {
          newValue[kind] = Object.fromEntries(values);
        }
      }
      if (Object.keys(newValue).length) {
        if (item.is("documentSelection")) {
          writer.setSelectionAttribute(ghsAttributeName, newValue);
        } else {
          writer.setAttribute(ghsAttributeName, newValue, item);
        }
      } else if (oldValue) {
        if (item.is("documentSelection")) {
          writer.removeSelectionAttribute(ghsAttributeName);
        } else {
          writer.removeAttribute(ghsAttributeName, item);
        }
      }
    }
    function toPascalCase(data) {
      return startCase(data).replace(/ /g, "");
    }
    function getHtmlAttributeName(viewElementName) {
      return `html${toPascalCase(viewElementName)}Attributes`;
    }
    function viewToModelObjectConverter({ model: modelName }) {
      return (viewElement, conversionApi) => {
        return conversionApi.writer.createElement(modelName, {
          htmlContent: viewElement.getCustomProperty("$rawContent")
        });
      };
    }
    function toObjectWidgetConverter(editor, { view: viewName, isInline }) {
      const t = editor.t;
      return (modelElement, { writer }) => {
        const widgetLabel = t("HTML object");
        const viewElement = createObjectView(viewName, modelElement, writer);
        const viewAttributes = modelElement.getAttribute(getHtmlAttributeName(viewName));
        writer.addClass("html-object-embed__content", viewElement);
        if (viewAttributes) {
          setViewAttributes(writer, viewAttributes, viewElement);
        }
        const viewContainer = writer.createContainerElement(isInline ? "span" : "div", {
          class: "html-object-embed",
          "data-html-object-embed-label": widgetLabel
        }, viewElement);
        return toWidget(viewContainer, writer, {
          label: widgetLabel
        });
      };
    }
    function createObjectView(viewName, modelElement, writer) {
      return writer.createRawElement(viewName, null, (domElement, domConverter) => {
        domConverter.setContentOf(domElement, modelElement.getAttribute("htmlContent"));
      });
    }
    function viewToAttributeInlineConverter({ view: viewName, model: attributeKey, allowEmpty }, dataFilter) {
      return (dispatcher) => {
        dispatcher.on(`element:${viewName}`, (evt, data, conversionApi) => {
          let viewAttributes = dataFilter.processViewAttributes(data.viewItem, conversionApi);
          if (!viewAttributes && !conversionApi.consumable.test(data.viewItem, {
            name: true
          })) {
            return;
          }
          viewAttributes = viewAttributes || {};
          conversionApi.consumable.consume(data.viewItem, {
            name: true
          });
          if (!data.modelRange) {
            data = Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
          }
          if (allowEmpty && data.modelRange.isCollapsed && Object.keys(viewAttributes).length) {
            const modelElement = conversionApi.writer.createElement("htmlEmptyElement");
            if (!conversionApi.safeInsert(modelElement, data.modelCursor)) {
              return;
            }
            const parts = conversionApi.getSplitParts(modelElement);
            data.modelRange = conversionApi.writer.createRange(data.modelRange.start, conversionApi.writer.createPositionAfter(parts[parts.length - 1]));
            conversionApi.updateConversionResult(modelElement, data);
            setAttributeOnItem2(modelElement, viewAttributes, conversionApi);
            return;
          }
          for (const node of data.modelRange.getItems()) {
            setAttributeOnItem2(node, viewAttributes, conversionApi);
          }
        }, {
          priority: "low"
        });
      };
      function setAttributeOnItem2(node, viewAttributes, conversionApi) {
        if (conversionApi.schema.checkAttribute(node, attributeKey)) {
          const nodeAttributes = node.getAttribute(attributeKey);
          const attributesToAdd = mergeViewElementAttributes(viewAttributes, nodeAttributes || {});
          conversionApi.writer.setAttribute(attributeKey, attributesToAdd, node);
        }
      }
    }
    function emptyInlineModelElementToViewConverter({ model: attributeKey, view: viewName }, asWidget) {
      return (item, { writer, consumable }) => {
        if (!item.hasAttribute(attributeKey)) {
          return null;
        }
        const viewElement = writer.createContainerElement(viewName);
        const attributeValue = item.getAttribute(attributeKey);
        consumable.consume(item, `attribute:${attributeKey}`);
        setViewAttributes(writer, attributeValue, viewElement);
        viewElement.getFillerOffset = () => null;
        return asWidget ? toWidget(viewElement, writer) : viewElement;
      };
    }
    function attributeToViewInlineConverter({ priority, view: viewName }) {
      return (attributeValue, conversionApi) => {
        if (!attributeValue) {
          return;
        }
        const { writer } = conversionApi;
        const viewElement = writer.createAttributeElement(viewName, null, {
          priority
        });
        setViewAttributes(writer, attributeValue, viewElement);
        return viewElement;
      };
    }
    function viewToModelBlockAttributeConverter({ view: viewName }, dataFilter) {
      return (dispatcher) => {
        dispatcher.on(`element:${viewName}`, (evt, data, conversionApi) => {
          if (!data.modelRange || data.modelRange.isCollapsed) {
            return;
          }
          const viewAttributes = dataFilter.processViewAttributes(data.viewItem, conversionApi);
          if (!viewAttributes) {
            return;
          }
          conversionApi.writer.setAttribute(getHtmlAttributeName(data.viewItem.name), viewAttributes, data.modelRange);
        }, {
          priority: "low"
        });
      };
    }
    function modelToViewBlockAttributeConverter({ view: viewName, model: modelName }) {
      return (dispatcher) => {
        dispatcher.on(`attribute:${getHtmlAttributeName(viewName)}:${modelName}`, (evt, data, conversionApi) => {
          if (!conversionApi.consumable.consume(data.item, evt.name)) {
            return;
          }
          const { attributeOldValue, attributeNewValue } = data;
          const viewWriter = conversionApi.writer;
          const viewElement = conversionApi.mapper.toViewElement(data.item);
          updateViewAttributes(viewWriter, attributeOldValue, attributeNewValue, viewElement);
        });
      };
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    var defaultConfig = {
      block: [
        // Existing features.
        {
          model: "codeBlock",
          view: "pre"
        },
        {
          model: "paragraph",
          view: "p"
        },
        {
          model: "blockQuote",
          view: "blockquote"
        },
        {
          model: "listItem",
          view: "li"
        },
        {
          model: "pageBreak",
          view: "div"
        },
        {
          model: "rawHtml",
          view: "div"
        },
        {
          model: "table",
          view: "table"
        },
        {
          model: "tableRow",
          view: "tr"
        },
        {
          model: "tableCell",
          view: "td"
        },
        {
          model: "tableCell",
          view: "th"
        },
        {
          model: "tableColumnGroup",
          view: "colgroup"
        },
        {
          model: "tableColumn",
          view: "col"
        },
        {
          model: "caption",
          view: "caption"
        },
        {
          model: "caption",
          view: "figcaption"
        },
        {
          model: "imageBlock",
          view: "img"
        },
        {
          model: "imageInline",
          view: "img"
        },
        // Compatibility features.
        {
          model: "htmlP",
          view: "p",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlBlockquote",
          view: "blockquote",
          modelSchema: {
            inheritAllFrom: "$container"
          }
        },
        {
          model: "htmlTable",
          view: "table",
          modelSchema: {
            allowWhere: "$block",
            isBlock: true
          }
        },
        {
          model: "htmlTbody",
          view: "tbody",
          modelSchema: {
            allowIn: "htmlTable",
            isBlock: false
          }
        },
        {
          model: "htmlThead",
          view: "thead",
          modelSchema: {
            allowIn: "htmlTable",
            isBlock: false
          }
        },
        {
          model: "htmlTfoot",
          view: "tfoot",
          modelSchema: {
            allowIn: "htmlTable",
            isBlock: false
          }
        },
        {
          model: "htmlCaption",
          view: "caption",
          modelSchema: {
            allowIn: "htmlTable",
            allowChildren: "$text",
            isBlock: false
          }
        },
        {
          model: "htmlColgroup",
          view: "colgroup",
          modelSchema: {
            allowIn: "htmlTable",
            allowChildren: "col",
            isBlock: false
          }
        },
        {
          model: "htmlCol",
          view: "col",
          modelSchema: {
            allowIn: "htmlColgroup",
            isBlock: false
          }
        },
        {
          model: "htmlTr",
          view: "tr",
          modelSchema: {
            allowIn: [
              "htmlTable",
              "htmlThead",
              "htmlTbody"
            ],
            isLimit: true
          }
        },
        // TODO can also include text.
        {
          model: "htmlTd",
          view: "td",
          modelSchema: {
            allowIn: "htmlTr",
            allowContentOf: "$container",
            isLimit: true,
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlTh",
          view: "th",
          modelSchema: {
            allowIn: "htmlTr",
            allowContentOf: "$container",
            isLimit: true,
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlFigure",
          view: "figure",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include other block elements.
        {
          model: "htmlFigcaption",
          view: "figcaption",
          modelSchema: {
            allowIn: "htmlFigure",
            allowChildren: "$text",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlAddress",
          view: "address",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlAside",
          view: "aside",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlMain",
          view: "main",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlDetails",
          view: "details",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        {
          model: "htmlSummary",
          view: "summary",
          modelSchema: {
            allowChildren: "$text",
            allowIn: "htmlDetails",
            isBlock: false
          }
        },
        {
          model: "htmlDiv",
          view: "div",
          paragraphLikeModel: "htmlDivParagraph",
          modelSchema: {
            inheritAllFrom: "$container"
          }
        },
        // TODO can also include text.
        {
          model: "htmlFieldset",
          view: "fieldset",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include h1-h6.
        {
          model: "htmlLegend",
          view: "legend",
          modelSchema: {
            allowIn: "htmlFieldset",
            allowChildren: "$text"
          }
        },
        // TODO can also include text.
        {
          model: "htmlHeader",
          view: "header",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlFooter",
          view: "footer",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlForm",
          view: "form",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: true
          }
        },
        {
          model: "htmlHgroup",
          view: "hgroup",
          modelSchema: {
            allowChildren: [
              "htmlH1",
              "htmlH2",
              "htmlH3",
              "htmlH4",
              "htmlH5",
              "htmlH6"
            ],
            isBlock: false
          }
        },
        {
          model: "htmlH1",
          view: "h1",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlH2",
          view: "h2",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlH3",
          view: "h3",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlH4",
          view: "h4",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlH5",
          view: "h5",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlH6",
          view: "h6",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "$htmlList",
          modelSchema: {
            allowWhere: "$container",
            allowChildren: [
              "$htmlList",
              "htmlLi"
            ],
            isBlock: false
          }
        },
        {
          model: "htmlDir",
          view: "dir",
          modelSchema: {
            inheritAllFrom: "$htmlList"
          }
        },
        {
          model: "htmlMenu",
          view: "menu",
          modelSchema: {
            inheritAllFrom: "$htmlList"
          }
        },
        {
          model: "htmlUl",
          view: "ul",
          modelSchema: {
            inheritAllFrom: "$htmlList"
          }
        },
        {
          model: "htmlOl",
          view: "ol",
          modelSchema: {
            inheritAllFrom: "$htmlList"
          }
        },
        // TODO can also include other block elements.
        {
          model: "htmlLi",
          view: "li",
          modelSchema: {
            allowIn: "$htmlList",
            allowChildren: "$text",
            isBlock: false
          }
        },
        {
          model: "htmlPre",
          view: "pre",
          modelSchema: {
            inheritAllFrom: "$block"
          }
        },
        {
          model: "htmlArticle",
          view: "article",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        {
          model: "htmlSection",
          view: "section",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        // TODO can also include text.
        {
          model: "htmlNav",
          view: "nav",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        },
        {
          model: "htmlDivDl",
          view: "div",
          modelSchema: {
            allowChildren: [
              "htmlDt",
              "htmlDd"
            ],
            allowIn: "htmlDl"
          }
        },
        {
          model: "htmlDl",
          view: "dl",
          modelSchema: {
            allowWhere: "$container",
            allowChildren: [
              "htmlDt",
              "htmlDd",
              "htmlDivDl"
            ],
            isBlock: false
          }
        },
        {
          model: "htmlDt",
          view: "dt",
          modelSchema: {
            allowChildren: "$block",
            isBlock: false
          }
        },
        {
          model: "htmlDd",
          view: "dd",
          modelSchema: {
            allowChildren: "$block",
            isBlock: false
          }
        },
        {
          model: "htmlCenter",
          view: "center",
          modelSchema: {
            inheritAllFrom: "$container",
            isBlock: false
          }
        }
      ],
      inline: [
        // Existing features (attribute set on an existing model element).
        {
          model: "htmlLiAttributes",
          view: "li",
          appliesToBlock: true,
          coupledAttribute: "listItemId"
        },
        {
          model: "htmlOlAttributes",
          view: "ol",
          appliesToBlock: true,
          coupledAttribute: "listItemId"
        },
        {
          model: "htmlUlAttributes",
          view: "ul",
          appliesToBlock: true,
          coupledAttribute: "listItemId"
        },
        {
          model: "htmlFigureAttributes",
          view: "figure",
          appliesToBlock: "table"
        },
        {
          model: "htmlTheadAttributes",
          view: "thead",
          appliesToBlock: "table"
        },
        {
          model: "htmlTbodyAttributes",
          view: "tbody",
          appliesToBlock: "table"
        },
        {
          model: "htmlFigureAttributes",
          view: "figure",
          appliesToBlock: "imageBlock"
        },
        // Compatibility features.
        {
          model: "htmlAcronym",
          view: "acronym",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlTt",
          view: "tt",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlFont",
          view: "font",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlTime",
          view: "time",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlVar",
          view: "var",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlBig",
          view: "big",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlSmall",
          view: "small",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlSamp",
          view: "samp",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlQ",
          view: "q",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlOutput",
          view: "output",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlKbd",
          view: "kbd",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlBdi",
          view: "bdi",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlBdo",
          view: "bdo",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlAbbr",
          view: "abbr",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlA",
          view: "a",
          priority: 5,
          coupledAttribute: "linkHref"
        },
        {
          model: "htmlStrong",
          view: "strong",
          coupledAttribute: "bold",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlB",
          view: "b",
          coupledAttribute: "bold",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlI",
          view: "i",
          coupledAttribute: "italic",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlEm",
          view: "em",
          coupledAttribute: "italic",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlS",
          view: "s",
          coupledAttribute: "strikethrough",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        // TODO According to HTML-spec can behave as div-like element, although CKE4 only handles it as an inline element.
        {
          model: "htmlDel",
          view: "del",
          coupledAttribute: "strikethrough",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        // TODO According to HTML-spec can behave as div-like element, although CKE4 only handles it as an inline element.
        {
          model: "htmlIns",
          view: "ins",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlU",
          view: "u",
          coupledAttribute: "underline",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlSub",
          view: "sub",
          coupledAttribute: "subscript",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlSup",
          view: "sup",
          coupledAttribute: "superscript",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlCode",
          view: "code",
          coupledAttribute: "code",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlMark",
          view: "mark",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlSpan",
          view: "span",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlCite",
          view: "cite",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlLabel",
          view: "label",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        {
          model: "htmlDfn",
          view: "dfn",
          attributeProperties: {
            copyOnEnter: true,
            isFormatting: true
          }
        },
        // Objects.
        {
          model: "htmlObject",
          view: "object",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlIframe",
          view: "iframe",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlInput",
          view: "input",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlButton",
          view: "button",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlTextarea",
          view: "textarea",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlSelect",
          view: "select",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlVideo",
          view: "video",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlEmbed",
          view: "embed",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlOembed",
          view: "oembed",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlAudio",
          view: "audio",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlImg",
          view: "img",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlCanvas",
          view: "canvas",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        // TODO it could be probably represented as non-object element, although it has graphical representation,
        // so probably makes more sense to keep it as an object.
        {
          model: "htmlMeter",
          view: "meter",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        // TODO it could be probably represented as non-object element, although it has graphical representation,
        // so probably makes more sense to keep it as an object.
        {
          model: "htmlProgress",
          view: "progress",
          isObject: true,
          modelSchema: {
            inheritAllFrom: "$inlineObject"
          }
        },
        {
          model: "htmlScript",
          view: "script",
          modelSchema: {
            allowWhere: [
              "$text",
              "$block"
            ],
            isInline: true
          }
        },
        {
          model: "htmlStyle",
          view: "style",
          modelSchema: {
            allowWhere: [
              "$text",
              "$block"
            ],
            isInline: true
          }
        },
        {
          model: "htmlCustomElement",
          view: "$customElement",
          modelSchema: {
            allowWhere: [
              "$text",
              "$block"
            ],
            allowAttributesOf: "$inlineObject",
            isInline: true
          }
        }
      ]
    };
    class DataSchema extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * A map of registered data schema definitions.
        */
        __publicField(this, "_definitions", []);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DataSchema";
      }
      /**
      * @inheritDoc
      */
      init() {
        for (const definition of defaultConfig.block) {
          this.registerBlockElement(definition);
        }
        for (const definition of defaultConfig.inline) {
          this.registerInlineElement(definition);
        }
      }
      /**
      * Add new data schema definition describing block element.
      */
      registerBlockElement(definition) {
        this._definitions.push({
          ...definition,
          isBlock: true
        });
      }
      /**
      * Add new data schema definition describing inline element.
      */
      registerInlineElement(definition) {
        this._definitions.push({
          ...definition,
          isInline: true
        });
      }
      /**
      * Updates schema definition describing block element with new properties.
      *
      * Creates new scheme if it doesn't exist.
      * Array properties are concatenated with original values.
      *
      * @param definition Definition update.
      */
      extendBlockElement(definition) {
        this._extendDefinition({
          ...definition,
          isBlock: true
        });
      }
      /**
      * Updates schema definition describing inline element with new properties.
      *
      * Creates new scheme if it doesn't exist.
      * Array properties are concatenated with original values.
      *
      * @param definition Definition update.
      */
      extendInlineElement(definition) {
        this._extendDefinition({
          ...definition,
          isInline: true
        });
      }
      /**
      * Returns all definitions matching the given view name.
      *
      * @param includeReferences Indicates if this method should also include definitions of referenced models.
      */
      getDefinitionsForView(viewName, includeReferences = false) {
        const definitions = /* @__PURE__ */ new Set();
        for (const definition of this._getMatchingViewDefinitions(viewName)) {
          if (includeReferences) {
            for (const reference of this._getReferences(definition.model)) {
              definitions.add(reference);
            }
          }
          definitions.add(definition);
        }
        return definitions;
      }
      /**
      * Returns definitions matching the given model name.
      */
      getDefinitionsForModel(modelName) {
        return this._definitions.filter((definition) => definition.model == modelName);
      }
      /**
      * Returns definitions matching the given view name.
      */
      _getMatchingViewDefinitions(viewName) {
        return this._definitions.filter((def) => def.view && testViewName(viewName, def.view));
      }
      /**
      * Resolves all definition references registered for the given data schema definition.
      *
      * @param modelName Data schema model name.
      */
      *_getReferences(modelName) {
        const inheritProperties = [
          "inheritAllFrom",
          "inheritTypesFrom",
          "allowWhere",
          "allowContentOf",
          "allowAttributesOf"
        ];
        const definitions = this._definitions.filter((definition) => definition.model == modelName);
        for (const { modelSchema } of definitions) {
          if (!modelSchema) {
            continue;
          }
          for (const property2 of inheritProperties) {
            for (const referenceName of toArray$1(modelSchema[property2] || [])) {
              const definitions2 = this._definitions.filter((definition) => definition.model == referenceName);
              for (const definition of definitions2) {
                if (referenceName !== modelName) {
                  yield* this._getReferences(definition.model);
                  yield definition;
                }
              }
            }
          }
        }
      }
      /**
      * Updates schema definition with new properties.
      *
      * Creates new scheme if it doesn't exist.
      * Array properties are concatenated with original values.
      *
      * @param definition Definition update.
      */
      _extendDefinition(definition) {
        const currentDefinitions = Array.from(this._definitions.entries()).filter(([, currentDefinition]) => currentDefinition.model == definition.model);
        if (currentDefinitions.length == 0) {
          this._definitions.push(definition);
          return;
        }
        for (const [idx, currentDefinition] of currentDefinitions) {
          this._definitions[idx] = mergeWith({}, currentDefinition, definition, (target, source) => {
            return Array.isArray(target) ? target.concat(source) : void 0;
          });
        }
      }
    }
    function testViewName(pattern, viewName) {
      if (typeof pattern === "string") {
        return pattern === viewName;
      }
      if (pattern instanceof RegExp) {
        return pattern.test(viewName);
      }
      return false;
    }
    class DataFilter extends Plugin {
      constructor(editor) {
        super(editor);
        /**
        * An instance of the {@link module:html-support/dataschema~DataSchema}.
        */
        __publicField(this, "_dataSchema");
        /**
        * {@link module:engine/view/matcher~Matcher Matcher} instance describing rules upon which
        * content attributes should be allowed.
        */
        __publicField(this, "_allowedAttributes");
        /**
        * {@link module:engine/view/matcher~Matcher Matcher} instance describing rules upon which
        * content attributes should be disallowed.
        */
        __publicField(this, "_disallowedAttributes");
        /**
         * Allowed element definitions by {@link module:html-support/datafilter~DataFilter#allowElement} method.
        */
        __publicField(this, "_allowedElements");
        /**
        * Disallowed element names by {@link module:html-support/datafilter~DataFilter#disallowElement} method.
        */
        __publicField(this, "_disallowedElements");
        /**
         * Indicates if {@link module:engine/controller/datacontroller~DataController editor's data controller}
         * data has been already initialized.
        */
        __publicField(this, "_dataInitialized");
        /**
        * Cached map of coupled attributes. Keys are the feature attributes names
        * and values are arrays with coupled GHS attributes names.
        */
        __publicField(this, "_coupledAttributes");
        this._dataSchema = editor.plugins.get("DataSchema");
        this._allowedAttributes = new Matcher();
        this._disallowedAttributes = new Matcher();
        this._allowedElements = /* @__PURE__ */ new Set();
        this._disallowedElements = /* @__PURE__ */ new Set();
        this._dataInitialized = false;
        this._coupledAttributes = null;
        this._registerElementsAfterInit();
        this._registerElementHandlers();
        this._registerCoupledAttributesPostFixer();
        this._registerAssociatedHtmlAttributesPostFixer();
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DataFilter";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataSchema,
          Widget
        ];
      }
      /**
      * Load a configuration of one or many elements, where their attributes should be allowed.
      *
      * **Note**: Rules will be applied just before next data pipeline data init or set.
      *
      * @param config Configuration of elements that should have their attributes accepted in the editor.
      */
      loadAllowedConfig(config) {
        for (const pattern of config) {
          const elementName = pattern.name || /[\s\S]+/;
          const rules = splitRules(pattern);
          this.allowElement(elementName);
          rules.forEach((pattern2) => this.allowAttributes(pattern2));
        }
      }
      /**
      * Load a configuration of one or many elements, where their attributes should be disallowed.
      *
      * **Note**: Rules will be applied just before next data pipeline data init or set.
      *
      * @param config Configuration of elements that should have their attributes rejected from the editor.
      */
      loadDisallowedConfig(config) {
        for (const pattern of config) {
          const elementName = pattern.name || /[\s\S]+/;
          const rules = splitRules(pattern);
          if (rules.length == 0) {
            this.disallowElement(elementName);
          } else {
            rules.forEach((pattern2) => this.disallowAttributes(pattern2));
          }
        }
      }
      /**
      * Load a configuration of one or many elements, where when empty should be allowed.
      *
      * **Note**: It modifies DataSchema so must be loaded before registering filtering rules.
      *
      * @param config Configuration of elements that should be preserved even if empty.
      */
      loadAllowedEmptyElementsConfig(config) {
        for (const elementName of config) {
          this.allowEmptyElement(elementName);
        }
      }
      /**
      * Allow the given element in the editor context.
      *
      * This method will only allow elements described by the {@link module:html-support/dataschema~DataSchema} used
      * to create data filter.
      *
      * **Note**: Rules will be applied just before next data pipeline data init or set.
      *
      * @param viewName String or regular expression matching view name.
      */
      allowElement(viewName) {
        for (const definition of this._dataSchema.getDefinitionsForView(viewName, true)) {
          this._addAllowedElement(definition);
          this._coupledAttributes = null;
        }
      }
      /**
      * Disallow the given element in the editor context.
      *
      * This method will only disallow elements described by the {@link module:html-support/dataschema~DataSchema} used
      * to create data filter.
      *
      * @param viewName String or regular expression matching view name.
      */
      disallowElement(viewName) {
        for (const definition of this._dataSchema.getDefinitionsForView(viewName, false)) {
          this._disallowedElements.add(definition.view);
        }
      }
      /**
      * Allow the given empty element in the editor context.
      *
      * This method will only allow elements described by the {@link module:html-support/dataschema~DataSchema} used
      * to create data filter.
      *
      * **Note**: It modifies DataSchema so must be called before registering filtering rules.
      *
      * @param viewName String or regular expression matching view name.
      */
      allowEmptyElement(viewName) {
        for (const definition of this._dataSchema.getDefinitionsForView(viewName, true)) {
          if (definition.isInline) {
            this._dataSchema.extendInlineElement({
              ...definition,
              allowEmpty: true
            });
          }
        }
      }
      /**
      * Allow the given attributes for view element allowed by {@link #allowElement} method.
      *
      * @param config Pattern matching all attributes which should be allowed.
      */
      allowAttributes(config) {
        this._allowedAttributes.add(config);
      }
      /**
      * Disallow the given attributes for view element allowed by {@link #allowElement} method.
      *
      * @param config Pattern matching all attributes which should be disallowed.
      */
      disallowAttributes(config) {
        this._disallowedAttributes.add(config);
      }
      /**
      * Processes all allowed and disallowed attributes on the view element by consuming them and returning the allowed ones.
      *
      * This method applies the configuration set up by {@link #allowAttributes `allowAttributes()`}
      * and {@link #disallowAttributes `disallowAttributes()`} over the given view element by consuming relevant attributes.
      * It returns the allowed attributes that were found on the given view element for further processing by integration code.
      *
      * ```ts
      * dispatcher.on( 'element:myElement', ( evt, data, conversionApi ) => {
      * 	// Get rid of disallowed and extract all allowed attributes from a viewElement.
      * 	const viewAttributes = dataFilter.processViewAttributes( data.viewItem, conversionApi );
      * 	// Do something with them, i.e. store inside a model as a dictionary.
      * 	if ( viewAttributes ) {
      * 		conversionApi.writer.setAttribute( 'htmlAttributesOfMyElement', viewAttributes, data.modelRange );
      * 	}
      * } );
      * ```
      *
      * @see module:engine/conversion/viewconsumable~ViewConsumable#consume
      *
      * @returns Object with following properties:
      * - attributes Set with matched attribute names.
      * - styles Set with matched style names.
      * - classes Set with matched class names.
      */
      processViewAttributes(viewElement, conversionApi) {
        const { consumable } = conversionApi;
        matchAndConsumeAttributes(viewElement, this._disallowedAttributes, consumable);
        return prepareGHSAttribute(viewElement, matchAndConsumeAttributes(viewElement, this._allowedAttributes, consumable));
      }
      /**
      * Adds allowed element definition and fires registration event.
      */
      _addAllowedElement(definition) {
        if (this._allowedElements.has(definition)) {
          return;
        }
        this._allowedElements.add(definition);
        if ("appliesToBlock" in definition && typeof definition.appliesToBlock == "string") {
          for (const relatedDefinition of this._dataSchema.getDefinitionsForModel(definition.appliesToBlock)) {
            if (relatedDefinition.isBlock) {
              this._addAllowedElement(relatedDefinition);
            }
          }
        }
        if (this._dataInitialized) {
          this.editor.data.once("set", () => {
            this._fireRegisterEvent(definition);
          }, {
            // With the highest priority listener we are able to register elements right before
            // running data conversion.
            priority: priorities.highest + 1
          });
        }
      }
      /**
       * Registers elements allowed by {@link module:html-support/datafilter~DataFilter#allowElement} method
       * once {@link module:engine/controller/datacontroller~DataController editor's data controller} is initialized.
      */
      _registerElementsAfterInit() {
        this.editor.data.on("init", () => {
          this._dataInitialized = true;
          for (const definition of this._allowedElements) {
            this._fireRegisterEvent(definition);
          }
        }, {
          // With highest priority listener we are able to register elements right before
          // running data conversion. Also:
          // * Make sure that priority is higher than the one used by `RealTimeCollaborationClient`,
          // as RTC is stopping event propagation.
          // * Make sure no other features hook into this event before GHS because otherwise the
          // downcast conversion (for these features) could run before GHS registered its converters
          // (https://github.com/ckeditor/ckeditor5/issues/11356).
          priority: priorities.highest + 1
        });
      }
      /**
      * Registers default element handlers.
      */
      _registerElementHandlers() {
        this.on("register", (evt, definition) => {
          const schema = this.editor.model.schema;
          if (definition.isObject && !schema.isRegistered(definition.model)) {
            this._registerObjectElement(definition);
          } else if (definition.isBlock) {
            this._registerBlockElement(definition);
          } else if (definition.isInline) {
            this._registerInlineElement(definition);
          } else {
            throw new CKEditorError("data-filter-invalid-definition", null, definition);
          }
          evt.stop();
        }, {
          priority: "lowest"
        });
      }
      /**
      * Registers a model post-fixer that is removing coupled GHS attributes of inline elements. Those attributes
      * are removed if a coupled feature attribute is removed.
      *
      * For example, consider following HTML:
      *
      * ```html
      * <a href="foo.html" id="myId">bar</a>
      * ```
      *
      * Which would be upcasted to following text node in the model:
      *
      * ```html
      * <$text linkHref="foo.html" htmlA="{ attributes: { id: 'myId' } }">bar</$text>
      * ```
      *
      * When the user removes the link from that text (using UI), only `linkHref` attribute would be removed:
      *
      * ```html
      * <$text htmlA="{ attributes: { id: 'myId' } }">bar</$text>
      * ```
      *
      * The `htmlA` attribute would stay in the model and would cause GHS to generate an `<a>` element.
      * This is incorrect from UX point of view, as the user wanted to remove the whole link (not only `href`).
      */
      _registerCoupledAttributesPostFixer() {
        const model = this.editor.model;
        const selection = model.document.selection;
        model.document.registerPostFixer((writer) => {
          const changes = model.document.differ.getChanges();
          let changed = false;
          const coupledAttributes = this._getCoupledAttributesMap();
          for (const change of changes) {
            if (change.type != "attribute" || change.attributeNewValue !== null) {
              continue;
            }
            const attributeKeys = coupledAttributes.get(change.attributeKey);
            if (!attributeKeys) {
              continue;
            }
            for (const { item } of change.range.getWalker()) {
              for (const attributeKey of attributeKeys) {
                if (item.hasAttribute(attributeKey)) {
                  writer.removeAttribute(attributeKey, item);
                  changed = true;
                }
              }
            }
          }
          return changed;
        });
        this.listenTo(selection, "change:attribute", (evt, { attributeKeys }) => {
          const removeAttributes = /* @__PURE__ */ new Set();
          const coupledAttributes = this._getCoupledAttributesMap();
          for (const attributeKey of attributeKeys) {
            if (selection.hasAttribute(attributeKey)) {
              continue;
            }
            const coupledAttributeKeys = coupledAttributes.get(attributeKey);
            if (!coupledAttributeKeys) {
              continue;
            }
            for (const coupledAttributeKey of coupledAttributeKeys) {
              if (selection.hasAttribute(coupledAttributeKey)) {
                removeAttributes.add(coupledAttributeKey);
              }
            }
          }
          if (removeAttributes.size == 0) {
            return;
          }
          model.change((writer) => {
            for (const attributeKey of removeAttributes) {
              writer.removeSelectionAttribute(attributeKey);
            }
          });
        });
      }
      /**
      * Removes `html*Attributes` attributes from incompatible elements.
      *
      * For example, consider the following HTML:
      *
      * ```html
      * <heading2 htmlH2Attributes="...">foobar[]</heading2>
      * ```
      *
      * Pressing `enter` creates a new `paragraph` element that inherits
      * the `htmlH2Attributes` attribute from `heading2`.
      *
      * ```html
      * <heading2 htmlH2Attributes="...">foobar</heading2>
      * <paragraph htmlH2Attributes="...">[]</paragraph>
      * ```
      *
      * This postfixer ensures that this doesn't happen, and that elements can
      * only have `html*Attributes` associated with them,
      * e.g.: `htmlPAttributes` for `<p>`, `htmlDivAttributes` for `<div>`, etc.
      *
      * With it enabled, pressing `enter` at the end of `<heading2>` will create
      * a new paragraph without the `htmlH2Attributes` attribute.
      *
      * ```html
      * <heading2 htmlH2Attributes="...">foobar</heading2>
      * <paragraph>[]</paragraph>
      * ```
      */
      _registerAssociatedHtmlAttributesPostFixer() {
        const model = this.editor.model;
        model.document.registerPostFixer((writer) => {
          const changes = model.document.differ.getChanges();
          let changed = false;
          for (const change of changes) {
            if (change.type !== "insert" || change.name === "$text") {
              continue;
            }
            for (const attr of change.attributes.keys()) {
              if (!attr.startsWith("html") || !attr.endsWith("Attributes")) {
                continue;
              }
              if (!model.schema.checkAttribute(change.name, attr)) {
                writer.removeAttribute(attr, change.position.nodeAfter);
                changed = true;
              }
            }
          }
          return changed;
        });
      }
      /**
      * Collects the map of coupled attributes. The returned map is keyed by the feature attribute name
      * and coupled GHS attribute names are stored in the value array.
      */
      _getCoupledAttributesMap() {
        if (this._coupledAttributes) {
          return this._coupledAttributes;
        }
        this._coupledAttributes = /* @__PURE__ */ new Map();
        for (const definition of this._allowedElements) {
          if (definition.coupledAttribute && definition.model) {
            const attributeNames = this._coupledAttributes.get(definition.coupledAttribute);
            if (attributeNames) {
              attributeNames.push(definition.model);
            } else {
              this._coupledAttributes.set(definition.coupledAttribute, [
                definition.model
              ]);
            }
          }
        }
        return this._coupledAttributes;
      }
      /**
      * Fires `register` event for the given element definition.
      */
      _fireRegisterEvent(definition) {
        if (definition.view && this._disallowedElements.has(definition.view)) {
          return;
        }
        this.fire(definition.view ? `register:${definition.view}` : "register", definition);
      }
      /**
      * Registers object element and attribute converters for the given data schema definition.
      */
      _registerObjectElement(definition) {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const { view: viewName, model: modelName } = definition;
        schema.register(modelName, definition.modelSchema);
        /* istanbul ignore next: paranoid check -- @preserve */
        if (!viewName) {
          return;
        }
        schema.extend(definition.model, {
          allowAttributes: [
            getHtmlAttributeName(viewName),
            "htmlContent"
          ]
        });
        editor.data.registerRawContentMatcher({
          name: viewName
        });
        conversion.for("upcast").elementToElement({
          view: viewName,
          model: viewToModelObjectConverter(definition),
          // With a `low` priority, `paragraph` plugin auto-paragraphing mechanism is executed. Make sure
          // this listener is called before it. If not, some elements will be transformed into a paragraph.
          // `+ 2` is used to take priority over `_addDefaultH1Conversion` in the Heading plugin.
          converterPriority: priorities.low + 2
        });
        conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, this));
        conversion.for("editingDowncast").elementToStructure({
          model: {
            name: modelName,
            attributes: [
              getHtmlAttributeName(viewName)
            ]
          },
          view: toObjectWidgetConverter(editor, definition)
        });
        conversion.for("dataDowncast").elementToElement({
          model: modelName,
          view: (modelElement, { writer }) => {
            return createObjectView(viewName, modelElement, writer);
          }
        });
        conversion.for("dataDowncast").add(modelToViewBlockAttributeConverter(definition));
      }
      /**
      * Registers block element and attribute converters for the given data schema definition.
      */
      _registerBlockElement(definition) {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const { view: viewName, model: modelName } = definition;
        if (!schema.isRegistered(definition.model)) {
          schema.register(definition.model, definition.modelSchema);
          if (!viewName) {
            return;
          }
          conversion.for("upcast").elementToElement({
            model: modelName,
            view: viewName,
            // With a `low` priority, `paragraph` plugin auto-paragraphing mechanism is executed. Make sure
            // this listener is called before it. If not, some elements will be transformed into a paragraph.
            // `+ 2` is used to take priority over `_addDefaultH1Conversion` in the Heading plugin.
            converterPriority: priorities.low + 2
          });
          conversion.for("downcast").elementToElement({
            model: modelName,
            view: viewName
          });
        }
        if (!viewName) {
          return;
        }
        schema.extend(definition.model, {
          allowAttributes: getHtmlAttributeName(viewName)
        });
        conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, this));
        conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
      }
      /**
      * Registers inline element and attribute converters for the given data schema definition.
      *
      * Extends `$text` model schema to allow the given definition model attribute and its properties.
      */
      _registerInlineElement(definition) {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const attributeKey = definition.model;
        if (definition.appliesToBlock) {
          return;
        }
        schema.extend("$text", {
          allowAttributes: attributeKey
        });
        if (definition.attributeProperties) {
          schema.setAttributeProperties(attributeKey, definition.attributeProperties);
        }
        conversion.for("upcast").add(viewToAttributeInlineConverter(definition, this));
        conversion.for("downcast").attributeToElement({
          model: attributeKey,
          view: attributeToViewInlineConverter(definition)
        });
        if (!definition.allowEmpty) {
          return;
        }
        schema.setAttributeProperties(attributeKey, {
          copyFromObject: false
        });
        if (!schema.isRegistered("htmlEmptyElement")) {
          schema.register("htmlEmptyElement", {
            inheritAllFrom: "$inlineObject"
          });
        }
        editor.data.htmlProcessor.domConverter.registerInlineObjectMatcher((element) => {
          if (element.name == definition.view && element.isEmpty && Array.from(element.getAttributeKeys()).length) {
            return {
              name: true
            };
          }
          return null;
        });
        conversion.for("editingDowncast").elementToElement({
          model: "htmlEmptyElement",
          view: emptyInlineModelElementToViewConverter(definition, true)
        });
        conversion.for("dataDowncast").elementToElement({
          model: "htmlEmptyElement",
          view: emptyInlineModelElementToViewConverter(definition)
        });
      }
    }
    function matchAndConsumeAttributes(viewElement, matcher, consumable) {
      const matches = matcher.matchAll(viewElement) || [];
      const stylesProcessor = viewElement.document.stylesProcessor;
      return matches.reduce((result, { match }) => {
        for (const style of match.styles || []) {
          const sortedRelatedStyles = stylesProcessor.getRelatedStyles(style).filter((relatedStyle) => relatedStyle.split("-").length > style.split("-").length).sort((a, b) => b.split("-").length - a.split("-").length);
          for (const relatedStyle of sortedRelatedStyles) {
            if (consumable.consume(viewElement, {
              styles: [
                relatedStyle
              ]
            })) {
              result.styles.push(relatedStyle);
            }
          }
          if (consumable.consume(viewElement, {
            styles: [
              style
            ]
          })) {
            result.styles.push(style);
          }
        }
        for (const className of match.classes || []) {
          if (consumable.consume(viewElement, {
            classes: [
              className
            ]
          })) {
            result.classes.push(className);
          }
        }
        for (const attributeName of match.attributes || []) {
          if (consumable.consume(viewElement, {
            attributes: [
              attributeName
            ]
          })) {
            result.attributes.push(attributeName);
          }
        }
        return result;
      }, {
        attributes: [],
        classes: [],
        styles: []
      });
    }
    function prepareGHSAttribute(viewElement, { attributes, classes, styles }) {
      if (!attributes.length && !classes.length && !styles.length) {
        return null;
      }
      return {
        ...attributes.length && {
          attributes: getAttributes(viewElement, attributes)
        },
        ...styles.length && {
          styles: getReducedStyles(viewElement, styles)
        },
        ...classes.length && {
          classes
        }
      };
    }
    function getAttributes(viewElement, attributes) {
      const attributesObject = {};
      for (const key of attributes) {
        const value = viewElement.getAttribute(key);
        if (value !== void 0 && isValidAttributeName(key)) {
          attributesObject[key] = value;
        }
      }
      return attributesObject;
    }
    function getReducedStyles(viewElement, styles) {
      const stylesMap = new StylesMap(viewElement.document.stylesProcessor);
      for (const key of styles) {
        const styleValue = viewElement.getStyle(key);
        if (styleValue !== void 0) {
          stylesMap.set(key, styleValue);
        }
      }
      return Object.fromEntries(stylesMap.getStylesEntries());
    }
    function splitPattern(pattern, attributeName) {
      const { name } = pattern;
      const attributeValue = pattern[attributeName];
      if (isPlainObject(attributeValue)) {
        return Object.entries(attributeValue).map(([key, value]) => ({
          name,
          [attributeName]: {
            [key]: value
          }
        }));
      }
      if (Array.isArray(attributeValue)) {
        return attributeValue.map((value) => ({
          name,
          [attributeName]: [
            value
          ]
        }));
      }
      return [
        pattern
      ];
    }
    function splitRules(rules) {
      const { name, attributes, classes, styles } = rules;
      const splitRules2 = [];
      if (attributes) {
        splitRules2.push(...splitPattern({
          name,
          attributes
        }, "attributes"));
      }
      if (classes) {
        splitRules2.push(...splitPattern({
          name,
          classes
        }, "classes"));
      }
      if (styles) {
        splitRules2.push(...splitPattern({
          name,
          styles
        }, "styles"));
      }
      return splitRules2;
    }
    class CodeBlockElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CodeBlockElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        if (!this.editor.plugins.has("CodeBlockEditing")) {
          return;
        }
        const dataFilter = this.editor.plugins.get(DataFilter);
        dataFilter.on("register:pre", (evt, definition) => {
          if (definition.model !== "codeBlock") {
            return;
          }
          const editor = this.editor;
          const schema = editor.model.schema;
          const conversion = editor.conversion;
          schema.extend("codeBlock", {
            allowAttributes: [
              "htmlPreAttributes",
              "htmlContentAttributes"
            ]
          });
          conversion.for("upcast").add(viewToModelCodeBlockAttributeConverter(dataFilter));
          conversion.for("downcast").add(modelToViewCodeBlockAttributeConverter());
          evt.stop();
        });
      }
    }
    function viewToModelCodeBlockAttributeConverter(dataFilter) {
      return (dispatcher) => {
        dispatcher.on("element:code", (evt, data, conversionApi) => {
          const viewCodeElement = data.viewItem;
          const viewPreElement = viewCodeElement.parent;
          if (!viewPreElement || !viewPreElement.is("element", "pre")) {
            return;
          }
          preserveElementAttributes(viewPreElement, "htmlPreAttributes");
          preserveElementAttributes(viewCodeElement, "htmlContentAttributes");
          function preserveElementAttributes(viewElement, attributeName) {
            const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
            if (viewAttributes) {
              conversionApi.writer.setAttribute(attributeName, viewAttributes, data.modelRange);
            }
          }
        }, {
          priority: "low"
        });
      };
    }
    function modelToViewCodeBlockAttributeConverter() {
      return (dispatcher) => {
        dispatcher.on("attribute:htmlPreAttributes:codeBlock", (evt, data, conversionApi) => {
          if (!conversionApi.consumable.consume(data.item, evt.name)) {
            return;
          }
          const { attributeOldValue, attributeNewValue } = data;
          const viewCodeElement = conversionApi.mapper.toViewElement(data.item);
          const viewPreElement = viewCodeElement.parent;
          updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewPreElement);
        });
        dispatcher.on("attribute:htmlContentAttributes:codeBlock", (evt, data, conversionApi) => {
          if (!conversionApi.consumable.consume(data.item, evt.name)) {
            return;
          }
          const { attributeOldValue, attributeNewValue } = data;
          const viewCodeElement = conversionApi.mapper.toViewElement(data.item);
          updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewCodeElement);
        });
      };
    }
    class DualContentModelElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "DualContentModelElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const dataFilter = this.editor.plugins.get(DataFilter);
        dataFilter.on("register", (evt, definition) => {
          const blockDefinition = definition;
          const editor = this.editor;
          const schema = editor.model.schema;
          const conversion = editor.conversion;
          if (!blockDefinition.paragraphLikeModel) {
            return;
          }
          if (schema.isRegistered(blockDefinition.model) || schema.isRegistered(blockDefinition.paragraphLikeModel)) {
            return;
          }
          const paragraphLikeModelDefinition = {
            model: blockDefinition.paragraphLikeModel,
            view: blockDefinition.view
          };
          schema.register(blockDefinition.model, blockDefinition.modelSchema);
          schema.register(paragraphLikeModelDefinition.model, {
            inheritAllFrom: "$block"
          });
          conversion.for("upcast").elementToElement({
            view: blockDefinition.view,
            model: (viewElement, { writer }) => {
              if (this._hasBlockContent(viewElement)) {
                return writer.createElement(blockDefinition.model);
              }
              return writer.createElement(paragraphLikeModelDefinition.model);
            },
            // With a `low` priority, `paragraph` plugin auto-paragraphing mechanism is executed. Make sure
            // this listener is called before it. If not, some elements will be transformed into a paragraph.
            converterPriority: priorities.low + 0.5
          });
          conversion.for("downcast").elementToElement({
            view: blockDefinition.view,
            model: blockDefinition.model
          });
          this._addAttributeConversion(blockDefinition);
          conversion.for("downcast").elementToElement({
            view: paragraphLikeModelDefinition.view,
            model: paragraphLikeModelDefinition.model
          });
          this._addAttributeConversion(paragraphLikeModelDefinition);
          evt.stop();
        });
      }
      /**
      * Checks whether the given view element includes any other block element.
      */
      _hasBlockContent(viewElement) {
        const view = this.editor.editing.view;
        const blockElements = view.domConverter.blockElements;
        for (const viewItem of view.createRangeIn(viewElement).getItems()) {
          if (viewItem.is("element") && blockElements.includes(viewItem.name)) {
            return true;
          }
        }
        return false;
      }
      /**
      * Adds attribute filtering conversion for the given data schema.
      */
      _addAttributeConversion(definition) {
        const editor = this.editor;
        const conversion = editor.conversion;
        const dataFilter = editor.plugins.get(DataFilter);
        editor.model.schema.extend(definition.model, {
          allowAttributes: getHtmlAttributeName(definition.view)
        });
        conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, dataFilter));
        conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
      }
    }
    class HeadingElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataSchema,
          Enter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "HeadingElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("HeadingEditing")) {
          return;
        }
        const options = editor.config.get("heading.options");
        this.registerHeadingElements(editor, options);
      }
      /**
      * Registers all elements supported by HeadingEditing to enable custom attributes for those elements.
      */
      registerHeadingElements(editor, options) {
        const dataSchema = editor.plugins.get(DataSchema);
        const headerModels = [];
        for (const option of options) {
          if ("model" in option && "view" in option) {
            dataSchema.registerBlockElement({
              view: option.view,
              model: option.model
            });
            headerModels.push(option.model);
          }
        }
        dataSchema.extendBlockElement({
          model: "htmlHgroup",
          modelSchema: {
            allowChildren: headerModels
          }
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function getDescendantElement(writer, containerElement, elementName) {
      const range = writer.createRangeOn(containerElement);
      for (const { item } of range.getWalker()) {
        if (item.is("element", elementName)) {
          return item;
        }
      }
    }
    class ImageElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("ImageInlineEditing") && !editor.plugins.has("ImageBlockEditing")) {
          return;
        }
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const dataFilter = editor.plugins.get(DataFilter);
        dataFilter.on("register:figure", () => {
          conversion.for("upcast").add(viewToModelFigureAttributeConverter$1(dataFilter));
        });
        dataFilter.on("register:img", (evt, definition) => {
          if (definition.model !== "imageBlock" && definition.model !== "imageInline") {
            return;
          }
          if (schema.isRegistered("imageBlock")) {
            schema.extend("imageBlock", {
              allowAttributes: [
                "htmlImgAttributes",
                // Figure and Link don't have model counterpart.
                // We will preserve attributes on image model element using these attribute keys.
                "htmlFigureAttributes",
                "htmlLinkAttributes"
              ]
            });
          }
          if (schema.isRegistered("imageInline")) {
            schema.extend("imageInline", {
              allowAttributes: [
                // `htmlA` is needed for standard GHS link integration.
                "htmlA",
                "htmlImgAttributes"
              ]
            });
          }
          conversion.for("upcast").add(viewToModelImageAttributeConverter(dataFilter));
          conversion.for("downcast").add(modelToViewImageAttributeConverter());
          if (editor.plugins.has("LinkImage")) {
            conversion.for("upcast").add(viewToModelLinkImageAttributeConverter(dataFilter, editor));
          }
          evt.stop();
        });
      }
    }
    function viewToModelImageAttributeConverter(dataFilter) {
      return (dispatcher) => {
        dispatcher.on("element:img", (evt, data, conversionApi) => {
          if (!data.modelRange) {
            return;
          }
          const viewImageElement = data.viewItem;
          const viewAttributes = dataFilter.processViewAttributes(viewImageElement, conversionApi);
          if (viewAttributes) {
            conversionApi.writer.setAttribute("htmlImgAttributes", viewAttributes, data.modelRange);
          }
        }, {
          priority: "low"
        });
      };
    }
    function viewToModelLinkImageAttributeConverter(dataFilter, editor) {
      const imageUtils = editor.plugins.get("ImageUtils");
      return (dispatcher) => {
        dispatcher.on("element:a", (evt, data, conversionApi) => {
          const viewLink = data.viewItem;
          const viewImage = imageUtils.findViewImgElement(viewLink);
          if (!viewImage) {
            return;
          }
          const modelImage = data.modelCursor.parent;
          if (!modelImage.is("element", "imageBlock")) {
            return;
          }
          const viewAttributes = dataFilter.processViewAttributes(viewLink, conversionApi);
          if (viewAttributes) {
            conversionApi.writer.setAttribute("htmlLinkAttributes", viewAttributes, modelImage);
          }
        }, {
          priority: "low"
        });
      };
    }
    function viewToModelFigureAttributeConverter$1(dataFilter) {
      return (dispatcher) => {
        dispatcher.on("element:figure", (evt, data, conversionApi) => {
          const viewFigureElement = data.viewItem;
          if (!data.modelRange || !viewFigureElement.hasClass("image")) {
            return;
          }
          const viewAttributes = dataFilter.processViewAttributes(viewFigureElement, conversionApi);
          if (viewAttributes) {
            conversionApi.writer.setAttribute("htmlFigureAttributes", viewAttributes, data.modelRange);
          }
        }, {
          priority: "low"
        });
      };
    }
    function modelToViewImageAttributeConverter() {
      return (dispatcher) => {
        addInlineAttributeConversion("htmlImgAttributes");
        addBlockAttributeConversion("img", "htmlImgAttributes");
        addBlockAttributeConversion("figure", "htmlFigureAttributes");
        addBlockAttributeConversion("a", "htmlLinkAttributes");
        function addInlineAttributeConversion(attributeName) {
          dispatcher.on(`attribute:${attributeName}:imageInline`, (evt, data, conversionApi) => {
            if (!conversionApi.consumable.consume(data.item, evt.name)) {
              return;
            }
            const { attributeOldValue, attributeNewValue } = data;
            const viewElement = conversionApi.mapper.toViewElement(data.item);
            updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewElement);
          }, {
            priority: "low"
          });
        }
        function addBlockAttributeConversion(elementName, attributeName) {
          dispatcher.on(`attribute:${attributeName}:imageBlock`, (evt, data, conversionApi) => {
            if (!conversionApi.consumable.test(data.item, evt.name)) {
              return;
            }
            const { attributeOldValue, attributeNewValue } = data;
            const containerElement = conversionApi.mapper.toViewElement(data.item);
            const viewElement = getDescendantElement(conversionApi.writer, containerElement, elementName);
            if (viewElement) {
              updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewElement);
              conversionApi.consumable.consume(data.item, evt.name);
            }
          }, {
            priority: "low"
          });
          if (elementName === "a") {
            dispatcher.on("attribute:linkHref:imageBlock", (evt, data, conversionApi) => {
              if (!conversionApi.consumable.consume(data.item, "attribute:htmlLinkAttributes:imageBlock")) {
                return;
              }
              const containerElement = conversionApi.mapper.toViewElement(data.item);
              const viewElement = getDescendantElement(conversionApi.writer, containerElement, "a");
              setViewAttributes(conversionApi.writer, data.item.getAttribute("htmlLinkAttributes"), viewElement);
            }, {
              priority: "low"
            });
          }
        }
      };
    }
    class MediaEmbedElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "MediaEmbedElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("MediaEmbed") || editor.config.get("mediaEmbed.previewsInData")) {
          return;
        }
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const dataFilter = this.editor.plugins.get(DataFilter);
        const dataSchema = this.editor.plugins.get(DataSchema);
        const mediaElementName = editor.config.get("mediaEmbed.elementName");
        dataSchema.registerBlockElement({
          model: "media",
          view: mediaElementName
        });
        dataFilter.on("register:figure", () => {
          conversion.for("upcast").add(viewToModelFigureAttributesConverter(dataFilter));
        });
        dataFilter.on(`register:${mediaElementName}`, (evt, definition) => {
          if (definition.model !== "media") {
            return;
          }
          schema.extend("media", {
            allowAttributes: [
              getHtmlAttributeName(mediaElementName),
              "htmlFigureAttributes"
            ]
          });
          conversion.for("upcast").add(viewToModelMediaAttributesConverter(dataFilter, mediaElementName));
          conversion.for("dataDowncast").add(modelToViewMediaAttributeConverter(mediaElementName));
          evt.stop();
        });
      }
    }
    function viewToModelMediaAttributesConverter(dataFilter, mediaElementName) {
      const upcastMedia = (evt, data, conversionApi) => {
        const viewMediaElement = data.viewItem;
        preserveElementAttributes(viewMediaElement, getHtmlAttributeName(mediaElementName));
        function preserveElementAttributes(viewElement, attributeName) {
          const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
          if (viewAttributes) {
            conversionApi.writer.setAttribute(attributeName, viewAttributes, data.modelRange);
          }
        }
      };
      return (dispatcher) => {
        dispatcher.on(`element:${mediaElementName}`, upcastMedia, {
          priority: "low"
        });
      };
    }
    function viewToModelFigureAttributesConverter(dataFilter) {
      return (dispatcher) => {
        dispatcher.on("element:figure", (evt, data, conversionApi) => {
          const viewFigureElement = data.viewItem;
          if (!data.modelRange || !viewFigureElement.hasClass("media")) {
            return;
          }
          const viewAttributes = dataFilter.processViewAttributes(viewFigureElement, conversionApi);
          if (viewAttributes) {
            conversionApi.writer.setAttribute("htmlFigureAttributes", viewAttributes, data.modelRange);
          }
        }, {
          priority: "low"
        });
      };
    }
    function modelToViewMediaAttributeConverter(mediaElementName) {
      return (dispatcher) => {
        addAttributeConversionDispatcherHandler(mediaElementName, getHtmlAttributeName(mediaElementName));
        addAttributeConversionDispatcherHandler("figure", "htmlFigureAttributes");
        function addAttributeConversionDispatcherHandler(elementName, attributeName) {
          dispatcher.on(`attribute:${attributeName}:media`, (evt, data, conversionApi) => {
            if (!conversionApi.consumable.consume(data.item, evt.name)) {
              return;
            }
            const { attributeOldValue, attributeNewValue } = data;
            const containerElement = conversionApi.mapper.toViewElement(data.item);
            const viewElement = getDescendantElement(conversionApi.writer, containerElement, elementName);
            updateViewAttributes(conversionApi.writer, attributeOldValue, attributeNewValue, viewElement);
          });
        }
      };
    }
    class ScriptElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ScriptElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const dataFilter = this.editor.plugins.get(DataFilter);
        dataFilter.on("register:script", (evt, definition) => {
          const editor = this.editor;
          const schema = editor.model.schema;
          const conversion = editor.conversion;
          schema.register("htmlScript", definition.modelSchema);
          schema.extend("htmlScript", {
            allowAttributes: [
              "htmlScriptAttributes",
              "htmlContent"
            ],
            isContent: true
          });
          editor.data.registerRawContentMatcher({
            name: "script"
          });
          conversion.for("upcast").elementToElement({
            view: "script",
            model: viewToModelObjectConverter(definition)
          });
          conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, dataFilter));
          conversion.for("downcast").elementToElement({
            model: "htmlScript",
            view: (modelElement, { writer }) => {
              return createObjectView("script", modelElement, writer);
            }
          });
          conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
          evt.stop();
        });
      }
    }
    class TableElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("TableEditing")) {
          return;
        }
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const dataFilter = editor.plugins.get(DataFilter);
        const tableUtils = editor.plugins.get("TableUtils");
        dataFilter.on("register:figure", () => {
          conversion.for("upcast").add(viewToModelFigureAttributeConverter(dataFilter));
        });
        dataFilter.on("register:table", (evt, definition) => {
          if (definition.model !== "table") {
            return;
          }
          schema.extend("table", {
            allowAttributes: [
              "htmlTableAttributes",
              // Figure, thead and tbody elements don't have model counterparts.
              // We will be preserving attributes on table element using these attribute keys.
              "htmlFigureAttributes",
              "htmlTheadAttributes",
              "htmlTbodyAttributes"
            ]
          });
          conversion.for("upcast").add(viewToModelTableAttributeConverter(dataFilter));
          conversion.for("downcast").add(modelToViewTableAttributeConverter());
          editor.model.document.registerPostFixer(createHeadingRowsPostFixer(editor.model, tableUtils));
          evt.stop();
        });
      }
    }
    function createHeadingRowsPostFixer(model, tableUtils) {
      return (writer) => {
        const changes = model.document.differ.getChanges();
        let wasFixed = false;
        for (const change of changes) {
          if (change.type != "attribute" || change.attributeKey != "headingRows") {
            continue;
          }
          const table2 = change.range.start.nodeAfter;
          const hasTHeadAttributes = table2.getAttribute("htmlTheadAttributes");
          const hasTBodyAttributes = table2.getAttribute("htmlTbodyAttributes");
          if (hasTHeadAttributes && !change.attributeNewValue) {
            writer.removeAttribute("htmlTheadAttributes", table2);
            wasFixed = true;
          } else if (hasTBodyAttributes && change.attributeNewValue == tableUtils.getRows(table2)) {
            writer.removeAttribute("htmlTbodyAttributes", table2);
            wasFixed = true;
          }
        }
        return wasFixed;
      };
    }
    function viewToModelTableAttributeConverter(dataFilter) {
      return (dispatcher) => {
        dispatcher.on("element:table", (evt, data, conversionApi) => {
          if (!data.modelRange) {
            return;
          }
          const viewTableElement = data.viewItem;
          preserveElementAttributes(viewTableElement, "htmlTableAttributes");
          for (const childNode of viewTableElement.getChildren()) {
            if (childNode.is("element", "thead")) {
              preserveElementAttributes(childNode, "htmlTheadAttributes");
            }
            if (childNode.is("element", "tbody")) {
              preserveElementAttributes(childNode, "htmlTbodyAttributes");
            }
          }
          function preserveElementAttributes(viewElement, attributeName) {
            const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
            if (viewAttributes) {
              conversionApi.writer.setAttribute(attributeName, viewAttributes, data.modelRange);
            }
          }
        }, {
          priority: "low"
        });
      };
    }
    function viewToModelFigureAttributeConverter(dataFilter) {
      return (dispatcher) => {
        dispatcher.on("element:figure", (evt, data, conversionApi) => {
          const viewFigureElement = data.viewItem;
          if (!data.modelRange || !viewFigureElement.hasClass("table")) {
            return;
          }
          const viewAttributes = dataFilter.processViewAttributes(viewFigureElement, conversionApi);
          if (viewAttributes) {
            conversionApi.writer.setAttribute("htmlFigureAttributes", viewAttributes, data.modelRange);
          }
        }, {
          priority: "low"
        });
      };
    }
    function modelToViewTableAttributeConverter() {
      return (dispatcher) => {
        addAttributeConversionDispatcherHandler("table", "htmlTableAttributes");
        addAttributeConversionDispatcherHandler("figure", "htmlFigureAttributes");
        addAttributeConversionDispatcherHandler("thead", "htmlTheadAttributes");
        addAttributeConversionDispatcherHandler("tbody", "htmlTbodyAttributes");
        function addAttributeConversionDispatcherHandler(elementName, attributeName) {
          dispatcher.on(`attribute:${attributeName}:table`, (evt, data, conversionApi) => {
            if (!conversionApi.consumable.test(data.item, evt.name)) {
              return;
            }
            const containerElement = conversionApi.mapper.toViewElement(data.item);
            const viewElement = getDescendantElement(conversionApi.writer, containerElement, elementName);
            if (!viewElement) {
              return;
            }
            conversionApi.consumable.consume(data.item, evt.name);
            updateViewAttributes(conversionApi.writer, data.attributeOldValue, data.attributeNewValue, viewElement);
          });
        }
      };
    }
    class StyleElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "StyleElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const dataFilter = this.editor.plugins.get(DataFilter);
        dataFilter.on("register:style", (evt, definition) => {
          const editor = this.editor;
          const schema = editor.model.schema;
          const conversion = editor.conversion;
          schema.register("htmlStyle", definition.modelSchema);
          schema.extend("htmlStyle", {
            allowAttributes: [
              "htmlStyleAttributes",
              "htmlContent"
            ],
            isContent: true
          });
          editor.data.registerRawContentMatcher({
            name: "style"
          });
          conversion.for("upcast").elementToElement({
            view: "style",
            model: viewToModelObjectConverter(definition)
          });
          conversion.for("upcast").add(viewToModelBlockAttributeConverter(definition, dataFilter));
          conversion.for("downcast").elementToElement({
            model: "htmlStyle",
            view: (modelElement, { writer }) => {
              return createObjectView("style", modelElement, writer);
            }
          });
          conversion.for("downcast").add(modelToViewBlockAttributeConverter(definition));
          evt.stop();
        });
      }
    }
    class ListElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("ListEditing")) {
          return;
        }
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        const dataFilter = editor.plugins.get(DataFilter);
        const listEditing = editor.plugins.get("ListEditing");
        const listUtils = editor.plugins.get("ListUtils");
        const viewElements = [
          "ul",
          "ol",
          "li"
        ];
        listEditing.registerDowncastStrategy({
          scope: "item",
          attributeName: "htmlLiAttributes",
          setAttributeOnDowncast: setViewAttributes
        });
        listEditing.registerDowncastStrategy({
          scope: "list",
          attributeName: "htmlUlAttributes",
          setAttributeOnDowncast: setViewAttributes
        });
        listEditing.registerDowncastStrategy({
          scope: "list",
          attributeName: "htmlOlAttributes",
          setAttributeOnDowncast: setViewAttributes
        });
        dataFilter.on("register", (evt, definition) => {
          if (!viewElements.includes(definition.view)) {
            return;
          }
          evt.stop();
          if (schema.checkAttribute("$block", "htmlLiAttributes")) {
            return;
          }
          const allowAttributes = viewElements.map((element) => getHtmlAttributeName(element));
          schema.extend("$listItem", {
            allowAttributes
          });
          conversion.for("upcast").add((dispatcher) => {
            dispatcher.on("element:ul", viewToModelListAttributeConverter("htmlUlAttributes", dataFilter), {
              priority: "low"
            });
            dispatcher.on("element:ol", viewToModelListAttributeConverter("htmlOlAttributes", dataFilter), {
              priority: "low"
            });
            dispatcher.on("element:li", viewToModelListAttributeConverter("htmlLiAttributes", dataFilter), {
              priority: "low"
            });
          });
        });
        listEditing.on("postFixer", (evt, { listNodes, writer }) => {
          for (const { node, previousNodeInList } of listNodes) {
            if (!previousNodeInList) {
              continue;
            }
            if (previousNodeInList.getAttribute("listType") == node.getAttribute("listType")) {
              const attribute = getAttributeFromListType(previousNodeInList.getAttribute("listType"));
              const value = previousNodeInList.getAttribute(attribute);
              if (!isEqual(node.getAttribute(attribute), value) && writer.model.schema.checkAttribute(node, attribute)) {
                writer.setAttribute(attribute, value, node);
                evt.return = true;
              }
            }
            if (previousNodeInList.getAttribute("listItemId") == node.getAttribute("listItemId")) {
              const value = previousNodeInList.getAttribute("htmlLiAttributes");
              if (!isEqual(node.getAttribute("htmlLiAttributes"), value) && writer.model.schema.checkAttribute(node, "htmlLiAttributes")) {
                writer.setAttribute("htmlLiAttributes", value, node);
                evt.return = true;
              }
            }
          }
        });
        listEditing.on("postFixer", (evt, { listNodes, writer }) => {
          for (const { node } of listNodes) {
            const listType = node.getAttribute("listType");
            if (!listUtils.isNumberedListType(listType) && node.getAttribute("htmlOlAttributes")) {
              writer.removeAttribute("htmlOlAttributes", node);
              evt.return = true;
            }
            if (listUtils.isNumberedListType(listType) && node.getAttribute("htmlUlAttributes")) {
              writer.removeAttribute("htmlUlAttributes", node);
              evt.return = true;
            }
          }
        });
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor = this.editor;
        if (!editor.commands.get("indentList")) {
          return;
        }
        const indentList = editor.commands.get("indentList");
        this.listenTo(indentList, "afterExecute", (evt, changedBlocks) => {
          editor.model.change((writer) => {
            for (const node of changedBlocks) {
              const attribute = getAttributeFromListType(node.getAttribute("listType"));
              if (!editor.model.schema.checkAttribute(node, attribute)) {
                continue;
              }
              writer.setAttribute(attribute, {}, node);
            }
          });
        });
      }
    }
    function viewToModelListAttributeConverter(attributeName, dataFilter) {
      return (evt, data, conversionApi) => {
        const viewElement = data.viewItem;
        if (!data.modelRange) {
          Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
        }
        const viewAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
        for (const item of data.modelRange.getItems({
          shallow: true
        })) {
          if (!item.hasAttribute("listItemId")) {
            continue;
          }
          if (item.hasAttribute("htmlUlAttributes") || item.hasAttribute("htmlOlAttributes")) {
            continue;
          }
          if (conversionApi.writer.model.schema.checkAttribute(item, attributeName)) {
            conversionApi.writer.setAttribute(attributeName, viewAttributes || {}, item);
          }
        }
      };
    }
    function getAttributeFromListType(listType) {
      return listType === "numbered" || listType == "customNumbered" ? "htmlOlAttributes" : "htmlUlAttributes";
    }
    class CustomElementSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter,
          DataSchema
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "CustomElementSupport";
      }
      /**
      * @inheritDoc
      */
      init() {
        const dataFilter = this.editor.plugins.get(DataFilter);
        const dataSchema = this.editor.plugins.get(DataSchema);
        dataFilter.on("register:$customElement", (evt, definition) => {
          evt.stop();
          const editor = this.editor;
          const schema = editor.model.schema;
          const conversion = editor.conversion;
          const unsafeElements = editor.editing.view.domConverter.unsafeElements;
          const preLikeElements = editor.data.htmlProcessor.domConverter.preElements;
          schema.register(definition.model, definition.modelSchema);
          schema.extend(definition.model, {
            allowAttributes: [
              "htmlElementName",
              "htmlCustomElementAttributes",
              "htmlContent"
            ],
            isContent: true
          });
          editor.data.htmlProcessor.domConverter.registerRawContentMatcher({
            name: "template"
          });
          conversion.for("upcast").elementToElement({
            view: /.*/,
            model: (viewElement, conversionApi) => {
              if (viewElement.name == "$comment") {
                return null;
              }
              if (!isValidElementName(viewElement.name)) {
                return null;
              }
              if (dataSchema.getDefinitionsForView(viewElement.name).size) {
                return null;
              }
              if (!unsafeElements.includes(viewElement.name)) {
                unsafeElements.push(viewElement.name);
              }
              if (!preLikeElements.includes(viewElement.name)) {
                preLikeElements.push(viewElement.name);
              }
              const modelElement = conversionApi.writer.createElement(definition.model, {
                htmlElementName: viewElement.name
              });
              const htmlAttributes = dataFilter.processViewAttributes(viewElement, conversionApi);
              if (htmlAttributes) {
                conversionApi.writer.setAttribute("htmlCustomElementAttributes", htmlAttributes, modelElement);
              }
              let htmlContent;
              if (viewElement.is("element", "template") && viewElement.getCustomProperty("$rawContent")) {
                htmlContent = viewElement.getCustomProperty("$rawContent");
              } else {
                const viewWriter = new UpcastWriter(viewElement.document);
                const documentFragment = viewWriter.createDocumentFragment(viewElement);
                const domFragment = editor.data.htmlProcessor.domConverter.viewToDom(documentFragment);
                const domElement = domFragment.firstChild;
                while (domElement.firstChild) {
                  domFragment.appendChild(domElement.firstChild);
                }
                domElement.remove();
                htmlContent = editor.data.htmlProcessor.htmlWriter.getHtml(domFragment);
              }
              conversionApi.writer.setAttribute("htmlContent", htmlContent, modelElement);
              for (const { item } of editor.editing.view.createRangeIn(viewElement)) {
                conversionApi.consumable.consume(item, {
                  name: true
                });
              }
              return modelElement;
            },
            converterPriority: "low"
          });
          conversion.for("editingDowncast").elementToElement({
            model: {
              name: definition.model,
              attributes: [
                "htmlElementName",
                "htmlCustomElementAttributes",
                "htmlContent"
              ]
            },
            view: (modelElement, { writer }) => {
              const viewName = modelElement.getAttribute("htmlElementName");
              const viewElement = writer.createRawElement(viewName);
              if (modelElement.hasAttribute("htmlCustomElementAttributes")) {
                setViewAttributes(writer, modelElement.getAttribute("htmlCustomElementAttributes"), viewElement);
              }
              return viewElement;
            }
          });
          conversion.for("dataDowncast").elementToElement({
            model: {
              name: definition.model,
              attributes: [
                "htmlElementName",
                "htmlCustomElementAttributes",
                "htmlContent"
              ]
            },
            view: (modelElement, { writer }) => {
              const viewName = modelElement.getAttribute("htmlElementName");
              const htmlContent = modelElement.getAttribute("htmlContent");
              const viewElement = writer.createRawElement(viewName, null, (domElement, domConverter) => {
                domConverter.setContentOf(domElement, htmlContent);
              });
              if (modelElement.hasAttribute("htmlCustomElementAttributes")) {
                setViewAttributes(writer, modelElement.getAttribute("htmlCustomElementAttributes"), viewElement);
              }
              return viewElement;
            }
          });
        });
      }
    }
    function isValidElementName(name) {
      try {
        document.createElement(name);
      } catch (error) {
        return false;
      }
      return true;
    }
    class GeneralHtmlSupport extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "GeneralHtmlSupport";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          DataFilter,
          CodeBlockElementSupport,
          DualContentModelElementSupport,
          HeadingElementSupport,
          ImageElementSupport,
          MediaEmbedElementSupport,
          ScriptElementSupport,
          TableElementSupport,
          StyleElementSupport,
          ListElementSupport,
          CustomElementSupport
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const dataFilter = editor.plugins.get(DataFilter);
        dataFilter.loadAllowedEmptyElementsConfig(editor.config.get("htmlSupport.allowEmpty") || []);
        dataFilter.loadAllowedConfig(editor.config.get("htmlSupport.allow") || []);
        dataFilter.loadDisallowedConfig(editor.config.get("htmlSupport.disallow") || []);
      }
      /**
      * Returns a GHS model attribute name related to a given view element name.
      *
      * @internal
      * @param viewElementName A view element name.
      */
      getGhsAttributeNameForElement(viewElementName) {
        const dataSchema = this.editor.plugins.get("DataSchema");
        const definitions = Array.from(dataSchema.getDefinitionsForView(viewElementName, false));
        const inlineDefinition = definitions.find((definition) => definition.isInline && !definitions[0].isObject);
        if (inlineDefinition) {
          return inlineDefinition.model;
        }
        return getHtmlAttributeName(viewElementName);
      }
      /**
      * Updates GHS model attribute for a specified view element name, so it includes the given class name.
      *
      * @internal
      * @param viewElementName A view element name.
      * @param className The css class to add.
      * @param selectable The selection or element to update.
      */
      addModelHtmlClass(viewElementName, className, selectable) {
        const model = this.editor.model;
        const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
        model.change((writer) => {
          for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
            modifyGhsAttribute(writer, item, ghsAttributeName, "classes", (classes) => {
              for (const value of toArray$1(className)) {
                classes.add(value);
              }
            });
          }
        });
      }
      /**
      * Updates GHS model attribute for a specified view element name, so it does not include the given class name.
      *
      * @internal
      * @param viewElementName A view element name.
      * @param className The css class to remove.
      * @param selectable The selection or element to update.
      */
      removeModelHtmlClass(viewElementName, className, selectable) {
        const model = this.editor.model;
        const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
        model.change((writer) => {
          for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
            modifyGhsAttribute(writer, item, ghsAttributeName, "classes", (classes) => {
              for (const value of toArray$1(className)) {
                classes.delete(value);
              }
            });
          }
        });
      }
      /**
      * Updates GHS model attribute for a specified view element name, so it includes the given attribute.
      *
      * @param viewElementName A view element name.
      * @param attributes The object with attributes to set.
      * @param selectable The selection or element to update.
      */
      setModelHtmlAttributes(viewElementName, attributes, selectable) {
        const model = this.editor.model;
        const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
        model.change((writer) => {
          for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
            modifyGhsAttribute(writer, item, ghsAttributeName, "attributes", (attributesMap) => {
              for (const [key, value] of Object.entries(attributes)) {
                attributesMap.set(key, value);
              }
            });
          }
        });
      }
      /**
      * Updates GHS model attribute for a specified view element name, so it does not include the given attribute.
      *
      * @param viewElementName A view element name.
      * @param attributeName The attribute name (or names) to remove.
      * @param selectable The selection or element to update.
      */
      removeModelHtmlAttributes(viewElementName, attributeName, selectable) {
        const model = this.editor.model;
        const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
        model.change((writer) => {
          for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
            modifyGhsAttribute(writer, item, ghsAttributeName, "attributes", (attributesMap) => {
              for (const key of toArray$1(attributeName)) {
                attributesMap.delete(key);
              }
            });
          }
        });
      }
      /**
      * Updates GHS model attribute for a specified view element name, so it includes a given style.
      *
      * @param viewElementName A view element name.
      * @param styles The object with styles to set.
      * @param selectable The selection or element to update.
      */
      setModelHtmlStyles(viewElementName, styles, selectable) {
        const model = this.editor.model;
        const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
        model.change((writer) => {
          for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
            modifyGhsAttribute(writer, item, ghsAttributeName, "styles", (stylesMap) => {
              for (const [key, value] of Object.entries(styles)) {
                stylesMap.set(key, value);
              }
            });
          }
        });
      }
      /**
      * Updates GHS model attribute for a specified view element name, so it does not include a given style.
      *
      * @param viewElementName A view element name.
      * @param properties The style (or styles list) to remove.
      * @param selectable The selection or element to update.
      */
      removeModelHtmlStyles(viewElementName, properties, selectable) {
        const model = this.editor.model;
        const ghsAttributeName = this.getGhsAttributeNameForElement(viewElementName);
        model.change((writer) => {
          for (const item of getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName)) {
            modifyGhsAttribute(writer, item, ghsAttributeName, "styles", (stylesMap) => {
              for (const key of toArray$1(properties)) {
                stylesMap.delete(key);
              }
            });
          }
        });
      }
    }
    function* getItemsToUpdateGhsAttribute(model, selectable, ghsAttributeName) {
      if (!selectable) {
        return;
      }
      if (!(Symbol.iterator in selectable) && selectable.is("documentSelection") && selectable.isCollapsed) {
        if (model.schema.checkAttributeInSelection(selectable, ghsAttributeName)) {
          yield selectable;
        }
      } else {
        for (const range of getValidRangesForSelectable(model, selectable, ghsAttributeName)) {
          yield* range.getItems({
            shallow: true
          });
        }
      }
    }
    function getValidRangesForSelectable(model, selectable, ghsAttributeName) {
      if (!(Symbol.iterator in selectable) && (selectable.is("node") || selectable.is("$text") || selectable.is("$textProxy"))) {
        if (model.schema.checkAttribute(selectable, ghsAttributeName)) {
          return [
            model.createRangeOn(selectable)
          ];
        } else {
          return [];
        }
      } else {
        return model.schema.getValidRanges(model.createSelection(selectable).getRanges(), ghsAttributeName);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function createInlineImageViewElement(writer) {
      return writer.createContainerElement("span", {
        class: "image-inline"
      }, writer.createEmptyElement("img"));
    }
    function createBlockImageViewElement(writer) {
      return writer.createContainerElement("figure", {
        class: "image"
      }, [
        writer.createEmptyElement("img"),
        writer.createSlot("children")
      ]);
    }
    function getImgViewElementMatcher(editor, matchImageType) {
      const imageUtils = editor.plugins.get("ImageUtils");
      const areBothImagePluginsLoaded = editor.plugins.has("ImageInlineEditing") && editor.plugins.has("ImageBlockEditing");
      return (element) => {
        if (!imageUtils.isInlineImageView(element)) {
          return null;
        }
        if (!areBothImagePluginsLoaded) {
          return getPositiveMatchPattern(element);
        }
        const imageType = element.getStyle("display") == "block" || element.findAncestor(imageUtils.isBlockImageView) ? "imageBlock" : "imageInline";
        if (imageType !== matchImageType) {
          return null;
        }
        return getPositiveMatchPattern(element);
      };
      function getPositiveMatchPattern(element) {
        const pattern = {
          name: true
        };
        if (element.hasAttribute("src")) {
          pattern.attributes = [
            "src"
          ];
        }
        return pattern;
      }
    }
    function determineImageTypeForInsertionAtSelection(schema, selection) {
      const firstBlock = first(selection.getSelectedBlocks());
      if (!firstBlock || schema.isObject(firstBlock)) {
        return "imageBlock";
      }
      if (firstBlock.isEmpty && firstBlock.name != "listItem") {
        return "imageBlock";
      }
      return "imageInline";
    }
    function getSizeValueIfInPx(size) {
      if (size && size.endsWith("px")) {
        return parseInt(size);
      }
      return null;
    }
    function widthAndHeightStylesAreBothSet(viewElement) {
      const widthStyle = getSizeValueIfInPx(viewElement.getStyle("width"));
      const heightStyle = getSizeValueIfInPx(viewElement.getStyle("height"));
      return !!(widthStyle && heightStyle);
    }
    const IMAGE_WIDGETS_CLASSES_MATCH_REGEXP = /^(image|image-inline)$/;
    class ImageUtils extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * DOM Emitter.
        */
        __publicField(this, "_domEmitter", new (DomEmitterMixin())());
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageUtils";
      }
      /**
      * Checks if the provided model element is an `image` or `imageInline`.
      */
      isImage(modelElement) {
        return this.isInlineImage(modelElement) || this.isBlockImage(modelElement);
      }
      /**
      * Checks if the provided view element represents an inline image.
      *
      * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
      */
      isInlineImageView(element) {
        return !!element && element.is("element", "img");
      }
      /**
      * Checks if the provided view element represents a block image.
      *
      * Also, see {@link module:image/imageutils~ImageUtils#isImageWidget}.
      */
      isBlockImageView(element) {
        return !!element && element.is("element", "figure") && element.hasClass("image");
      }
      /**
      * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionRange}
      * method.
      *
      * ```ts
      * const imageUtils = editor.plugins.get( 'ImageUtils' );
      *
      * imageUtils.insertImage( { src: 'path/to/image.jpg' } );
      * ```
      *
      * @param attributes Attributes of the inserted image.
      * This method filters out the attributes which are disallowed by the {@link module:engine/model/schema~Schema}.
      * @param selectable Place to insert the image. If not specified,
      * the {@link module:widget/utils~findOptimalInsertionRange} logic will be applied for the block images
      * and `model.document.selection` for the inline images.
      *
      * **Note**: If `selectable` is passed, this helper will not be able to set selection attributes (such as `linkHref`)
      * and apply them to the new image. In this case, make sure all selection attributes are passed in `attributes`.
      *
      * @param imageType Image type of inserted image. If not specified,
      * it will be determined automatically depending of editor config or place of the insertion.
      * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
      * The default is `true`.
      * @return The inserted model image element.
      */
      insertImage(attributes = {}, selectable = null, imageType = null, options = {}) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const determinedImageType = determineImageTypeForInsertion(editor, selectable || selection, imageType);
        attributes = {
          ...Object.fromEntries(selection.getAttributes()),
          ...attributes
        };
        for (const attributeName in attributes) {
          if (!model.schema.checkAttribute(determinedImageType, attributeName)) {
            delete attributes[attributeName];
          }
        }
        return model.change((writer) => {
          const { setImageSizes = true } = options;
          const imageElement = writer.createElement(determinedImageType, attributes);
          model.insertObject(imageElement, selectable, null, {
            setSelection: "on",
            // If we want to insert a block image (for whatever reason) then we don't want to split text blocks.
            // This applies only when we don't have the selectable specified (i.e., we insert multiple block images at once).
            findOptimalPosition: !selectable && determinedImageType != "imageInline" ? "auto" : void 0
          });
          if (imageElement.parent) {
            if (setImageSizes) {
              this.setImageNaturalSizeAttributes(imageElement);
            }
            return imageElement;
          }
          return null;
        });
      }
      /**
      * Reads original image sizes and sets them as `width` and `height`.
      *
      * The `src` attribute may not be available if the user is using an upload adapter. In such a case,
      * this method is called again after the upload process is complete and the `src` attribute is available.
      */
      setImageNaturalSizeAttributes(imageElement) {
        const src = imageElement.getAttribute("src");
        if (!src) {
          return;
        }
        if (imageElement.getAttribute("width") || imageElement.getAttribute("height")) {
          return;
        }
        this.editor.model.change((writer) => {
          const img = new global$1.window.Image();
          this._domEmitter.listenTo(img, "load", () => {
            if (!imageElement.getAttribute("width") && !imageElement.getAttribute("height")) {
              this.editor.model.enqueueChange(writer.batch, (writer2) => {
                writer2.setAttribute("width", img.naturalWidth, imageElement);
                writer2.setAttribute("height", img.naturalHeight, imageElement);
              });
            }
            this._domEmitter.stopListening(img, "load");
          });
          img.src = src;
        });
      }
      /**
      * Returns an image widget editing view element if one is selected or is among the selection's ancestors.
      */
      getClosestSelectedImageWidget(selection) {
        const selectionPosition = selection.getFirstPosition();
        if (!selectionPosition) {
          return null;
        }
        const viewElement = selection.getSelectedElement();
        if (viewElement && this.isImageWidget(viewElement)) {
          return viewElement;
        }
        let parent2 = selectionPosition.parent;
        while (parent2) {
          if (parent2.is("element") && this.isImageWidget(parent2)) {
            return parent2;
          }
          parent2 = parent2.parent;
        }
        return null;
      }
      /**
      * Returns a image model element if one is selected or is among the selection's ancestors.
      */
      getClosestSelectedImageElement(selection) {
        const selectedElement = selection.getSelectedElement();
        return this.isImage(selectedElement) ? selectedElement : selection.getFirstPosition().findAncestor("imageBlock");
      }
      /**
      * Returns an image widget editing view based on the passed image view.
      */
      getImageWidgetFromImageView(imageView) {
        return imageView.findAncestor({
          classes: IMAGE_WIDGETS_CLASSES_MATCH_REGEXP
        });
      }
      /**
      * Checks if image can be inserted at current model selection.
      *
      * @internal
      */
      isImageAllowed() {
        const model = this.editor.model;
        const selection = model.document.selection;
        return isImageAllowedInParent(this.editor, selection) && isNotInsideImage(selection);
      }
      /**
      * Converts a given {@link module:engine/view/element~Element} to an image widget:
      * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget
      * element.
      * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
      *
      * @param writer An instance of the view writer.
      * @param label The element's label. It will be concatenated with the image `alt` attribute if one is present.
      */
      toImageWidget(viewElement, writer, label) {
        writer.setCustomProperty("image", true, viewElement);
        const labelCreator = () => {
          const imgElement = this.findViewImgElement(viewElement);
          const altText = imgElement.getAttribute("alt");
          return altText ? `${altText} ${label}` : label;
        };
        return toWidget(viewElement, writer, {
          label: labelCreator
        });
      }
      /**
      * Checks if a given view element is an image widget.
      */
      isImageWidget(viewElement) {
        return !!viewElement.getCustomProperty("image") && isWidget(viewElement);
      }
      /**
      * Checks if the provided model element is an `image`.
      */
      isBlockImage(modelElement) {
        return !!modelElement && modelElement.is("element", "imageBlock");
      }
      /**
      * Checks if the provided model element is an `imageInline`.
      */
      isInlineImage(modelElement) {
        return !!modelElement && modelElement.is("element", "imageInline");
      }
      /**
      * Get the view `<img>` from another view element, e.g. a widget (`<figure class="image">`), a link (`<a>`).
      *
      * The `<img>` can be located deep in other elements, so this helper performs a deep tree search.
      */
      findViewImgElement(figureView) {
        if (this.isInlineImageView(figureView)) {
          return figureView;
        }
        const editingView = this.editor.editing.view;
        for (const { item } of editingView.createRangeIn(figureView)) {
          if (this.isInlineImageView(item)) {
            return item;
          }
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._domEmitter.stopListening();
        return super.destroy();
      }
    }
    function isImageAllowedInParent(editor, selection) {
      const imageType = determineImageTypeForInsertion(editor, selection, null);
      if (imageType == "imageBlock") {
        const parent2 = getInsertImageParent(selection, editor.model);
        if (editor.model.schema.checkChild(parent2, "imageBlock")) {
          return true;
        }
      } else if (editor.model.schema.checkChild(selection.focus, "imageInline")) {
        return true;
      }
      return false;
    }
    function isNotInsideImage(selection) {
      return [
        ...selection.focus.getAncestors()
      ].every((ancestor) => !ancestor.is("element", "imageBlock"));
    }
    function getInsertImageParent(selection, model) {
      const insertionRange = findOptimalInsertionRange(selection, model);
      const parent2 = insertionRange.start.parent;
      if (parent2.isEmpty && !parent2.is("element", "$root")) {
        return parent2.parent;
      }
      return parent2;
    }
    function determineImageTypeForInsertion(editor, selectable, imageType) {
      const schema = editor.model.schema;
      const configImageInsertType = editor.config.get("image.insert.type");
      if (!editor.plugins.has("ImageBlockEditing")) {
        return "imageInline";
      }
      if (!editor.plugins.has("ImageInlineEditing")) {
        return "imageBlock";
      }
      if (imageType) {
        return imageType;
      }
      if (configImageInsertType === "inline") {
        return "imageInline";
      }
      if (configImageInsertType !== "auto") {
        return "imageBlock";
      }
      if (selectable.is("selection")) {
        return determineImageTypeForInsertionAtSelection(schema, selectable);
      }
      return schema.checkChild(selectable, "imageInline") ? "imageInline" : "imageBlock";
    }
    class ImageTextAlternativeCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const imageUtils = editor.plugins.get("ImageUtils");
        const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
        this.isEnabled = !!element;
        if (this.isEnabled && element.hasAttribute("alt")) {
          this.value = element.getAttribute("alt");
        } else {
          this.value = false;
        }
      }
      /**
      * Executes the command.
      *
      * @fires execute
      * @param options
      * @param options.newValue The new value of the `alt` attribute to set.
      */
      execute(options) {
        const editor = this.editor;
        const imageUtils = editor.plugins.get("ImageUtils");
        const model = editor.model;
        const imageElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
        model.change((writer) => {
          writer.setAttribute("alt", options.newValue, imageElement);
        });
      }
    }
    class ImageTextAlternativeEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageUtils
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageTextAlternativeEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        this.editor.commands.add("imageTextAlternative", new ImageTextAlternativeCommand(this.editor));
      }
    }
    class TextAlternativeFormView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * Tracks information about the DOM focus in the form.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * An input with a label.
        */
        __publicField(this, "labeledInput");
        /**
        * A button used to submit the form.
        */
        __publicField(this, "saveButtonView");
        /**
        * A button used to cancel the form.
        */
        __publicField(this, "cancelButtonView");
        /**
        * A collection of views which can be focused in the form.
        */
        __publicField(this, "_focusables");
        /**
        * Helps cycling over {@link #_focusables} in the form.
        */
        __publicField(this, "_focusCycler");
        const t = this.locale.t;
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.labeledInput = this._createLabeledInputView();
        this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
        this.saveButtonView.type = "submit";
        this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "form",
          attributes: {
            class: [
              "ck",
              "ck-text-alternative-form",
              "ck-responsive-form"
            ],
            // https://github.com/ckeditor/ckeditor5-image/issues/40
            tabindex: "-1"
          },
          children: [
            this.labeledInput,
            this.saveButtonView,
            this.cancelButtonView
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this.keystrokes.listenTo(this.element);
        submitHandler({
          view: this
        });
        [
          this.labeledInput,
          this.saveButtonView,
          this.cancelButtonView
        ].forEach((v) => {
          this._focusables.add(v);
          this.focusTracker.add(v.element);
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Creates the button view.
      *
      * @param label The button label
      * @param icon The button's icon.
      * @param className The additional button CSS class name.
      * @param eventName The event name that the ButtonView#execute event will be delegated to.
      * @returns The button view instance.
      */
      _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.locale);
        button.set({
          label,
          icon,
          tooltip: true
        });
        button.extendTemplate({
          attributes: {
            class: className
          }
        });
        if (eventName) {
          button.delegate("execute").to(this, eventName);
        }
        return button;
      }
      /**
      * Creates an input with a label.
      *
      * @returns Labeled field view instance.
      */
      _createLabeledInputView() {
        const t = this.locale.t;
        const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
        labeledInput.label = t("Text alternative");
        return labeledInput;
      }
    }
    function repositionContextualBalloon$1(editor) {
      const balloon = editor.plugins.get("ContextualBalloon");
      const imageUtils = editor.plugins.get("ImageUtils");
      if (imageUtils.getClosestSelectedImageWidget(editor.editing.view.document.selection)) {
        const position = getBalloonPositionData(editor);
        balloon.updatePosition(position);
      }
    }
    function getBalloonPositionData(editor) {
      const editingView = editor.editing.view;
      const defaultPositions = BalloonPanelView.defaultPositions;
      const imageUtils = editor.plugins.get("ImageUtils");
      return {
        target: editingView.domConverter.mapViewToDom(imageUtils.getClosestSelectedImageWidget(editingView.document.selection)),
        positions: [
          defaultPositions.northArrowSouth,
          defaultPositions.northArrowSouthWest,
          defaultPositions.northArrowSouthEast,
          defaultPositions.southArrowNorth,
          defaultPositions.southArrowNorthWest,
          defaultPositions.southArrowNorthEast,
          defaultPositions.viewportStickyNorth
        ]
      };
    }
    class ImageTextAlternativeUI extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The contextual balloon plugin instance.
        */
        __publicField(this, "_balloon");
        /**
        * A form containing a textarea and buttons, used to change the `alt` text value.
        */
        __publicField(this, "_form");
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ContextualBalloon
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageTextAlternativeUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        this._createButton();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this._form) {
          this._form.destroy();
        }
      }
      /**
      * Creates a button showing the balloon panel for changing the image text alternative and
      * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
      */
      _createButton() {
        const editor = this.editor;
        const t = editor.t;
        editor.ui.componentFactory.add("imageTextAlternative", (locale) => {
          const command = editor.commands.get("imageTextAlternative");
          const view = new ButtonView(locale);
          view.set({
            label: t("Change image text alternative"),
            icon: icons.textAlternative,
            tooltip: true
          });
          view.bind("isEnabled").to(command, "isEnabled");
          view.bind("isOn").to(command, "value", (value) => !!value);
          this.listenTo(view, "execute", () => {
            this._showForm();
          });
          return view;
        });
      }
      /**
      * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
      * form.
      */
      _createForm() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const imageUtils = editor.plugins.get("ImageUtils");
        this._balloon = this.editor.plugins.get("ContextualBalloon");
        this._form = new (CssTransitionDisablerMixin(TextAlternativeFormView))(editor.locale);
        this._form.render();
        this.listenTo(this._form, "submit", () => {
          editor.execute("imageTextAlternative", {
            newValue: this._form.labeledInput.fieldView.element.value
          });
          this._hideForm(true);
        });
        this.listenTo(this._form, "cancel", () => {
          this._hideForm(true);
        });
        this._form.keystrokes.set("Esc", (data, cancel2) => {
          this._hideForm(true);
          cancel2();
        });
        this.listenTo(editor.ui, "update", () => {
          if (!imageUtils.getClosestSelectedImageWidget(viewDocument.selection)) {
            this._hideForm(true);
          } else if (this._isVisible) {
            repositionContextualBalloon$1(editor);
          }
        });
        clickOutsideHandler({
          emitter: this._form,
          activator: () => this._isVisible,
          contextElements: () => [
            this._balloon.view.element
          ],
          callback: () => this._hideForm()
        });
      }
      /**
      * Shows the {@link #_form} in the {@link #_balloon}.
      */
      _showForm() {
        if (this._isVisible) {
          return;
        }
        if (!this._form) {
          this._createForm();
        }
        const editor = this.editor;
        const command = editor.commands.get("imageTextAlternative");
        const labeledInput = this._form.labeledInput;
        this._form.disableCssTransitions();
        if (!this._isInBalloon) {
          this._balloon.add({
            view: this._form,
            position: getBalloonPositionData(editor)
          });
        }
        labeledInput.fieldView.value = labeledInput.fieldView.element.value = command.value || "";
        this._form.labeledInput.fieldView.select();
        this._form.enableCssTransitions();
      }
      /**
      * Removes the {@link #_form} from the {@link #_balloon}.
      *
      * @param focusEditable Controls whether the editing view is focused afterwards.
      */
      _hideForm(focusEditable = false) {
        if (!this._isInBalloon) {
          return;
        }
        if (this._form.focusTracker.isFocused) {
          this._form.saveButtonView.focus();
        }
        this._balloon.remove(this._form);
        if (focusEditable) {
          this.editor.editing.view.focus();
        }
      }
      /**
      * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
      */
      get _isVisible() {
        return !!this._balloon && this._balloon.visibleView === this._form;
      }
      /**
      * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
      */
      get _isInBalloon() {
        return !!this._balloon && this._balloon.hasView(this._form);
      }
    }
    class ImageTextAlternative extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageTextAlternativeEditing,
          ImageTextAlternativeUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageTextAlternative";
      }
    }
    function upcastImageFigure(imageUtils) {
      const converter = (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.viewItem, {
          name: true,
          classes: "image"
        })) {
          return;
        }
        const viewImage = imageUtils.findViewImgElement(data.viewItem);
        if (!viewImage || !conversionApi.consumable.test(viewImage, {
          name: true
        })) {
          return;
        }
        conversionApi.consumable.consume(data.viewItem, {
          name: true,
          classes: "image"
        });
        const conversionResult = conversionApi.convertItem(viewImage, data.modelCursor);
        const modelImage = first(conversionResult.modelRange.getItems());
        if (!modelImage) {
          conversionApi.consumable.revert(data.viewItem, {
            name: true,
            classes: "image"
          });
          return;
        }
        conversionApi.convertChildren(data.viewItem, modelImage);
        conversionApi.updateConversionResult(modelImage, data);
      };
      return (dispatcher) => {
        dispatcher.on("element:figure", converter);
      };
    }
    function downcastSrcsetAttribute(imageUtils, imageType) {
      const converter = (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const writer = conversionApi.writer;
        const element = conversionApi.mapper.toViewElement(data.item);
        const img = imageUtils.findViewImgElement(element);
        if (data.attributeNewValue === null) {
          writer.removeAttribute("srcset", img);
          writer.removeAttribute("sizes", img);
        } else {
          if (data.attributeNewValue) {
            writer.setAttribute("srcset", data.attributeNewValue, img);
            writer.setAttribute("sizes", "100vw", img);
          }
        }
      };
      return (dispatcher) => {
        dispatcher.on(`attribute:srcset:${imageType}`, converter);
      };
    }
    function downcastImageAttribute(imageUtils, imageType, attributeKey) {
      const converter = (evt, data, conversionApi) => {
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const viewWriter = conversionApi.writer;
        const element = conversionApi.mapper.toViewElement(data.item);
        const img = imageUtils.findViewImgElement(element);
        viewWriter.setAttribute(data.attributeKey, data.attributeNewValue || "", img);
      };
      return (dispatcher) => {
        dispatcher.on(`attribute:${attributeKey}:${imageType}`, converter);
      };
    }
    class ImageLoadObserver extends Observer {
      /**
      * @inheritDoc
      */
      observe(domRoot) {
        this.listenTo(domRoot, "load", (event, domEvent) => {
          const domElement = domEvent.target;
          if (this.checkShouldIgnoreEventFromTarget(domElement)) {
            return;
          }
          if (domElement.tagName == "IMG") {
            this._fireEvents(domEvent);
          }
        }, {
          useCapture: true
        });
      }
      /**
      * @inheritDoc
      */
      stopObserving(domRoot) {
        this.stopListening(domRoot);
      }
      /**
      * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
      * {@link module:engine/view/document~Document#event:imageLoaded}
      * if observer {@link #isEnabled is enabled}.
      *
      * @param domEvent The DOM event.
      */
      _fireEvents(domEvent) {
        if (this.isEnabled) {
          this.document.fire("layoutChanged");
          this.document.fire("imageLoaded", domEvent);
        }
      }
    }
    class InsertImageCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        const configImageInsertType = editor.config.get("image.insert.type");
        if (!editor.plugins.has("ImageBlockEditing")) {
          if (configImageInsertType === "block") {
            logWarning("image-block-plugin-required");
          }
        }
        if (!editor.plugins.has("ImageInlineEditing")) {
          if (configImageInsertType === "inline") {
            logWarning("image-inline-plugin-required");
          }
        }
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const imageUtils = this.editor.plugins.get("ImageUtils");
        this.isEnabled = imageUtils.isImageAllowed();
      }
      /**
      * Executes the command.
      *
      * @fires execute
      * @param options Options for the executed command.
      * @param options.source The image source or an array of image sources to insert.
      * See the documentation of the command to learn more about accepted formats.
      */
      execute(options) {
        const sourceDefinitions = toArray$1(options.source);
        const selection = this.editor.model.document.selection;
        const imageUtils = this.editor.plugins.get("ImageUtils");
        const selectionAttributes = Object.fromEntries(selection.getAttributes());
        sourceDefinitions.forEach((sourceDefinition, index2) => {
          const selectedElement = selection.getSelectedElement();
          if (typeof sourceDefinition === "string") {
            sourceDefinition = {
              src: sourceDefinition
            };
          }
          if (index2 && selectedElement && imageUtils.isImage(selectedElement)) {
            const position = this.editor.model.createPositionAfter(selectedElement);
            imageUtils.insertImage({
              ...sourceDefinition,
              ...selectionAttributes
            }, position);
          } else {
            imageUtils.insertImage({
              ...sourceDefinition,
              ...selectionAttributes
            });
          }
        });
      }
    }
    class ReplaceImageSourceCommand extends Command {
      constructor(editor) {
        super(editor);
        this.decorate("cleanupImage");
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const imageUtils = editor.plugins.get("ImageUtils");
        const element = this.editor.model.document.selection.getSelectedElement();
        this.isEnabled = imageUtils.isImage(element);
        this.value = this.isEnabled ? element.getAttribute("src") : null;
      }
      /**
      * Executes the command.
      *
      * @fires execute
      * @param options Options for the executed command.
      * @param options.source The image source to replace.
      */
      execute(options) {
        const image2 = this.editor.model.document.selection.getSelectedElement();
        const imageUtils = this.editor.plugins.get("ImageUtils");
        this.editor.model.change((writer) => {
          writer.setAttribute("src", options.source, image2);
          this.cleanupImage(writer, image2);
          imageUtils.setImageNaturalSizeAttributes(image2);
        });
      }
      /**
      * Cleanup image attributes that are not relevant to the new source.
      *
      * Removed attributes are: 'srcset', 'sizes', 'sources', 'width', 'height', 'alt'.
      *
      * This method is decorated, to allow custom cleanup logic.
      * For example, to remove 'myImageId' attribute after 'src' has changed:
      *
      * ```ts
      * replaceImageSourceCommand.on( 'cleanupImage', ( eventInfo, [ writer, image ] ) => {
      * 	writer.removeAttribute( 'myImageId', image );
      * } );
      * ```
      */
      cleanupImage(writer, image2) {
        writer.removeAttribute("srcset", image2);
        writer.removeAttribute("sizes", image2);
        writer.removeAttribute("sources", image2);
        writer.removeAttribute("width", image2);
        writer.removeAttribute("height", image2);
        writer.removeAttribute("alt", image2);
      }
    }
    class ImageEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageUtils
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const conversion = editor.conversion;
        editor.editing.view.addObserver(ImageLoadObserver);
        conversion.for("upcast").attributeToAttribute({
          view: {
            name: "img",
            key: "alt"
          },
          model: "alt"
        }).attributeToAttribute({
          view: {
            name: "img",
            key: "srcset"
          },
          model: "srcset"
        });
        const insertImageCommand = new InsertImageCommand(editor);
        const replaceImageSourceCommand = new ReplaceImageSourceCommand(editor);
        editor.commands.add("insertImage", insertImageCommand);
        editor.commands.add("replaceImageSource", replaceImageSourceCommand);
        editor.commands.add("imageInsert", insertImageCommand);
      }
    }
    class ImageSizeAttributes extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageUtils
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageSizeAttributes";
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        this._registerSchema();
        this._registerConverters("imageBlock");
        this._registerConverters("imageInline");
      }
      /**
      * Registers the `width` and `height` attributes for inline and block images.
      */
      _registerSchema() {
        if (this.editor.plugins.has("ImageBlockEditing")) {
          this.editor.model.schema.extend("imageBlock", {
            allowAttributes: [
              "width",
              "height"
            ]
          });
        }
        if (this.editor.plugins.has("ImageInlineEditing")) {
          this.editor.model.schema.extend("imageInline", {
            allowAttributes: [
              "width",
              "height"
            ]
          });
        }
      }
      /**
      * Registers converters for `width` and `height` attributes.
      */
      _registerConverters(imageType) {
        const editor = this.editor;
        const imageUtils = editor.plugins.get("ImageUtils");
        const viewElementName = imageType === "imageBlock" ? "figure" : "img";
        editor.conversion.for("upcast").attributeToAttribute({
          view: {
            name: viewElementName,
            styles: {
              width: /.+/
            }
          },
          model: {
            key: "width",
            value: (viewElement) => {
              if (widthAndHeightStylesAreBothSet(viewElement)) {
                return getSizeValueIfInPx(viewElement.getStyle("width"));
              }
              return null;
            }
          }
        }).attributeToAttribute({
          view: {
            name: viewElementName,
            key: "width"
          },
          model: "width"
        }).attributeToAttribute({
          view: {
            name: viewElementName,
            styles: {
              height: /.+/
            }
          },
          model: {
            key: "height",
            value: (viewElement) => {
              if (widthAndHeightStylesAreBothSet(viewElement)) {
                return getSizeValueIfInPx(viewElement.getStyle("height"));
              }
              return null;
            }
          }
        }).attributeToAttribute({
          view: {
            name: viewElementName,
            key: "height"
          },
          model: "height"
        });
        editor.conversion.for("editingDowncast").add((dispatcher) => {
          attachDowncastConverter(dispatcher, "width", "width", true);
          attachDowncastConverter(dispatcher, "height", "height", true);
        });
        editor.conversion.for("dataDowncast").add((dispatcher) => {
          attachDowncastConverter(dispatcher, "width", "width", false);
          attachDowncastConverter(dispatcher, "height", "height", false);
        });
        function attachDowncastConverter(dispatcher, modelAttributeName, viewAttributeName, setRatioForInlineImage) {
          dispatcher.on(`attribute:${modelAttributeName}:${imageType}`, (evt, data, conversionApi) => {
            if (!conversionApi.consumable.consume(data.item, evt.name)) {
              return;
            }
            const viewWriter = conversionApi.writer;
            const viewElement = conversionApi.mapper.toViewElement(data.item);
            const img = imageUtils.findViewImgElement(viewElement);
            if (data.attributeNewValue !== null) {
              viewWriter.setAttribute(viewAttributeName, data.attributeNewValue, img);
            } else {
              viewWriter.removeAttribute(viewAttributeName, img);
            }
            if (data.item.hasAttribute("sources")) {
              return;
            }
            const isResized = data.item.hasAttribute("resizedWidth");
            if (imageType === "imageInline" && !isResized && !setRatioForInlineImage) {
              return;
            }
            const width = data.item.getAttribute("width");
            const height = data.item.getAttribute("height");
            if (width && height) {
              viewWriter.setStyle("aspect-ratio", `${width}/${height}`, img);
            }
          });
        }
      }
    }
    class ImageTypeCommand extends Command {
      /**
      * @inheritDoc
      *
      * @param modelElementName Model element name the command converts to.
      */
      constructor(editor, modelElementName) {
        super(editor);
        /**
        * Model element name the command converts to.
        */
        __publicField(this, "_modelElementName");
        this._modelElementName = modelElementName;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const imageUtils = editor.plugins.get("ImageUtils");
        const element = imageUtils.getClosestSelectedImageElement(this.editor.model.document.selection);
        if (this._modelElementName === "imageBlock") {
          this.isEnabled = imageUtils.isInlineImage(element);
        } else {
          this.isEnabled = imageUtils.isBlockImage(element);
        }
      }
      /**
      * Executes the command and changes the type of a selected image.
      *
      * @fires execute
      * @param options.setImageSizes Specifies whether the image `width` and `height` attributes should be set automatically.
      * The default is `true`.
      * @returns An object containing references to old and new model image elements
      * (for before and after the change) so external integrations can hook into the decorated
      * `execute` event and handle this change. `null` if the type change failed.
      */
      execute(options = {}) {
        const editor = this.editor;
        const model = this.editor.model;
        const imageUtils = editor.plugins.get("ImageUtils");
        const oldElement = imageUtils.getClosestSelectedImageElement(model.document.selection);
        const attributes = Object.fromEntries(oldElement.getAttributes());
        if (!attributes.src && !attributes.uploadId) {
          return null;
        }
        return model.change((writer) => {
          const { setImageSizes = true } = options;
          const markers = Array.from(model.markers).filter((marker) => marker.getRange().containsItem(oldElement));
          const newElement = imageUtils.insertImage(attributes, model.createSelection(oldElement, "on"), this._modelElementName, {
            setImageSizes
          });
          if (!newElement) {
            return null;
          }
          const newElementRange = writer.createRangeOn(newElement);
          for (const marker of markers) {
            const markerRange = marker.getRange();
            const range = markerRange.root.rootName != "$graveyard" ? markerRange.getJoined(newElementRange, true) : newElementRange;
            writer.updateMarker(marker, {
              range
            });
          }
          return {
            oldElement,
            newElement
          };
        });
      }
    }
    class ImagePlaceholder extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageUtils
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImagePlaceholder";
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        this._setupSchema();
        this._setupConversion();
        this._setupLoadListener();
      }
      /**
      * Extends model schema.
      */
      _setupSchema() {
        const schema = this.editor.model.schema;
        if (schema.isRegistered("imageBlock")) {
          schema.extend("imageBlock", {
            allowAttributes: [
              "placeholder"
            ]
          });
        }
        if (schema.isRegistered("imageInline")) {
          schema.extend("imageInline", {
            allowAttributes: [
              "placeholder"
            ]
          });
        }
      }
      /**
      * Registers converters.
      */
      _setupConversion() {
        const editor = this.editor;
        const conversion = editor.conversion;
        const imageUtils = editor.plugins.get("ImageUtils");
        conversion.for("editingDowncast").add((dispatcher) => {
          dispatcher.on("attribute:placeholder", (evt, data, conversionApi) => {
            if (!conversionApi.consumable.test(data.item, evt.name)) {
              return;
            }
            if (!data.item.is("element", "imageBlock") && !data.item.is("element", "imageInline")) {
              return;
            }
            conversionApi.consumable.consume(data.item, evt.name);
            const viewWriter = conversionApi.writer;
            const element = conversionApi.mapper.toViewElement(data.item);
            const img = imageUtils.findViewImgElement(element);
            if (data.attributeNewValue) {
              viewWriter.addClass("image_placeholder", img);
              viewWriter.setStyle("background-image", `url(${data.attributeNewValue})`, img);
              viewWriter.setCustomProperty("editingPipeline:doNotReuseOnce", true, img);
            } else {
              viewWriter.removeClass("image_placeholder", img);
              viewWriter.removeStyle("background-image", img);
            }
          });
        });
      }
      /**
      * Prepares listener for image load.
      */
      _setupLoadListener() {
        const editor = this.editor;
        const model = editor.model;
        const editing = editor.editing;
        const editingView = editing.view;
        const imageUtils = editor.plugins.get("ImageUtils");
        editingView.addObserver(ImageLoadObserver);
        this.listenTo(editingView.document, "imageLoaded", (evt, domEvent) => {
          const imgViewElement = editingView.domConverter.mapDomToView(domEvent.target);
          if (!imgViewElement) {
            return;
          }
          const viewElement = imageUtils.getImageWidgetFromImageView(imgViewElement);
          if (!viewElement) {
            return;
          }
          const modelElement = editing.mapper.toModelElement(viewElement);
          if (!modelElement || !modelElement.hasAttribute("placeholder")) {
            return;
          }
          model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            writer.removeAttribute("placeholder", modelElement);
          });
        });
      }
    }
    class ImageBlockEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageEditing,
          ImageSizeAttributes,
          ImageUtils,
          ImagePlaceholder,
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageBlockEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        schema.register("imageBlock", {
          inheritAllFrom: "$blockObject",
          allowAttributes: [
            "alt",
            "src",
            "srcset"
          ]
        });
        this._setupConversion();
        if (editor.plugins.has("ImageInlineEditing")) {
          editor.commands.add("imageTypeBlock", new ImageTypeCommand(this.editor, "imageBlock"));
          this._setupClipboardIntegration();
        }
      }
      /**
      * Configures conversion pipelines to support upcasting and downcasting
      * block images (block image widgets) and their attributes.
      */
      _setupConversion() {
        const editor = this.editor;
        const t = editor.t;
        const conversion = editor.conversion;
        const imageUtils = editor.plugins.get("ImageUtils");
        conversion.for("dataDowncast").elementToStructure({
          model: "imageBlock",
          view: (modelElement, { writer }) => createBlockImageViewElement(writer)
        });
        conversion.for("editingDowncast").elementToStructure({
          model: "imageBlock",
          view: (modelElement, { writer }) => imageUtils.toImageWidget(createBlockImageViewElement(writer), writer, t("image widget"))
        });
        conversion.for("downcast").add(downcastImageAttribute(imageUtils, "imageBlock", "src")).add(downcastImageAttribute(imageUtils, "imageBlock", "alt")).add(downcastSrcsetAttribute(imageUtils, "imageBlock"));
        conversion.for("upcast").elementToElement({
          view: getImgViewElementMatcher(editor, "imageBlock"),
          model: (viewImage, { writer }) => writer.createElement("imageBlock", viewImage.hasAttribute("src") ? {
            src: viewImage.getAttribute("src")
          } : void 0)
        }).add(upcastImageFigure(imageUtils));
      }
      /**
      * Integrates the plugin with the clipboard pipeline.
      *
      * Idea is that the feature should recognize the user's intent when an **inline** image is
      * pasted or dropped. If such an image is pasted/dropped:
      *
      * * into an empty block (e.g. an empty paragraph),
      * * on another object (e.g. some block widget).
      *
      * it gets converted into a block image on the fly. We assume this is the user's intent
      * if they decided to put their image there.
      *
      * See the `ImageInlineEditing` for the similar integration that works in the opposite direction.
      *
      * The feature also sets image `width` and `height` attributes on paste.
      */
      _setupClipboardIntegration() {
        const editor = this.editor;
        const model = editor.model;
        const editingView = editor.editing.view;
        const imageUtils = editor.plugins.get("ImageUtils");
        const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
        this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
          const docFragmentChildren = Array.from(data.content.getChildren());
          let modelRange;
          if (!docFragmentChildren.every(imageUtils.isInlineImageView)) {
            return;
          }
          if (data.targetRanges) {
            modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
          } else {
            modelRange = model.document.selection.getFirstRange();
          }
          const selection = model.createSelection(modelRange);
          if (determineImageTypeForInsertionAtSelection(model.schema, selection) === "imageBlock") {
            const writer = new UpcastWriter(editingView.document);
            const blockViewImages = docFragmentChildren.map((inlineViewImage) => writer.createElement("figure", {
              class: "image"
            }, inlineViewImage));
            data.content = writer.createDocumentFragment(blockViewImages);
          }
        });
        this.listenTo(clipboardPipeline, "contentInsertion", (evt, data) => {
          if (data.method !== "paste") {
            return;
          }
          model.change((writer) => {
            const range = writer.createRangeIn(data.content);
            for (const item of range.getItems()) {
              if (item.is("element", "imageBlock")) {
                imageUtils.setImageNaturalSizeAttributes(item);
              }
            }
          });
        });
      }
    }
    class ImageInsertFormView extends View {
      /**
      * Creates a view for the dropdown panel of {@link module:image/imageinsert/imageinsertui~ImageInsertUI}.
      *
      * @param locale The localization services instance.
      * @param integrations An integrations object that contains components (or tokens for components) to be shown in the panel view.
      */
      constructor(locale, integrations = []) {
        super(locale);
        /**
        * Tracks information about DOM focus in the form.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of views that can be focused in the form.
        */
        __publicField(this, "_focusables");
        /**
        * Helps cycling over {@link #_focusables} in the form.
        */
        __publicField(this, "_focusCycler");
        /**
        * A collection of the defined integrations for inserting the images.
        */
        __publicField(this, "children");
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this._focusables = new ViewCollection();
        this.children = this.createCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        for (const view of integrations) {
          this.children.add(view);
          this._focusables.add(view);
          if (view instanceof CollapsibleView) {
            this._focusables.addMany(view.children);
          }
        }
        this.setTemplate({
          tag: "form",
          attributes: {
            class: [
              "ck",
              "ck-image-insert-form"
            ],
            tabindex: -1
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        submitHandler({
          view: this
        });
        for (const view of this._focusables) {
          this.focusTracker.add(view.element);
        }
        this.keystrokes.listenTo(this.element);
        const stopPropagation = (data) => data.stopPropagation();
        this.keystrokes.set("arrowright", stopPropagation);
        this.keystrokes.set("arrowleft", stopPropagation);
        this.keystrokes.set("arrowup", stopPropagation);
        this.keystrokes.set("arrowdown", stopPropagation);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the first {@link #_focusables focusable} in the form.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
    }
    class ImageInsertUI extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The dropdown view responsible for displaying the image insert UI.
        */
        __publicField(this, "dropdownView");
        /**
        * Registered integrations map.
        */
        __publicField(this, "_integrations", /* @__PURE__ */ new Map());
        editor.config.define("image.insert.integrations", [
          "upload",
          "assetManager",
          "url"
        ]);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageInsertUI";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        const imageUtils = editor.plugins.get("ImageUtils");
        this.set("isImageSelected", false);
        this.listenTo(editor.model.document, "change", () => {
          this.isImageSelected = imageUtils.isImage(selection.getSelectedElement());
        });
        const componentCreator = (locale) => this._createToolbarComponent(locale);
        const menuBarComponentCreator = (locale) => this._createMenuBarComponent(locale);
        editor.ui.componentFactory.add("insertImage", componentCreator);
        editor.ui.componentFactory.add("imageInsert", componentCreator);
        editor.ui.componentFactory.add("menuBar:insertImage", menuBarComponentCreator);
      }
      /**
      * Registers the insert image dropdown integration.
      */
      registerIntegration({ name, observable, buttonViewCreator, formViewCreator, menuBarButtonViewCreator, requiresForm = false }) {
        if (this._integrations.has(name)) {
          logWarning("image-insert-integration-exists", {
            name
          });
        }
        this._integrations.set(name, {
          observable,
          buttonViewCreator,
          menuBarButtonViewCreator,
          formViewCreator,
          requiresForm
        });
      }
      /**
      * Creates the toolbar component.
      */
      _createToolbarComponent(locale) {
        const editor = this.editor;
        const t = locale.t;
        const integrations = this._prepareIntegrations();
        if (!integrations.length) {
          return null;
        }
        let dropdownButton;
        const firstIntegration = integrations[0];
        if (integrations.length == 1) {
          if (!firstIntegration.requiresForm) {
            return firstIntegration.buttonViewCreator(true);
          }
          dropdownButton = firstIntegration.buttonViewCreator(true);
        } else {
          const actionButton = firstIntegration.buttonViewCreator(false);
          dropdownButton = new SplitButtonView(locale, actionButton);
          dropdownButton.tooltip = true;
          dropdownButton.bind("label").to(this, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace image") : t("Insert image"));
        }
        const dropdownView = this.dropdownView = createDropdown(locale, dropdownButton);
        const observables = integrations.map(({ observable }) => typeof observable == "function" ? observable() : observable);
        dropdownView.bind("isEnabled").toMany(observables, "isEnabled", (...isEnabled2) => isEnabled2.some((isEnabled3) => isEnabled3));
        dropdownView.once("change:isOpen", () => {
          const integrationViews = integrations.map(({ formViewCreator }) => formViewCreator(integrations.length == 1));
          const imageInsertFormView = new ImageInsertFormView(editor.locale, integrationViews);
          dropdownView.panelView.children.add(imageInsertFormView);
        });
        return dropdownView;
      }
      /**
      * Creates the menu bar component.
      */
      _createMenuBarComponent(locale) {
        const t = locale.t;
        const integrations = this._prepareIntegrations();
        if (!integrations.length) {
          return null;
        }
        let resultView;
        const firstIntegration = integrations[0];
        if (integrations.length == 1) {
          resultView = firstIntegration.menuBarButtonViewCreator(true);
        } else {
          resultView = new MenuBarMenuView(locale);
          const listView = new MenuBarMenuListView(locale);
          resultView.panelView.children.add(listView);
          resultView.buttonView.set({
            icon: icons.image,
            label: t("Image")
          });
          for (const integration of integrations) {
            const listItemView = new MenuBarMenuListItemView(locale, resultView);
            const buttonView = integration.menuBarButtonViewCreator(false);
            listItemView.children.add(buttonView);
            listView.items.add(listItemView);
          }
        }
        return resultView;
      }
      /**
      * Validates the integrations list.
      */
      _prepareIntegrations() {
        const editor = this.editor;
        const items = editor.config.get("image.insert.integrations");
        const result = [];
        if (!items.length) {
          logWarning("image-insert-integrations-not-specified");
          return result;
        }
        for (const item of items) {
          if (!this._integrations.has(item)) {
            if (![
              "upload",
              "assetManager",
              "url"
            ].includes(item)) {
              logWarning("image-insert-unknown-integration", {
                item
              });
            }
            continue;
          }
          result.push(this._integrations.get(item));
        }
        if (!result.length) {
          logWarning("image-insert-integrations-not-registered");
        }
        return result;
      }
    }
    class ImageBlock extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageBlockEditing,
          Widget,
          ImageTextAlternative,
          ImageInsertUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageBlock";
      }
    }
    class ImageInlineEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageEditing,
          ImageSizeAttributes,
          ImageUtils,
          ImagePlaceholder,
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageInlineEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        schema.register("imageInline", {
          inheritAllFrom: "$inlineObject",
          allowAttributes: [
            "alt",
            "src",
            "srcset"
          ],
          // Disallow inline images in captions (at least for now).
          // This is the best spot to do that because independent packages can introduce captions (ImageCaption, TableCaption, etc.).
          disallowIn: [
            "caption"
          ]
        });
        this._setupConversion();
        if (editor.plugins.has("ImageBlockEditing")) {
          editor.commands.add("imageTypeInline", new ImageTypeCommand(this.editor, "imageInline"));
          this._setupClipboardIntegration();
        }
      }
      /**
      * Configures conversion pipelines to support upcasting and downcasting
      * inline images (inline image widgets) and their attributes.
      */
      _setupConversion() {
        const editor = this.editor;
        const t = editor.t;
        const conversion = editor.conversion;
        const imageUtils = editor.plugins.get("ImageUtils");
        conversion.for("dataDowncast").elementToElement({
          model: "imageInline",
          view: (modelElement, { writer }) => writer.createEmptyElement("img")
        });
        conversion.for("editingDowncast").elementToStructure({
          model: "imageInline",
          view: (modelElement, { writer }) => imageUtils.toImageWidget(createInlineImageViewElement(writer), writer, t("image widget"))
        });
        conversion.for("downcast").add(downcastImageAttribute(imageUtils, "imageInline", "src")).add(downcastImageAttribute(imageUtils, "imageInline", "alt")).add(downcastSrcsetAttribute(imageUtils, "imageInline"));
        conversion.for("upcast").elementToElement({
          view: getImgViewElementMatcher(editor, "imageInline"),
          model: (viewImage, { writer }) => writer.createElement("imageInline", viewImage.hasAttribute("src") ? {
            src: viewImage.getAttribute("src")
          } : void 0)
        });
      }
      /**
      * Integrates the plugin with the clipboard pipeline.
      *
      * Idea is that the feature should recognize the user's intent when an **block** image is
      * pasted or dropped. If such an image is pasted/dropped into a non-empty block
      * (e.g. a paragraph with some text) it gets converted into an inline image on the fly.
      *
      * We assume this is the user's intent if they decided to put their image there.
      *
      * **Note**: If a block image has a caption, it will not be converted to an inline image
      * to avoid the confusion. Captions are added on purpose and they should never be lost
      * in the clipboard pipeline.
      *
      * See the `ImageBlockEditing` for the similar integration that works in the opposite direction.
      *
      * The feature also sets image `width` and `height` attributes when pasting.
      */
      _setupClipboardIntegration() {
        const editor = this.editor;
        const model = editor.model;
        const editingView = editor.editing.view;
        const imageUtils = editor.plugins.get("ImageUtils");
        const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
        this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
          const docFragmentChildren = Array.from(data.content.getChildren());
          let modelRange;
          if (!docFragmentChildren.every(imageUtils.isBlockImageView)) {
            return;
          }
          if (data.targetRanges) {
            modelRange = editor.editing.mapper.toModelRange(data.targetRanges[0]);
          } else {
            modelRange = model.document.selection.getFirstRange();
          }
          const selection = model.createSelection(modelRange);
          if (determineImageTypeForInsertionAtSelection(model.schema, selection) === "imageInline") {
            const writer = new UpcastWriter(editingView.document);
            const inlineViewImages = docFragmentChildren.map((blockViewImage) => {
              if (blockViewImage.childCount === 1) {
                Array.from(blockViewImage.getAttributes()).forEach((attribute) => writer.setAttribute(...attribute, imageUtils.findViewImgElement(blockViewImage)));
                return blockViewImage.getChild(0);
              } else {
                return blockViewImage;
              }
            });
            data.content = writer.createDocumentFragment(inlineViewImages);
          }
        });
        this.listenTo(clipboardPipeline, "contentInsertion", (evt, data) => {
          if (data.method !== "paste") {
            return;
          }
          model.change((writer) => {
            const range = writer.createRangeIn(data.content);
            for (const item of range.getItems()) {
              if (item.is("element", "imageInline")) {
                imageUtils.setImageNaturalSizeAttributes(item);
              }
            }
          });
        });
      }
    }
    class ImageInline extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageInlineEditing,
          Widget,
          ImageTextAlternative,
          ImageInsertUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageInline";
      }
    }
    function createImageTypeRegExp(types) {
      const regExpSafeNames = types.map((type) => type.replace("+", "\\+"));
      return new RegExp(`^image\\/(${regExpSafeNames.join("|")})$`);
    }
    function fetchLocalImage(image2) {
      return new Promise((resolve, reject) => {
        const imageSrc = image2.getAttribute("src");
        fetch(imageSrc).then((resource) => resource.blob()).then((blob) => {
          const mimeType = getImageMimeType(blob, imageSrc);
          const ext = mimeType.replace("image/", "");
          const filename = `image.${ext}`;
          const file = new File([
            blob
          ], filename, {
            type: mimeType
          });
          resolve(file);
        }).catch((err) => {
          return err && err.name === "TypeError" ? convertLocalImageOnCanvas(imageSrc).then(resolve).catch(reject) : reject(err);
        });
      });
    }
    function isLocalImage(imageUtils, node) {
      if (!imageUtils.isInlineImageView(node) || !node.getAttribute("src")) {
        return false;
      }
      return !!node.getAttribute("src").match(/^data:image\/\w+;base64,/g) || !!node.getAttribute("src").match(/^blob:/g);
    }
    function getImageMimeType(blob, src) {
      if (blob.type) {
        return blob.type;
      } else if (src.match(/data:(image\/\w+);base64/)) {
        return src.match(/data:(image\/\w+);base64/)[1].toLowerCase();
      } else {
        return "image/jpeg";
      }
    }
    function convertLocalImageOnCanvas(imageSrc) {
      return getBlobFromCanvas(imageSrc).then((blob) => {
        const mimeType = getImageMimeType(blob, imageSrc);
        const ext = mimeType.replace("image/", "");
        const filename = `image.${ext}`;
        return new File([
          blob
        ], filename, {
          type: mimeType
        });
      });
    }
    function getBlobFromCanvas(imageSrc) {
      return new Promise((resolve, reject) => {
        const image2 = global$1.document.createElement("img");
        image2.addEventListener("load", () => {
          const canvas = global$1.document.createElement("canvas");
          canvas.width = image2.width;
          canvas.height = image2.height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(image2, 0, 0);
          canvas.toBlob((blob) => blob ? resolve(blob) : reject());
        });
        image2.addEventListener("error", () => reject());
        image2.src = imageSrc;
      });
    }
    class ImageUploadUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageUploadUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        editor.ui.componentFactory.add("uploadImage", () => this._createToolbarButton());
        editor.ui.componentFactory.add("imageUpload", () => this._createToolbarButton());
        editor.ui.componentFactory.add("menuBar:uploadImage", () => this._createMenuBarButton("standalone"));
        if (editor.plugins.has("ImageInsertUI")) {
          editor.plugins.get("ImageInsertUI").registerIntegration({
            name: "upload",
            observable: () => editor.commands.get("uploadImage"),
            buttonViewCreator: () => this._createToolbarButton(),
            formViewCreator: () => this._createDropdownButton(),
            menuBarButtonViewCreator: (isOnly) => this._createMenuBarButton(isOnly ? "insertOnly" : "insertNested")
          });
        }
      }
      /**
      * Creates the base for various kinds of the button component provided by this feature.
      */
      _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get("uploadImage");
        const imageTypes = editor.config.get("image.upload.types");
        const imageTypesRegExp = createImageTypeRegExp(imageTypes);
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
          acceptedType: imageTypes.map((type) => `image/${type}`).join(","),
          allowMultipleFiles: true,
          label: t("Upload from computer"),
          icon: icons.imageUpload
        });
        view.bind("isEnabled").to(command);
        view.on("done", (evt, files) => {
          const imagesToUpload = Array.from(files).filter((file) => imageTypesRegExp.test(file.type));
          if (imagesToUpload.length) {
            editor.execute("uploadImage", {
              file: imagesToUpload
            });
            editor.editing.view.focus();
          }
        });
        return view;
      }
      /**
      * Creates a simple toolbar button, with an icon and a tooltip.
      */
      _createToolbarButton() {
        const t = this.editor.locale.t;
        const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
        const button = this._createButton(FileDialogButtonView);
        button.tooltip = true;
        button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace image from computer") : t("Upload image from computer"));
        return button;
      }
      /**
      * Creates a button for the dropdown view, with an icon, text and no tooltip.
      */
      _createDropdownButton() {
        const t = this.editor.locale.t;
        const imageInsertUI = this.editor.plugins.get("ImageInsertUI");
        const button = this._createButton(FileDialogButtonView);
        button.withText = true;
        button.bind("label").to(imageInsertUI, "isImageSelected", (isImageSelected) => isImageSelected ? t("Replace from computer") : t("Upload from computer"));
        button.on("execute", () => {
          imageInsertUI.dropdownView.isOpen = false;
        });
        return button;
      }
      /**
      * Creates a button for the menu bar.
      */
      _createMenuBarButton(type) {
        const t = this.editor.locale.t;
        const button = this._createButton(MenuBarMenuListItemFileDialogButtonView);
        button.withText = true;
        switch (type) {
          case "standalone":
            button.label = t("Image from computer");
            break;
          case "insertOnly":
            button.label = t("Image");
            break;
          case "insertNested":
            button.label = t("From computer");
            break;
        }
        return button;
      }
    }
    class ImageUploadProgress extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The image placeholder that is displayed before real image data can be accessed.
        *
        * For the record, this image is a 1x1 px GIF with an aspect ratio set by CSS.
        */
        __publicField(this, "placeholder");
        /**
        * This method is called each time the image `uploadStatus` attribute is changed.
        *
        * @param evt An object containing information about the fired event.
        * @param data Additional information about the change.
        */
        __publicField(this, "uploadStatusChange", (evt, data, conversionApi) => {
          const editor = this.editor;
          const modelImage = data.item;
          const uploadId = modelImage.getAttribute("uploadId");
          if (!conversionApi.consumable.consume(data.item, evt.name)) {
            return;
          }
          const imageUtils = editor.plugins.get("ImageUtils");
          const fileRepository = editor.plugins.get(FileRepository);
          const status = uploadId ? data.attributeNewValue : null;
          const placeholder = this.placeholder;
          const viewFigure = editor.editing.mapper.toViewElement(modelImage);
          const viewWriter = conversionApi.writer;
          if (status == "reading") {
            _startAppearEffect(viewFigure, viewWriter);
            _showPlaceholder(imageUtils, placeholder, viewFigure, viewWriter);
            return;
          }
          if (status == "uploading") {
            const loader = fileRepository.loaders.get(uploadId);
            _startAppearEffect(viewFigure, viewWriter);
            if (!loader) {
              _showPlaceholder(imageUtils, placeholder, viewFigure, viewWriter);
            } else {
              _hidePlaceholder(viewFigure, viewWriter);
              _showProgressBar(viewFigure, viewWriter, loader, editor.editing.view);
              _displayLocalImage(imageUtils, viewFigure, viewWriter, loader);
            }
            return;
          }
          if (status == "complete" && fileRepository.loaders.get(uploadId)) {
            _showCompleteIcon(viewFigure, viewWriter, editor.editing.view);
          }
          _hideProgressBar(viewFigure, viewWriter);
          _hidePlaceholder(viewFigure, viewWriter);
          _stopAppearEffect(viewFigure, viewWriter);
        });
        this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageUploadProgress";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (editor.plugins.has("ImageBlockEditing")) {
          editor.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange);
        }
        if (editor.plugins.has("ImageInlineEditing")) {
          editor.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
        }
      }
    }
    function _startAppearEffect(viewFigure, writer) {
      if (!viewFigure.hasClass("ck-appear")) {
        writer.addClass("ck-appear", viewFigure);
      }
    }
    function _stopAppearEffect(viewFigure, writer) {
      writer.removeClass("ck-appear", viewFigure);
    }
    function _showPlaceholder(imageUtils, placeholder, viewFigure, writer) {
      if (!viewFigure.hasClass("ck-image-upload-placeholder")) {
        writer.addClass("ck-image-upload-placeholder", viewFigure);
      }
      const viewImg = imageUtils.findViewImgElement(viewFigure);
      if (viewImg.getAttribute("src") !== placeholder) {
        writer.setAttribute("src", placeholder, viewImg);
      }
      if (!_getUIElement(viewFigure, "placeholder")) {
        writer.insert(writer.createPositionAfter(viewImg), _createPlaceholder(writer));
      }
    }
    function _hidePlaceholder(viewFigure, writer) {
      if (viewFigure.hasClass("ck-image-upload-placeholder")) {
        writer.removeClass("ck-image-upload-placeholder", viewFigure);
      }
      _removeUIElement(viewFigure, writer, "placeholder");
    }
    function _showProgressBar(viewFigure, writer, loader, view) {
      const progressBar = _createProgressBar(writer);
      writer.insert(writer.createPositionAt(viewFigure, "end"), progressBar);
      loader.on("change:uploadedPercent", (evt, name, value) => {
        view.change((writer2) => {
          writer2.setStyle("width", value + "%", progressBar);
        });
      });
    }
    function _hideProgressBar(viewFigure, writer) {
      _removeUIElement(viewFigure, writer, "progressBar");
    }
    function _showCompleteIcon(viewFigure, writer, view) {
      const completeIcon = writer.createUIElement("div", {
        class: "ck-image-upload-complete-icon"
      });
      writer.insert(writer.createPositionAt(viewFigure, "end"), completeIcon);
      setTimeout(() => {
        view.change((writer2) => writer2.remove(writer2.createRangeOn(completeIcon)));
      }, 3e3);
    }
    function _createProgressBar(writer) {
      const progressBar = writer.createUIElement("div", {
        class: "ck-progress-bar"
      });
      writer.setCustomProperty("progressBar", true, progressBar);
      return progressBar;
    }
    function _createPlaceholder(writer) {
      const placeholder = writer.createUIElement("div", {
        class: "ck-upload-placeholder-loader"
      });
      writer.setCustomProperty("placeholder", true, placeholder);
      return placeholder;
    }
    function _getUIElement(imageFigure, uniqueProperty) {
      for (const child of imageFigure.getChildren()) {
        if (child.getCustomProperty(uniqueProperty)) {
          return child;
        }
      }
    }
    function _removeUIElement(viewFigure, writer, uniqueProperty) {
      const element = _getUIElement(viewFigure, uniqueProperty);
      if (element) {
        writer.remove(writer.createRangeOn(element));
      }
    }
    function _displayLocalImage(imageUtils, viewFigure, writer, loader) {
      if (loader.data) {
        const viewImg = imageUtils.findViewImgElement(viewFigure);
        writer.setAttribute("src", loader.data, viewImg);
      }
    }
    class UploadImageCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const imageUtils = editor.plugins.get("ImageUtils");
        const selectedElement = editor.model.document.selection.getSelectedElement();
        this.isEnabled = imageUtils.isImageAllowed() || imageUtils.isImage(selectedElement);
      }
      /**
      * Executes the command.
      *
      * @fires execute
      * @param options Options for the executed command.
      * @param options.file The image file or an array of image files to upload.
      */
      execute(options) {
        const files = toArray$1(options.file);
        const selection = this.editor.model.document.selection;
        const imageUtils = this.editor.plugins.get("ImageUtils");
        const selectionAttributes = Object.fromEntries(selection.getAttributes());
        files.forEach((file, index2) => {
          const selectedElement = selection.getSelectedElement();
          if (index2 && selectedElement && imageUtils.isImage(selectedElement)) {
            const position = this.editor.model.createPositionAfter(selectedElement);
            this._uploadImage(file, selectionAttributes, position);
          } else {
            this._uploadImage(file, selectionAttributes);
          }
        });
      }
      /**
      * Handles uploading single file.
      */
      _uploadImage(file, attributes, position) {
        const editor = this.editor;
        const fileRepository = editor.plugins.get(FileRepository);
        const loader = fileRepository.createLoader(file);
        const imageUtils = editor.plugins.get("ImageUtils");
        if (!loader) {
          return;
        }
        imageUtils.insertImage({
          ...attributes,
          uploadId: loader.id
        }, position);
      }
    }
    class ImageUploadEditing extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * An internal mapping of {@link module:upload/filerepository~FileLoader#id file loader UIDs} and
        * model elements during the upload.
        *
        * Model element of the uploaded image can change, for instance, when {@link module:image/image/imagetypecommand~ImageTypeCommand}
        * is executed as a result of adding caption or changing image style. As a result, the upload logic must keep track of the model
        * element (reference) and resolve the upload for the correct model element (instead of the one that landed in the `$graveyard`
        * after image type changed).
        */
        __publicField(this, "_uploadImageElements");
        editor.config.define("image", {
          upload: {
            types: [
              "jpeg",
              "png",
              "gif",
              "bmp",
              "webp",
              "tiff"
            ]
          }
        });
        this._uploadImageElements = /* @__PURE__ */ new Map();
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          FileRepository,
          Notification,
          ClipboardPipeline,
          ImageUtils
        ];
      }
      static get pluginName() {
        return "ImageUploadEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const doc = editor.model.document;
        const conversion = editor.conversion;
        const fileRepository = editor.plugins.get(FileRepository);
        const imageUtils = editor.plugins.get("ImageUtils");
        const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
        const imageTypes = createImageTypeRegExp(editor.config.get("image.upload.types"));
        const uploadImageCommand = new UploadImageCommand(editor);
        editor.commands.add("uploadImage", uploadImageCommand);
        editor.commands.add("imageUpload", uploadImageCommand);
        conversion.for("upcast").attributeToAttribute({
          view: {
            name: "img",
            key: "uploadId"
          },
          model: "uploadId"
        });
        this.listenTo(editor.editing.view.document, "clipboardInput", (evt, data) => {
          if (isHtmlIncluded(data.dataTransfer)) {
            return;
          }
          const images = Array.from(data.dataTransfer.files).filter((file) => {
            if (!file) {
              return false;
            }
            return imageTypes.test(file.type);
          });
          if (!images.length) {
            return;
          }
          evt.stop();
          editor.model.change((writer) => {
            if (data.targetRanges) {
              writer.setSelection(data.targetRanges.map((viewRange) => editor.editing.mapper.toModelRange(viewRange)));
            }
            editor.execute("uploadImage", {
              file: images
            });
          });
        });
        this.listenTo(clipboardPipeline, "inputTransformation", (evt, data) => {
          const fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).map((value) => value.item).filter((viewElement) => isLocalImage(imageUtils, viewElement) && !viewElement.getAttribute("uploadProcessed")).map((viewElement) => {
            return {
              promise: fetchLocalImage(viewElement),
              imageElement: viewElement
            };
          });
          if (!fetchableImages.length) {
            return;
          }
          const writer = new UpcastWriter(editor.editing.view.document);
          for (const fetchableImage of fetchableImages) {
            writer.setAttribute("uploadProcessed", true, fetchableImage.imageElement);
            const loader = fileRepository.createLoader(fetchableImage.promise);
            if (loader) {
              writer.setAttribute("src", "", fetchableImage.imageElement);
              writer.setAttribute("uploadId", loader.id, fetchableImage.imageElement);
            }
          }
        });
        editor.editing.view.document.on("dragover", (evt, data) => {
          data.preventDefault();
        });
        doc.on("change", () => {
          const changes = doc.differ.getChanges({
            includeChangesInGraveyard: true
          }).reverse();
          const insertedImagesIds = /* @__PURE__ */ new Set();
          for (const entry of changes) {
            if (entry.type == "insert" && entry.name != "$text") {
              const item = entry.position.nodeAfter;
              const isInsertedInGraveyard = entry.position.root.rootName == "$graveyard";
              for (const imageElement of getImagesFromChangeItem(editor, item)) {
                const uploadId = imageElement.getAttribute("uploadId");
                if (!uploadId) {
                  continue;
                }
                const loader = fileRepository.loaders.get(uploadId);
                if (!loader) {
                  continue;
                }
                if (isInsertedInGraveyard) {
                  if (!insertedImagesIds.has(uploadId)) {
                    loader.abort();
                  }
                } else {
                  insertedImagesIds.add(uploadId);
                  this._uploadImageElements.set(uploadId, imageElement);
                  if (loader.status == "idle") {
                    this._readAndUpload(loader);
                  }
                }
              }
            }
          }
        });
        this.on("uploadComplete", (evt, { imageElement, data }) => {
          const urls = data.urls ? data.urls : data;
          this.editor.model.change((writer) => {
            writer.setAttribute("src", urls.default, imageElement);
            this._parseAndSetSrcsetAttributeOnImage(urls, imageElement, writer);
            imageUtils.setImageNaturalSizeAttributes(imageElement);
          });
        }, {
          priority: "low"
        });
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const schema = this.editor.model.schema;
        if (this.editor.plugins.has("ImageBlockEditing")) {
          schema.extend("imageBlock", {
            allowAttributes: [
              "uploadId",
              "uploadStatus"
            ]
          });
        }
        if (this.editor.plugins.has("ImageInlineEditing")) {
          schema.extend("imageInline", {
            allowAttributes: [
              "uploadId",
              "uploadStatus"
            ]
          });
        }
      }
      /**
      * Reads and uploads an image.
      *
      * The image is read from the disk and as a Base64-encoded string it is set temporarily to
      * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target
      * image's URL (the URL to the uploaded image on the server).
      */
      _readAndUpload(loader) {
        const editor = this.editor;
        const model = editor.model;
        const t = editor.locale.t;
        const fileRepository = editor.plugins.get(FileRepository);
        const notification = editor.plugins.get(Notification);
        const imageUtils = editor.plugins.get("ImageUtils");
        const imageUploadElements = this._uploadImageElements;
        model.enqueueChange({
          isUndoable: false
        }, (writer) => {
          writer.setAttribute("uploadStatus", "reading", imageUploadElements.get(loader.id));
        });
        return loader.read().then(() => {
          const promise = loader.upload();
          const imageElement = imageUploadElements.get(loader.id);
          /* istanbul ignore next -- @preserve */
          if (env.isSafari) {
            const viewFigure = editor.editing.mapper.toViewElement(imageElement);
            const viewImg = imageUtils.findViewImgElement(viewFigure);
            editor.editing.view.once("render", () => {
              if (!viewImg.parent) {
                return;
              }
              const domFigure = editor.editing.view.domConverter.mapViewToDom(viewImg.parent);
              if (!domFigure) {
                return;
              }
              const originalDisplay = domFigure.style.display;
              domFigure.style.display = "none";
              domFigure._ckHack = domFigure.offsetHeight;
              domFigure.style.display = originalDisplay;
            });
          }
          if (editor.ui) {
            editor.ui.ariaLiveAnnouncer.announce(t("Uploading image"));
          }
          model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            writer.setAttribute("uploadStatus", "uploading", imageElement);
          });
          return promise;
        }).then((data) => {
          model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            const imageElement = imageUploadElements.get(loader.id);
            writer.setAttribute("uploadStatus", "complete", imageElement);
            if (editor.ui) {
              editor.ui.ariaLiveAnnouncer.announce(t("Image upload complete"));
            }
            this.fire("uploadComplete", {
              data,
              imageElement
            });
          });
          clean();
        }).catch((error) => {
          if (editor.ui) {
            editor.ui.ariaLiveAnnouncer.announce(t("Error during image upload"));
          }
          if (loader.status !== "error" && loader.status !== "aborted") {
            throw error;
          }
          if (loader.status == "error" && error) {
            notification.showWarning(error, {
              title: t("Upload failed"),
              namespace: "upload"
            });
          }
          model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            writer.remove(imageUploadElements.get(loader.id));
          });
          clean();
        });
        function clean() {
          model.enqueueChange({
            isUndoable: false
          }, (writer) => {
            const imageElement = imageUploadElements.get(loader.id);
            writer.removeAttribute("uploadId", imageElement);
            writer.removeAttribute("uploadStatus", imageElement);
            imageUploadElements.delete(loader.id);
          });
          fileRepository.destroyLoader(loader);
        }
      }
      /**
      * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.
      *
      * @param data Data object from which `srcset` will be created.
      * @param image The image element on which the `srcset` attribute will be set.
      */
      _parseAndSetSrcsetAttributeOnImage(data, image2, writer) {
        let maxWidth = 0;
        const srcsetAttribute = Object.keys(data).filter((key) => {
          const width = parseInt(key, 10);
          if (!isNaN(width)) {
            maxWidth = Math.max(maxWidth, width);
            return true;
          }
        }).map((key) => `${data[key]} ${key}w`).join(", ");
        if (srcsetAttribute != "") {
          const attributes = {
            srcset: srcsetAttribute
          };
          if (!image2.hasAttribute("width") && !image2.hasAttribute("height")) {
            attributes.width = maxWidth;
          }
          writer.setAttributes(attributes, image2);
        }
      }
    }
    function isHtmlIncluded(dataTransfer) {
      return Array.from(dataTransfer.types).includes("text/html") && dataTransfer.getData("text/html") !== "";
    }
    function getImagesFromChangeItem(editor, item) {
      const imageUtils = editor.plugins.get("ImageUtils");
      return Array.from(editor.model.createRangeOn(item)).filter((value) => imageUtils.isImage(value.item)).map((value) => value.item);
    }
    class ImageUpload extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ImageUpload";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ImageUploadEditing,
          ImageUploadUI,
          ImageUploadProgress
        ];
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class AutomaticDecorators {
      constructor() {
        /**
        * Stores the definition of {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}.
        * This data is used as a source for a downcast dispatcher to create a proper conversion to output data.
        */
        __publicField(this, "_definitions", /* @__PURE__ */ new Set());
      }
      /**
      * Gives information about the number of decorators stored in the {@link module:link/utils/automaticdecorators~AutomaticDecorators}
      * instance.
      */
      get length() {
        return this._definitions.size;
      }
      /**
      * Adds automatic decorator objects or an array with them to be used during downcasting.
      *
      * @param item A configuration object of automatic rules for decorating links. It might also be an array of such objects.
      */
      add(item) {
        if (Array.isArray(item)) {
          item.forEach((item2) => this._definitions.add(item2));
        } else {
          this._definitions.add(item);
        }
      }
      /**
      * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
      *
      * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
      */
      getDispatcher() {
        return (dispatcher) => {
          dispatcher.on("attribute:linkHref", (evt, data, conversionApi) => {
            if (!conversionApi.consumable.test(data.item, "attribute:linkHref")) {
              return;
            }
            if (!(data.item.is("selection") || conversionApi.schema.isInline(data.item))) {
              return;
            }
            const viewWriter = conversionApi.writer;
            const viewSelection = viewWriter.document.selection;
            for (const item of this._definitions) {
              const viewElement = viewWriter.createAttributeElement("a", item.attributes, {
                priority: 5
              });
              if (item.classes) {
                viewWriter.addClass(item.classes, viewElement);
              }
              for (const key in item.styles) {
                viewWriter.setStyle(key, item.styles[key], viewElement);
              }
              viewWriter.setCustomProperty("link", true, viewElement);
              if (item.callback(data.attributeNewValue)) {
                if (data.item.is("selection")) {
                  viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
                } else {
                  viewWriter.wrap(conversionApi.mapper.toViewRange(data.range), viewElement);
                }
              } else {
                viewWriter.unwrap(conversionApi.mapper.toViewRange(data.range), viewElement);
              }
            }
          }, {
            priority: "high"
          });
        };
      }
      /**
      * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method
      * when linking images.
      *
      * @returns A dispatcher function used as conversion helper in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
      */
      getDispatcherForLinkedImage() {
        return (dispatcher) => {
          dispatcher.on("attribute:linkHref:imageBlock", (evt, data, { writer, mapper }) => {
            const viewFigure = mapper.toViewElement(data.item);
            const linkInImage = Array.from(viewFigure.getChildren()).find((child) => child.is("element", "a"));
            for (const item of this._definitions) {
              const attributes = toMap(item.attributes);
              if (item.callback(data.attributeNewValue)) {
                for (const [key, val] of attributes) {
                  if (key === "class") {
                    writer.addClass(val, linkInImage);
                  } else {
                    writer.setAttribute(key, val, linkInImage);
                  }
                }
                if (item.classes) {
                  writer.addClass(item.classes, linkInImage);
                }
                for (const key in item.styles) {
                  writer.setStyle(key, item.styles[key], linkInImage);
                }
              } else {
                for (const [key, val] of attributes) {
                  if (key === "class") {
                    writer.removeClass(val, linkInImage);
                  } else {
                    writer.removeAttribute(key, linkInImage);
                  }
                }
                if (item.classes) {
                  writer.removeClass(item.classes, linkInImage);
                }
                for (const key in item.styles) {
                  writer.removeStyle(key, linkInImage);
                }
              }
            }
          });
        };
      }
    }
    const ATTRIBUTE_WHITESPACES = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
    const SAFE_URL_TEMPLATE = "^(?:(?:<protocols>):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))";
    const EMAIL_REG_EXP = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
    const PROTOCOL_REG_EXP = /^((\w+:(\/{2,})?)|(\W))/i;
    const DEFAULT_LINK_PROTOCOLS = [
      "https?",
      "ftps?",
      "mailto"
    ];
    const LINK_KEYSTROKE = "Ctrl+K";
    function isLinkElement(node) {
      return node.is("attributeElement") && !!node.getCustomProperty("link");
    }
    function createLinkElement(href, { writer }) {
      const linkElement = writer.createAttributeElement("a", {
        href
      }, {
        priority: 5
      });
      writer.setCustomProperty("link", true, linkElement);
      return linkElement;
    }
    function ensureSafeUrl(url, allowedProtocols = DEFAULT_LINK_PROTOCOLS) {
      const urlString = String(url);
      const protocolsList = allowedProtocols.join("|");
      const customSafeRegex = new RegExp(`${SAFE_URL_TEMPLATE.replace("<protocols>", protocolsList)}`, "i");
      return isSafeUrl(urlString, customSafeRegex) ? urlString : "#";
    }
    function isSafeUrl(url, customRegexp) {
      const normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, "");
      return !!normalizedUrl.match(customRegexp);
    }
    function getLocalizedDecorators(t, decorators) {
      const localizedDecoratorsLabels = {
        "Open in a new tab": t("Open in a new tab"),
        "Downloadable": t("Downloadable")
      };
      decorators.forEach((decorator) => {
        if ("label" in decorator && localizedDecoratorsLabels[decorator.label]) {
          decorator.label = localizedDecoratorsLabels[decorator.label];
        }
        return decorator;
      });
      return decorators;
    }
    function normalizeDecorators(decorators) {
      const retArray = [];
      if (decorators) {
        for (const [key, value] of Object.entries(decorators)) {
          const decorator = Object.assign({}, value, {
            id: `link${upperFirst(key)}`
          });
          retArray.push(decorator);
        }
      }
      return retArray;
    }
    function isLinkableElement(element, schema) {
      if (!element) {
        return false;
      }
      return schema.checkAttribute(element.name, "linkHref");
    }
    function isEmail(value) {
      return EMAIL_REG_EXP.test(value);
    }
    function addLinkProtocolIfApplicable(link2, defaultProtocol) {
      const protocol2 = isEmail(link2) ? "mailto:" : defaultProtocol;
      const isProtocolNeeded = !!protocol2 && !linkHasProtocol(link2);
      return link2 && isProtocolNeeded ? protocol2 + link2 : link2;
    }
    function linkHasProtocol(link2) {
      return PROTOCOL_REG_EXP.test(link2);
    }
    function openLink(link2) {
      window.open(link2, "_blank", "noopener");
    }
    class LinkCommand extends Command {
      constructor() {
        super(...arguments);
        /**
        * A collection of {@link module:link/utils/manualdecorator~ManualDecorator manual decorators}
        * corresponding to the {@link module:link/linkconfig~LinkConfig#decorators decorator configuration}.
        *
        * You can consider it a model with states of manual decorators added to the currently selected link.
        */
        __publicField(this, "manualDecorators", new Collection());
        /**
        * An instance of the helper that ties together all {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition}
        * that are used by the {@glink features/link link} and the {@glink features/images/images-linking linking images} features.
        */
        __publicField(this, "automaticDecorators", new AutomaticDecorators());
      }
      /**
      * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
      */
      restoreManualDecoratorStates() {
        for (const manualDecorator of this.manualDecorators) {
          manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement() || first(selection.getSelectedBlocks());
        if (isLinkableElement(selectedElement, model.schema)) {
          this.value = selectedElement.getAttribute("linkHref");
          this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
        } else {
          this.value = selection.getAttribute("linkHref");
          this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
        }
        for (const manualDecorator of this.manualDecorators) {
          manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
      }
      /**
      * Executes the command.
      *
      * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
      * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
      *
      * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
      * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
      * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
      * The selection will be updated to wrap the just inserted text node.
      *
      * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
      *
      * # Decorators and model attribute management
      *
      * There is an optional argument to this command that applies or removes model
      * {@glink framework/architecture/editing-engine#text-attributes text attributes} brought by
      * {@link module:link/utils/manualdecorator~ManualDecorator manual link decorators}.
      *
      * Text attribute names in the model correspond to the entries in the {@link module:link/linkconfig~LinkConfig#decorators
      * configuration}.
      * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
      * corresponds to `'myDecorator'` in the configuration.
      *
      * To learn more about link decorators, check out the {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`}
      * documentation.
      *
      * Here is how to manage decorator attributes with the link command:
      *
      * ```ts
      * const linkCommand = editor.commands.get( 'link' );
      *
      * // Adding a new decorator attribute.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: true
      * } );
      *
      * // Removing a decorator attribute from the selection.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: false
      * } );
      *
      * // Adding multiple decorator attributes at the same time.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: true,
      * 	linkIsDownloadable: true,
      * } );
      *
      * // Removing and adding decorator attributes at the same time.
      * linkCommand.execute( 'http://example.com', {
      * 	linkIsExternal: false,
      * 	linkFoo: true,
      * 	linkIsDownloadable: false,
      * } );
      * ```
      *
      * **Note**: If the decorator attribute name is not specified, its state remains untouched.
      *
      * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
      * decorator attributes.
      *
      * @fires execute
      * @param href Link destination.
      * @param manualDecoratorIds The information about manual decorator attributes to be applied or removed upon execution.
      */
      execute(href, manualDecoratorIds = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const truthyManualDecorators = [];
        const falsyManualDecorators = [];
        for (const name in manualDecoratorIds) {
          if (manualDecoratorIds[name]) {
            truthyManualDecorators.push(name);
          } else {
            falsyManualDecorators.push(name);
          }
        }
        model.change((writer) => {
          if (selection.isCollapsed) {
            const position = selection.getFirstPosition();
            if (selection.hasAttribute("linkHref")) {
              const linkText = extractTextFromSelection(selection);
              let linkRange = findAttributeRange(position, "linkHref", selection.getAttribute("linkHref"), model);
              if (selection.getAttribute("linkHref") === linkText) {
                linkRange = this._updateLinkContent(model, writer, linkRange, href);
              }
              writer.setAttribute("linkHref", href, linkRange);
              truthyManualDecorators.forEach((item) => {
                writer.setAttribute(item, true, linkRange);
              });
              falsyManualDecorators.forEach((item) => {
                writer.removeAttribute(item, linkRange);
              });
              writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));
            } else if (href !== "") {
              const attributes = toMap(selection.getAttributes());
              attributes.set("linkHref", href);
              truthyManualDecorators.forEach((item) => {
                attributes.set(item, true);
              });
              const { end: positionAfter } = model.insertContent(writer.createText(href, attributes), position);
              writer.setSelection(positionAfter);
            }
            [
              "linkHref",
              ...truthyManualDecorators,
              ...falsyManualDecorators
            ].forEach((item) => {
              writer.removeSelectionAttribute(item);
            });
          } else {
            const ranges = model.schema.getValidRanges(selection.getRanges(), "linkHref");
            const allowedRanges = [];
            for (const element of selection.getSelectedBlocks()) {
              if (model.schema.checkAttribute(element, "linkHref")) {
                allowedRanges.push(writer.createRangeOn(element));
              }
            }
            const rangesToUpdate = allowedRanges.slice();
            for (const range of ranges) {
              if (this._isRangeToUpdate(range, allowedRanges)) {
                rangesToUpdate.push(range);
              }
            }
            for (const range of rangesToUpdate) {
              let linkRange = range;
              if (rangesToUpdate.length === 1) {
                const linkText = extractTextFromSelection(selection);
                if (selection.getAttribute("linkHref") === linkText) {
                  linkRange = this._updateLinkContent(model, writer, range, href);
                  writer.setSelection(writer.createSelection(linkRange));
                }
              }
              writer.setAttribute("linkHref", href, linkRange);
              truthyManualDecorators.forEach((item) => {
                writer.setAttribute(item, true, linkRange);
              });
              falsyManualDecorators.forEach((item) => {
                writer.removeAttribute(item, linkRange);
              });
            }
          }
        });
      }
      /**
      * Provides information whether a decorator with a given name is present in the currently processed selection.
      *
      * @param decoratorName The name of the manual decorator used in the model
      * @returns The information whether a given decorator is currently present in the selection.
      */
      _getDecoratorStateFromModel(decoratorName) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (isLinkableElement(selectedElement, model.schema)) {
          return selectedElement.getAttribute(decoratorName);
        }
        return selection.getAttribute(decoratorName);
      }
      /**
      * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
      *
      * @param range A range to check.
      * @param allowedRanges An array of ranges created on elements where the attribute is accepted.
      */
      _isRangeToUpdate(range, allowedRanges) {
        for (const allowedRange of allowedRanges) {
          if (allowedRange.containsRange(range)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Updates selected link with a new value as its content and as its href attribute.
      *
      * @param model Model is need to insert content.
      * @param writer Writer is need to create text element in model.
      * @param range A range where should be inserted content.
      * @param href A link value which should be in the href attribute and in the content.
      */
      _updateLinkContent(model, writer, range, href) {
        const text2 = writer.createText(href, {
          linkHref: href
        });
        return model.insertContent(text2, range);
      }
    }
    function extractTextFromSelection(selection) {
      if (selection.isCollapsed) {
        const firstPosition = selection.getFirstPosition();
        return firstPosition.textNode && firstPosition.textNode.data;
      } else {
        const rangeItems = Array.from(selection.getFirstRange().getItems());
        if (rangeItems.length > 1) {
          return null;
        }
        const firstNode = rangeItems[0];
        if (firstNode.is("$text") || firstNode.is("$textProxy")) {
          return firstNode.data;
        }
        return null;
      }
    }
    class UnlinkCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (isLinkableElement(selectedElement, model.schema)) {
          this.isEnabled = model.schema.checkAttribute(selectedElement, "linkHref");
        } else {
          this.isEnabled = model.schema.checkAttributeInSelection(selection, "linkHref");
        }
      }
      /**
      * Executes the command.
      *
      * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
      * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
      *
      * # Decorators
      *
      * If {@link module:link/linkconfig~LinkConfig#decorators `config.link.decorators`} is specified,
      * all configured decorators are removed together with the `linkHref` attribute.
      *
      * @fires execute
      */
      execute() {
        const editor = this.editor;
        const model = this.editor.model;
        const selection = model.document.selection;
        const linkCommand = editor.commands.get("link");
        model.change((writer) => {
          const rangesToUnlink = selection.isCollapsed ? [
            findAttributeRange(selection.getFirstPosition(), "linkHref", selection.getAttribute("linkHref"), model)
          ] : model.schema.getValidRanges(selection.getRanges(), "linkHref");
          for (const range of rangesToUnlink) {
            writer.removeAttribute("linkHref", range);
            if (linkCommand) {
              for (const manualDecorator of linkCommand.manualDecorators) {
                writer.removeAttribute(manualDecorator.id, range);
              }
            }
          }
        });
      }
    }
    class ManualDecorator extends (/* @__PURE__ */ ObservableMixin()) {
      /**
      * Creates a new instance of {@link module:link/utils/manualdecorator~ManualDecorator}.
      *
      * @param config.id The name of the attribute used in the model that represents a given manual decorator.
      * For example: `'linkIsExternal'`.
      * @param config.label The label used in the user interface to toggle the manual decorator.
      * @param config.attributes A set of attributes added to output data when the decorator is active for a specific link.
      * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
      * @param [config.defaultValue] Controls whether the decorator is "on" by default.
      */
      constructor({ id, label, attributes, classes, styles, defaultValue }) {
        super();
        /**
        * An ID of a manual decorator which is the name of the attribute in the model, for example: 'linkManualDecorator0'.
        */
        __publicField(this, "id");
        /**
        * The default value of manual decorator.
        */
        __publicField(this, "defaultValue");
        /**
        * The label used in the user interface to toggle the manual decorator.
        */
        __publicField(this, "label");
        /**
        * A set of attributes added to downcasted data when the decorator is activated for a specific link.
        * Attributes should be added in a form of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
        */
        __publicField(this, "attributes");
        /**
        * A set of classes added to downcasted data when the decorator is activated for a specific link.
        * Classes should be added in a form of classes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
        */
        __publicField(this, "classes");
        /**
        * A set of styles added to downcasted data when the decorator is activated for a specific link.
        * Styles should be added in a form of styles defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
        */
        __publicField(this, "styles");
        this.id = id;
        this.set("value", void 0);
        this.defaultValue = defaultValue;
        this.label = label;
        this.attributes = attributes;
        this.classes = classes;
        this.styles = styles;
      }
      /**
      * Returns {@link module:engine/view/matcher~MatcherPattern} with decorator attributes.
      *
      * @internal
      */
      _createPattern() {
        return {
          attributes: this.attributes,
          classes: this.classes,
          styles: this.styles
        };
      }
    }
    const HIGHLIGHT_CLASS = "ck-link_selected";
    const DECORATOR_AUTOMATIC = "automatic";
    const DECORATOR_MANUAL = "manual";
    const EXTERNAL_LINKS_REGEXP = /^(https?:)?\/\//;
    class LinkEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "LinkEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TwoStepCaretMovement,
          Input,
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        editor.config.define("link", {
          allowCreatingEmptyLinks: false,
          addTargetToExternalLinks: false
        });
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const allowedProtocols = this.editor.config.get("link.allowedProtocols");
        editor.model.schema.extend("$text", {
          allowAttributes: "linkHref"
        });
        editor.conversion.for("dataDowncast").attributeToElement({
          model: "linkHref",
          view: createLinkElement
        });
        editor.conversion.for("editingDowncast").attributeToElement({
          model: "linkHref",
          view: (href, conversionApi) => {
            return createLinkElement(ensureSafeUrl(href, allowedProtocols), conversionApi);
          }
        });
        editor.conversion.for("upcast").elementToAttribute({
          view: {
            name: "a",
            attributes: {
              href: true
            }
          },
          model: {
            key: "linkHref",
            value: (viewElement) => viewElement.getAttribute("href")
          }
        });
        editor.commands.add("link", new LinkCommand(editor));
        editor.commands.add("unlink", new UnlinkCommand(editor));
        const linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get("link.decorators")));
        this._enableAutomaticDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_AUTOMATIC));
        this._enableManualDecorators(linkDecorators.filter((item) => item.mode === DECORATOR_MANUAL));
        const twoStepCaretMovementPlugin = editor.plugins.get(TwoStepCaretMovement);
        twoStepCaretMovementPlugin.registerAttribute("linkHref");
        inlineHighlight(editor, "linkHref", "a", HIGHLIGHT_CLASS);
        this._enableLinkOpen();
        this._enableSelectionAttributesFixer();
        this._enableClipboardIntegration();
      }
      /**
      * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorAutomaticDefinition automatic decorators}
      * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
      * for each one of them. Downcast dispatchers are obtained using the
      * {@link module:link/utils/automaticdecorators~AutomaticDecorators#getDispatcher} method.
      *
      * **Note**: This method also activates the automatic external link decorator if enabled with
      * {@link module:link/linkconfig~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
      */
      _enableAutomaticDecorators(automaticDecoratorDefinitions) {
        const editor = this.editor;
        const command = editor.commands.get("link");
        const automaticDecorators = command.automaticDecorators;
        if (editor.config.get("link.addTargetToExternalLinks")) {
          automaticDecorators.add({
            id: "linkIsExternal",
            mode: DECORATOR_AUTOMATIC,
            callback: (url) => !!url && EXTERNAL_LINKS_REGEXP.test(url),
            attributes: {
              target: "_blank",
              rel: "noopener noreferrer"
            }
          });
        }
        automaticDecorators.add(automaticDecoratorDefinitions);
        if (automaticDecorators.length) {
          editor.conversion.for("downcast").add(automaticDecorators.getDispatcher());
        }
      }
      /**
      * Processes an array of configured {@link module:link/linkconfig~LinkDecoratorManualDefinition manual decorators},
      * transforms them into {@link module:link/utils/manualdecorator~ManualDecorator} instances and stores them in the
      * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
      *
      * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
      * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
      * with adequate model attributes.
      */
      _enableManualDecorators(manualDecoratorDefinitions) {
        if (!manualDecoratorDefinitions.length) {
          return;
        }
        const editor = this.editor;
        const command = editor.commands.get("link");
        const manualDecorators = command.manualDecorators;
        manualDecoratorDefinitions.forEach((decoratorDefinition) => {
          editor.model.schema.extend("$text", {
            allowAttributes: decoratorDefinition.id
          });
          const decorator = new ManualDecorator(decoratorDefinition);
          manualDecorators.add(decorator);
          editor.conversion.for("downcast").attributeToElement({
            model: decorator.id,
            view: (manualDecoratorValue, { writer, schema }, { item }) => {
              if (!(item.is("selection") || schema.isInline(item))) {
                return;
              }
              if (manualDecoratorValue) {
                const element = writer.createAttributeElement("a", decorator.attributes, {
                  priority: 5
                });
                if (decorator.classes) {
                  writer.addClass(decorator.classes, element);
                }
                for (const key in decorator.styles) {
                  writer.setStyle(key, decorator.styles[key], element);
                }
                writer.setCustomProperty("link", true, element);
                return element;
              }
            }
          });
          editor.conversion.for("upcast").elementToAttribute({
            view: {
              name: "a",
              ...decorator._createPattern()
            },
            model: {
              key: decorator.id
            }
          });
        });
      }
      /**
      * Attaches handlers for {@link module:engine/view/document~Document#event:enter} and
      * {@link module:engine/view/document~Document#event:click} to enable link following.
      */
      _enableLinkOpen() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        this.listenTo(viewDocument, "click", (evt, data) => {
          const shouldOpen = env.isMac ? data.domEvent.metaKey : data.domEvent.ctrlKey;
          if (!shouldOpen) {
            return;
          }
          let clickedElement = data.domTarget;
          if (clickedElement.tagName.toLowerCase() != "a") {
            clickedElement = clickedElement.closest("a");
          }
          if (!clickedElement) {
            return;
          }
          const url = clickedElement.getAttribute("href");
          if (!url) {
            return;
          }
          evt.stop();
          data.preventDefault();
          openLink(url);
        }, {
          context: "$capture"
        });
        this.listenTo(viewDocument, "keydown", (evt, data) => {
          const linkCommand = editor.commands.get("link");
          const url = linkCommand.value;
          const shouldOpen = !!url && data.keyCode === keyCodes.enter && data.altKey;
          if (!shouldOpen) {
            return;
          }
          evt.stop();
          openLink(url);
        });
      }
      /**
      * Watches the DocumentSelection attribute changes and removes link decorator attributes when the linkHref attribute is removed.
      *
      * This is to ensure that there is no left-over link decorator attributes on the document selection that is no longer in a link.
      */
      _enableSelectionAttributesFixer() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        this.listenTo(selection, "change:attribute", (evt, { attributeKeys }) => {
          if (!attributeKeys.includes("linkHref") || selection.hasAttribute("linkHref")) {
            return;
          }
          model.change((writer) => {
            removeLinkAttributesFromSelection(writer, getLinkAttributesAllowedOnText(model.schema));
          });
        });
      }
      /**
      * Enables URL fixing on pasting.
      */
      _enableClipboardIntegration() {
        const editor = this.editor;
        const model = editor.model;
        const defaultProtocol = this.editor.config.get("link.defaultProtocol");
        if (!defaultProtocol) {
          return;
        }
        this.listenTo(editor.plugins.get("ClipboardPipeline"), "contentInsertion", (evt, data) => {
          model.change((writer) => {
            const range = writer.createRangeIn(data.content);
            for (const item of range.getItems()) {
              if (item.hasAttribute("linkHref")) {
                const newLink = addLinkProtocolIfApplicable(item.getAttribute("linkHref"), defaultProtocol);
                writer.setAttribute("linkHref", newLink, item);
              }
            }
          });
        });
      }
    }
    function removeLinkAttributesFromSelection(writer, linkAttributes) {
      writer.removeSelectionAttribute("linkHref");
      for (const attribute of linkAttributes) {
        writer.removeSelectionAttribute(attribute);
      }
    }
    function getLinkAttributesAllowedOnText(schema) {
      const textAttributes = schema.getDefinition("$text").allowAttributes;
      return textAttributes.filter((attribute) => attribute.startsWith("link"));
    }
    class LinkFormView extends View {
      /**
      * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
      *
      * Also see {@link #render}.
      *
      * @param locale The localization services instance.
      * @param linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
      * @param validators  Form validators used by {@link #isValid}.
      */
      constructor(locale, linkCommand, validators) {
        super(locale);
        /**
        * Tracks information about DOM focus in the form.
        */
        __publicField(this, "focusTracker", new FocusTracker());
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes", new KeystrokeHandler());
        /**
        * The URL input view.
        */
        __publicField(this, "urlInputView");
        /**
        * The Save button view.
        */
        __publicField(this, "saveButtonView");
        /**
        * The Cancel button view.
        */
        __publicField(this, "cancelButtonView");
        /**
        * A collection of {@link module:ui/button/switchbuttonview~SwitchButtonView},
        * which corresponds to {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators}
        * configured in the editor.
        */
        __publicField(this, "_manualDecoratorSwitches");
        /**
        * A collection of child views in the form.
        */
        __publicField(this, "children");
        /**
        * An array of form validators used by {@link #isValid}.
        */
        __publicField(this, "_validators");
        /**
        * A collection of views that can be focused in the form.
        */
        __publicField(this, "_focusables", new ViewCollection());
        /**
        * Helps cycling over {@link #_focusables} in the form.
        */
        __publicField(this, "_focusCycler");
        const t = locale.t;
        this._validators = validators;
        this.urlInputView = this._createUrlInput();
        this.saveButtonView = this._createButton(t("Save"), icons.check, "ck-button-save");
        this.saveButtonView.type = "submit";
        this.cancelButtonView = this._createButton(t("Cancel"), icons.cancel, "ck-button-cancel", "cancel");
        this._manualDecoratorSwitches = this._createManualDecoratorSwitches(linkCommand);
        this.children = this._createFormChildren(linkCommand.manualDecorators);
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        const classList = [
          "ck",
          "ck-link-form",
          "ck-responsive-form"
        ];
        if (linkCommand.manualDecorators.length) {
          classList.push("ck-link-form_layout-vertical", "ck-vertical-form");
        }
        this.setTemplate({
          tag: "form",
          attributes: {
            class: classList,
            // https://github.com/ckeditor/ckeditor5-link/issues/90
            tabindex: "-1"
          },
          children: this.children
        });
      }
      /**
      * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
      * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
      * in the {@link module:link/ui/linkformview~LinkFormView}.
      *
      * @returns Key-value pairs, where the key is the name of the decorator and the value is its state.
      */
      getDecoratorSwitchesState() {
        return Array.from(this._manualDecoratorSwitches).reduce((accumulator, switchButton) => {
          accumulator[switchButton.name] = switchButton.isOn;
          return accumulator;
        }, {});
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        submitHandler({
          view: this
        });
        const childViews = [
          this.urlInputView,
          ...this._manualDecoratorSwitches,
          this.saveButtonView,
          this.cancelButtonView
        ];
        childViews.forEach((v) => {
          this._focusables.add(v);
          this.focusTracker.add(v.element);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the fist {@link #_focusables} in the form.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Validates the form and returns `false` when some fields are invalid.
      */
      isValid() {
        this.resetFormStatus();
        for (const validator of this._validators) {
          const errorText = validator(this);
          if (errorText) {
            this.urlInputView.errorText = errorText;
            return false;
          }
        }
        return true;
      }
      /**
      * Cleans up the supplementary error and information text of the {@link #urlInputView}
      * bringing them back to the state when the form has been displayed for the first time.
      *
      * See {@link #isValid}.
      */
      resetFormStatus() {
        this.urlInputView.errorText = null;
      }
      /**
      * Creates a labeled input view.
      *
      * @returns Labeled field view instance.
      */
      _createUrlInput() {
        const t = this.locale.t;
        const labeledInput = new LabeledFieldView(this.locale, createLabeledInputText);
        labeledInput.fieldView.inputMode = "url";
        labeledInput.label = t("Link URL");
        return labeledInput;
      }
      /**
      * Creates a button view.
      *
      * @param label The button label.
      * @param icon The button icon.
      * @param className The additional button CSS class name.
      * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
      * @returns The button view instance.
      */
      _createButton(label, icon, className, eventName) {
        const button = new ButtonView(this.locale);
        button.set({
          label,
          icon,
          tooltip: true
        });
        button.extendTemplate({
          attributes: {
            class: className
          }
        });
        if (eventName) {
          button.delegate("execute").to(this, eventName);
        }
        return button;
      }
      /**
      * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
      * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
      *
      * @param linkCommand A reference to the link command.
      * @returns ViewCollection of switch buttons.
      */
      _createManualDecoratorSwitches(linkCommand) {
        const switches = this.createCollection();
        for (const manualDecorator of linkCommand.manualDecorators) {
          const switchButton = new SwitchButtonView(this.locale);
          switchButton.set({
            name: manualDecorator.id,
            label: manualDecorator.label,
            withText: true
          });
          switchButton.bind("isOn").toMany([
            manualDecorator,
            linkCommand
          ], "value", (decoratorValue, commandValue) => {
            return commandValue === void 0 && decoratorValue === void 0 ? !!manualDecorator.defaultValue : !!decoratorValue;
          });
          switchButton.on("execute", () => {
            manualDecorator.set("value", !switchButton.isOn);
          });
          switches.add(switchButton);
        }
        return switches;
      }
      /**
      * Populates the {@link #children} collection of the form.
      *
      * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
      * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
      * to these decorators.
      *
      * @param manualDecorators A reference to
      * the collection of manual decorators stored in the link command.
      * @returns The children of link form view.
      */
      _createFormChildren(manualDecorators) {
        const children = this.createCollection();
        children.add(this.urlInputView);
        if (manualDecorators.length) {
          const additionalButtonsView = new View();
          additionalButtonsView.setTemplate({
            tag: "ul",
            children: this._manualDecoratorSwitches.map((switchButton) => ({
              tag: "li",
              children: [
                switchButton
              ],
              attributes: {
                class: [
                  "ck",
                  "ck-list__item"
                ]
              }
            })),
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-list"
              ]
            }
          });
          children.add(additionalButtonsView);
        }
        children.add(this.saveButtonView);
        children.add(this.cancelButtonView);
        return children;
      }
      /**
      * The native DOM `value` of the {@link #urlInputView} element.
      *
      * **Note**: Do not confuse it with the {@link module:ui/inputtext/inputtextview~InputTextView#value}
      * which works one way only and may not represent the actual state of the component in the DOM.
      */
      get url() {
        const { element } = this.urlInputView.fieldView;
        if (!element) {
          return null;
        }
        return element.value.trim();
      }
    }
    var unlinkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
    class LinkActionsView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale, linkConfig = {}) {
        super(locale);
        /**
        * Tracks information about DOM focus in the actions.
        */
        __publicField(this, "focusTracker", new FocusTracker());
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes", new KeystrokeHandler());
        /**
        * The href preview view.
        */
        __publicField(this, "previewButtonView");
        /**
        * The unlink button view.
        */
        __publicField(this, "unlinkButtonView");
        /**
        * The edit link button view.
        */
        __publicField(this, "editButtonView");
        /**
        * A collection of views that can be focused in the view.
        */
        __publicField(this, "_focusables", new ViewCollection());
        /**
        * Helps cycling over {@link #_focusables} in the view.
        */
        __publicField(this, "_focusCycler");
        __publicField(this, "_linkConfig");
        const t = locale.t;
        this.previewButtonView = this._createPreviewButton();
        this.unlinkButtonView = this._createButton(t("Unlink"), unlinkIcon, "unlink");
        this.editButtonView = this._createButton(t("Edit link"), icons.pencil, "edit");
        this.set("href", void 0);
        this._linkConfig = linkConfig;
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-link-actions",
              "ck-responsive-form"
            ],
            // https://github.com/ckeditor/ckeditor5-link/issues/90
            tabindex: "-1"
          },
          children: [
            this.previewButtonView,
            this.editButtonView,
            this.unlinkButtonView
          ]
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        const childViews = [
          this.previewButtonView,
          this.editButtonView,
          this.unlinkButtonView
        ];
        childViews.forEach((v) => {
          this._focusables.add(v);
          this.focusTracker.add(v.element);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the fist {@link #_focusables} in the actions.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Creates a button view.
      *
      * @param label The button label.
      * @param icon The button icon.
      * @param eventName An event name that the `ButtonView#execute` event will be delegated to.
      * @returns The button view instance.
      */
      _createButton(label, icon, eventName) {
        const button = new ButtonView(this.locale);
        button.set({
          label,
          icon,
          tooltip: true
        });
        button.delegate("execute").to(this, eventName);
        return button;
      }
      /**
      * Creates a link href preview button.
      *
      * @returns The button view instance.
      */
      _createPreviewButton() {
        const button = new ButtonView(this.locale);
        const bind = this.bindTemplate;
        const t = this.t;
        button.set({
          withText: true,
          tooltip: t("Open link in new tab")
        });
        button.extendTemplate({
          attributes: {
            class: [
              "ck",
              "ck-link-actions__preview"
            ],
            href: bind.to("href", (href) => href && ensureSafeUrl(href, this._linkConfig.allowedProtocols)),
            target: "_blank",
            rel: "noopener noreferrer"
          }
        });
        button.bind("label").to(this, "href", (href) => {
          return href || t("This link has no URL");
        });
        button.bind("isEnabled").to(this, "href", (href) => !!href);
        button.template.tag = "a";
        button.template.eventListeners = {};
        return button;
      }
    }
    var linkIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
    const VISUAL_SELECTION_MARKER_NAME = "link-ui";
    class LinkUI extends Plugin {
      constructor() {
        super(...arguments);
        /**
        * The actions view displayed inside of the balloon.
        */
        __publicField(this, "actionsView", null);
        /**
        * The form view displayed inside the balloon.
        */
        __publicField(this, "formView", null);
        /**
        * The contextual balloon plugin instance.
        */
        __publicField(this, "_balloon");
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ContextualBalloon
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "LinkUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        editor.editing.view.addObserver(ClickObserver);
        this._balloon = editor.plugins.get(ContextualBalloon);
        this._createToolbarLinkButton();
        this._enableBalloonActivators();
        editor.conversion.for("editingDowncast").markerToHighlight({
          model: VISUAL_SELECTION_MARKER_NAME,
          view: {
            classes: [
              "ck-fake-link-selection"
            ]
          }
        });
        editor.conversion.for("editingDowncast").markerToElement({
          model: VISUAL_SELECTION_MARKER_NAME,
          view: {
            name: "span",
            classes: [
              "ck-fake-link-selection",
              "ck-fake-link-selection_collapsed"
            ]
          }
        });
        editor.accessibility.addKeystrokeInfos({
          keystrokes: [
            {
              label: t("Create link"),
              keystroke: LINK_KEYSTROKE
            },
            {
              label: t("Move out of a link"),
              keystroke: [
                [
                  "arrowleft",
                  "arrowleft"
                ],
                [
                  "arrowright",
                  "arrowright"
                ]
              ]
            }
          ]
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this.formView) {
          this.formView.destroy();
        }
        if (this.actionsView) {
          this.actionsView.destroy();
        }
      }
      /**
      * Creates views.
      */
      _createViews() {
        this.actionsView = this._createActionsView();
        this.formView = this._createFormView();
        this._enableUserBalloonInteractions();
      }
      /**
      * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
      */
      _createActionsView() {
        const editor = this.editor;
        const actionsView = new LinkActionsView(editor.locale, editor.config.get("link"));
        const linkCommand = editor.commands.get("link");
        const unlinkCommand = editor.commands.get("unlink");
        actionsView.bind("href").to(linkCommand, "value");
        actionsView.editButtonView.bind("isEnabled").to(linkCommand);
        actionsView.unlinkButtonView.bind("isEnabled").to(unlinkCommand);
        this.listenTo(actionsView, "edit", () => {
          this._addFormView();
        });
        this.listenTo(actionsView, "unlink", () => {
          editor.execute("unlink");
          this._hideUI();
        });
        actionsView.keystrokes.set("Esc", (data, cancel2) => {
          this._hideUI();
          cancel2();
        });
        actionsView.keystrokes.set(LINK_KEYSTROKE, (data, cancel2) => {
          this._addFormView();
          cancel2();
        });
        return actionsView;
      }
      /**
      * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
      */
      _createFormView() {
        const editor = this.editor;
        const linkCommand = editor.commands.get("link");
        const defaultProtocol = editor.config.get("link.defaultProtocol");
        const formView = new (CssTransitionDisablerMixin(LinkFormView))(editor.locale, linkCommand, getFormValidators(editor));
        formView.urlInputView.fieldView.bind("value").to(linkCommand, "value");
        formView.urlInputView.bind("isEnabled").to(linkCommand, "isEnabled");
        formView.saveButtonView.bind("isEnabled").to(linkCommand, "isEnabled");
        this.listenTo(formView, "submit", () => {
          if (formView.isValid()) {
            const { value } = formView.urlInputView.fieldView.element;
            const parsedUrl = addLinkProtocolIfApplicable(value, defaultProtocol);
            editor.execute("link", parsedUrl, formView.getDecoratorSwitchesState());
            this._closeFormView();
          }
        });
        this.listenTo(formView.urlInputView, "change:errorText", () => {
          editor.ui.update();
        });
        this.listenTo(formView, "cancel", () => {
          this._closeFormView();
        });
        formView.keystrokes.set("Esc", (data, cancel2) => {
          this._closeFormView();
          cancel2();
        });
        return formView;
      }
      /**
      * Creates a toolbar Link button. Clicking this button will show
      * a {@link #_balloon} attached to the selection.
      */
      _createToolbarLinkButton() {
        const editor = this.editor;
        const linkCommand = editor.commands.get("link");
        editor.ui.componentFactory.add("link", () => {
          const button = this._createButton(ButtonView);
          button.set({
            tooltip: true,
            isToggleable: true
          });
          button.bind("isOn").to(linkCommand, "value", (value) => !!value);
          return button;
        });
        editor.ui.componentFactory.add("menuBar:link", () => {
          return this._createButton(MenuBarMenuListItemButtonView);
        });
      }
      /**
      * Creates a button for link command to use either in toolbar or in menu bar.
      */
      _createButton(ButtonClass) {
        const editor = this.editor;
        const locale = editor.locale;
        const command = editor.commands.get("link");
        const view = new ButtonClass(editor.locale);
        const t = locale.t;
        view.set({
          label: t("Link"),
          icon: linkIcon,
          keystroke: LINK_KEYSTROKE
        });
        view.bind("isEnabled").to(command, "isEnabled");
        this.listenTo(view, "execute", () => this._showUI(true));
        return view;
      }
      /**
      * Attaches actions that control whether the balloon panel containing the
      * {@link #formView} should be displayed.
      */
      _enableBalloonActivators() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        this.listenTo(viewDocument, "click", () => {
          const parentLink = this._getSelectedLinkElement();
          if (parentLink) {
            this._showUI();
          }
        });
        editor.keystrokes.set(LINK_KEYSTROKE, (keyEvtData, cancel2) => {
          cancel2();
          if (editor.commands.get("link").isEnabled) {
            this._showUI(true);
          }
        });
      }
      /**
      * Attaches actions that control whether the balloon panel containing the
      * {@link #formView} is visible or not.
      */
      _enableUserBalloonInteractions() {
        this.editor.keystrokes.set("Tab", (data, cancel2) => {
          if (this._areActionsVisible && !this.actionsView.focusTracker.isFocused) {
            this.actionsView.focus();
            cancel2();
          }
        }, {
          // Use the high priority because the link UI navigation is more important
          // than other feature's actions, e.g. list indentation.
          // https://github.com/ckeditor/ckeditor5-link/issues/146
          priority: "high"
        });
        this.editor.keystrokes.set("Esc", (data, cancel2) => {
          if (this._isUIVisible) {
            this._hideUI();
            cancel2();
          }
        });
        clickOutsideHandler({
          emitter: this.formView,
          activator: () => this._isUIInPanel,
          contextElements: () => [
            this._balloon.view.element
          ],
          callback: () => this._hideUI()
        });
      }
      /**
      * Adds the {@link #actionsView} to the {@link #_balloon}.
      *
      * @internal
      */
      _addActionsView() {
        if (!this.actionsView) {
          this._createViews();
        }
        if (this._areActionsInPanel) {
          return;
        }
        this._balloon.add({
          view: this.actionsView,
          position: this._getBalloonPositionData()
        });
      }
      /**
      * Adds the {@link #formView} to the {@link #_balloon}.
      */
      _addFormView() {
        if (!this.formView) {
          this._createViews();
        }
        if (this._isFormInPanel) {
          return;
        }
        const editor = this.editor;
        const linkCommand = editor.commands.get("link");
        this.formView.disableCssTransitions();
        this.formView.resetFormStatus();
        this._balloon.add({
          view: this.formView,
          position: this._getBalloonPositionData()
        });
        this.formView.urlInputView.fieldView.value = linkCommand.value || "";
        if (this._balloon.visibleView === this.formView) {
          this.formView.urlInputView.fieldView.select();
        }
        this.formView.enableCssTransitions();
      }
      /**
      * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
      * decided upon the link command value (which has a value if the document selection is in the link).
      *
      * Additionally, if any {@link module:link/linkconfig~LinkConfig#decorators} are defined in the editor configuration, the state of
      * switch buttons responsible for manual decorator handling is restored.
      */
      _closeFormView() {
        const linkCommand = this.editor.commands.get("link");
        linkCommand.restoreManualDecoratorStates();
        if (linkCommand.value !== void 0) {
          this._removeFormView();
        } else {
          this._hideUI();
        }
      }
      /**
      * Removes the {@link #formView} from the {@link #_balloon}.
      */
      _removeFormView() {
        if (this._isFormInPanel) {
          this.formView.saveButtonView.focus();
          this.formView.urlInputView.fieldView.reset();
          this._balloon.remove(this.formView);
          this.editor.editing.view.focus();
          this._hideFakeVisualSelection();
        }
      }
      /**
      * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
      *
      * @internal
      */
      _showUI(forceVisible = false) {
        if (!this.formView) {
          this._createViews();
        }
        if (!this._getSelectedLinkElement()) {
          this._showFakeVisualSelection();
          this._addActionsView();
          if (forceVisible) {
            this._balloon.showStack("main");
          }
          this._addFormView();
        } else {
          if (this._areActionsVisible) {
            this._addFormView();
          } else {
            this._addActionsView();
          }
          if (forceVisible) {
            this._balloon.showStack("main");
          }
        }
        this._startUpdatingUI();
      }
      /**
      * Removes the {@link #formView} from the {@link #_balloon}.
      *
      * See {@link #_addFormView}, {@link #_addActionsView}.
      */
      _hideUI() {
        if (!this._isUIInPanel) {
          return;
        }
        const editor = this.editor;
        this.stopListening(editor.ui, "update");
        this.stopListening(this._balloon, "change:visibleView");
        editor.editing.view.focus();
        this._removeFormView();
        this._balloon.remove(this.actionsView);
        this._hideFakeVisualSelection();
      }
      /**
      * Makes the UI react to the {@link module:ui/editorui/editorui~EditorUI#event:update} event to
      * reposition itself when the editor UI should be refreshed.
      *
      * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
      */
      _startUpdatingUI() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        let prevSelectedLink = this._getSelectedLinkElement();
        let prevSelectionParent = getSelectionParent();
        const update = () => {
          const selectedLink = this._getSelectedLinkElement();
          const selectionParent = getSelectionParent();
          if (prevSelectedLink && !selectedLink || !prevSelectedLink && selectionParent !== prevSelectionParent) {
            this._hideUI();
          } else if (this._isUIVisible) {
            this._balloon.updatePosition(this._getBalloonPositionData());
          }
          prevSelectedLink = selectedLink;
          prevSelectionParent = selectionParent;
        };
        function getSelectionParent() {
          return viewDocument.selection.focus.getAncestors().reverse().find((node) => node.is("element"));
        }
        this.listenTo(editor.ui, "update", update);
        this.listenTo(this._balloon, "change:visibleView", update);
      }
      /**
      * Returns `true` when {@link #formView} is in the {@link #_balloon}.
      */
      get _isFormInPanel() {
        return !!this.formView && this._balloon.hasView(this.formView);
      }
      /**
      * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
      */
      get _areActionsInPanel() {
        return !!this.actionsView && this._balloon.hasView(this.actionsView);
      }
      /**
      * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
      * currently visible.
      */
      get _areActionsVisible() {
        return !!this.actionsView && this._balloon.visibleView === this.actionsView;
      }
      /**
      * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
      */
      get _isUIInPanel() {
        return this._isFormInPanel || this._areActionsInPanel;
      }
      /**
      * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
      * currently visible.
      */
      get _isUIVisible() {
        const visibleView = this._balloon.visibleView;
        return !!this.formView && visibleView == this.formView || this._areActionsVisible;
      }
      /**
      * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
      * to the target element or selection.
      *
      * If the selection is collapsed and inside a link element, the panel will be attached to the
      * entire link element. Otherwise, it will be attached to the selection.
      */
      _getBalloonPositionData() {
        const view = this.editor.editing.view;
        const model = this.editor.model;
        const viewDocument = view.document;
        let target;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
          const markerViewElements = Array.from(this.editor.editing.mapper.markerNameToElements(VISUAL_SELECTION_MARKER_NAME));
          const newRange = view.createRange(view.createPositionBefore(markerViewElements[0]), view.createPositionAfter(markerViewElements[markerViewElements.length - 1]));
          target = view.domConverter.viewRangeToDom(newRange);
        } else {
          target = () => {
            const targetLink = this._getSelectedLinkElement();
            return targetLink ? (
              // When selection is inside link element, then attach panel to this element.
              view.domConverter.mapViewToDom(targetLink)
            ) : (
              // Otherwise attach panel to the selection.
              view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange())
            );
          };
        }
        return {
          target
        };
      }
      /**
      * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
      * the {@link module:engine/view/document~Document editing view's} selection or `null`
      * if there is none.
      *
      * **Note**: For a non–collapsed selection, the link element is returned when **fully**
      * selected and the **only** element within the selection boundaries, or when
      * a linked widget is selected.
      */
      _getSelectedLinkElement() {
        const view = this.editor.editing.view;
        const selection = view.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (selection.isCollapsed || selectedElement && isWidget(selectedElement)) {
          return findLinkElementAncestor(selection.getFirstPosition());
        } else {
          const range = selection.getFirstRange().getTrimmed();
          const startLink = findLinkElementAncestor(range.start);
          const endLink = findLinkElementAncestor(range.end);
          if (!startLink || startLink != endLink) {
            return null;
          }
          if (view.createRangeIn(startLink).getTrimmed().isEqual(range)) {
            return startLink;
          } else {
            return null;
          }
        }
      }
      /**
      * Displays a fake visual selection when the contextual balloon is displayed.
      *
      * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
      */
      _showFakeVisualSelection() {
        const model = this.editor.model;
        model.change((writer) => {
          const range = model.document.selection.getFirstRange();
          if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
            writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
              range
            });
          } else {
            if (range.start.isAtEnd) {
              const startPosition = range.start.getLastMatchingPosition(({ item }) => !model.schema.isContent(item), {
                boundaries: range
              });
              writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                usingOperation: false,
                affectsData: false,
                range: writer.createRange(startPosition, range.end)
              });
            } else {
              writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
                usingOperation: false,
                affectsData: false,
                range
              });
            }
          }
        });
      }
      /**
      * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
      */
      _hideFakeVisualSelection() {
        const model = this.editor.model;
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
          model.change((writer) => {
            writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
          });
        }
      }
    }
    function findLinkElementAncestor(position) {
      return position.getAncestors().find((ancestor) => isLinkElement(ancestor)) || null;
    }
    function getFormValidators(editor) {
      const t = editor.t;
      const allowCreatingEmptyLinks = editor.config.get("link.allowCreatingEmptyLinks");
      return [
        (form) => {
          if (!allowCreatingEmptyLinks && !form.url.length) {
            return t("Link URL must not be empty.");
          }
        }
      ];
    }
    const MIN_LINK_LENGTH_WITH_SPACE_AT_END = 4;
    const URL_REG_EXP = new RegExp(
      // Group 1: Line start or after a space.
      "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
      "i"
    );
    const URL_GROUP_IN_MATCH = 2;
    class AutoLink extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Delete,
          LinkEditing
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "AutoLink";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        selection.on("change:range", () => {
          this.isEnabled = !selection.anchor.parent.is("element", "codeBlock");
        });
        this._enableTypingHandling();
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        this._enableEnterHandling();
        this._enableShiftEnterHandling();
        this._enablePasteLinking();
      }
      /**
      * For given position, returns a range that includes the whole link that contains the position.
      *
      * If position is not inside a link, returns `null`.
      */
      _expandLinkRange(model, position) {
        if (position.textNode && position.textNode.hasAttribute("linkHref")) {
          return findAttributeRange(position, "linkHref", position.textNode.getAttribute("linkHref"), model);
        } else {
          return null;
        }
      }
      /**
      * Extends the document selection to includes all links that intersects with given `selectedRange`.
      */
      _selectEntireLinks(writer, selectedRange) {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const selStart = selection.getFirstPosition();
        const selEnd = selection.getLastPosition();
        let updatedSelection = selectedRange.getJoined(this._expandLinkRange(model, selStart) || selectedRange);
        if (updatedSelection) {
          updatedSelection = updatedSelection.getJoined(this._expandLinkRange(model, selEnd) || selectedRange);
        }
        if (updatedSelection && (updatedSelection.start.isBefore(selStart) || updatedSelection.end.isAfter(selEnd))) {
          writer.setSelection(updatedSelection);
        }
      }
      /**
      * Enables autolinking on pasting a URL when some content is selected.
      */
      _enablePasteLinking() {
        const editor = this.editor;
        const model = editor.model;
        const selection = model.document.selection;
        const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
        const linkCommand = editor.commands.get("link");
        clipboardPipeline.on("inputTransformation", (evt, data) => {
          if (!this.isEnabled || !linkCommand.isEnabled || selection.isCollapsed || data.method !== "paste") {
            return;
          }
          if (selection.rangeCount > 1) {
            return;
          }
          const selectedRange = selection.getFirstRange();
          const newLink = data.dataTransfer.getData("text/plain");
          if (!newLink) {
            return;
          }
          const matches = newLink.match(URL_REG_EXP);
          if (matches && matches[2] === newLink) {
            model.change((writer) => {
              this._selectEntireLinks(writer, selectedRange);
              linkCommand.execute(newLink);
            });
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
      /**
      * Enables autolinking on typing.
      */
      _enableTypingHandling() {
        const editor = this.editor;
        const watcher = new TextWatcher(editor.model, (text2) => {
          if (!isSingleSpaceAtTheEnd(text2)) {
            return;
          }
          const url = getUrlAtTextEnd(text2.substr(0, text2.length - 1));
          if (url) {
            return {
              url
            };
          }
        });
        watcher.on("matched:data", (evt, data) => {
          const { batch, range, url } = data;
          if (!batch.isTyping) {
            return;
          }
          const linkEnd = range.end.getShiftedBy(-1);
          const linkStart = linkEnd.getShiftedBy(-url.length);
          const linkRange = editor.model.createRange(linkStart, linkEnd);
          this._applyAutoLink(url, linkRange);
        });
        watcher.bind("isEnabled").to(this);
      }
      /**
      * Enables autolinking on the <kbd>Enter</kbd> key.
      */
      _enableEnterHandling() {
        const editor = this.editor;
        const model = editor.model;
        const enterCommand = editor.commands.get("enter");
        if (!enterCommand) {
          return;
        }
        enterCommand.on("execute", () => {
          const position = model.document.selection.getFirstPosition();
          if (!position.parent.previousSibling) {
            return;
          }
          const rangeToCheck = model.createRangeIn(position.parent.previousSibling);
          this._checkAndApplyAutoLinkOnRange(rangeToCheck);
        });
      }
      /**
      * Enables autolinking on the <kbd>Shift</kbd>+<kbd>Enter</kbd> keyboard shortcut.
      */
      _enableShiftEnterHandling() {
        const editor = this.editor;
        const model = editor.model;
        const shiftEnterCommand = editor.commands.get("shiftEnter");
        if (!shiftEnterCommand) {
          return;
        }
        shiftEnterCommand.on("execute", () => {
          const position = model.document.selection.getFirstPosition();
          const rangeToCheck = model.createRange(model.createPositionAt(position.parent, 0), position.getShiftedBy(-1));
          this._checkAndApplyAutoLinkOnRange(rangeToCheck);
        });
      }
      /**
      * Checks if the passed range contains a linkable text.
      */
      _checkAndApplyAutoLinkOnRange(rangeToCheck) {
        const model = this.editor.model;
        const { text: text2, range } = getLastTextLine(rangeToCheck, model);
        const url = getUrlAtTextEnd(text2);
        if (url) {
          const linkRange = model.createRange(range.end.getShiftedBy(-url.length), range.end);
          this._applyAutoLink(url, linkRange);
        }
      }
      /**
      * Applies a link on a given range if the link should be applied.
      *
      * @param url The URL to link.
      * @param range The text range to apply the link attribute to.
      */
      _applyAutoLink(url, range) {
        const model = this.editor.model;
        const defaultProtocol = this.editor.config.get("link.defaultProtocol");
        const fullUrl = addLinkProtocolIfApplicable(url, defaultProtocol);
        if (!this.isEnabled || !isLinkAllowedOnRange(range, model) || !linkHasProtocol(fullUrl) || linkIsAlreadySet(range)) {
          return;
        }
        this._persistAutoLink(fullUrl, range);
      }
      /**
      * Enqueues autolink changes in the model.
      *
      * @param url The URL to link.
      * @param range The text range to apply the link attribute to.
      */
      _persistAutoLink(url, range) {
        const model = this.editor.model;
        const deletePlugin = this.editor.plugins.get("Delete");
        model.enqueueChange((writer) => {
          writer.setAttribute("linkHref", url, range);
          model.enqueueChange(() => {
            deletePlugin.requestUndoOnBackspace();
          });
        });
      }
    }
    function isSingleSpaceAtTheEnd(text2) {
      return text2.length > MIN_LINK_LENGTH_WITH_SPACE_AT_END && text2[text2.length - 1] === " " && text2[text2.length - 2] !== " ";
    }
    function getUrlAtTextEnd(text2) {
      const match = URL_REG_EXP.exec(text2);
      return match ? match[URL_GROUP_IN_MATCH] : null;
    }
    function isLinkAllowedOnRange(range, model) {
      return model.schema.checkAttributeInSelection(model.createSelection(range), "linkHref");
    }
    function linkIsAlreadySet(range) {
      const item = range.start.nodeAfter;
      return !!item && item.hasAttribute("linkHref");
    }
    class Link extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          LinkEditing,
          LinkUI,
          AutoLink
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Link";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class ListWalker {
      /**
      * Creates a document list iterator.
      *
      * @param startElement The start list item block element.
      * @param options.direction The iterating direction.
      * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
      * @param options.sameAttributes Additional attributes that must be the same for each block.
      * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
      * in the result.
      * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
      * in the result.
      * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
      * in the result.
      */
      constructor(startElement, options) {
        /**
        * The start list item block element.
        */
        __publicField(this, "_startElement");
        /**
        * The reference indent. Initialized by the indent of the start block.
        */
        __publicField(this, "_referenceIndent");
        /**
        * The iterating direction.
        */
        __publicField(this, "_isForward");
        /**
        * Whether start block should be included in the result (if it's matching other criteria).
        */
        __publicField(this, "_includeSelf");
        /**
        * Additional attributes that must be the same for each block.
        */
        __publicField(this, "_sameAttributes");
        /**
        * Whether blocks with the same indent level as the start block should be included in the result.
        */
        __publicField(this, "_sameIndent");
        /**
        * Whether blocks with a lower indent level than the start block should be included in the result.
        */
        __publicField(this, "_lowerIndent");
        /**
        * Whether blocks with a higher indent level than the start block should be included in the result.
        */
        __publicField(this, "_higherIndent");
        this._startElement = startElement;
        this._referenceIndent = startElement.getAttribute("listIndent");
        this._isForward = options.direction == "forward";
        this._includeSelf = !!options.includeSelf;
        this._sameAttributes = toArray$1(options.sameAttributes || []);
        this._sameIndent = !!options.sameIndent;
        this._lowerIndent = !!options.lowerIndent;
        this._higherIndent = !!options.higherIndent;
      }
      /**
      * Performs only first step of iteration and returns the result.
      *
      * @param startElement The start list item block element.
      * @param options.direction The iterating direction.
      * @param options.includeSelf Whether start block should be included in the result (if it's matching other criteria).
      * @param options.sameAttributes Additional attributes that must be the same for each block.
      * @param options.sameIndent Whether blocks with the same indent level as the start block should be included
      * in the result.
      * @param options.lowerIndent Whether blocks with a lower indent level than the start block should be included
      * in the result.
      * @param options.higherIndent Whether blocks with a higher indent level than the start block should be included
      * in the result.
      */
      static first(startElement, options) {
        const walker = new this(startElement, options);
        const iterator = walker[Symbol.iterator]();
        return first(iterator);
      }
      /**
      * Iterable interface.
      */
      *[Symbol.iterator]() {
        const nestedItems = [];
        for (const { node } of iterateSiblingListBlocks(this._getStartNode(), this._isForward ? "forward" : "backward")) {
          const indent2 = node.getAttribute("listIndent");
          if (indent2 < this._referenceIndent) {
            if (!this._lowerIndent) {
              break;
            }
            this._referenceIndent = indent2;
          } else if (indent2 > this._referenceIndent) {
            if (!this._higherIndent) {
              continue;
            }
            if (!this._isForward) {
              nestedItems.push(node);
              continue;
            }
          } else {
            if (!this._sameIndent) {
              if (this._higherIndent) {
                if (nestedItems.length) {
                  yield* nestedItems;
                  nestedItems.length = 0;
                }
                break;
              }
              continue;
            }
            if (this._sameAttributes.some((attr) => node.getAttribute(attr) !== this._startElement.getAttribute(attr))) {
              break;
            }
          }
          if (nestedItems.length) {
            yield* nestedItems;
            nestedItems.length = 0;
          }
          yield node;
        }
      }
      /**
      * Returns the model element to start iterating.
      */
      _getStartNode() {
        if (this._includeSelf) {
          return this._startElement;
        }
        return this._isForward ? this._startElement.nextSibling : this._startElement.previousSibling;
      }
    }
    function* iterateSiblingListBlocks(node, direction = "forward") {
      const isForward = direction == "forward";
      const previousNodesByIndent = [];
      let previous = null;
      while (isListItemBlock(node)) {
        let previousNodeInList = null;
        if (previous) {
          const nodeIndent = node.getAttribute("listIndent");
          const previousNodeIndent = previous.getAttribute("listIndent");
          if (nodeIndent > previousNodeIndent) {
            previousNodesByIndent[previousNodeIndent] = previous;
          } else if (nodeIndent < previousNodeIndent) {
            previousNodeInList = previousNodesByIndent[nodeIndent];
            previousNodesByIndent.length = nodeIndent;
          } else {
            previousNodeInList = previous;
          }
        }
        yield {
          node,
          previous,
          previousNodeInList
        };
        previous = node;
        node = isForward ? node.nextSibling : node.previousSibling;
      }
    }
    class ListBlocksIterable {
      /**
      * @param listHead The head element of a list.
      */
      constructor(listHead) {
        __publicField(this, "_listHead");
        this._listHead = listHead;
      }
      /**
      * List blocks iterator.
      *
      * Iterates over all blocks of a list.
      */
      [Symbol.iterator]() {
        return iterateSiblingListBlocks(this._listHead, "forward");
      }
    }
    class ListItemUid {
      /**
      * Returns the next ID.
      *
      * @internal
      */
      /* istanbul ignore next: static function definition -- @preserve */
      static next() {
        return uid();
      }
    }
    function isListItemBlock(node) {
      return !!node && node.is("element") && node.hasAttribute("listItemId");
    }
    function getAllListItemBlocks(listItem, options = {}) {
      return [
        ...getListItemBlocks(listItem, {
          ...options,
          direction: "backward"
        }),
        ...getListItemBlocks(listItem, {
          ...options,
          direction: "forward"
        })
      ];
    }
    function getListItemBlocks(listItem, options = {}) {
      const isForward = options.direction == "forward";
      const items = Array.from(new ListWalker(listItem, {
        ...options,
        includeSelf: isForward,
        sameIndent: true,
        sameAttributes: "listItemId"
      }));
      return isForward ? items : items.reverse();
    }
    function getNestedListBlocks(listItem) {
      return Array.from(new ListWalker(listItem, {
        direction: "forward",
        higherIndent: true
      }));
    }
    function getListItems(listItem, options) {
      const backwardBlocks = new ListWalker(listItem, {
        sameIndent: true,
        sameAttributes: "listType",
        ...options
      });
      const forwardBlocks = new ListWalker(listItem, {
        sameIndent: true,
        sameAttributes: "listType",
        includeSelf: true,
        direction: "forward",
        ...options
      });
      return [
        ...Array.from(backwardBlocks).reverse(),
        ...forwardBlocks
      ];
    }
    function isFirstBlockOfListItem(listBlock) {
      const previousSibling = ListWalker.first(listBlock, {
        sameIndent: true,
        sameAttributes: "listItemId"
      });
      if (!previousSibling) {
        return true;
      }
      return false;
    }
    function isLastBlockOfListItem(listBlock) {
      const nextSibling = ListWalker.first(listBlock, {
        direction: "forward",
        sameIndent: true,
        sameAttributes: "listItemId"
      });
      if (!nextSibling) {
        return true;
      }
      return false;
    }
    function expandListBlocksToCompleteItems(blocks, options = {}) {
      blocks = toArray$1(blocks);
      const higherIndent = options.withNested !== false;
      const allBlocks = /* @__PURE__ */ new Set();
      for (const block2 of blocks) {
        for (const itemBlock of getAllListItemBlocks(block2, {
          higherIndent
        })) {
          allBlocks.add(itemBlock);
        }
      }
      return sortBlocks(allBlocks);
    }
    function expandListBlocksToCompleteList(blocks) {
      blocks = toArray$1(blocks);
      const allBlocks = /* @__PURE__ */ new Set();
      for (const block2 of blocks) {
        for (const itemBlock of getListItems(block2)) {
          allBlocks.add(itemBlock);
        }
      }
      return sortBlocks(allBlocks);
    }
    function splitListItemBefore(listBlock, writer) {
      const blocks = getListItemBlocks(listBlock, {
        direction: "forward"
      });
      const id = ListItemUid.next();
      for (const block2 of blocks) {
        writer.setAttribute("listItemId", id, block2);
      }
      return blocks;
    }
    function mergeListItemBefore(listBlock, parentBlock, writer) {
      const attributes = {};
      for (const [key, value] of parentBlock.getAttributes()) {
        if (key.startsWith("list")) {
          attributes[key] = value;
        }
      }
      const blocks = getListItemBlocks(listBlock, {
        direction: "forward"
      });
      for (const block2 of blocks) {
        writer.setAttributes(attributes, block2);
      }
      return blocks;
    }
    function indentBlocks(blocks, writer, { expand, indentBy = 1 } = {}) {
      blocks = toArray$1(blocks);
      const allBlocks = expand ? expandListBlocksToCompleteItems(blocks) : blocks;
      for (const block2 of allBlocks) {
        const blockIndent = block2.getAttribute("listIndent") + indentBy;
        if (blockIndent < 0) {
          removeListAttributes(block2, writer);
        } else {
          writer.setAttribute("listIndent", blockIndent, block2);
        }
      }
      return allBlocks;
    }
    function outdentBlocksWithMerge(blocks, writer) {
      blocks = toArray$1(blocks);
      const allBlocks = expandListBlocksToCompleteItems(blocks);
      const visited = /* @__PURE__ */ new Set();
      const referenceIndent = Math.min(...allBlocks.map((block2) => block2.getAttribute("listIndent")));
      const parentBlocks = /* @__PURE__ */ new Map();
      for (const block2 of allBlocks) {
        parentBlocks.set(block2, ListWalker.first(block2, {
          lowerIndent: true
        }));
      }
      for (const block2 of allBlocks) {
        if (visited.has(block2)) {
          continue;
        }
        visited.add(block2);
        const blockIndent = block2.getAttribute("listIndent") - 1;
        if (blockIndent < 0) {
          removeListAttributes(block2, writer);
          continue;
        }
        if (block2.getAttribute("listIndent") == referenceIndent) {
          const mergedBlocks = mergeListItemIfNotLast(block2, parentBlocks.get(block2), writer);
          for (const mergedBlock of mergedBlocks) {
            visited.add(mergedBlock);
          }
          if (mergedBlocks.length) {
            continue;
          }
        }
        writer.setAttribute("listIndent", blockIndent, block2);
      }
      return sortBlocks(visited);
    }
    function removeListAttributes(blocks, writer) {
      blocks = toArray$1(blocks);
      for (const block2 of blocks) {
        if (block2.is("element", "listItem")) {
          writer.rename(block2, "paragraph");
        }
      }
      for (const block2 of blocks) {
        for (const attributeKey of block2.getAttributeKeys()) {
          if (attributeKey.startsWith("list")) {
            writer.removeAttribute(attributeKey, block2);
          }
        }
      }
      return blocks;
    }
    function isSingleListItem(blocks) {
      if (!blocks.length) {
        return false;
      }
      const firstItemId = blocks[0].getAttribute("listItemId");
      if (!firstItemId) {
        return false;
      }
      return !blocks.some((item) => item.getAttribute("listItemId") != firstItemId);
    }
    function outdentFollowingItems(lastBlock, writer) {
      const changedBlocks = [];
      let currentIndent = Number.POSITIVE_INFINITY;
      for (const { node } of iterateSiblingListBlocks(lastBlock.nextSibling, "forward")) {
        const indent2 = node.getAttribute("listIndent");
        if (indent2 == 0) {
          break;
        }
        if (indent2 < currentIndent) {
          currentIndent = indent2;
        }
        const newIndent = indent2 - currentIndent;
        writer.setAttribute("listIndent", newIndent, node);
        changedBlocks.push(node);
      }
      return changedBlocks;
    }
    function sortBlocks(blocks) {
      return Array.from(blocks).filter((block2) => block2.root.rootName !== "$graveyard").sort((a, b) => a.index - b.index);
    }
    function getSelectedBlockObject(model) {
      const selectedElement = model.document.selection.getSelectedElement();
      if (!selectedElement) {
        return null;
      }
      if (model.schema.isObject(selectedElement) && model.schema.isBlock(selectedElement)) {
        return selectedElement;
      }
      return null;
    }
    function canBecomeSimpleListItem(block2, schema) {
      return schema.checkChild(block2.parent, "listItem") && schema.checkChild(block2, "$text") && !schema.isObject(block2);
    }
    function isNumberedListType(listType) {
      return listType == "numbered" || listType == "customNumbered";
    }
    function mergeListItemIfNotLast(block2, parentBlock, writer) {
      const parentItemBlocks = getListItemBlocks(parentBlock, {
        direction: "forward"
      });
      if (parentItemBlocks.pop().index > block2.index) {
        return mergeListItemBefore(block2, parentBlock, writer);
      }
      return [];
    }
    class ListIndentCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param indentDirection The direction of indent. If it is equal to `backward`, the command
      * will outdent a list item.
      */
      constructor(editor, indentDirection) {
        super(editor);
        /**
        * Determines by how much the command will change the list item's indent attribute.
        */
        __publicField(this, "_direction");
        this._direction = indentDirection;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
      *
      * @fires execute
      * @fires afterExecute
      */
      execute() {
        const model = this.editor.model;
        const blocks = getSelectedListBlocks(model.document.selection);
        model.change((writer) => {
          const changedBlocks = [];
          if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
            if (this._direction == "forward") {
              changedBlocks.push(...indentBlocks(blocks, writer));
            }
            changedBlocks.push(...splitListItemBefore(blocks[0], writer));
          } else {
            if (this._direction == "forward") {
              changedBlocks.push(...indentBlocks(blocks, writer, {
                expand: true
              }));
            } else {
              changedBlocks.push(...outdentBlocksWithMerge(blocks, writer));
            }
          }
          for (const block2 of changedBlocks) {
            if (!block2.hasAttribute("listType")) {
              continue;
            }
            const previousItemBlock = ListWalker.first(block2, {
              sameIndent: true
            });
            if (previousItemBlock) {
              writer.setAttribute("listType", previousItemBlock.getAttribute("listType"), block2);
            }
          }
          this._fireAfterExecute(changedBlocks);
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        let blocks = getSelectedListBlocks(this.editor.model.document.selection);
        let firstBlock = blocks[0];
        if (!firstBlock) {
          return false;
        }
        if (this._direction == "backward") {
          return true;
        }
        if (isSingleListItem(blocks) && !isFirstBlockOfListItem(blocks[0])) {
          return true;
        }
        blocks = expandListBlocksToCompleteItems(blocks);
        firstBlock = blocks[0];
        const siblingItem = ListWalker.first(firstBlock, {
          sameIndent: true
        });
        if (!siblingItem) {
          return false;
        }
        if (siblingItem.getAttribute("listType") == firstBlock.getAttribute("listType")) {
          return true;
        }
        return false;
      }
    }
    function getSelectedListBlocks(selection) {
      const blocks = Array.from(selection.getSelectedBlocks());
      const firstNonListBlockIndex = blocks.findIndex((block2) => !isListItemBlock(block2));
      if (firstNonListBlockIndex != -1) {
        blocks.length = firstNonListBlockIndex;
      }
      return blocks;
    }
    class ListCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param type List type that will be handled by this command.
      */
      constructor(editor, type, options = {}) {
        super(editor);
        /**
        * The type of the list created by the command.
        */
        __publicField(this, "type");
        /**
        * List Walker options that change the range of the list items to be changed when the selection is collapsed within a list item.
        *
        * In a multi-level list, when the selection is collapsed within a list item, instead of changing only the list items of the same list
        * type and current indent level, the entire list structure is changed (all list items at all indent levels of any list type).
        */
        __publicField(this, "_listWalkerOptions");
        this.type = type;
        this._listWalkerOptions = options.multiLevel ? {
          higherIndent: true,
          lowerIndent: true,
          sameAttributes: []
        } : void 0;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.value = this._getValue();
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Executes the list command.
      *
      * @fires execute
      * @fires afterExecute
      * @param options Command options.
      * @param options.forceValue If set, it will force the command behavior. If `true`, the command will try to convert the
      * selected items and potentially the neighbor elements to the proper list items. If set to `false` it will convert selected elements
      * to paragraphs. If not set, the command will toggle selected elements to list items or paragraphs, depending on the selection.
      * @param options.additionalAttributes Additional attributes that are set for list items when the command is executed.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const document2 = model.document;
        const selectedBlockObject = getSelectedBlockObject(model);
        const blocks = Array.from(document2.selection.getSelectedBlocks()).filter((block2) => model.schema.checkAttribute(block2, "listType") || canBecomeSimpleListItem(block2, model.schema));
        const turnOff = options.forceValue !== void 0 ? !options.forceValue : this.value;
        model.change((writer) => {
          if (turnOff) {
            const lastBlock = blocks[blocks.length - 1];
            const itemBlocks = getListItemBlocks(lastBlock, {
              direction: "forward"
            });
            const changedBlocks = [];
            if (itemBlocks.length > 1) {
              changedBlocks.push(...splitListItemBefore(itemBlocks[1], writer));
            }
            changedBlocks.push(...removeListAttributes(blocks, writer));
            changedBlocks.push(...outdentFollowingItems(lastBlock, writer));
            this._fireAfterExecute(changedBlocks);
          } else if ((selectedBlockObject || document2.selection.isCollapsed) && isListItemBlock(blocks[0])) {
            const changedBlocks = getListItems(selectedBlockObject || blocks[0], this._listWalkerOptions);
            for (const block2 of changedBlocks) {
              writer.setAttributes({
                ...options.additionalAttributes,
                listType: this.type
              }, block2);
            }
            this._fireAfterExecute(changedBlocks);
          } else {
            const changedBlocks = [];
            for (const block2 of blocks) {
              if (!block2.hasAttribute("listType")) {
                if (!block2.is("element", "listItem") && canBecomeSimpleListItem(block2, model.schema)) {
                  writer.rename(block2, "listItem");
                }
                writer.setAttributes({
                  ...options.additionalAttributes,
                  listIndent: 0,
                  listItemId: ListItemUid.next(),
                  listType: this.type
                }, block2);
                changedBlocks.push(block2);
              } else {
                for (const node of expandListBlocksToCompleteItems(block2, {
                  withNested: false
                })) {
                  if (node.getAttribute("listType") != this.type) {
                    writer.setAttributes({
                      ...options.additionalAttributes,
                      listType: this.type
                    }, node);
                    changedBlocks.push(node);
                  }
                }
              }
            }
            this._fireAfterExecute(changedBlocks);
          }
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks the command's {@link #value}.
      *
      * @returns The current value.
      */
      _getValue() {
        const selection = this.editor.model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        if (!blocks.length) {
          return false;
        }
        for (const block2 of blocks) {
          if (block2.getAttribute("listType") != this.type) {
            return false;
          }
        }
        return true;
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        const model = this.editor.model;
        const schema = model.schema;
        const selection = model.document.selection;
        const blocks = Array.from(selection.getSelectedBlocks());
        if (!blocks.length) {
          return false;
        }
        if (this.value) {
          return true;
        }
        for (const block2 of blocks) {
          if (schema.checkAttribute(block2, "listType") || canBecomeSimpleListItem(block2, schema)) {
            return true;
          }
        }
        return false;
      }
    }
    class ListMergeCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param direction Whether list item should be merged before or after the selected block.
      */
      constructor(editor, direction) {
        super(editor);
        /**
        * Whether list item should be merged before or after the selected block.
        */
        __publicField(this, "_direction");
        this._direction = direction;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Merges list blocks together (depending on the {@link #constructor}'s `direction` parameter).
      *
      * @fires execute
      * @fires afterExecute
      * @param options Command options.
      * @param options.shouldMergeOnBlocksContentLevel When set `true`, merging will be performed together
      * with {@link module:engine/model/model~Model#deleteContent} to get rid of the inline content in the selection or take advantage
      * of the heuristics in `deleteContent()` that helps convert lists into paragraphs in certain cases.
      */
      execute({ shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel2 = false } = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const changedBlocks = [];
        model.change((writer) => {
          const { firstElement, lastElement } = this._getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2);
          const firstIndent = firstElement.getAttribute("listIndent") || 0;
          const lastIndent = lastElement.getAttribute("listIndent");
          const lastElementId = lastElement.getAttribute("listItemId");
          if (firstIndent != lastIndent) {
            const nestedLastElementBlocks = getNestedListBlocks(lastElement);
            changedBlocks.push(...indentBlocks([
              lastElement,
              ...nestedLastElementBlocks
            ], writer, {
              indentBy: firstIndent - lastIndent,
              // If outdenting, the entire sub-tree that follows must be included.
              expand: firstIndent < lastIndent
            }));
          }
          if (shouldMergeOnBlocksContentLevel2) {
            let sel = selection;
            if (selection.isCollapsed) {
              sel = writer.createSelection(writer.createRange(writer.createPositionAt(firstElement, "end"), writer.createPositionAt(lastElement, 0)));
            }
            model.deleteContent(sel, {
              doNotResetEntireContent: selection.isCollapsed
            });
            const lastElementAfterDelete = sel.getLastPosition().parent;
            const nextSibling = lastElementAfterDelete.nextSibling;
            changedBlocks.push(lastElementAfterDelete);
            if (nextSibling && nextSibling !== lastElement && nextSibling.getAttribute("listItemId") == lastElementId) {
              changedBlocks.push(...mergeListItemBefore(nextSibling, lastElementAfterDelete, writer));
            }
          } else {
            changedBlocks.push(...mergeListItemBefore(lastElement, firstElement, writer));
          }
          this._fireAfterExecute(changedBlocks);
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const selectedBlockObject = getSelectedBlockObject(model);
        if (selection.isCollapsed || selectedBlockObject) {
          const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
          if (!isListItemBlock(positionParent)) {
            return false;
          }
          const siblingNode = this._direction == "backward" ? positionParent.previousSibling : positionParent.nextSibling;
          if (!siblingNode) {
            return false;
          }
          if (isSingleListItem([
            positionParent,
            siblingNode
          ])) {
            return false;
          }
        } else {
          const lastPosition = selection.getLastPosition();
          const firstPosition = selection.getFirstPosition();
          if (lastPosition.parent === firstPosition.parent) {
            return false;
          }
          if (!isListItemBlock(lastPosition.parent)) {
            return false;
          }
        }
        return true;
      }
      /**
      * Returns the boundary elements the merge should be executed for. These are not necessarily selection's first
      * and last position parents but sometimes sibling or even further blocks depending on the context.
      *
      * @param selection The selection the merge is executed for.
      * @param shouldMergeOnBlocksContentLevel When `true`, merge is performed together with
      * {@link module:engine/model/model~Model#deleteContent} to remove the inline content within the selection.
      */
      _getMergeSubjectElements(selection, shouldMergeOnBlocksContentLevel2) {
        const model = this.editor.model;
        const selectedBlockObject = getSelectedBlockObject(model);
        let firstElement, lastElement;
        if (selection.isCollapsed || selectedBlockObject) {
          const positionParent = selectedBlockObject || selection.getFirstPosition().parent;
          const isFirstBlock = isFirstBlockOfListItem(positionParent);
          if (this._direction == "backward") {
            lastElement = positionParent;
            if (isFirstBlock && !shouldMergeOnBlocksContentLevel2) {
              firstElement = ListWalker.first(positionParent, {
                sameIndent: true,
                lowerIndent: true
              });
            } else {
              firstElement = positionParent.previousSibling;
            }
          } else {
            firstElement = positionParent;
            lastElement = positionParent.nextSibling;
          }
        } else {
          firstElement = selection.getFirstPosition().parent;
          lastElement = selection.getLastPosition().parent;
        }
        return {
          firstElement,
          lastElement
        };
      }
    }
    class ListSplitCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor The editor instance.
      * @param direction Whether list item should be split before or after the selected block.
      */
      constructor(editor, direction) {
        super(editor);
        /**
        * Whether list item should be split before or after the selected block.
        */
        __publicField(this, "_direction");
        this._direction = direction;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = this._checkEnabled();
      }
      /**
      * Splits the list item at the selection.
      *
      * @fires execute
      * @fires afterExecute
      */
      execute() {
        const editor = this.editor;
        editor.model.change((writer) => {
          const changedBlocks = splitListItemBefore(this._getStartBlock(), writer);
          this._fireAfterExecute(changedBlocks);
        });
      }
      /**
      * Fires the `afterExecute` event.
      *
      * @param changedBlocks The changed list elements.
      */
      _fireAfterExecute(changedBlocks) {
        this.fire("afterExecute", sortBlocks(new Set(changedBlocks)));
      }
      /**
      * Checks whether the command can be enabled in the current context.
      *
      * @returns Whether the command should be enabled.
      */
      _checkEnabled() {
        const selection = this.editor.model.document.selection;
        const block2 = this._getStartBlock();
        return selection.isCollapsed && isListItemBlock(block2) && !isFirstBlockOfListItem(block2);
      }
      /**
      * Returns the model element that is the main focus of the command (according to the current selection and command direction).
      */
      _getStartBlock() {
        const doc = this.editor.model.document;
        const positionParent = doc.selection.getFirstPosition().parent;
        return this._direction == "before" ? positionParent : positionParent.nextSibling;
      }
    }
    class ListUtils extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListUtils";
      }
      /**
      * Expands the given list of selected blocks to include all the items of the lists they're in.
      *
      * @param blocks The list of selected blocks.
      */
      expandListBlocksToCompleteList(blocks) {
        return expandListBlocksToCompleteList(blocks);
      }
      /**
      * Check if the given block is the first in the list item.
      *
      * @param listBlock The list block element.
      */
      isFirstBlockOfListItem(listBlock) {
        return isFirstBlockOfListItem(listBlock);
      }
      /**
      * Returns true if the given model node is a list item block.
      *
      * @param node A model node.
      */
      isListItemBlock(node) {
        return isListItemBlock(node);
      }
      /**
      * Expands the given list of selected blocks to include the leading and tailing blocks of partially selected list items.
      *
      * @param blocks The list of selected blocks.
      * @param options.withNested Whether should include nested list items.
      */
      expandListBlocksToCompleteItems(blocks, options = {}) {
        return expandListBlocksToCompleteItems(blocks, options);
      }
      /**
      * Returns true if listType is of type `numbered` or `customNumbered`.
      */
      isNumberedListType(listType) {
        return isNumberedListType(listType);
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function isListView(viewElement) {
      return viewElement.is("element", "ol") || viewElement.is("element", "ul");
    }
    function isListItemView(viewElement) {
      return viewElement.is("element", "li");
    }
    function getIndent$1(listItem) {
      let indent2 = 0;
      let parent2 = listItem.parent;
      while (parent2) {
        if (isListItemView(parent2)) {
          indent2++;
        } else {
          const previousSibling = parent2.previousSibling;
          if (previousSibling && isListItemView(previousSibling)) {
            indent2++;
          }
        }
        parent2 = parent2.parent;
      }
      return indent2;
    }
    function createListElement(writer, indent2, type, id = getViewElementIdForListType(type, indent2)) {
      return writer.createAttributeElement(getViewElementNameForListType(type), null, {
        priority: 2 * indent2 / 100 - 100,
        id
      });
    }
    function createListItemElement(writer, indent2, id) {
      return writer.createAttributeElement("li", null, {
        priority: (2 * indent2 + 1) / 100 - 100,
        id
      });
    }
    function getViewElementNameForListType(type) {
      return type == "numbered" || type == "customNumbered" ? "ol" : "ul";
    }
    function getViewElementIdForListType(type, indent2) {
      return `list-${type}-${indent2}`;
    }
    function findAndAddListHeadToMap(position, itemToListHead) {
      const previousNode = position.nodeBefore;
      if (!isListItemBlock(previousNode)) {
        const item = position.nodeAfter;
        if (isListItemBlock(item)) {
          itemToListHead.set(item, item);
        }
      } else {
        let listHead = previousNode;
        for (const { node } of iterateSiblingListBlocks(listHead, "backward")) {
          listHead = node;
          if (itemToListHead.has(listHead)) {
            return;
          }
        }
        itemToListHead.set(previousNode, listHead);
      }
    }
    function fixListIndents(listNodes, writer) {
      let maxIndent = 0;
      let prevIndent = -1;
      let fixBy = null;
      let applied = false;
      for (const { node } of listNodes) {
        const itemIndent = node.getAttribute("listIndent");
        if (itemIndent > maxIndent) {
          let newIndent;
          if (fixBy === null) {
            fixBy = itemIndent - maxIndent;
            newIndent = maxIndent;
          } else {
            if (fixBy > itemIndent) {
              fixBy = itemIndent;
            }
            newIndent = itemIndent - fixBy;
          }
          if (newIndent > prevIndent + 1) {
            newIndent = prevIndent + 1;
          }
          writer.setAttribute("listIndent", newIndent, node);
          applied = true;
          prevIndent = newIndent;
        } else {
          fixBy = null;
          maxIndent = itemIndent + 1;
          prevIndent = itemIndent;
        }
      }
      return applied;
    }
    function fixListItemIds(listNodes, seenIds, writer) {
      const visited = /* @__PURE__ */ new Set();
      let applied = false;
      for (const { node } of listNodes) {
        if (visited.has(node)) {
          continue;
        }
        let listType = node.getAttribute("listType");
        let listItemId = node.getAttribute("listItemId");
        if (seenIds.has(listItemId)) {
          listItemId = ListItemUid.next();
        }
        seenIds.add(listItemId);
        if (node.is("element", "listItem")) {
          if (node.getAttribute("listItemId") != listItemId) {
            writer.setAttribute("listItemId", listItemId, node);
            applied = true;
          }
          continue;
        }
        for (const block2 of getListItemBlocks(node, {
          direction: "forward"
        })) {
          visited.add(block2);
          if (block2.getAttribute("listType") != listType) {
            listItemId = ListItemUid.next();
            listType = block2.getAttribute("listType");
          }
          if (block2.getAttribute("listItemId") != listItemId) {
            writer.setAttribute("listItemId", listItemId, block2);
            applied = true;
          }
        }
      }
      return applied;
    }
    function listItemUpcastConverter() {
      return (evt, data, conversionApi) => {
        const { writer, schema } = conversionApi;
        if (!data.modelRange) {
          return;
        }
        const items = Array.from(data.modelRange.getItems({
          shallow: true
        })).filter((item) => schema.checkAttribute(item, "listItemId"));
        if (!items.length) {
          return;
        }
        const listItemId = ListItemUid.next();
        const listIndent = getIndent$1(data.viewItem);
        let listType = data.viewItem.parent && data.viewItem.parent.is("element", "ol") ? "numbered" : "bulleted";
        const firstItemListType = items[0].getAttribute("listType");
        if (firstItemListType) {
          listType = firstItemListType;
        }
        const attributes = {
          listItemId,
          listIndent,
          listType
        };
        for (const item of items) {
          if (!item.hasAttribute("listItemId")) {
            writer.setAttributes(attributes, item);
          }
        }
        if (items.length > 1) {
          if (items[1].getAttribute("listItemId") != attributes.listItemId) {
            conversionApi.keepEmptyElement(items[0]);
          }
        }
      };
    }
    function listUpcastCleanList() {
      return (evt, data, conversionApi) => {
        if (!conversionApi.consumable.test(data.viewItem, {
          name: true
        })) {
          return;
        }
        const viewWriter = new UpcastWriter(data.viewItem.document);
        for (const child of Array.from(data.viewItem.getChildren())) {
          if (!isListItemView(child) && !isListView(child)) {
            viewWriter.remove(child);
          }
        }
      };
    }
    function reconvertItemsOnDataChange(model, editing, attributeNames, listEditing) {
      return () => {
        const changes = model.document.differ.getChanges();
        const itemsToRefresh = [];
        const itemToListHead = /* @__PURE__ */ new Map();
        const changedItems = /* @__PURE__ */ new Set();
        for (const entry of changes) {
          if (entry.type == "insert" && entry.name != "$text") {
            findAndAddListHeadToMap(entry.position, itemToListHead);
            if (!entry.attributes.has("listItemId")) {
              findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
            } else {
              changedItems.add(entry.position.nodeAfter);
            }
          } else if (entry.type == "remove" && entry.attributes.has("listItemId")) {
            findAndAddListHeadToMap(entry.position, itemToListHead);
          } else if (entry.type == "attribute") {
            const item = entry.range.start.nodeAfter;
            if (attributeNames.includes(entry.attributeKey)) {
              findAndAddListHeadToMap(entry.range.start, itemToListHead);
              if (entry.attributeNewValue === null) {
                findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
                if (doesItemBlockRequiresRefresh(item)) {
                  itemsToRefresh.push(item);
                }
              } else {
                changedItems.add(item);
              }
            } else if (isListItemBlock(item)) {
              if (doesItemBlockRequiresRefresh(item)) {
                itemsToRefresh.push(item);
              }
            }
          }
        }
        for (const listHead of itemToListHead.values()) {
          itemsToRefresh.push(...collectListItemsToRefresh(listHead, changedItems));
        }
        for (const item of new Set(itemsToRefresh)) {
          editing.reconvertItem(item);
        }
      };
      function collectListItemsToRefresh(listHead, changedItems) {
        const itemsToRefresh = [];
        const visited = /* @__PURE__ */ new Set();
        const stack = [];
        for (const { node, previous } of iterateSiblingListBlocks(listHead, "forward")) {
          if (visited.has(node)) {
            continue;
          }
          const itemIndent = node.getAttribute("listIndent");
          if (previous && itemIndent < previous.getAttribute("listIndent")) {
            stack.length = itemIndent + 1;
          }
          stack[itemIndent] = Object.fromEntries(Array.from(node.getAttributes()).filter(([key]) => attributeNames.includes(key)));
          const blocks = getListItemBlocks(node, {
            direction: "forward"
          });
          for (const block2 of blocks) {
            visited.add(block2);
            if (doesItemBlockRequiresRefresh(block2, blocks)) {
              itemsToRefresh.push(block2);
            } else if (doesItemWrappingRequiresRefresh(block2, stack, changedItems)) {
              itemsToRefresh.push(block2);
            }
          }
        }
        return itemsToRefresh;
      }
      function doesItemBlockRequiresRefresh(item, blocks) {
        const viewElement = editing.mapper.toViewElement(item);
        if (!viewElement) {
          return false;
        }
        const needsRefresh = listEditing.fire("checkElement", {
          modelElement: item,
          viewElement
        });
        if (needsRefresh) {
          return true;
        }
        if (!item.is("element", "paragraph") && !item.is("element", "listItem")) {
          return false;
        }
        const useBogus = shouldUseBogusParagraph(item, attributeNames, blocks);
        if (useBogus && viewElement.is("element", "p")) {
          return true;
        } else if (!useBogus && viewElement.is("element", "span")) {
          return true;
        }
        return false;
      }
      function doesItemWrappingRequiresRefresh(item, stack, changedItems) {
        if (changedItems.has(item)) {
          return false;
        }
        const viewElement = editing.mapper.toViewElement(item);
        let indent2 = stack.length - 1;
        for (let element = viewElement.parent; !element.is("editableElement"); element = element.parent) {
          const isListItemElement = isListItemView(element);
          const isListElement = isListView(element);
          if (!isListElement && !isListItemElement) {
            continue;
          }
          const eventName = `checkAttributes:${isListItemElement ? "item" : "list"}`;
          const needsRefresh = listEditing.fire(eventName, {
            viewElement: element,
            modelAttributes: stack[indent2]
          });
          if (needsRefresh) {
            break;
          }
          if (isListElement) {
            indent2--;
            if (indent2 < 0) {
              return false;
            }
          }
        }
        return true;
      }
    }
    function listItemDowncastConverter(attributeNames, strategies, model, { dataPipeline } = {}) {
      const consumer = createAttributesConsumer(attributeNames);
      return (evt, data, conversionApi) => {
        const { writer, mapper, consumable } = conversionApi;
        const listItem = data.item;
        if (!attributeNames.includes(data.attributeKey)) {
          return;
        }
        if (!consumer(listItem, consumable)) {
          return;
        }
        const viewElement = findMappedViewElement(listItem, mapper, model);
        removeCustomMarkerElements(viewElement, writer, mapper);
        unwrapListItemBlock(viewElement, writer);
        const viewRange = insertCustomMarkerElements(listItem, viewElement, strategies, writer, {
          dataPipeline
        });
        wrapListItemBlock(listItem, viewRange, strategies, writer);
      };
    }
    function listItemDowncastRemoveConverter(schema) {
      return (evt, data, conversionApi) => {
        const { writer, mapper } = conversionApi;
        const elementName = evt.name.split(":")[1];
        if (!schema.checkAttribute(elementName, "listItemId")) {
          return;
        }
        const viewStart = mapper.toViewPosition(data.position);
        const modelEnd = data.position.getShiftedBy(data.length);
        const viewEnd = mapper.toViewPosition(modelEnd, {
          isPhantom: true
        });
        const viewRange = writer.createRange(viewStart, viewEnd).getTrimmed();
        const viewElement = viewRange.end.nodeBefore;
        /* istanbul ignore next -- @preserve */
        if (!viewElement) {
          return;
        }
        removeCustomMarkerElements(viewElement, writer, mapper);
      };
    }
    function bogusParagraphCreator(attributeNames, { dataPipeline } = {}) {
      return (modelElement, { writer }) => {
        if (!shouldUseBogusParagraph(modelElement, attributeNames)) {
          return null;
        }
        if (!dataPipeline) {
          return writer.createContainerElement("span", {
            class: "ck-list-bogus-paragraph"
          });
        }
        const viewElement = writer.createContainerElement("p");
        writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
        return viewElement;
      };
    }
    function findMappedViewElement(element, mapper, model) {
      const modelRange = model.createRangeOn(element);
      const viewRange = mapper.toViewRange(modelRange).getTrimmed();
      return viewRange.end.nodeBefore;
    }
    function createModelToViewPositionMapper(strategies, view) {
      return (evt, data) => {
        if (data.modelPosition.offset > 0) {
          return;
        }
        const positionParent = data.modelPosition.parent;
        if (!isListItemBlock(positionParent)) {
          return;
        }
        if (!strategies.some((strategy) => strategy.scope == "itemMarker" && strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(positionParent))) {
          return;
        }
        const viewElement = data.mapper.toViewElement(positionParent);
        const viewRange = view.createRangeIn(viewElement);
        const viewWalker = viewRange.getWalker();
        let positionAfterLastMarker = viewRange.start;
        for (const { item } of viewWalker) {
          if (item.is("element") && data.mapper.toModelElement(item) || item.is("$textProxy")) {
            break;
          }
          if (item.is("element") && item.getCustomProperty("listItemMarker")) {
            positionAfterLastMarker = view.createPositionAfter(item);
            viewWalker.skip(({ previousPosition }) => !previousPosition.isEqual(positionAfterLastMarker));
          }
        }
        data.viewPosition = positionAfterLastMarker;
      };
    }
    function removeCustomMarkerElements(viewElement, viewWriter, mapper) {
      while (viewElement.parent.is("attributeElement") && viewElement.parent.getCustomProperty("listItemWrapper")) {
        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), viewElement.parent);
      }
      const markersToRemove = [];
      collectMarkersToRemove(viewWriter.createPositionBefore(viewElement).getWalker({
        direction: "backward"
      }));
      collectMarkersToRemove(viewWriter.createRangeIn(viewElement).getWalker());
      for (const marker of markersToRemove) {
        viewWriter.remove(marker);
      }
      function collectMarkersToRemove(viewWalker) {
        for (const { item } of viewWalker) {
          if (item.is("element") && mapper.toModelElement(item)) {
            break;
          }
          if (item.is("element") && item.getCustomProperty("listItemMarker")) {
            markersToRemove.push(item);
          }
        }
      }
    }
    function insertCustomMarkerElements(listItem, viewElement, strategies, writer, { dataPipeline }) {
      let viewRange = writer.createRangeOn(viewElement);
      if (!isFirstBlockOfListItem(listItem)) {
        return viewRange;
      }
      for (const strategy of strategies) {
        if (strategy.scope != "itemMarker") {
          continue;
        }
        const markerElement = strategy.createElement(writer, listItem, {
          dataPipeline
        });
        if (!markerElement) {
          continue;
        }
        writer.setCustomProperty("listItemMarker", true, markerElement);
        if (strategy.canInjectMarkerIntoElement && strategy.canInjectMarkerIntoElement(listItem)) {
          writer.insert(writer.createPositionAt(viewElement, 0), markerElement);
        } else {
          writer.insert(viewRange.start, markerElement);
          viewRange = writer.createRange(writer.createPositionBefore(markerElement), writer.createPositionAfter(viewElement));
        }
        if (!strategy.createWrapperElement || !strategy.canWrapElement) {
          continue;
        }
        const wrapper = strategy.createWrapperElement(writer, listItem, {
          dataPipeline
        });
        writer.setCustomProperty("listItemWrapper", true, wrapper);
        if (strategy.canWrapElement(listItem)) {
          viewRange = writer.wrap(viewRange, wrapper);
        } else {
          viewRange = writer.wrap(writer.createRangeOn(markerElement), wrapper);
          viewRange = writer.createRange(viewRange.start, writer.createPositionAfter(viewElement));
        }
      }
      return viewRange;
    }
    function unwrapListItemBlock(viewElement, viewWriter) {
      let attributeElement = viewElement.parent;
      while (attributeElement.is("attributeElement") && [
        "ul",
        "ol",
        "li"
      ].includes(attributeElement.name)) {
        const parentElement = attributeElement.parent;
        viewWriter.unwrap(viewWriter.createRangeOn(viewElement), attributeElement);
        attributeElement = parentElement;
      }
    }
    function wrapListItemBlock(listItem, viewRange, strategies, writer) {
      if (!listItem.hasAttribute("listIndent")) {
        return;
      }
      const listItemIndent = listItem.getAttribute("listIndent");
      let currentListItem = listItem;
      for (let indent2 = listItemIndent; indent2 >= 0; indent2--) {
        const listItemViewElement = createListItemElement(writer, indent2, currentListItem.getAttribute("listItemId"));
        const listViewElement = createListElement(writer, indent2, currentListItem.getAttribute("listType"));
        for (const strategy of strategies) {
          if ((strategy.scope == "list" || strategy.scope == "item") && currentListItem.hasAttribute(strategy.attributeName)) {
            strategy.setAttributeOnDowncast(writer, currentListItem.getAttribute(strategy.attributeName), strategy.scope == "list" ? listViewElement : listItemViewElement);
          }
        }
        viewRange = writer.wrap(viewRange, listItemViewElement);
        viewRange = writer.wrap(viewRange, listViewElement);
        if (indent2 == 0) {
          break;
        }
        currentListItem = ListWalker.first(currentListItem, {
          lowerIndent: true
        });
        if (!currentListItem) {
          break;
        }
      }
    }
    function createAttributesConsumer(attributeNames) {
      return (node, consumable) => {
        const events = [];
        for (const attributeName of attributeNames) {
          if (node.hasAttribute(attributeName)) {
            events.push(`attribute:${attributeName}`);
          }
        }
        if (!events.every((event) => consumable.test(node, event) !== false)) {
          return false;
        }
        events.forEach((event) => consumable.consume(node, event));
        return true;
      };
    }
    function shouldUseBogusParagraph(item, attributeNames, blocks = getAllListItemBlocks(item)) {
      if (!isListItemBlock(item)) {
        return false;
      }
      for (const attributeKey of item.getAttributeKeys()) {
        if (attributeKey.startsWith("selection:")) {
          continue;
        }
        if (!attributeNames.includes(attributeKey)) {
          return false;
        }
      }
      return blocks.length < 2;
    }
    const LIST_BASE_ATTRIBUTES = [
      "listType",
      "listIndent",
      "listItemId"
    ];
    class ListEditing extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The list of registered downcast strategies.
        */
        __publicField(this, "_downcastStrategies", []);
        editor.config.define("list.multiBlock", true);
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          Enter,
          Delete,
          ListUtils,
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        const multiBlock = editor.config.get("list.multiBlock");
        if (editor.plugins.has("LegacyListEditing")) {
          throw new CKEditorError("list-feature-conflict", this, {
            conflictPlugin: "LegacyListEditing"
          });
        }
        model.schema.register("$listItem", {
          allowAttributes: LIST_BASE_ATTRIBUTES
        });
        if (multiBlock) {
          model.schema.extend("$container", {
            allowAttributesOf: "$listItem"
          });
          model.schema.extend("$block", {
            allowAttributesOf: "$listItem"
          });
          model.schema.extend("$blockObject", {
            allowAttributesOf: "$listItem"
          });
        } else {
          model.schema.register("listItem", {
            inheritAllFrom: "$block",
            allowAttributesOf: "$listItem"
          });
        }
        for (const attribute of LIST_BASE_ATTRIBUTES) {
          model.schema.setAttributeProperties(attribute, {
            copyOnReplace: true
          });
        }
        editor.commands.add("numberedList", new ListCommand(editor, "numbered"));
        editor.commands.add("bulletedList", new ListCommand(editor, "bulleted"));
        editor.commands.add("customNumberedList", new ListCommand(editor, "customNumbered", {
          multiLevel: true
        }));
        editor.commands.add("customBulletedList", new ListCommand(editor, "customBulleted", {
          multiLevel: true
        }));
        editor.commands.add("indentList", new ListIndentCommand(editor, "forward"));
        editor.commands.add("outdentList", new ListIndentCommand(editor, "backward"));
        editor.commands.add("splitListItemBefore", new ListSplitCommand(editor, "before"));
        editor.commands.add("splitListItemAfter", new ListSplitCommand(editor, "after"));
        if (multiBlock) {
          editor.commands.add("mergeListItemBackward", new ListMergeCommand(editor, "backward"));
          editor.commands.add("mergeListItemForward", new ListMergeCommand(editor, "forward"));
        }
        this._setupDeleteIntegration();
        this._setupEnterIntegration();
        this._setupTabIntegration();
        this._setupClipboardIntegration();
        this._setupAccessibilityIntegration();
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor = this.editor;
        const commands = editor.commands;
        const indent2 = commands.get("indent");
        const outdent2 = commands.get("outdent");
        if (indent2) {
          indent2.registerChildCommand(commands.get("indentList"), {
            priority: "high"
          });
        }
        if (outdent2) {
          outdent2.registerChildCommand(commands.get("outdentList"), {
            priority: "lowest"
          });
        }
        this._setupModelPostFixing();
        this._setupConversion();
      }
      /**
      * Registers a downcast strategy.
      *
      * **Note**: Strategies must be registered in the `Plugin#init()` phase so that it can be applied
      * in the `ListEditing#afterInit()`.
      *
      * @param strategy The downcast strategy to register.
      */
      registerDowncastStrategy(strategy) {
        this._downcastStrategies.push(strategy);
      }
      /**
      * Returns list of model attribute names that should affect downcast conversion.
      */
      getListAttributeNames() {
        return [
          ...LIST_BASE_ATTRIBUTES,
          ...this._downcastStrategies.map((strategy) => strategy.attributeName)
        ];
      }
      /**
      * Attaches the listener to the {@link module:engine/view/document~Document#event:delete} event and handles backspace/delete
      * keys in and around document lists.
      */
      _setupDeleteIntegration() {
        const editor = this.editor;
        const mergeBackwardCommand = editor.commands.get("mergeListItemBackward");
        const mergeForwardCommand = editor.commands.get("mergeListItemForward");
        this.listenTo(editor.editing.view.document, "delete", (evt, data) => {
          const selection = editor.model.document.selection;
          if (getSelectedBlockObject(editor.model)) {
            return;
          }
          editor.model.change(() => {
            const firstPosition = selection.getFirstPosition();
            if (selection.isCollapsed && data.direction == "backward") {
              if (!firstPosition.isAtStart) {
                return;
              }
              const positionParent = firstPosition.parent;
              if (!isListItemBlock(positionParent)) {
                return;
              }
              const previousBlock = ListWalker.first(positionParent, {
                sameAttributes: "listType",
                sameIndent: true
              });
              if (!previousBlock && positionParent.getAttribute("listIndent") === 0) {
                if (!isLastBlockOfListItem(positionParent)) {
                  editor.execute("splitListItemAfter");
                }
                editor.execute("outdentList");
              } else {
                if (!mergeBackwardCommand || !mergeBackwardCommand.isEnabled) {
                  return;
                }
                mergeBackwardCommand.execute({
                  shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, "backward")
                });
              }
              data.preventDefault();
              evt.stop();
            } else {
              if (selection.isCollapsed && !selection.getLastPosition().isAtEnd) {
                return;
              }
              if (!mergeForwardCommand || !mergeForwardCommand.isEnabled) {
                return;
              }
              mergeForwardCommand.execute({
                shouldMergeOnBlocksContentLevel: shouldMergeOnBlocksContentLevel(editor.model, "forward")
              });
              data.preventDefault();
              evt.stop();
            }
          });
        }, {
          context: "li"
        });
      }
      /**
      * Attaches a listener to the {@link module:engine/view/document~Document#event:enter} event and handles enter key press
      * in document lists.
      */
      _setupEnterIntegration() {
        const editor = this.editor;
        const model = editor.model;
        const commands = editor.commands;
        const enterCommand = commands.get("enter");
        this.listenTo(editor.editing.view.document, "enter", (evt, data) => {
          const doc = model.document;
          const positionParent = doc.selection.getFirstPosition().parent;
          if (doc.selection.isCollapsed && isListItemBlock(positionParent) && positionParent.isEmpty && !data.isSoft) {
            const isFirstBlock = isFirstBlockOfListItem(positionParent);
            const isLastBlock = isLastBlockOfListItem(positionParent);
            if (isFirstBlock && isLastBlock) {
              editor.execute("outdentList");
              data.preventDefault();
              evt.stop();
            } else if (isFirstBlock && !isLastBlock) {
              editor.execute("splitListItemAfter");
              data.preventDefault();
              evt.stop();
            } else if (isLastBlock) {
              editor.execute("splitListItemBefore");
              data.preventDefault();
              evt.stop();
            }
          }
        }, {
          context: "li"
        });
        this.listenTo(enterCommand, "afterExecute", () => {
          const splitCommand = commands.get("splitListItemBefore");
          splitCommand.refresh();
          if (!splitCommand.isEnabled) {
            return;
          }
          const doc = editor.model.document;
          const positionParent = doc.selection.getLastPosition().parent;
          const listItemBlocks = getAllListItemBlocks(positionParent);
          if (listItemBlocks.length === 2) {
            splitCommand.execute();
          }
        });
      }
      /**
      * Attaches a listener to the {@link module:engine/view/document~Document#event:tab} event and handles tab key and tab+shift keys
      * presses in document lists.
      */
      _setupTabIntegration() {
        const editor = this.editor;
        this.listenTo(editor.editing.view.document, "tab", (evt, data) => {
          const commandName = data.shiftKey ? "outdentList" : "indentList";
          const command = this.editor.commands.get(commandName);
          if (command.isEnabled) {
            editor.execute(commandName);
            data.stopPropagation();
            data.preventDefault();
            evt.stop();
          }
        }, {
          context: "li"
        });
      }
      /**
      * Registers the conversion helpers for the document-list feature.
      */
      _setupConversion() {
        const editor = this.editor;
        const model = editor.model;
        const attributeNames = this.getListAttributeNames();
        const multiBlock = editor.config.get("list.multiBlock");
        const elementName = multiBlock ? "paragraph" : "listItem";
        editor.conversion.for("upcast").elementToElement({
          view: "li",
          model: (viewElement, { writer }) => writer.createElement(elementName, {
            listType: ""
          })
        }).elementToElement({
          view: "p",
          model: (viewElement, { writer }) => {
            if (viewElement.parent && viewElement.parent.is("element", "li")) {
              return writer.createElement(elementName, {
                listType: ""
              });
            }
            return null;
          },
          converterPriority: "high"
        }).add((dispatcher) => {
          dispatcher.on("element:li", listItemUpcastConverter());
          dispatcher.on("element:ul", listUpcastCleanList(), {
            priority: "high"
          });
          dispatcher.on("element:ol", listUpcastCleanList(), {
            priority: "high"
          });
        });
        if (!multiBlock) {
          editor.conversion.for("downcast").elementToElement({
            model: "listItem",
            view: "p"
          });
        }
        editor.conversion.for("editingDowncast").elementToElement({
          model: elementName,
          view: bogusParagraphCreator(attributeNames),
          converterPriority: "high"
        }).add((dispatcher) => {
          dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model));
          dispatcher.on("remove", listItemDowncastRemoveConverter(model.schema));
        });
        editor.conversion.for("dataDowncast").elementToElement({
          model: elementName,
          view: bogusParagraphCreator(attributeNames, {
            dataPipeline: true
          }),
          converterPriority: "high"
        }).add((dispatcher) => {
          dispatcher.on("attribute", listItemDowncastConverter(attributeNames, this._downcastStrategies, model, {
            dataPipeline: true
          }));
        });
        const modelToViewPositionMapper = createModelToViewPositionMapper(this._downcastStrategies, editor.editing.view);
        editor.editing.mapper.on("modelToViewPosition", modelToViewPositionMapper);
        editor.data.mapper.on("modelToViewPosition", modelToViewPositionMapper);
        this.listenTo(model.document, "change:data", reconvertItemsOnDataChange(model, editor.editing, attributeNames, this), {
          priority: "high"
        });
        this.on("checkAttributes:item", (evt, { viewElement, modelAttributes }) => {
          if (viewElement.id != modelAttributes.listItemId) {
            evt.return = true;
            evt.stop();
          }
        });
        this.on("checkAttributes:list", (evt, { viewElement, modelAttributes }) => {
          if (viewElement.name != getViewElementNameForListType(modelAttributes.listType) || viewElement.id != getViewElementIdForListType(modelAttributes.listType, modelAttributes.listIndent)) {
            evt.return = true;
            evt.stop();
          }
        });
      }
      /**
      * Registers model post-fixers.
      */
      _setupModelPostFixing() {
        const model = this.editor.model;
        const attributeNames = this.getListAttributeNames();
        model.document.registerPostFixer((writer) => modelChangePostFixer$1(model, writer, attributeNames, this));
        this.on("postFixer", (evt, { listNodes, writer }) => {
          evt.return = fixListIndents(listNodes, writer) || evt.return;
        }, {
          priority: "high"
        });
        this.on("postFixer", (evt, { listNodes, writer, seenIds }) => {
          evt.return = fixListItemIds(listNodes, seenIds, writer) || evt.return;
        }, {
          priority: "high"
        });
      }
      /**
      * Integrates the feature with the clipboard via {@link module:engine/model/model~Model#insertContent} and
      * {@link module:engine/model/model~Model#getSelectedContent}.
      */
      _setupClipboardIntegration() {
        const model = this.editor.model;
        const clipboardPipeline = this.editor.plugins.get("ClipboardPipeline");
        this.listenTo(model, "insertContent", createModelIndentPasteFixer(model), {
          priority: "high"
        });
        this.listenTo(clipboardPipeline, "outputTransformation", (evt, data) => {
          model.change((writer) => {
            const allContentChildren = Array.from(data.content.getChildren());
            const lastItem = allContentChildren[allContentChildren.length - 1];
            if (allContentChildren.length > 1 && lastItem.is("element") && lastItem.isEmpty) {
              const contentChildrenExceptLastItem = allContentChildren.slice(0, -1);
              if (contentChildrenExceptLastItem.every(isListItemBlock)) {
                writer.remove(lastItem);
              }
            }
            if (data.method == "copy" || data.method == "cut") {
              const allChildren = Array.from(data.content.getChildren());
              const isSingleListItemSelected = isSingleListItem(allChildren);
              if (isSingleListItemSelected) {
                removeListAttributes(allChildren, writer);
              }
            }
          });
        });
      }
      /**
      * Informs editor accessibility features about keystrokes brought by the plugin.
      */
      _setupAccessibilityIntegration() {
        const editor = this.editor;
        const t = editor.t;
        editor.accessibility.addKeystrokeInfoGroup({
          id: "list",
          label: t("Keystrokes that can be used in a list"),
          keystrokes: [
            {
              label: t("Increase list item indent"),
              keystroke: "Tab"
            },
            {
              label: t("Decrease list item indent"),
              keystroke: "Shift+Tab"
            }
          ]
        });
      }
    }
    function modelChangePostFixer$1(model, writer, attributeNames, listEditing) {
      const changes = model.document.differ.getChanges();
      const itemToListHead = /* @__PURE__ */ new Map();
      const multiBlock = listEditing.editor.config.get("list.multiBlock");
      let applied = false;
      for (const entry of changes) {
        if (entry.type == "insert" && entry.name != "$text") {
          const item = entry.position.nodeAfter;
          if (!model.schema.checkAttribute(item, "listItemId")) {
            for (const attributeName of Array.from(item.getAttributeKeys())) {
              if (attributeNames.includes(attributeName)) {
                writer.removeAttribute(attributeName, item);
                applied = true;
              }
            }
          }
          findAndAddListHeadToMap(entry.position, itemToListHead);
          if (!entry.attributes.has("listItemId")) {
            findAndAddListHeadToMap(entry.position.getShiftedBy(entry.length), itemToListHead);
          }
          for (const { item: innerItem, previousPosition } of model.createRangeIn(item)) {
            if (isListItemBlock(innerItem)) {
              findAndAddListHeadToMap(previousPosition, itemToListHead);
            }
          }
        } else if (entry.type == "remove") {
          findAndAddListHeadToMap(entry.position, itemToListHead);
        } else if (entry.type == "attribute" && attributeNames.includes(entry.attributeKey)) {
          findAndAddListHeadToMap(entry.range.start, itemToListHead);
          if (entry.attributeNewValue === null) {
            findAndAddListHeadToMap(entry.range.start.getShiftedBy(1), itemToListHead);
          }
        }
        if (!multiBlock && entry.type == "attribute" && LIST_BASE_ATTRIBUTES.includes(entry.attributeKey)) {
          const element = entry.range.start.nodeAfter;
          if (entry.attributeNewValue === null && element && element.is("element", "listItem")) {
            writer.rename(element, "paragraph");
            applied = true;
          } else if (entry.attributeOldValue === null && element && element.is("element") && element.name != "listItem") {
            writer.rename(element, "listItem");
            applied = true;
          }
        }
      }
      const seenIds = /* @__PURE__ */ new Set();
      for (const listHead of itemToListHead.values()) {
        applied = listEditing.fire("postFixer", {
          listNodes: new ListBlocksIterable(listHead),
          listHead,
          writer,
          seenIds
        }) || applied;
      }
      return applied;
    }
    function createModelIndentPasteFixer(model) {
      return (evt, [content, selectable]) => {
        const items = content.is("documentFragment") ? Array.from(content.getChildren()) : [
          content
        ];
        if (!items.length) {
          return;
        }
        const selection = selectable ? model.createSelection(selectable) : model.document.selection;
        const position = selection.getFirstPosition();
        let refItem;
        if (isListItemBlock(position.parent)) {
          refItem = position.parent;
        } else if (isListItemBlock(position.nodeBefore)) {
          refItem = position.nodeBefore;
        } else {
          return;
        }
        model.change((writer) => {
          const refType = refItem.getAttribute("listType");
          const refIndent = refItem.getAttribute("listIndent");
          const firstElementIndent = items[0].getAttribute("listIndent") || 0;
          const indentDiff = Math.max(refIndent - firstElementIndent, 0);
          for (const item of items) {
            const isListItem = isListItemBlock(item);
            if (refItem.is("element", "listItem") && item.is("element", "paragraph")) {
              writer.rename(item, "listItem");
            }
            writer.setAttributes({
              listIndent: (isListItem ? item.getAttribute("listIndent") : 0) + indentDiff,
              listItemId: isListItem ? item.getAttribute("listItemId") : ListItemUid.next(),
              listType: refType
            }, item);
          }
        });
      };
    }
    function shouldMergeOnBlocksContentLevel(model, direction) {
      const selection = model.document.selection;
      if (!selection.isCollapsed) {
        return !getSelectedBlockObject(model);
      }
      if (direction === "forward") {
        return true;
      }
      const firstPosition = selection.getFirstPosition();
      const positionParent = firstPosition.parent;
      const previousSibling = positionParent.previousSibling;
      if (model.schema.isObject(previousSibling)) {
        return false;
      }
      if (previousSibling.isEmpty) {
        return true;
      }
      return isSingleListItem([
        positionParent,
        previousSibling
      ]);
    }
    function createUIComponents(editor, commandName, label, icon) {
      editor.ui.componentFactory.add(commandName, () => {
        const buttonView = _createButton(ButtonView, editor, commandName, label, icon);
        buttonView.set({
          tooltip: true,
          isToggleable: true
        });
        return buttonView;
      });
      editor.ui.componentFactory.add(`menuBar:${commandName}`, () => _createButton(MenuBarMenuListItemButtonView, editor, commandName, label, icon));
    }
    function _createButton(ButtonClass, editor, commandName, label, icon) {
      const command = editor.commands.get(commandName);
      const view = new ButtonClass(editor.locale);
      view.set({
        label,
        icon
      });
      view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
      view.on("execute", () => {
        editor.execute(commandName);
        editor.editing.view.focus();
      });
      return view;
    }
    class ListUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const t = this.editor.t;
        if (!this.editor.ui.componentFactory.has("numberedList")) {
          createUIComponents(this.editor, "numberedList", t("Numbered List"), icons.numberedList);
        }
        if (!this.editor.ui.componentFactory.has("bulletedList")) {
          createUIComponents(this.editor, "bulletedList", t("Bulleted List"), icons.bulletedList);
        }
      }
    }
    class List extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ListEditing,
          ListUI
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "List";
      }
    }
    const LIST_STYLE_TYPES = [
      {
        listStyle: "disc",
        typeAttribute: "disc",
        listType: "bulleted"
      },
      {
        listStyle: "circle",
        typeAttribute: "circle",
        listType: "bulleted"
      },
      {
        listStyle: "square",
        typeAttribute: "square",
        listType: "bulleted"
      },
      {
        listStyle: "decimal",
        typeAttribute: "1",
        listType: "numbered"
      },
      {
        listStyle: "decimal-leading-zero",
        typeAttribute: null,
        listType: "numbered"
      },
      {
        listStyle: "lower-roman",
        typeAttribute: "i",
        listType: "numbered"
      },
      {
        listStyle: "upper-roman",
        typeAttribute: "I",
        listType: "numbered"
      },
      {
        listStyle: "lower-alpha",
        typeAttribute: "a",
        listType: "numbered"
      },
      {
        listStyle: "upper-alpha",
        typeAttribute: "A",
        listType: "numbered"
      },
      {
        listStyle: "lower-latin",
        typeAttribute: "a",
        listType: "numbered"
      },
      {
        listStyle: "upper-latin",
        typeAttribute: "A",
        listType: "numbered"
      }
    ];
    for (const { listStyle, typeAttribute, listType } of LIST_STYLE_TYPES) {
    }
    function getDefaults() {
      return {
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    let defaults = getDefaults();
    function changeDefaults(newDefaults) {
      defaults = newDefaults;
    }
    const escapeTest = /[&<>"']/;
    const escapeReplace = /[&<>"']/g;
    const escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    const escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    const escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const getEscapeReplacement = (ch) => escapeReplacements[ch];
    function escape(html2, encode) {
      if (encode) {
        if (escapeTest.test(html2)) {
          return html2.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html2)) {
          return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html2;
    }
    const unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape(html2) {
      return html2.replace(unescapeTest, (_, n) => {
        n = n.toLowerCase();
        if (n === "colon") return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    const caret = /(^|[^\[])\^/g;
    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      const obj = {
        replace: (name, val) => {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: () => {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    const nonWordAndColonTest = /[^\w:]/g;
    const originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        let prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    const baseUrls = {};
    const justDomain = /^[^:]+:\/*[^/]*$/;
    const protocol = /^([^:]+:)[\s\S]*$/;
    const domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      const relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    const noopTest = { exec: function noopTest2() {
    } };
    function merge(obj) {
      let i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells(tableRow, count2) {
      const row = tableRow.replace(/\|/g, (match, offset, str) => {
        let escaped = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\") escaped = !escaped;
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      let i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (cells.length > 0 && !cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (cells.length > count2) {
        cells.splice(count2);
      } else {
        while (cells.length < count2) cells.push("");
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim(str, c, invert) {
      const l = str.length;
      if (l === 0) {
        return "";
      }
      let suffLen = 0;
      while (suffLen < l) {
        const currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l - suffLen);
    }
    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      const l = str.length;
      let level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString(pattern, count2) {
      if (count2 < 1) {
        return "";
      }
      let result = "";
      while (count2 > 1) {
        if (count2 & 1) {
          result += pattern;
        }
        count2 >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    function outputLink(cap, link2, raw, lexer) {
      const href = link2.href;
      const title = link2.title ? escape(link2.title) : null;
      const text2 = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer.state.inLink = true;
        const token = {
          type: "link",
          raw,
          href,
          title,
          text: text2,
          tokens: lexer.inlineTokens(text2, [])
        };
        lexer.state.inLink = false;
        return token;
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: escape(text2)
        };
      }
    }
    function indentCodeCompensation(raw, text2) {
      const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text2;
      }
      const indentToCode = matchIndentToCode[1];
      return text2.split("\n").map((node) => {
        const matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        const [indentInNode] = matchIndentInNode;
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    class Tokenizer {
      constructor(options) {
        this.options = options || defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text2 = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text2, "\n") : text2
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text2 = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text: text2
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text2 = cap[2].trim();
          if (/#$/.test(text2)) {
            const trimmed = rtrim(text2, "#");
            if (this.options.pedantic) {
              text2 = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text2 = trimmed.trim();
            }
          }
          const token = {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text: text2,
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text2 = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            tokens: this.lexer.blockTokens(text2, []),
            text: text2
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent2, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0];
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent2 = 2;
              itemContents = line.trimLeft();
            } else {
              indent2 = cap[2].search(/[^ ]/);
              indent2 = indent2 > 4 ? 1 : indent2;
              itemContents = line.slice(indent2);
              indent2 += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent2 - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
              while (src) {
                rawLine = src.split("\n", 1)[0];
                line = rawLine;
                if (this.options.pedantic) {
                  line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (nextBulletRegex.test(line)) {
                  break;
                }
                if (line.search(/[^ ]/) >= indent2 || !line.trim()) {
                  itemContents += "\n" + line.slice(indent2);
                } else if (!blankLine) {
                  itemContents += "\n" + line;
                } else {
                  break;
                }
                if (!blankLine && !line.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
              }
            }
            if (!list.loose) {
              if (endsWithBlankLine) {
                list.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list.raw += raw;
          }
          list.items[list.items.length - 1].raw = raw.trimRight();
          list.items[list.items.length - 1].text = itemContents.trimRight();
          list.raw = list.raw.trimRight();
          const l = list.items.length;
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
            const spacers = list.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.every((t) => {
              const chars = t.raw.split("");
              let lineBreaks = 0;
              for (const char of chars) {
                if (char === "\n") {
                  lineBreaks += 1;
                }
                if (lineBreaks > 1) {
                  return true;
                }
              }
              return false;
            });
            if (!list.loose && spacers.length && hasMultipleLineBreaks) {
              list.loose = true;
              list.items[i].loose = true;
            }
          }
          return list;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            token.type = "paragraph";
            token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            token.tokens = [];
            this.lexer.inline(token.text, token.tokens);
          }
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1]).map((c) => {
              return { text: c };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
                return { text: c };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = [];
              this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = [];
                this.lexer.inlineTokens(row[k].text, row[k].tokens);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          const token = {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const token = {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          const token = {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link2 = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link2 = links[link2.toLowerCase()];
          if (!link2 || !link2.href) {
            const text2 = cap[0].charAt(0);
            return {
              type: "text",
              raw: text2,
              text: text2
            };
          }
          return outputLink(cap, link2, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match) return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u)) return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim) continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0) continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              const text3 = src.slice(1, lLength + match.index + rLength);
              return {
                type: "em",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: text3,
                tokens: this.lexer.inlineTokens(text3, [])
              };
            }
            const text2 = src.slice(2, lLength + match.index + rLength - 1);
            return {
              type: "strong",
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: text2,
              tokens: this.lexer.inlineTokens(text2, [])
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text2 = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text2);
          const hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text2 = text2.substring(1, text2.length - 1);
          }
          text2 = escape(text2, true);
          return {
            type: "codespan",
            raw: cap[0],
            text: text2
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2], [])
          };
        }
      }
      autolink(src, mangle2) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text2, href;
          if (cap[2] === "@") {
            text2 = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text2;
          } else {
            text2 = escape(cap[1]);
            href = text2;
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [
              {
                type: "text",
                raw: text2,
                text: text2
              }
            ]
          };
        }
      }
      url(src, mangle2) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text2, href;
          if (cap[2] === "@") {
            text2 = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text2;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text2 = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text2;
            } else {
              href = text2;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [
              {
                type: "text",
                raw: text2,
                text: text2
              }
            ]
          };
        }
      }
      inlineText(src, smartypants2) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text2;
          if (this.lexer.state.inRawBlock) {
            text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text2 = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text: text2
          };
        }
      }
    }
    const block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
      // Cells
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit(
        `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
      ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      // fences not supported
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    const inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
        //        () Skip orphan delim inside strong    (1) #***                (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
        // ^- Not allowed for _
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /\\\*|\\_/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    function smartypants(text2) {
      return text2.replace(/---/g, "—").replace(/--/g, "–").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘").replace(/'/g, "’").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“").replace(/"/g, "”").replace(/\.{3}/g, "…");
    }
    function mangle(text2) {
      let out = "", i, ch;
      const l = text2.length;
      for (i = 0; i < l; i++) {
        ch = text2.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    class Lexer {
      constructor(options) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block,
          inline
        };
      }
      /**
       * Static Lex Method
       */
      static lex(src, options) {
        const lexer = new Lexer(options);
        return lexer.lex(src);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(src, options) {
        const lexer = new Lexer(options);
        return lexer.inlineTokens(src);
      }
      /**
       * Preprocessing
       */
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      /**
       * Lexing
       */
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, "");
        }
        let token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens) {
        this.inlineQueue.push({ src, tokens });
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    }
    class Renderer {
      constructor(options) {
        this.options = options || defaults;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote2) {
        return "<blockquote>\n" + quote2 + "</blockquote>\n";
      }
      html(html2) {
        return html2;
      }
      heading(text2, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text2 + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text2 + "</h" + level + ">\n";
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text2) {
        return "<li>" + text2 + "</li>\n";
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text2) {
        return "<p>" + text2 + "</p>\n";
      }
      table(header, body) {
        if (body) body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }
      // span level renderer
      strong(text2) {
        return "<strong>" + text2 + "</strong>";
      }
      em(text2) {
        return "<em>" + text2 + "</em>";
      }
      codespan(text2) {
        return "<code>" + text2 + "</code>";
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text2) {
        return "<del>" + text2 + "</del>";
      }
      link(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        let out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text2 + "</a>";
        return out;
      }
      image(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        let out = '<img src="' + href + '" alt="' + text2 + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text2) {
        return text2;
      }
    }
    class TextRenderer {
      // no need for block level renderers
      strong(text2) {
        return text2;
      }
      em(text2) {
        return text2;
      }
      codespan(text2) {
        return text2;
      }
      del(text2) {
        return text2;
      }
      html(text2) {
        return text2;
      }
      text(text2) {
        return text2;
      }
      link(href, title, text2) {
        return "" + text2;
      }
      image(href, title, text2) {
        return "" + text2;
      }
      br() {
        return "";
      }
    }
    class Slugger {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      /**
       * Finds the next safe (unique) slug to use
       */
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      /**
       * Convert string to unique id
       * @param {object} options
       * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
       */
      slug(value, options = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options.dryrun);
      }
    }
    class Parser {
      constructor(options) {
        this.options = options || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      /**
       * Static Parse Method
       */
      static parse(tokens, options) {
        const parser = new Parser(options);
        return parser.parse(tokens);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(tokens, options) {
        const parser = new Parser(options);
        return parser.parseInline(tokens);
      }
      /**
       * Parse Loop
       */
      parse(tokens, top = true) {
        let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(
                this.parseInline(token.tokens),
                token.depth,
                unescape(this.parseInline(token.tokens, this.textRenderer)),
                this.slugger
              );
              continue;
            }
            case "code": {
              out += this.renderer.code(
                token.text,
                token.lang,
                token.escaped
              );
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(
                  this.parseInline(token.header[j].tokens),
                  { header: true, align: token.align[j] }
                );
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(
                    this.parseInline(row[k].tokens),
                    { header: false, align: token.align[k] }
                  );
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i, token, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    }
    function marked(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        const done = function(err) {
          let out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length) return done();
        let pending = 0;
        marked.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      try {
        const tokens = Lexer.lex(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parse(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    }
    marked.options = marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = getDefaults;
    marked.defaults = defaults;
    marked.use = function(...args) {
      const opts = merge({}, ...args);
      const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
      let hasExtensions;
      args.forEach((pack) => {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          const renderer = marked.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret = pack.renderer[prop].apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.walkTokens) {
          const walkTokens = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            pack.walkTokens.call(this, token);
            if (walkTokens) {
              walkTokens.call(this, token);
            }
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked.setOptions(opts);
      });
    };
    marked.walkTokens = function(tokens, callback) {
      for (const token of tokens) {
        callback.call(marked, token);
        switch (token.type) {
          case "table": {
            for (const cell of token.header) {
              marked.walkTokens(cell.tokens, callback);
            }
            for (const row of token.rows) {
              for (const cell of row) {
                marked.walkTokens(cell.tokens, callback);
              }
            }
            break;
          }
          case "list": {
            marked.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                marked.walkTokens(token[childTokens], callback);
              });
            } else if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.parse = marked;
    marked.options;
    marked.setOptions;
    marked.use;
    marked.walkTokens;
    marked.parseInline;
    Parser.parse;
    Lexer.lex;
    var root = typeof window !== "undefined" ? window : {};
    function canParseHTMLNatively() {
      var Parser2 = root.DOMParser;
      var canParse = false;
      try {
        if (new Parser2().parseFromString("", "text/html")) {
          canParse = true;
        }
      } catch (e) {
      }
      return canParse;
    }
    function createHTMLParser() {
      var Parser2 = function() {
      };
      {
        if (shouldUseActiveX()) {
          Parser2.prototype.parseFromString = function(string) {
            var doc = new window.ActiveXObject("htmlfile");
            doc.designMode = "on";
            doc.open();
            doc.write(string);
            doc.close();
            return doc;
          };
        } else {
          Parser2.prototype.parseFromString = function(string) {
            var doc = document.implementation.createHTMLDocument("");
            doc.open();
            doc.write(string);
            doc.close();
            return doc;
          };
        }
      }
      return Parser2;
    }
    function shouldUseActiveX() {
      var useActiveX = false;
      try {
        document.implementation.createHTMLDocument("").open();
      } catch (e) {
        if (root.ActiveXObject) useActiveX = true;
      }
      return useActiveX;
    }
    canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    [
      keyCodes.arrowup,
      keyCodes.arrowdown,
      keyCodes.esc
    ];
    [
      keyCodes.enter,
      keyCodes.tab
    ];
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function convertCssLengthToPx(value) {
      const numericValue = parseFloat(value);
      if (value.endsWith("pt")) {
        return toPx(numericValue * 96 / 72);
      } else if (value.endsWith("pc")) {
        return toPx(numericValue * 12 * 96 / 72);
      } else if (value.endsWith("in")) {
        return toPx(numericValue * 96);
      } else if (value.endsWith("cm")) {
        return toPx(numericValue * 96 / 2.54);
      } else if (value.endsWith("mm")) {
        return toPx(numericValue / 10 * 96 / 2.54);
      }
      return value;
    }
    function isPx(value) {
      return value !== void 0 && value.endsWith("px");
    }
    function toPx(value) {
      return value.toFixed(2).replace(/\.?0+$/, "") + "px";
    }
    function transformListItemLikeElementsIntoLists(documentFragment, stylesString, hasMultiLevelListPlugin) {
      if (!documentFragment.childCount) {
        return;
      }
      const writer = new UpcastWriter(documentFragment.document);
      const itemLikeElements = findAllItemLikeElements(documentFragment, writer);
      if (!itemLikeElements.length) {
        return;
      }
      const encounteredLists = {};
      const stack = [];
      for (const itemLikeElement of itemLikeElements) {
        if (itemLikeElement.indent !== void 0) {
          if (!isListContinuation(itemLikeElement)) {
            stack.length = 0;
          }
          const originalListId = `${itemLikeElement.id}:${itemLikeElement.indent}`;
          const indent2 = Math.min(itemLikeElement.indent - 1, stack.length);
          if (indent2 < stack.length && stack[indent2].id !== itemLikeElement.id) {
            stack.length = indent2;
          }
          if (indent2 < stack.length - 1) {
            stack.length = indent2 + 1;
          } else {
            const listStyle = detectListStyle(itemLikeElement, stylesString);
            if (indent2 > stack.length - 1 || stack[indent2].listElement.name != listStyle.type) {
              if (indent2 == 0 && listStyle.type == "ol" && itemLikeElement.id !== void 0 && encounteredLists[originalListId]) {
                listStyle.startIndex = encounteredLists[originalListId];
              }
              const listElement = createNewEmptyList(listStyle, writer, hasMultiLevelListPlugin);
              if (isPx(itemLikeElement.marginLeft) && (indent2 == 0 || isPx(stack[indent2 - 1].marginLeft))) {
                let marginLeft = itemLikeElement.marginLeft;
                if (indent2 > 0) {
                  marginLeft = toPx(parseFloat(marginLeft) - parseFloat(stack[indent2 - 1].marginLeft));
                }
                writer.setStyle("padding-left", marginLeft, listElement);
              }
              if (stack.length == 0) {
                const parent2 = itemLikeElement.element.parent;
                const index2 = parent2.getChildIndex(itemLikeElement.element) + 1;
                writer.insertChild(index2, listElement, parent2);
              } else {
                const parentListItems = stack[indent2 - 1].listItemElements;
                writer.appendChild(listElement, parentListItems[parentListItems.length - 1]);
              }
              stack[indent2] = {
                ...itemLikeElement,
                listElement,
                listItemElements: []
              };
              if (indent2 == 0 && itemLikeElement.id !== void 0) {
                encounteredLists[originalListId] = listStyle.startIndex || 1;
              }
            }
          }
          const listItem = itemLikeElement.element.name == "li" ? itemLikeElement.element : writer.createElement("li");
          writer.appendChild(listItem, stack[indent2].listElement);
          stack[indent2].listItemElements.push(listItem);
          if (indent2 == 0 && itemLikeElement.id !== void 0) {
            encounteredLists[originalListId]++;
          }
          if (itemLikeElement.element != listItem) {
            writer.appendChild(itemLikeElement.element, listItem);
          }
          removeBulletElement(itemLikeElement.element, writer);
          writer.removeStyle("text-indent", itemLikeElement.element);
          writer.removeStyle("margin-left", itemLikeElement.element);
        } else {
          const stackItem = stack.find((stackItem2) => stackItem2.marginLeft == itemLikeElement.marginLeft);
          if (stackItem) {
            const listItems = stackItem.listItemElements;
            writer.appendChild(itemLikeElement.element, listItems[listItems.length - 1]);
            writer.removeStyle("margin-left", itemLikeElement.element);
          } else {
            stack.length = 0;
          }
        }
      }
    }
    function unwrapParagraphInListItem(documentFragment, writer) {
      for (const value of writer.createRangeIn(documentFragment)) {
        const element = value.item;
        if (element.is("element", "li")) {
          const firstChild = element.getChild(0);
          if (firstChild && firstChild.is("element", "p")) {
            writer.unwrapElement(firstChild);
          }
        }
      }
    }
    function findAllItemLikeElements(documentFragment, writer) {
      const range = writer.createRangeIn(documentFragment);
      const itemLikeElements = [];
      const foundMargins = /* @__PURE__ */ new Set();
      for (const item of range.getItems()) {
        if (!item.is("element") || !item.name.match(/^(p|h\d+|li|div)$/)) {
          continue;
        }
        let marginLeft = getMarginLeftNormalized(item);
        if (marginLeft !== void 0 && parseFloat(marginLeft) == 0 && !Array.from(item.getClassNames()).find((className) => className.startsWith("MsoList"))) {
          marginLeft = void 0;
        }
        if (item.hasStyle("mso-list") || marginLeft !== void 0 && foundMargins.has(marginLeft)) {
          const itemData = getListItemData(item);
          itemLikeElements.push({
            element: item,
            id: itemData.id,
            order: itemData.order,
            indent: itemData.indent,
            marginLeft
          });
          if (marginLeft !== void 0) {
            foundMargins.add(marginLeft);
          }
        } else {
          foundMargins.clear();
        }
      }
      return itemLikeElements;
    }
    function isListContinuation(currentItem) {
      const previousSibling = currentItem.element.previousSibling;
      if (!previousSibling) {
        return isList(currentItem.element.parent);
      }
      return isList(previousSibling);
    }
    function isList(element) {
      return element.is("element", "ol") || element.is("element", "ul");
    }
    function detectListStyle(listLikeItem, stylesString) {
      const listStyleRegexp = new RegExp(`@list l${listLikeItem.id}:level${listLikeItem.indent}\\s*({[^}]*)`, "gi");
      const listStyleTypeRegex = /mso-level-number-format:([^;]{0,100});/gi;
      const listStartIndexRegex = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi;
      const legalStyleListRegex = new RegExp(`@list\\s+l${listLikeItem.id}:level\\d\\s*{[^{]*mso-level-text:"%\\d\\\\.`, "gi");
      const multiLevelNumberFormatTypeRegex = new RegExp(`@list l${listLikeItem.id}:level\\d\\s*{[^{]*mso-level-number-format:`, "gi");
      const legalStyleListMatch = legalStyleListRegex.exec(stylesString);
      const multiLevelNumberFormatMatch = multiLevelNumberFormatTypeRegex.exec(stylesString);
      const islegalStyleList = legalStyleListMatch && !multiLevelNumberFormatMatch;
      const listStyleMatch = listStyleRegexp.exec(stylesString);
      let listStyleType = "decimal";
      let type = "ol";
      let startIndex = null;
      if (listStyleMatch && listStyleMatch[1]) {
        const listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);
        if (listStyleTypeMatch && listStyleTypeMatch[1]) {
          listStyleType = listStyleTypeMatch[1].trim();
          type = listStyleType !== "bullet" && listStyleType !== "image" ? "ol" : "ul";
        }
        if (listStyleType === "bullet") {
          const bulletedStyle = findBulletedListStyle(listLikeItem.element);
          if (bulletedStyle) {
            listStyleType = bulletedStyle;
          }
        } else {
          const listStartIndexMatch = listStartIndexRegex.exec(listStyleMatch[1]);
          if (listStartIndexMatch && listStartIndexMatch[1]) {
            startIndex = parseInt(listStartIndexMatch[1]);
          }
        }
        if (islegalStyleList) {
          type = "ol";
        }
      }
      return {
        type,
        startIndex,
        style: mapListStyleDefinition(listStyleType),
        isLegalStyleList: islegalStyleList
      };
    }
    function findBulletedListStyle(element) {
      if (element.name == "li" && element.parent.name == "ul" && element.parent.hasAttribute("type")) {
        return element.parent.getAttribute("type");
      }
      const listMarkerElement = findListMarkerNode(element);
      if (!listMarkerElement) {
        return null;
      }
      const listMarker = listMarkerElement._data;
      if (listMarker === "o") {
        return "circle";
      } else if (listMarker === "·") {
        return "disc";
      } else if (listMarker === "§") {
        return "square";
      }
      return null;
    }
    function findListMarkerNode(element) {
      if (element.getChild(0).is("$text")) {
        return null;
      }
      for (const childNode of element.getChildren()) {
        if (!childNode.is("element", "span")) {
          continue;
        }
        const textNodeOrElement = childNode.getChild(0);
        if (!textNodeOrElement) {
          continue;
        }
        if (textNodeOrElement.is("$text")) {
          return textNodeOrElement;
        }
        return textNodeOrElement.getChild(0);
      }
      /* istanbul ignore next -- @preserve */
      return null;
    }
    function mapListStyleDefinition(value) {
      if (value.startsWith("arabic-leading-zero")) {
        return "decimal-leading-zero";
      }
      switch (value) {
        case "alpha-upper":
          return "upper-alpha";
        case "alpha-lower":
          return "lower-alpha";
        case "roman-upper":
          return "upper-roman";
        case "roman-lower":
          return "lower-roman";
        case "circle":
        case "disc":
        case "square":
          return value;
        default:
          return null;
      }
    }
    function createNewEmptyList(listStyle, writer, hasMultiLevelListPlugin) {
      const list = writer.createElement(listStyle.type);
      if (listStyle.style) {
        writer.setStyle("list-style-type", listStyle.style, list);
      }
      if (listStyle.startIndex && listStyle.startIndex > 1) {
        writer.setAttribute("start", listStyle.startIndex, list);
      }
      if (listStyle.isLegalStyleList && hasMultiLevelListPlugin) {
        writer.addClass("legal-list", list);
      }
      return list;
    }
    function getListItemData(element) {
      const listStyle = element.getStyle("mso-list");
      if (listStyle === void 0) {
        return {};
      }
      const idMatch = listStyle.match(/(^|\s{1,100})l(\d+)/i);
      const orderMatch = listStyle.match(/\s{0,100}lfo(\d+)/i);
      const indentMatch = listStyle.match(/\s{0,100}level(\d+)/i);
      if (idMatch && orderMatch && indentMatch) {
        return {
          id: idMatch[2],
          order: orderMatch[1],
          indent: parseInt(indentMatch[1])
        };
      }
      return {
        indent: 1
        // Handle empty mso-list style as a marked for default list item.
      };
    }
    function removeBulletElement(element, writer) {
      const bulletMatcher = new Matcher({
        name: "span",
        styles: {
          "mso-list": "Ignore"
        }
      });
      const range = writer.createRangeIn(element);
      for (const value of range) {
        if (value.type === "elementStart" && bulletMatcher.match(value.item)) {
          writer.remove(value.item);
        }
      }
    }
    function getMarginLeftNormalized(element) {
      const value = element.getStyle("margin-left");
      if (value === void 0 || value.endsWith("px")) {
        return value;
      }
      return convertCssLengthToPx(value);
    }
    function replaceImagesSourceWithBase64(documentFragment, rtfData) {
      if (!documentFragment.childCount) {
        return;
      }
      const upcastWriter = new UpcastWriter(documentFragment.document);
      const shapesIds = findAllShapesIds(documentFragment, upcastWriter);
      removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);
      insertMissingImgs(shapesIds, documentFragment, upcastWriter);
      removeAllShapeElements(documentFragment, upcastWriter);
      const images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);
      if (images.length) {
        replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);
      }
    }
    function _convertHexToBase64(hexString) {
      return btoa(hexString.match(/\w{2}/g).map((char) => {
        return String.fromCharCode(parseInt(char, 16));
      }).join(""));
    }
    function findAllShapesIds(documentFragment, writer) {
      const range = writer.createRangeIn(documentFragment);
      const shapeElementsMatcher = new Matcher({
        name: /v:(.+)/
      });
      const shapesIds = [];
      for (const value of range) {
        if (value.type != "elementStart") {
          continue;
        }
        const el = value.item;
        const previousSibling = el.previousSibling;
        const prevSiblingName = previousSibling && previousSibling.is("element") ? previousSibling.name : null;
        const exceptionIds = [
          "Chart"
        ];
        const isElementAShape = shapeElementsMatcher.match(el);
        const hasElementGfxdataAttribute = el.getAttribute("o:gfxdata");
        const isPreviousSiblingAShapeType = prevSiblingName === "v:shapetype";
        const isElementIdInExceptionsArray = hasElementGfxdataAttribute && exceptionIds.some((item) => el.getAttribute("id").includes(item));
        if (isElementAShape && hasElementGfxdataAttribute && !isPreviousSiblingAShapeType && !isElementIdInExceptionsArray) {
          shapesIds.push(value.item.getAttribute("id"));
        }
      }
      return shapesIds;
    }
    function removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {
      const range = writer.createRangeIn(documentFragment);
      const imageElementsMatcher = new Matcher({
        name: "img"
      });
      const imgs = [];
      for (const value of range) {
        if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
          const el = value.item;
          const shapes = el.getAttribute("v:shapes") ? el.getAttribute("v:shapes").split(" ") : [];
          if (shapes.length && shapes.every((shape) => shapesIds.indexOf(shape) > -1)) {
            imgs.push(el);
          } else if (!el.getAttribute("src")) {
            imgs.push(el);
          }
        }
      }
      for (const img of imgs) {
        writer.remove(img);
      }
    }
    function removeAllShapeElements(documentFragment, writer) {
      const range = writer.createRangeIn(documentFragment);
      const shapeElementsMatcher = new Matcher({
        name: /v:(.+)/
      });
      const shapes = [];
      for (const value of range) {
        if (value.type == "elementStart" && shapeElementsMatcher.match(value.item)) {
          shapes.push(value.item);
        }
      }
      for (const shape of shapes) {
        writer.remove(shape);
      }
    }
    function insertMissingImgs(shapeIds, documentFragment, writer) {
      const range = writer.createRangeIn(documentFragment);
      const shapes = [];
      for (const value of range) {
        if (value.type == "elementStart" && value.item.is("element", "v:shape")) {
          const id = value.item.getAttribute("id");
          if (shapeIds.includes(id)) {
            continue;
          }
          if (!containsMatchingImg(value.item.parent.getChildren(), id)) {
            shapes.push(value.item);
          }
        }
      }
      for (const shape of shapes) {
        const attrs = {
          src: findSrc(shape)
        };
        if (shape.hasAttribute("alt")) {
          attrs.alt = shape.getAttribute("alt");
        }
        const img = writer.createElement("img", attrs);
        writer.insertChild(shape.index + 1, img, shape.parent);
      }
      function containsMatchingImg(nodes, id) {
        for (const node of nodes) {
          /* istanbul ignore else -- @preserve */
          if (node.is("element")) {
            if (node.name == "img" && node.getAttribute("v:shapes") == id) {
              return true;
            }
            if (containsMatchingImg(node.getChildren(), id)) {
              return true;
            }
          }
        }
        return false;
      }
      function findSrc(shape) {
        for (const child of shape.getChildren()) {
          /* istanbul ignore else -- @preserve */
          if (child.is("element") && child.getAttribute("src")) {
            return child.getAttribute("src");
          }
        }
      }
    }
    function findAllImageElementsWithLocalSource(documentFragment, writer) {
      const range = writer.createRangeIn(documentFragment);
      const imageElementsMatcher = new Matcher({
        name: "img"
      });
      const imgs = [];
      for (const value of range) {
        if (value.item.is("element") && imageElementsMatcher.match(value.item)) {
          if (value.item.getAttribute("src").startsWith("file://")) {
            imgs.push(value.item);
          }
        }
      }
      return imgs;
    }
    function extractImageDataFromRtf(rtfData) {
      if (!rtfData) {
        return [];
      }
      const regexPictureHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
      const regexPicture = new RegExp("(?:(" + regexPictureHeader.source + "))([\\da-fA-F\\s]+)\\}", "g");
      const images = rtfData.match(regexPicture);
      const result = [];
      if (images) {
        for (const image2 of images) {
          let imageType = false;
          if (image2.includes("\\pngblip")) {
            imageType = "image/png";
          } else if (image2.includes("\\jpegblip")) {
            imageType = "image/jpeg";
          }
          if (imageType) {
            result.push({
              hex: image2.replace(regexPictureHeader, "").replace(/[^\da-fA-F]/g, ""),
              type: imageType
            });
          }
        }
      }
      return result;
    }
    function replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {
      if (imageElements.length === imagesHexSources.length) {
        for (let i = 0; i < imageElements.length; i++) {
          const newSrc = `data:${imagesHexSources[i].type};base64,${_convertHexToBase64(imagesHexSources[i].hex)}`;
          writer.setAttribute("src", newSrc, imageElements[i]);
        }
      }
    }
    function removeMSAttributes(documentFragment) {
      const elementsToUnwrap = [];
      const writer = new UpcastWriter(documentFragment.document);
      for (const { item } of writer.createRangeIn(documentFragment)) {
        if (!item.is("element")) {
          continue;
        }
        for (const className of item.getClassNames()) {
          if (/\bmso/gi.exec(className)) {
            writer.removeClass(className, item);
          }
        }
        for (const styleName of item.getStyleNames()) {
          if (/\bmso/gi.exec(styleName)) {
            writer.removeStyle(styleName, item);
          }
        }
        if (item.is("element", "w:sdt") || item.is("element", "w:sdtpr") && item.isEmpty || item.is("element", "o:p") && item.isEmpty) {
          elementsToUnwrap.push(item);
        }
      }
      for (const item of elementsToUnwrap) {
        const itemParent = item.parent;
        const childIndex = itemParent.getChildIndex(item);
        writer.insertChild(childIndex, item.getChildren(), itemParent);
        writer.remove(item);
      }
    }
    const msWordMatch1 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
    const msWordMatch2 = /xmlns:o="urn:schemas-microsoft-com/i;
    class MSWordNormalizer {
      /**
      * Creates a new `MSWordNormalizer` instance.
      *
      * @param document View document.
      */
      constructor(document2, hasMultiLevelListPlugin = false) {
        __publicField(this, "document");
        __publicField(this, "hasMultiLevelListPlugin");
        this.document = document2;
        this.hasMultiLevelListPlugin = hasMultiLevelListPlugin;
      }
      /**
      * @inheritDoc
      */
      isActive(htmlString) {
        return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);
      }
      /**
      * @inheritDoc
      */
      execute(data) {
        const { body: documentFragment, stylesString } = data._parsedData;
        transformListItemLikeElementsIntoLists(documentFragment, stylesString, this.hasMultiLevelListPlugin);
        replaceImagesSourceWithBase64(documentFragment, data.dataTransfer.getData("text/rtf"));
        removeMSAttributes(documentFragment);
        data.content = documentFragment;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function removeBoldWrapper(documentFragment, writer) {
      for (const child of documentFragment.getChildren()) {
        if (child.is("element", "b") && child.getStyle("font-weight") === "normal") {
          const childIndex = documentFragment.getChildIndex(child);
          writer.remove(child);
          writer.insertChild(childIndex, child.getChildren(), documentFragment);
        }
      }
    }
    function transformBlockBrsToParagraphs(documentFragment, writer) {
      const viewDocument = new Document$1(writer.document.stylesProcessor);
      const domConverter = new DomConverter(viewDocument, {
        renderingMode: "data"
      });
      const blockElements = domConverter.blockElements;
      const inlineObjectElements = domConverter.inlineObjectElements;
      const elementsToReplace = [];
      for (const value of writer.createRangeIn(documentFragment)) {
        const element = value.item;
        if (element.is("element", "br")) {
          const nextSibling = findSibling(element, "forward", writer, {
            blockElements,
            inlineObjectElements
          });
          const previousSibling = findSibling(element, "backward", writer, {
            blockElements,
            inlineObjectElements
          });
          const nextSiblingIsBlock = isBlockViewElement(nextSibling, blockElements);
          const previousSiblingIsBlock = isBlockViewElement(previousSibling, blockElements);
          if (previousSiblingIsBlock || nextSiblingIsBlock) {
            elementsToReplace.push(element);
          }
        }
      }
      for (const element of elementsToReplace) {
        if (element.hasClass("Apple-interchange-newline")) {
          writer.remove(element);
        } else {
          writer.replace(element, writer.createElement("p"));
        }
      }
    }
    function findSibling(viewElement, direction, writer, { blockElements, inlineObjectElements }) {
      let position = writer.createPositionAt(viewElement, direction == "forward" ? "after" : "before");
      position = position.getLastMatchingPosition(({ item }) => item.is("element") && !blockElements.includes(item.name) && !inlineObjectElements.includes(item.name), {
        direction
      });
      return direction == "forward" ? position.nodeAfter : position.nodeBefore;
    }
    function isBlockViewElement(node, blockElements) {
      return !!node && node.is("element") && blockElements.includes(node.name);
    }
    const googleDocsMatch = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
    class GoogleDocsNormalizer {
      /**
      * Creates a new `GoogleDocsNormalizer` instance.
      *
      * @param document View document.
      */
      constructor(document2) {
        __publicField(this, "document");
        this.document = document2;
      }
      /**
      * @inheritDoc
      */
      isActive(htmlString) {
        return googleDocsMatch.test(htmlString);
      }
      /**
      * @inheritDoc
      */
      execute(data) {
        const writer = new UpcastWriter(this.document);
        const { body: documentFragment } = data._parsedData;
        removeBoldWrapper(documentFragment, writer);
        unwrapParagraphInListItem(documentFragment, writer);
        transformBlockBrsToParagraphs(documentFragment, writer);
        data.content = documentFragment;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function removeXmlns(documentFragment, writer) {
      for (const child of documentFragment.getChildren()) {
        if (child.is("element", "table") && child.hasAttribute("xmlns")) {
          writer.removeAttribute("xmlns", child);
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function removeGoogleSheetsTag(documentFragment, writer) {
      for (const child of documentFragment.getChildren()) {
        if (child.is("element", "google-sheets-html-origin")) {
          const childIndex = documentFragment.getChildIndex(child);
          writer.remove(child);
          writer.insertChild(childIndex, child.getChildren(), documentFragment);
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function removeInvalidTableWidth(documentFragment, writer) {
      for (const child of documentFragment.getChildren()) {
        if (child.is("element", "table") && child.getStyle("width") === "0px") {
          writer.removeStyle("width", child);
        }
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function removeStyleBlock(documentFragment, writer) {
      for (const child of Array.from(documentFragment.getChildren())) {
        if (child.is("element", "style")) {
          writer.remove(child);
        }
      }
    }
    const googleSheetsMatch = /<google-sheets-html-origin/i;
    class GoogleSheetsNormalizer {
      /**
      * Creates a new `GoogleSheetsNormalizer` instance.
      *
      * @param document View document.
      */
      constructor(document2) {
        __publicField(this, "document");
        this.document = document2;
      }
      /**
      * @inheritDoc
      */
      isActive(htmlString) {
        return googleSheetsMatch.test(htmlString);
      }
      /**
      * @inheritDoc
      */
      execute(data) {
        const writer = new UpcastWriter(this.document);
        const { body: documentFragment } = data._parsedData;
        removeGoogleSheetsTag(documentFragment, writer);
        removeXmlns(documentFragment, writer);
        removeInvalidTableWidth(documentFragment, writer);
        removeStyleBlock(documentFragment, writer);
        data.content = documentFragment;
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function normalizeSpacing(htmlString) {
      return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
    }
    function normalizeSpacerunSpans(htmlDocument) {
      htmlDocument.querySelectorAll("span[style*=spacerun]").forEach((el) => {
        const htmlElement = el;
        const innerTextLength = htmlElement.innerText.length || 0;
        htmlElement.innerText = Array(innerTextLength + 1).join("  ").substr(0, innerTextLength);
      });
    }
    function normalizeSafariSpaceSpans(htmlString) {
      return htmlString.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (fullMatch, spaces) => {
        return spaces.length === 1 ? " " : Array(spaces.length + 1).join("  ").substr(0, spaces.length);
      });
    }
    function parseHtml(htmlString, stylesProcessor) {
      const domParser = new DOMParser();
      htmlString = htmlString.replace(/<!--\[if gte vml 1]>/g, "");
      htmlString = htmlString.replace(/<o:SmartTagType(?:\s+[^\s>=]+(?:="[^"]*")?)*\s*\/?>/gi, "");
      const normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString));
      const htmlDocument = domParser.parseFromString(normalizedHtml, "text/html");
      normalizeSpacerunSpans(htmlDocument);
      const bodyString = htmlDocument.body.innerHTML;
      const bodyView = documentToView(htmlDocument, stylesProcessor);
      const stylesObject = extractStyles(htmlDocument);
      return {
        body: bodyView,
        bodyString,
        styles: stylesObject.styles,
        stylesString: stylesObject.stylesString
      };
    }
    function documentToView(htmlDocument, stylesProcessor) {
      const viewDocument = new Document$1(stylesProcessor);
      const domConverter = new DomConverter(viewDocument, {
        renderingMode: "data"
      });
      const fragment = htmlDocument.createDocumentFragment();
      const nodes = htmlDocument.body.childNodes;
      while (nodes.length > 0) {
        fragment.appendChild(nodes[0]);
      }
      return domConverter.domToView(fragment, {
        skipComments: true
      });
    }
    function extractStyles(htmlDocument) {
      const styles = [];
      const stylesString = [];
      const styleTags = Array.from(htmlDocument.getElementsByTagName("style"));
      for (const style of styleTags) {
        if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {
          styles.push(style.sheet);
          stylesString.push(style.innerHTML);
        }
      }
      return {
        styles,
        stylesString: stylesString.join(" ")
      };
    }
    function cleanContentAfterBody(htmlString) {
      const bodyCloseTag = "</body>";
      const htmlCloseTag = "</html>";
      const bodyCloseIndex = htmlString.indexOf(bodyCloseTag);
      if (bodyCloseIndex < 0) {
        return htmlString;
      }
      const htmlCloseIndex = htmlString.indexOf(htmlCloseTag, bodyCloseIndex + bodyCloseTag.length);
      return htmlString.substring(0, bodyCloseIndex + bodyCloseTag.length) + (htmlCloseIndex >= 0 ? htmlString.substring(htmlCloseIndex) : "");
    }
    class PasteFromOffice extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "PasteFromOffice";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardPipeline
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const clipboardPipeline = editor.plugins.get("ClipboardPipeline");
        const viewDocument = editor.editing.view.document;
        const normalizers = [];
        const hasMultiLevelListPlugin = this.editor.plugins.has("MultiLevelList");
        normalizers.push(new MSWordNormalizer(viewDocument, hasMultiLevelListPlugin));
        normalizers.push(new GoogleDocsNormalizer(viewDocument));
        normalizers.push(new GoogleSheetsNormalizer(viewDocument));
        clipboardPipeline.on("inputTransformation", (evt, data) => {
          if (data._isTransformedWithPasteFromOffice) {
            return;
          }
          const codeBlock2 = editor.model.document.selection.getFirstPosition().parent;
          if (codeBlock2.is("element", "codeBlock")) {
            return;
          }
          const htmlString = data.dataTransfer.getData("text/html");
          const activeNormalizer = normalizers.find((normalizer) => normalizer.isActive(htmlString));
          if (activeNormalizer) {
            if (!data._parsedData) {
              data._parsedData = parseHtml(htmlString, viewDocument.stylesProcessor);
            }
            activeNormalizer.execute(data);
            data._isTransformedWithPasteFromOffice = true;
          }
        }, {
          priority: "high"
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class StyleGridButtonView extends ButtonView {
      /**
      * Creates an instance of the {@link module:style/ui/stylegridbuttonview~StyleGridButtonView} class.
      *
      * @param locale The localization services instance.
      * @param styleDefinition Definition of the style.
      */
      constructor(locale, styleDefinition) {
        super(locale);
        /**
        * Definition of the style the button will apply when executed.
        */
        __publicField(this, "styleDefinition");
        /**
        * The view rendering the preview of the style.
        */
        __publicField(this, "previewView");
        this.styleDefinition = styleDefinition;
        this.previewView = this._createPreview();
        this.set({
          label: styleDefinition.name,
          class: "ck-style-grid__button",
          withText: true
        });
        this.extendTemplate({
          attributes: {
            role: "option"
          }
        });
        this.children.add(this.previewView, 0);
      }
      /**
      * Creates the view representing the preview of the style.
      */
      _createPreview() {
        const previewView = new View(this.locale);
        previewView.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-reset_all-excluded",
              "ck-style-grid__button__preview",
              "ck-content"
            ],
            // The preview "AaBbCcDdEeFfGgHhIiJj" should not be read by screen readers because it is purely presentational.
            "aria-hidden": "true"
          },
          children: [
            this.styleDefinition.previewTemplate
          ]
        });
        return previewView;
      }
    }
    class StyleGridView extends View {
      /**
      * Creates an instance of the {@link module:style/ui/stylegridview~StyleGridView} class.
      *
      * @param locale The localization services instance.
      * @param styleDefinitions Definitions of the styles.
      */
      constructor(locale, styleDefinitions) {
        super(locale);
        /**
        * Tracks information about the DOM focus in the view.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of style {@link module:style/ui/stylegridbuttonview~StyleGridButtonView buttons}.
        */
        __publicField(this, "children");
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.set("activeStyles", []);
        this.set("enabledStyles", []);
        this.children = this.createCollection();
        this.children.delegate("execute").to(this);
        for (const definition of styleDefinitions) {
          const gridTileView = new StyleGridButtonView(locale, definition);
          this.children.add(gridTileView);
        }
        this.on("change:activeStyles", () => {
          for (const child of this.children) {
            child.isOn = this.activeStyles.includes(child.styleDefinition.name);
          }
        });
        this.on("change:enabledStyles", () => {
          for (const child of this.children) {
            child.isEnabled = this.enabledStyles.includes(child.styleDefinition.name);
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-style-grid"
            ],
            role: "listbox"
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        for (const child of this.children) {
          this.focusTracker.add(child.element);
        }
        addKeyboardHandlingForGrid({
          keystrokeHandler: this.keystrokes,
          focusTracker: this.focusTracker,
          gridItems: this.children,
          numberOfColumns: 3,
          uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Focuses the first style button in the grid.
      */
      focus() {
        this.children.first.focus();
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
    }
    class StyleGroupView extends View {
      /**
      * Creates an instance of the {@link module:style/ui/stylegroupview~StyleGroupView} class.
      *
      * @param locale The localization services instance.
      * @param label The localized label of the group.
      * @param styleDefinitions Definitions of the styles in the group.
      */
      constructor(locale, label, styleDefinitions) {
        super(locale);
        /**
        * The styles grid of the group.
        */
        __publicField(this, "gridView");
        /**
        * The label of the group.
        */
        __publicField(this, "labelView");
        this.labelView = new LabelView(locale);
        this.labelView.text = label;
        this.gridView = new StyleGridView(locale, styleDefinitions);
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-style-panel__style-group"
            ],
            role: "group",
            "aria-labelledby": this.labelView.id
          },
          children: [
            this.labelView,
            this.gridView
          ]
        });
      }
    }
    class StylePanelView extends View {
      /**
      * Creates an instance of the {@link module:style/ui/stylegroupview~StyleGroupView} class.
      *
      * @param locale The localization services instance.
      * @param styleDefinitions Normalized definitions of the styles.
      */
      constructor(locale, styleDefinitions) {
        super(locale);
        /**
        * Tracks information about DOM focus in the panel.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of panel children.
        */
        __publicField(this, "children");
        /**
        * A view representing block styles group.
        */
        __publicField(this, "blockStylesGroupView");
        /**
        * A view representing inline styles group
        */
        __publicField(this, "inlineStylesGroupView");
        /**
        * A collection of views that can be focused in the panel.
        */
        __publicField(this, "_focusables");
        /**
        * Helps cycling over {@link #_focusables} in the panel.
        */
        __publicField(this, "_focusCycler");
        const t = locale.t;
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.children = this.createCollection();
        this.blockStylesGroupView = new StyleGroupView(locale, t("Block styles"), styleDefinitions.block);
        this.inlineStylesGroupView = new StyleGroupView(locale, t("Text styles"), styleDefinitions.inline);
        this.set("activeStyles", []);
        this.set("enabledStyles", []);
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate style groups backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
            focusPrevious: [
              "shift + tab"
            ],
            // Navigate style groups forward using the <kbd>Tab</kbd> key.
            focusNext: [
              "tab"
            ]
          }
        });
        if (styleDefinitions.block.length) {
          this.children.add(this.blockStylesGroupView);
        }
        if (styleDefinitions.inline.length) {
          this.children.add(this.inlineStylesGroupView);
        }
        this.blockStylesGroupView.gridView.delegate("execute").to(this);
        this.inlineStylesGroupView.gridView.delegate("execute").to(this);
        this.blockStylesGroupView.gridView.bind("activeStyles", "enabledStyles").to(this, "activeStyles", "enabledStyles");
        this.inlineStylesGroupView.gridView.bind("activeStyles", "enabledStyles").to(this, "activeStyles", "enabledStyles");
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-style-panel"
            ]
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        this._focusables.add(this.blockStylesGroupView.gridView);
        this._focusables.add(this.inlineStylesGroupView.gridView);
        this.focusTracker.add(this.blockStylesGroupView.gridView.element);
        this.focusTracker.add(this.inlineStylesGroupView.gridView.element);
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Focuses the first focusable element in the panel.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Focuses the last focusable element in the panel.
      */
      focusLast() {
        this._focusCycler.focusLast();
      }
    }
    const NON_PREVIEWABLE_ELEMENT_NAMES = [
      "caption",
      "colgroup",
      "dd",
      "dt",
      "figcaption",
      "legend",
      "li",
      "optgroup",
      "option",
      "rp",
      "rt",
      "summary",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "tr"
    ];
    class StyleUtils extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        __publicField(this, "_htmlSupport");
        this.decorate("isStyleEnabledForBlock");
        this.decorate("isStyleActiveForBlock");
        this.decorate("getAffectedBlocks");
        this.decorate("isStyleEnabledForInlineSelection");
        this.decorate("isStyleActiveForInlineSelection");
        this.decorate("getAffectedInlineSelectable");
        this.decorate("getStylePreview");
        this.decorate("configureGHSDataFilter");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "StyleUtils";
      }
      /**
      * @inheritDoc
      */
      init() {
        this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
      }
      /**
      * Normalizes {@link module:style/styleconfig~StyleConfig#definitions} in the configuration of the styles feature.
      * The structure of normalized styles looks as follows:
      *
      * ```ts
      * {
      * 	block: [
      * 		<module:style/style~StyleDefinition>,
      * 		<module:style/style~StyleDefinition>,
      * 		...
      * 	],
      * 	inline: [
      * 		<module:style/style~StyleDefinition>,
      * 		<module:style/style~StyleDefinition>,
      * 		...
      * 	]
      * }
      * ```
      *
      * @returns An object with normalized style definitions grouped into `block` and `inline` categories (arrays).
      */
      normalizeConfig(dataSchema, styleDefinitions = []) {
        const normalizedDefinitions = {
          block: [],
          inline: []
        };
        for (const definition of styleDefinitions) {
          const modelElements = [];
          const ghsAttributes = [];
          for (const ghsDefinition of dataSchema.getDefinitionsForView(definition.element)) {
            const appliesToBlock = "appliesToBlock" in ghsDefinition ? ghsDefinition.appliesToBlock : false;
            if (ghsDefinition.isBlock || appliesToBlock) {
              if (typeof appliesToBlock == "string") {
                modelElements.push(appliesToBlock);
              } else if (ghsDefinition.isBlock) {
                const ghsBlockDefinition = ghsDefinition;
                modelElements.push(ghsDefinition.model);
                if (ghsBlockDefinition.paragraphLikeModel) {
                  modelElements.push(ghsBlockDefinition.paragraphLikeModel);
                }
              }
            } else {
              ghsAttributes.push(ghsDefinition.model);
            }
          }
          const previewTemplate = this.getStylePreview(definition, [
            {
              text: "AaBbCcDdEeFfGgHhIiJj"
            }
          ]);
          if (modelElements.length) {
            normalizedDefinitions.block.push({
              ...definition,
              previewTemplate,
              modelElements,
              isBlock: true
            });
          } else {
            normalizedDefinitions.inline.push({
              ...definition,
              previewTemplate,
              ghsAttributes
            });
          }
        }
        return normalizedDefinitions;
      }
      /**
      * Verifies if the given style is applicable to the provided block element.
      *
      * @internal
      */
      isStyleEnabledForBlock(definition, block2) {
        const model = this.editor.model;
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        if (!model.schema.checkAttribute(block2, attributeName)) {
          return false;
        }
        return definition.modelElements.includes(block2.name);
      }
      /**
      * Returns true if the given style is applied to the specified block element.
      *
      * @internal
      */
      isStyleActiveForBlock(definition, block2) {
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        const ghsAttributeValue = block2.getAttribute(attributeName);
        return this.hasAllClasses(ghsAttributeValue, definition.classes);
      }
      /**
      * Returns an array of block elements that style should be applied to.
      *
      * @internal
      */
      getAffectedBlocks(definition, block2) {
        if (definition.modelElements.includes(block2.name)) {
          return [
            block2
          ];
        }
        return null;
      }
      /**
      * Verifies if the given style is applicable to the provided document selection.
      *
      * @internal
      */
      isStyleEnabledForInlineSelection(definition, selection) {
        const model = this.editor.model;
        for (const ghsAttributeName of definition.ghsAttributes) {
          if (model.schema.checkAttributeInSelection(selection, ghsAttributeName)) {
            return true;
          }
        }
        return false;
      }
      /**
      * Returns true if the given style is applied to the specified document selection.
      *
      * @internal
      */
      isStyleActiveForInlineSelection(definition, selection) {
        for (const ghsAttributeName of definition.ghsAttributes) {
          const ghsAttributeValue = this._getValueFromFirstAllowedNode(selection, ghsAttributeName);
          if (this.hasAllClasses(ghsAttributeValue, definition.classes)) {
            return true;
          }
        }
        return false;
      }
      /**
      * Returns a selectable that given style should be applied to.
      *
      * @internal
      */
      getAffectedInlineSelectable(definition, selection) {
        return selection;
      }
      /**
      * Returns the `TemplateDefinition` used by styles dropdown to render style preview.
      *
      * @internal
      */
      getStylePreview(definition, children) {
        const { element, classes } = definition;
        return {
          tag: isPreviewable(element) ? element : "div",
          attributes: {
            class: classes
          },
          children
        };
      }
      /**
      * Verifies if all classes are present in the given GHS attribute.
      *
      * @internal
      */
      hasAllClasses(ghsAttributeValue, classes) {
        return isObject$1(ghsAttributeValue) && hasClassesProperty(ghsAttributeValue) && classes.every((className) => ghsAttributeValue.classes.includes(className));
      }
      /**
      * This is where the styles feature configures the GHS feature. This method translates normalized
      * {@link module:style/styleconfig~StyleDefinition style definitions} to
      * {@link module:engine/view/matcher~MatcherObjectPattern matcher patterns} and feeds them to the GHS
      * {@link module:html-support/datafilter~DataFilter} plugin.
      *
      * @internal
      */
      configureGHSDataFilter({ block: block2, inline: inline2 }) {
        const ghsDataFilter = this.editor.plugins.get("DataFilter");
        ghsDataFilter.loadAllowedConfig(block2.map(normalizedStyleDefinitionToMatcherPattern));
        ghsDataFilter.loadAllowedConfig(inline2.map(normalizedStyleDefinitionToMatcherPattern));
      }
      /**
      * Checks the attribute value of the first node in the selection that allows the attribute.
      * For the collapsed selection, returns the selection attribute.
      *
      * @param selection The document selection.
      * @param attributeName Name of the GHS attribute.
      * @returns The attribute value.
      */
      _getValueFromFirstAllowedNode(selection, attributeName) {
        const model = this.editor.model;
        const schema = model.schema;
        if (selection.isCollapsed) {
          return selection.getAttribute(attributeName);
        }
        for (const range of selection.getRanges()) {
          for (const item of range.getItems()) {
            if (schema.checkAttribute(item, attributeName)) {
              return item.getAttribute(attributeName);
            }
          }
        }
        return null;
      }
    }
    function hasClassesProperty(obj) {
      return Boolean(obj.classes) && Array.isArray(obj.classes);
    }
    function isPreviewable(elementName) {
      return !NON_PREVIEWABLE_ELEMENT_NAMES.includes(elementName);
    }
    function normalizedStyleDefinitionToMatcherPattern({ element, classes }) {
      return {
        name: element,
        classes
      };
    }
    class StyleUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "StyleUI";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          StyleUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const dataSchema = editor.plugins.get("DataSchema");
        const styleUtils = editor.plugins.get("StyleUtils");
        const styleDefinitions = editor.config.get("style.definitions");
        const normalizedStyleDefinitions = styleUtils.normalizeConfig(dataSchema, styleDefinitions);
        editor.ui.componentFactory.add("style", (locale) => {
          const t = locale.t;
          const dropdown = createDropdown(locale);
          const styleCommand = editor.commands.get("style");
          dropdown.once("change:isOpen", () => {
            const panelView = new StylePanelView(locale, normalizedStyleDefinitions);
            dropdown.panelView.children.add(panelView);
            panelView.delegate("execute").to(dropdown);
            panelView.bind("activeStyles").to(styleCommand, "value");
            panelView.bind("enabledStyles").to(styleCommand, "enabledStyles");
          });
          dropdown.bind("isEnabled").to(styleCommand);
          dropdown.buttonView.withText = true;
          dropdown.buttonView.bind("label").to(styleCommand, "value", (value) => {
            if (value.length > 1) {
              return t("Multiple styles");
            } else if (value.length === 1) {
              return value[0];
            } else {
              return t("Styles");
            }
          });
          dropdown.bind("class").to(styleCommand, "value", (value) => {
            const classes = [
              "ck-style-dropdown"
            ];
            if (value.length > 1) {
              classes.push("ck-style-dropdown_multiple-active");
            }
            return classes.join(" ");
          });
          dropdown.on("execute", (evt) => {
            editor.execute("style", {
              styleName: evt.source.styleDefinition.name
            });
            editor.editing.view.focus();
          });
          return dropdown;
        });
      }
    }
    class StyleCommand extends Command {
      /**
      * Creates an instance of the command.
      *
      * @param editor Editor on which this command will be used.
      * @param styleDefinitions Normalized definitions of the styles.
      */
      constructor(editor, styleDefinitions) {
        super(editor);
        /**
        * Normalized definitions of the styles.
        */
        __publicField(this, "_styleDefinitions");
        /**
        * The StyleUtils plugin.
        */
        __publicField(this, "_styleUtils");
        this.set("value", []);
        this.set("enabledStyles", []);
        this._styleDefinitions = styleDefinitions;
        this._styleUtils = this.editor.plugins.get(StyleUtils);
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const value = /* @__PURE__ */ new Set();
        const enabledStyles = /* @__PURE__ */ new Set();
        for (const definition of this._styleDefinitions.inline) {
          if (this._styleUtils.isStyleEnabledForInlineSelection(definition, selection)) {
            enabledStyles.add(definition.name);
          }
          if (this._styleUtils.isStyleActiveForInlineSelection(definition, selection)) {
            value.add(definition.name);
          }
        }
        const firstBlock = first(selection.getSelectedBlocks()) || selection.getFirstPosition().parent;
        if (firstBlock) {
          const ancestorBlocks = firstBlock.getAncestors({
            includeSelf: true,
            parentFirst: true
          });
          for (const block2 of ancestorBlocks) {
            if (block2.is("rootElement")) {
              break;
            }
            for (const definition of this._styleDefinitions.block) {
              if (!this._styleUtils.isStyleEnabledForBlock(definition, block2)) {
                continue;
              }
              enabledStyles.add(definition.name);
              if (this._styleUtils.isStyleActiveForBlock(definition, block2)) {
                value.add(definition.name);
              }
            }
            if (model.schema.isObject(block2)) {
              break;
            }
          }
        }
        this.enabledStyles = Array.from(enabledStyles).sort();
        this.isEnabled = this.enabledStyles.length > 0;
        this.value = this.isEnabled ? Array.from(value).sort() : [];
      }
      /**
      * Executes the command &ndash; applies the style classes to the selection or removes it from the selection.
      *
      * If the command value already contains the requested style, it will remove the style classes. Otherwise, it will set it.
      *
      * The execution result differs, depending on the {@link module:engine/model/document~Document#selection} and the
      * style type (inline or block):
      *
      * * When applying inline styles:
      *   * If the selection is on a range, the command applies the style classes to all nodes in that range.
      *   * If the selection is collapsed in a non-empty node, the command applies the style classes to the
      * {@link module:engine/model/document~Document#selection}.
      *
      * * When applying block styles:
      *   * If the selection is on a range, the command applies the style classes to the nearest block parent element.
      *
      * @fires execute
      * @param options Command options.
      * @param options.styleName Style name matching the one defined in the
      * {@link module:style/styleconfig~StyleConfig#definitions configuration}.
      * @param options.forceValue Whether the command should add given style (`true`) or remove it (`false`) from the selection.
      * If not set (default), the command will toggle the style basing on the first selected node. Note, that this will not force
      * setting a style on an element that cannot receive given style.
      */
      execute({ styleName, forceValue }) {
        if (!this.enabledStyles.includes(styleName)) {
          logWarning("style-command-executed-with-incorrect-style-name");
          return;
        }
        const model = this.editor.model;
        const selection = model.document.selection;
        const htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
        const allDefinitions = [
          ...this._styleDefinitions.inline,
          ...this._styleDefinitions.block
        ];
        const activeDefinitions = allDefinitions.filter(({ name }) => this.value.includes(name));
        const definition = allDefinitions.find(({ name }) => name == styleName);
        const shouldAddStyle = forceValue === void 0 ? !this.value.includes(definition.name) : forceValue;
        model.change(() => {
          let selectables;
          if (isBlockStyleDefinition(definition)) {
            selectables = this._findAffectedBlocks(getBlocksFromSelection(selection), definition);
          } else {
            selectables = [
              this._styleUtils.getAffectedInlineSelectable(definition, selection)
            ];
          }
          for (const selectable of selectables) {
            if (shouldAddStyle) {
              htmlSupport.addModelHtmlClass(definition.element, definition.classes, selectable);
            } else {
              htmlSupport.removeModelHtmlClass(definition.element, getDefinitionExclusiveClasses(activeDefinitions, definition), selectable);
            }
          }
        });
      }
      /**
      * Returns a set of elements that should be affected by the block-style change.
      */
      _findAffectedBlocks(selectedBlocks, definition) {
        const blocks = /* @__PURE__ */ new Set();
        for (const selectedBlock of selectedBlocks) {
          const ancestorBlocks = selectedBlock.getAncestors({
            includeSelf: true,
            parentFirst: true
          });
          for (const block2 of ancestorBlocks) {
            if (block2.is("rootElement")) {
              break;
            }
            const affectedBlocks = this._styleUtils.getAffectedBlocks(definition, block2);
            if (affectedBlocks) {
              for (const affectedBlock of affectedBlocks) {
                blocks.add(affectedBlock);
              }
              break;
            }
          }
        }
        return blocks;
      }
    }
    function getDefinitionExclusiveClasses(activeDefinitions, definition) {
      return activeDefinitions.reduce((classes, currentDefinition) => {
        if (currentDefinition.name === definition.name) {
          return classes;
        }
        return classes.filter((className) => !currentDefinition.classes.includes(className));
      }, definition.classes);
    }
    function isBlockStyleDefinition(definition) {
      return "isBlock" in definition;
    }
    function getBlocksFromSelection(selection) {
      const blocks = Array.from(selection.getSelectedBlocks());
      if (blocks.length) {
        return blocks;
      }
      return [
        selection.getFirstPosition().parent
      ];
    }
    class ListStyleSupport extends Plugin {
      constructor() {
        super(...arguments);
        __publicField(this, "_listUtils");
        __publicField(this, "_styleUtils");
        __publicField(this, "_htmlSupport");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "ListStyleSupport";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          StyleUtils,
          "GeneralHtmlSupport"
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("ListEditing")) {
          return;
        }
        this._styleUtils = editor.plugins.get(StyleUtils);
        this._listUtils = this.editor.plugins.get("ListUtils");
        this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
        this.listenTo(this._styleUtils, "isStyleEnabledForBlock", (evt, [definition, block2]) => {
          if (this._isStyleEnabledForBlock(definition, block2)) {
            evt.return = true;
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "isStyleActiveForBlock", (evt, [definition, block2]) => {
          if (this._isStyleActiveForBlock(definition, block2)) {
            evt.return = true;
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "getAffectedBlocks", (evt, [definition, block2]) => {
          const blocks = this._getAffectedBlocks(definition, block2);
          if (blocks) {
            evt.return = blocks;
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "getStylePreview", (evt, [definition, children]) => {
          const templateDefinition = this._getStylePreview(definition, children);
          if (templateDefinition) {
            evt.return = templateDefinition;
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
      /**
      * Verifies if the given style is applicable to the provided block element.
      */
      _isStyleEnabledForBlock(definition, block2) {
        const model = this.editor.model;
        if (![
          "ol",
          "ul",
          "li"
        ].includes(definition.element)) {
          return false;
        }
        if (!this._listUtils.isListItemBlock(block2)) {
          return false;
        }
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        if (definition.element == "ol" || definition.element == "ul") {
          if (!model.schema.checkAttribute(block2, attributeName)) {
            return false;
          }
          const isNumbered = this._listUtils.isNumberedListType(block2.getAttribute("listType"));
          const viewElementName = isNumbered ? "ol" : "ul";
          return definition.element == viewElementName;
        } else {
          return model.schema.checkAttribute(block2, attributeName);
        }
      }
      /**
      * Returns true if the given style is applied to the specified block element.
      */
      _isStyleActiveForBlock(definition, block2) {
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        const ghsAttributeValue = block2.getAttribute(attributeName);
        return this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes);
      }
      /**
      * Returns an array of block elements that style should be applied to.
      */
      _getAffectedBlocks(definition, block2) {
        if (!this._isStyleEnabledForBlock(definition, block2)) {
          return null;
        }
        if (definition.element == "li") {
          return this._listUtils.expandListBlocksToCompleteItems(block2, {
            withNested: false
          });
        } else {
          return this._listUtils.expandListBlocksToCompleteList(block2);
        }
      }
      /**
      * Returns a view template definition for the style preview.
      */
      _getStylePreview(definition, children) {
        const { element, classes } = definition;
        if (element == "ol" || element == "ul") {
          return {
            tag: element,
            attributes: {
              class: classes
            },
            children: [
              {
                tag: "li",
                children
              }
            ]
          };
        } else if (element == "li") {
          return {
            tag: "ol",
            children: [
              {
                tag: element,
                attributes: {
                  class: classes
                },
                children
              }
            ]
          };
        }
        return null;
      }
    }
    class TableStyleSupport extends Plugin {
      constructor() {
        super(...arguments);
        __publicField(this, "_tableUtils");
        __publicField(this, "_styleUtils");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableStyleSupport";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          StyleUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("TableEditing")) {
          return;
        }
        this._styleUtils = editor.plugins.get(StyleUtils);
        this._tableUtils = this.editor.plugins.get("TableUtils");
        this.listenTo(this._styleUtils, "isStyleEnabledForBlock", (evt, [definition, block2]) => {
          if (this._isApplicable(definition, block2)) {
            evt.return = this._isStyleEnabledForBlock(definition, block2);
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "getAffectedBlocks", (evt, [definition, block2]) => {
          if (this._isApplicable(definition, block2)) {
            evt.return = this._getAffectedBlocks(definition, block2);
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "configureGHSDataFilter", (evt, [{ block: block2 }]) => {
          const ghsDataFilter = this.editor.plugins.get("DataFilter");
          ghsDataFilter.loadAllowedConfig(block2.filter((definition) => definition.element == "figcaption").map((definition) => ({
            name: "caption",
            classes: definition.classes
          })));
        });
      }
      /**
      * Checks if this plugin's custom logic should be applied for defintion-block pair.
      *
      * @param definition Style definition that is being considered.
      * @param block Block element to check if should be styled.
      * @returns True if the defintion-block pair meet the plugin criteria, false otherwise.
      */
      _isApplicable(definition, block2) {
        if ([
          "td",
          "th"
        ].includes(definition.element)) {
          return block2.name == "tableCell";
        }
        if ([
          "thead",
          "tbody"
        ].includes(definition.element)) {
          return block2.name == "table";
        }
        return false;
      }
      /**
      * Checks if the style definition should be applied to selected block.
      *
      * @param definition Style definition that is being considered.
      * @param block Block element to check if should be styled.
      * @returns True if the block should be style with the style description, false otherwise.
      */
      _isStyleEnabledForBlock(definition, block2) {
        if ([
          "td",
          "th"
        ].includes(definition.element)) {
          const location = this._tableUtils.getCellLocation(block2);
          const tableRow = block2.parent;
          const table2 = tableRow.parent;
          const headingRows = table2.getAttribute("headingRows") || 0;
          const headingColumns = table2.getAttribute("headingColumns") || 0;
          const isHeadingCell = location.row < headingRows || location.column < headingColumns;
          if (definition.element == "th") {
            return isHeadingCell;
          } else {
            return !isHeadingCell;
          }
        }
        if ([
          "thead",
          "tbody"
        ].includes(definition.element)) {
          const headingRows = block2.getAttribute("headingRows") || 0;
          if (definition.element == "thead") {
            return headingRows > 0;
          } else {
            return headingRows < this._tableUtils.getRows(block2);
          }
        }
        /* istanbul ignore next -- @preserve */
        return false;
      }
      /**
      * Gets all blocks that the style should be applied to.
      *
      * @param definition Style definition that is being considered.
      * @param block A block element from selection.
      * @returns An array with the block that was passed as an argument if meets the criteria, null otherwise.
      */
      _getAffectedBlocks(definition, block2) {
        if (!this._isStyleEnabledForBlock(definition, block2)) {
          return null;
        }
        return [
          block2
        ];
      }
    }
    class LinkStyleSupport extends Plugin {
      constructor() {
        super(...arguments);
        __publicField(this, "_styleUtils");
        __publicField(this, "_htmlSupport");
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "LinkStyleSupport";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          StyleUtils,
          "GeneralHtmlSupport"
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        if (!editor.plugins.has("LinkEditing")) {
          return;
        }
        this._styleUtils = editor.plugins.get(StyleUtils);
        this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
        this.listenTo(this._styleUtils, "isStyleEnabledForInlineSelection", (evt, [definition, selection]) => {
          if (definition.element == "a") {
            evt.return = this._isStyleEnabled(definition, selection);
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "isStyleActiveForInlineSelection", (evt, [definition, selection]) => {
          if (definition.element == "a") {
            evt.return = this._isStyleActive(definition, selection);
            evt.stop();
          }
        }, {
          priority: "high"
        });
        this.listenTo(this._styleUtils, "getAffectedInlineSelectable", (evt, [definition, selection]) => {
          if (definition.element != "a") {
            return;
          }
          const selectable = this._getAffectedSelectable(definition, selection);
          if (selectable) {
            evt.return = selectable;
            evt.stop();
          }
        }, {
          priority: "high"
        });
      }
      /**
      * Verifies if the given style is applicable to the provided document selection.
      */
      _isStyleEnabled(definition, selection) {
        const model = this.editor.model;
        if (selection.isCollapsed) {
          return selection.hasAttribute("linkHref");
        }
        for (const range of selection.getRanges()) {
          for (const item of range.getItems()) {
            if ((item.is("$textProxy") || model.schema.isInline(item)) && item.hasAttribute("linkHref")) {
              return true;
            }
          }
        }
        return false;
      }
      /**
      * Returns true if the given style is applied to the specified document selection.
      */
      _isStyleActive(definition, selection) {
        const model = this.editor.model;
        const attributeName = this._htmlSupport.getGhsAttributeNameForElement(definition.element);
        if (selection.isCollapsed) {
          if (selection.hasAttribute("linkHref")) {
            const ghsAttributeValue = selection.getAttribute(attributeName);
            if (this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes)) {
              return true;
            }
          }
          return false;
        }
        for (const range of selection.getRanges()) {
          for (const item of range.getItems()) {
            if ((item.is("$textProxy") || model.schema.isInline(item)) && item.hasAttribute("linkHref")) {
              const ghsAttributeValue = item.getAttribute(attributeName);
              return this._styleUtils.hasAllClasses(ghsAttributeValue, definition.classes);
            }
          }
        }
        return false;
      }
      /**
      * Returns a selectable that given style should be applied to.
      */
      _getAffectedSelectable(definition, selection) {
        const model = this.editor.model;
        if (selection.isCollapsed) {
          const linkHref = selection.getAttribute("linkHref");
          return findAttributeRange(selection.getFirstPosition(), "linkHref", linkHref, model);
        }
        const ranges = [];
        for (const range of selection.getRanges()) {
          const expandedRange = model.createRange(expandAttributePosition(range.start, "linkHref", true, model), expandAttributePosition(range.end, "linkHref", false, model));
          for (const item of expandedRange.getItems()) {
            if ((item.is("$textProxy") || model.schema.isInline(item)) && item.hasAttribute("linkHref")) {
              ranges.push(this.editor.model.createRangeOn(item));
            }
          }
        }
        return normalizeRanges(ranges);
      }
    }
    function expandAttributePosition(position, attributeName, lookBack, model) {
      const referenceNode = position.textNode || (lookBack ? position.nodeAfter : position.nodeBefore);
      if (!referenceNode || !referenceNode.hasAttribute(attributeName)) {
        return position;
      }
      const attributeValue = referenceNode.getAttribute(attributeName);
      return findAttributeRangeBound(position, attributeName, attributeValue, lookBack, model);
    }
    function normalizeRanges(ranges) {
      for (let i = 1; i < ranges.length; i++) {
        const joinedRange = ranges[i - 1].getJoined(ranges[i]);
        if (joinedRange) {
          ranges.splice(--i, 2, joinedRange);
        }
      }
      return ranges;
    }
    class StyleEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "StyleEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          "GeneralHtmlSupport",
          StyleUtils,
          ListStyleSupport,
          TableStyleSupport,
          LinkStyleSupport
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const dataSchema = editor.plugins.get("DataSchema");
        const styleUtils = editor.plugins.get("StyleUtils");
        const styleDefinitions = editor.config.get("style.definitions");
        const normalizedStyleDefinitions = styleUtils.normalizeConfig(dataSchema, styleDefinitions);
        editor.commands.add("style", new StyleCommand(editor, normalizedStyleDefinitions));
        styleUtils.configureGHSDataFilter(normalizedStyleDefinitions);
      }
    }
    class Style extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Style";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          StyleEditing,
          StyleUI
        ];
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function upcastStyleToAttribute(conversion, options) {
      const { modelAttribute, styleName, viewElement, defaultValue, reduceBoxSides = false, shouldUpcast = () => true } = options;
      conversion.for("upcast").attributeToAttribute({
        view: {
          name: viewElement,
          styles: {
            [styleName]: /[\s\S]+/
          }
        },
        model: {
          key: modelAttribute,
          value: (viewElement2) => {
            if (!shouldUpcast(viewElement2)) {
              return;
            }
            const normalized = viewElement2.getNormalizedStyle(styleName);
            const value = reduceBoxSides ? reduceBoxSidesValue(normalized) : normalized;
            if (defaultValue !== value) {
              return value;
            }
          }
        }
      });
    }
    function upcastBorderStyles(conversion, viewElementName, modelAttributes, defaultBorder) {
      conversion.for("upcast").add((dispatcher) => dispatcher.on("element:" + viewElementName, (evt, data, conversionApi) => {
        if (!data.modelRange) {
          return;
        }
        const stylesToConsume = [
          "border-top-width",
          "border-top-color",
          "border-top-style",
          "border-bottom-width",
          "border-bottom-color",
          "border-bottom-style",
          "border-right-width",
          "border-right-color",
          "border-right-style",
          "border-left-width",
          "border-left-color",
          "border-left-style"
        ].filter((styleName) => data.viewItem.hasStyle(styleName));
        if (!stylesToConsume.length) {
          return;
        }
        const matcherPattern = {
          styles: stylesToConsume
        };
        if (!conversionApi.consumable.test(data.viewItem, matcherPattern)) {
          return;
        }
        const modelElement = [
          ...data.modelRange.getItems({
            shallow: true
          })
        ].pop();
        conversionApi.consumable.consume(data.viewItem, matcherPattern);
        const normalizedBorder = {
          style: data.viewItem.getNormalizedStyle("border-style"),
          color: data.viewItem.getNormalizedStyle("border-color"),
          width: data.viewItem.getNormalizedStyle("border-width")
        };
        const reducedBorder = {
          style: reduceBoxSidesValue(normalizedBorder.style),
          color: reduceBoxSidesValue(normalizedBorder.color),
          width: reduceBoxSidesValue(normalizedBorder.width)
        };
        if (reducedBorder.style !== defaultBorder.style) {
          conversionApi.writer.setAttribute(modelAttributes.style, reducedBorder.style, modelElement);
        }
        if (reducedBorder.color !== defaultBorder.color) {
          conversionApi.writer.setAttribute(modelAttributes.color, reducedBorder.color, modelElement);
        }
        if (reducedBorder.width !== defaultBorder.width) {
          conversionApi.writer.setAttribute(modelAttributes.width, reducedBorder.width, modelElement);
        }
      }));
    }
    function downcastAttributeToStyle(conversion, options) {
      const { modelElement, modelAttribute, styleName } = options;
      conversion.for("downcast").attributeToAttribute({
        model: {
          name: modelElement,
          key: modelAttribute
        },
        view: (modelAttributeValue) => ({
          key: "style",
          value: {
            [styleName]: modelAttributeValue
          }
        })
      });
    }
    function downcastTableAttribute(conversion, options) {
      const { modelAttribute, styleName } = options;
      conversion.for("downcast").add((dispatcher) => dispatcher.on(`attribute:${modelAttribute}:table`, (evt, data, conversionApi) => {
        const { item, attributeNewValue } = data;
        const { mapper, writer } = conversionApi;
        if (!conversionApi.consumable.consume(data.item, evt.name)) {
          return;
        }
        const table2 = [
          ...mapper.toViewElement(item).getChildren()
        ].find((child) => child.is("element", "table"));
        if (attributeNewValue) {
          writer.setStyle(styleName, attributeNewValue, table2);
        } else {
          writer.removeStyle(styleName, table2);
        }
      }));
    }
    function reduceBoxSidesValue(style) {
      if (!style) {
        return;
      }
      const sides = [
        "top",
        "right",
        "bottom",
        "left"
      ];
      const allSidesDefined = sides.every((side) => style[side]);
      if (!allSidesDefined) {
        return style;
      }
      const topSideStyle = style.top;
      const allSidesEqual = sides.every((side) => style[side] === topSideStyle);
      if (!allSidesEqual) {
        return style;
      }
      return topSideStyle;
    }
    function updateNumericAttribute(key, value, item, writer, defaultValue = 1) {
      if (value !== void 0 && value !== null && defaultValue !== void 0 && defaultValue !== null && value > defaultValue) {
        writer.setAttribute(key, value, item);
      } else {
        writer.removeAttribute(key, item);
      }
    }
    function createEmptyTableCell(writer, insertPosition, attributes = {}) {
      const tableCell = writer.createElement("tableCell", attributes);
      writer.insertElement("paragraph", tableCell);
      writer.insert(tableCell, insertPosition);
      return tableCell;
    }
    function isHeadingColumnCell(tableUtils, tableCell) {
      const table2 = tableCell.parent.parent;
      const headingColumns = parseInt(table2.getAttribute("headingColumns") || "0");
      const { column } = tableUtils.getCellLocation(tableCell);
      return !!headingColumns && column < headingColumns;
    }
    function enableProperty$1(schema, conversion, options) {
      const { modelAttribute } = options;
      schema.extend("tableCell", {
        allowAttributes: [
          modelAttribute
        ]
      });
      upcastStyleToAttribute(conversion, {
        viewElement: /^(td|th)$/,
        ...options
      });
      downcastAttributeToStyle(conversion, {
        modelElement: "tableCell",
        ...options
      });
    }
    function getSelectionAffectedTable(selection) {
      const selectedElement = selection.getSelectedElement();
      if (selectedElement && selectedElement.is("element", "table")) {
        return selectedElement;
      }
      return selection.getFirstPosition().findAncestor("table");
    }
    function upcastTableFigure() {
      return (dispatcher) => {
        dispatcher.on("element:figure", (evt, data, conversionApi) => {
          if (!conversionApi.consumable.test(data.viewItem, {
            name: true,
            classes: "table"
          })) {
            return;
          }
          const viewTable = getViewTableFromFigure(data.viewItem);
          if (!viewTable || !conversionApi.consumable.test(viewTable, {
            name: true
          })) {
            return;
          }
          conversionApi.consumable.consume(data.viewItem, {
            name: true,
            classes: "table"
          });
          const conversionResult = conversionApi.convertItem(viewTable, data.modelCursor);
          const modelTable = first(conversionResult.modelRange.getItems());
          if (!modelTable) {
            conversionApi.consumable.revert(data.viewItem, {
              name: true,
              classes: "table"
            });
            return;
          }
          conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelTable, "end"));
          conversionApi.updateConversionResult(modelTable, data);
        });
      };
    }
    function upcastTable() {
      return (dispatcher) => {
        dispatcher.on("element:table", (evt, data, conversionApi) => {
          const viewTable = data.viewItem;
          if (!conversionApi.consumable.test(viewTable, {
            name: true
          })) {
            return;
          }
          const { rows, headingRows, headingColumns } = scanTable(viewTable);
          const attributes = {};
          if (headingColumns) {
            attributes.headingColumns = headingColumns;
          }
          if (headingRows) {
            attributes.headingRows = headingRows;
          }
          const table2 = conversionApi.writer.createElement("table", attributes);
          if (!conversionApi.safeInsert(table2, data.modelCursor)) {
            return;
          }
          conversionApi.consumable.consume(viewTable, {
            name: true
          });
          rows.forEach((row) => conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table2, "end")));
          conversionApi.convertChildren(viewTable, conversionApi.writer.createPositionAt(table2, "end"));
          if (table2.isEmpty) {
            const row = conversionApi.writer.createElement("tableRow");
            conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table2, "end"));
            createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, "end"));
          }
          conversionApi.updateConversionResult(table2, data);
        });
      };
    }
    function skipEmptyTableRow() {
      return (dispatcher) => {
        dispatcher.on("element:tr", (evt, data) => {
          if (data.viewItem.isEmpty && data.modelCursor.index == 0) {
            evt.stop();
          }
        }, {
          priority: "high"
        });
      };
    }
    function ensureParagraphInTableCell(elementName) {
      return (dispatcher) => {
        dispatcher.on(`element:${elementName}`, (evt, data, { writer }) => {
          if (!data.modelRange) {
            return;
          }
          const tableCell = data.modelRange.start.nodeAfter;
          const modelCursor = writer.createPositionAt(tableCell, 0);
          if (data.viewItem.isEmpty) {
            writer.insertElement("paragraph", modelCursor);
            return;
          }
          const childNodes = Array.from(tableCell.getChildren());
          if (childNodes.every((node) => node.is("element", "$marker"))) {
            const paragraph2 = writer.createElement("paragraph");
            writer.insert(paragraph2, writer.createPositionAt(tableCell, 0));
            for (const node of childNodes) {
              writer.move(writer.createRangeOn(node), writer.createPositionAt(paragraph2, "end"));
            }
          }
        }, {
          priority: "low"
        });
      };
    }
    function getViewTableFromFigure(figureView) {
      for (const figureChild of figureView.getChildren()) {
        if (figureChild.is("element", "table")) {
          return figureChild;
        }
      }
    }
    function scanTable(viewTable) {
      let headingRows = 0;
      let headingColumns = void 0;
      const headRows = [];
      const bodyRows = [];
      let firstTheadElement;
      for (const tableChild of Array.from(viewTable.getChildren())) {
        if (tableChild.name !== "tbody" && tableChild.name !== "thead" && tableChild.name !== "tfoot") {
          continue;
        }
        if (tableChild.name === "thead" && !firstTheadElement) {
          firstTheadElement = tableChild;
        }
        const trs = Array.from(tableChild.getChildren()).filter((el) => el.is("element", "tr"));
        for (const tr of trs) {
          if (firstTheadElement && tableChild === firstTheadElement || tableChild.name === "tbody" && Array.from(tr.getChildren()).length && Array.from(tr.getChildren()).every((e) => e.is("element", "th"))) {
            headingRows++;
            headRows.push(tr);
          } else {
            bodyRows.push(tr);
            const headingCols = scanRowForHeadingColumns(tr);
            if (!headingColumns || headingCols < headingColumns) {
              headingColumns = headingCols;
            }
          }
        }
      }
      return {
        headingRows,
        headingColumns: headingColumns || 0,
        rows: [
          ...headRows,
          ...bodyRows
        ]
      };
    }
    function scanRowForHeadingColumns(tr) {
      let headingColumns = 0;
      let index2 = 0;
      const children = Array.from(tr.getChildren()).filter((child) => child.name === "th" || child.name === "td");
      while (index2 < children.length && children[index2].name === "th") {
        const th = children[index2];
        const colspan = parseInt(th.getAttribute("colspan") || "1");
        headingColumns = headingColumns + colspan;
        index2++;
      }
      return headingColumns;
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    class TableWalker {
      /**
      * Creates an instance of the table walker.
      *
      * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
      * It walks row by row and column by column in order to output values defined in the constructor.
      * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
      * pass the `includeAllSlots` option to the constructor.
      *
      * The most important values of the iterator are column and row indexes of a cell.
      *
      * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.
      *
      * To iterate over a given row:
      *
      * ```ts
      * const tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );
      *
      * for ( const tableSlot of tableWalker ) {
      *   console.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );
      * }
      * ```
      *
      * For instance the code above for the following table:
      *
      *  +----+----+----+----+----+----+
      *  | 00      | 02 | 03 | 04 | 05 |
      *  |         +----+----+----+----+
      *  |         | 12      | 14 | 15 |
      *  |         +----+----+----+    +
      *  |         | 22           |    |
      *  |----+----+----+----+----+    +
      *  | 30 | 31 | 32 | 33 | 34 |    |
      *  +----+----+----+----+----+----+
      *
      * will log in the console:
      *
      *  'A cell at row 1 and column 2'
      *  'A cell at row 1 and column 4'
      *  'A cell at row 1 and column 5'
      *  'A cell at row 2 and column 2'
      *
      * To also iterate over spanned cells:
      *
      * ```ts
      * const tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );
      *
      * for ( const tableSlot of tableWalker ) {
      *   console.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );
      * }
      * ```
      *
      * will log in the console for the table from the previous example:
      *
      *  'Cell at 1 x 0 : is spanned'
      *  'Cell at 1 x 1 : is spanned'
      *  'Cell at 1 x 2 : is anchored'
      *  'Cell at 1 x 3 : is spanned'
      *  'Cell at 1 x 4 : is anchored'
      *  'Cell at 1 x 5 : is anchored'
      *
      * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.
      * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`
      * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).
      *
      * @param table A table over which the walker iterates.
      * @param options An object with configuration.
      * @param options.row A row index for which this iterator will output cells. Can't be used together with `startRow` and `endRow`.
      * @param options.startRow A row index from which this iterator should start. Can't be used together with `row`. Default value is 0.
      * @param options.endRow A row index at which this iterator should end. Can't be used together with `row`.
      * @param options.column A column index for which this iterator will output cells.
      * Can't be used together with `startColumn` and `endColumn`.
      * @param options.startColumn A column index from which this iterator should start.
      * Can't be used together with `column`. Default value is 0.
      * @param options.endColumn A column index at which this iterator should end. Can't be used together with `column`.
      * @param options.includeAllSlots Also return values for spanned cells. Default value is "false".
      */
      constructor(table2, options = {}) {
        /**
        * The walker's table element.
        *
        * @internal
        */
        __publicField(this, "_table");
        /**
        * A row index from which this iterator will start.
        */
        __publicField(this, "_startRow");
        /**
        * A row index at which this iterator will end.
        */
        __publicField(this, "_endRow");
        /**
        * If set, the table walker will only output cells from a given column and following ones or cells that overlap them.
        */
        __publicField(this, "_startColumn");
        /**
        * If set, the table walker will only output cells up to a given column.
        */
        __publicField(this, "_endColumn");
        /**
        * Enables output of spanned cells that are normally not yielded.
        */
        __publicField(this, "_includeAllSlots");
        /**
        * Row indexes to skip from the iteration.
        */
        __publicField(this, "_skipRows");
        /**
        * The current row index.
        *
        * @internal
        */
        __publicField(this, "_row");
        /**
        * The index of the current row element in the table.
        *
        * @internal
        */
        __publicField(this, "_rowIndex");
        /**
        * The current column index.
        *
        * @internal
        */
        __publicField(this, "_column");
        /**
        * The cell index in a parent row. For spanned cells when {@link #_includeAllSlots} is set to `true`,
        * this represents the index of the next table cell.
        *
        * @internal
        */
        __publicField(this, "_cellIndex");
        /**
        * Holds a map of spanned cells in a table.
        */
        __publicField(this, "_spannedCells");
        /**
        * Index of the next column where a cell is anchored.
        */
        __publicField(this, "_nextCellAtColumn");
        /**
        * Indicates whether the iterator jumped to (or close to) the start row, ignoring rows that don't need to be traversed.
        */
        __publicField(this, "_jumpedToStartRow", false);
        this._table = table2;
        this._startRow = options.row !== void 0 ? options.row : options.startRow || 0;
        this._endRow = options.row !== void 0 ? options.row : options.endRow;
        this._startColumn = options.column !== void 0 ? options.column : options.startColumn || 0;
        this._endColumn = options.column !== void 0 ? options.column : options.endColumn;
        this._includeAllSlots = !!options.includeAllSlots;
        this._skipRows = /* @__PURE__ */ new Set();
        this._row = 0;
        this._rowIndex = 0;
        this._column = 0;
        this._cellIndex = 0;
        this._spannedCells = /* @__PURE__ */ new Map();
        this._nextCellAtColumn = -1;
      }
      /**
      * Iterable interface.
      */
      [Symbol.iterator]() {
        return this;
      }
      /**
      * Gets the next table walker's value.
      *
      * @returns The next table walker's value.
      */
      next() {
        if (this._canJumpToStartRow()) {
          this._jumpToNonSpannedRowClosestToStartRow();
        }
        const row = this._table.getChild(this._rowIndex);
        if (!row || this._isOverEndRow()) {
          return {
            done: true,
            value: void 0
          };
        }
        if (!row.is("element", "tableRow")) {
          this._rowIndex++;
          return this.next();
        }
        if (this._isOverEndColumn()) {
          return this._advanceToNextRow();
        }
        let outValue = null;
        const spanData = this._getSpanned();
        if (spanData) {
          if (this._includeAllSlots && !this._shouldSkipSlot()) {
            outValue = this._formatOutValue(spanData.cell, spanData.row, spanData.column);
          }
        } else {
          const cell = row.getChild(this._cellIndex);
          if (!cell) {
            return this._advanceToNextRow();
          }
          const colspan = parseInt(cell.getAttribute("colspan") || "1");
          const rowspan = parseInt(cell.getAttribute("rowspan") || "1");
          if (colspan > 1 || rowspan > 1) {
            this._recordSpans(cell, rowspan, colspan);
          }
          if (!this._shouldSkipSlot()) {
            outValue = this._formatOutValue(cell);
          }
          this._nextCellAtColumn = this._column + colspan;
        }
        this._column++;
        if (this._column == this._nextCellAtColumn) {
          this._cellIndex++;
        }
        return outValue || this.next();
      }
      /**
      * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row
      * to output.
      *
      * @param row The row index to skip.
      */
      skipRow(row) {
        this._skipRows.add(row);
      }
      /**
      * Advances internal cursor to the next row.
      */
      _advanceToNextRow() {
        this._row++;
        this._rowIndex++;
        this._column = 0;
        this._cellIndex = 0;
        this._nextCellAtColumn = -1;
        return this.next();
      }
      /**
      * Checks if the current row is over {@link #_endRow}.
      */
      _isOverEndRow() {
        return this._endRow !== void 0 && this._row > this._endRow;
      }
      /**
      * Checks if the current cell is over {@link #_endColumn}
      */
      _isOverEndColumn() {
        return this._endColumn !== void 0 && this._column > this._endColumn;
      }
      /**
      * A common method for formatting the iterator's output value.
      *
      * @param cell The table cell to output.
      * @param anchorRow The row index of a cell anchor slot.
      * @param anchorColumn The column index of a cell anchor slot.
      */
      _formatOutValue(cell, anchorRow = this._row, anchorColumn = this._column) {
        return {
          done: false,
          value: new TableSlot(this, cell, anchorRow, anchorColumn)
        };
      }
      /**
      * Checks if the current slot should be skipped.
      */
      _shouldSkipSlot() {
        const rowIsMarkedAsSkipped = this._skipRows.has(this._row);
        const rowIsBeforeStartRow = this._row < this._startRow;
        const columnIsBeforeStartColumn = this._column < this._startColumn;
        const columnIsAfterEndColumn = this._endColumn !== void 0 && this._column > this._endColumn;
        return rowIsMarkedAsSkipped || rowIsBeforeStartRow || columnIsBeforeStartColumn || columnIsAfterEndColumn;
      }
      /**
      * Returns the cell element that is spanned over the current cell location.
      */
      _getSpanned() {
        const rowMap = this._spannedCells.get(this._row);
        if (!rowMap) {
          return null;
        }
        return rowMap.get(this._column) || null;
      }
      /**
      * Updates spanned cells map relative to the current cell location and its span dimensions.
      *
      * @param cell A cell that is spanned.
      * @param rowspan Cell height.
      * @param colspan Cell width.
      */
      _recordSpans(cell, rowspan, colspan) {
        const data = {
          cell,
          row: this._row,
          column: this._column
        };
        for (let rowToUpdate = this._row; rowToUpdate < this._row + rowspan; rowToUpdate++) {
          for (let columnToUpdate = this._column; columnToUpdate < this._column + colspan; columnToUpdate++) {
            if (rowToUpdate != this._row || columnToUpdate != this._column) {
              this._markSpannedCell(rowToUpdate, columnToUpdate, data);
            }
          }
        }
      }
      /**
      * Marks the cell location as spanned by another cell.
      *
      * @param row The row index of the cell location.
      * @param column The column index of the cell location.
      * @param data A spanned cell details (cell element, anchor row and column).
      */
      _markSpannedCell(row, column, data) {
        if (!this._spannedCells.has(row)) {
          this._spannedCells.set(row, /* @__PURE__ */ new Map());
        }
        const rowSpans = this._spannedCells.get(row);
        rowSpans.set(column, data);
      }
      /**
      * Checks if part of the table can be skipped.
      */
      _canJumpToStartRow() {
        return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
      }
      /**
      * Sets the current row to `this._startRow` or the first row before it that has the number of cells
      * equal to the number of columns in the table.
      *
      * Example:
      * 	+----+----+----+
      *  | 00 | 01 | 02 |
      *  |----+----+----+
      *  | 10      | 12 |
      *  |         +----+
      *  |         | 22 |
      *  |         +----+
      *  |         | 32 | <--- Start row
      *  +----+----+----+
      *  | 40 | 41 | 42 |
      *  +----+----+----+
      *
      * If the 4th row is a `this._startRow`, this method will:
      * 1.) Count the number of columns this table has based on the first row (3 columns in this case).
      * 2.) Check if the 4th row contains 3 cells. It doesn't, so go to the row before it.
      * 3.) Check if the 3rd row contains 3 cells. It doesn't, so go to the row before it.
      * 4.) Check if the 2nd row contains 3 cells. It does, so set the current row to that row.
      *
      * Setting the current row this way is necessary to let the `next()`  method loop over the cells
      * spanning multiple rows or columns and update the `this._spannedCells` property.
      */
      _jumpToNonSpannedRowClosestToStartRow() {
        const firstRowLength = this._getRowLength(0);
        for (let i = this._startRow; !this._jumpedToStartRow; i--) {
          if (firstRowLength === this._getRowLength(i)) {
            this._row = i;
            this._rowIndex = i;
            this._jumpedToStartRow = true;
          }
        }
      }
      /**
      * Returns a number of columns in a row taking `colspan` into consideration.
      */
      _getRowLength(rowIndex) {
        const row = this._table.getChild(rowIndex);
        return [
          ...row.getChildren()
        ].reduce((cols, row2) => {
          return cols + parseInt(row2.getAttribute("colspan") || "1");
        }, 0);
      }
    }
    class TableSlot {
      /**
      * Creates an instance of the table walker value.
      *
      * @param tableWalker The table walker instance.
      * @param cell The current table cell.
      * @param anchorRow The row index of a cell anchor slot.
      * @param anchorColumn The column index of a cell anchor slot.
      */
      constructor(tableWalker, cell, anchorRow, anchorColumn) {
        /**
        * The current table cell.
        */
        __publicField(this, "cell");
        /**
        * The row index of a table slot.
        */
        __publicField(this, "row");
        /**
        * The column index of a table slot.
        */
        __publicField(this, "column");
        /**
        * The row index of a cell anchor slot.
        */
        __publicField(this, "cellAnchorRow");
        /**
        * The column index of a cell anchor slot.
        */
        __publicField(this, "cellAnchorColumn");
        /**
        * The index of the current cell in the parent row.
        */
        __publicField(this, "_cellIndex");
        /**
        * The index of the current row element in the table.
        */
        __publicField(this, "_rowIndex");
        /**
        * The table element.
        */
        __publicField(this, "_table");
        this.cell = cell;
        this.row = tableWalker._row;
        this.column = tableWalker._column;
        this.cellAnchorRow = anchorRow;
        this.cellAnchorColumn = anchorColumn;
        this._cellIndex = tableWalker._cellIndex;
        this._rowIndex = tableWalker._rowIndex;
        this._table = tableWalker._table;
      }
      // @if CK_DEBUG // public get isSpanned(): unknown { return throwMissingGetterError( 'isSpanned' ); }
      // @if CK_DEBUG // public get colspan(): unknown { return throwMissingGetterError( 'colspan' ); }
      // @if CK_DEBUG // public get rowspan(): unknown { return throwMissingGetterError( 'rowspan' ); }
      // @if CK_DEBUG // public get cellIndex(): unknown { return throwMissingGetterError( 'cellIndex' ); }
      /**
      * Whether the cell is anchored in the current slot.
      */
      get isAnchor() {
        return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
      }
      /**
      * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.
      */
      get cellWidth() {
        return parseInt(this.cell.getAttribute("colspan") || "1");
      }
      /**
      * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.
      */
      get cellHeight() {
        return parseInt(this.cell.getAttribute("rowspan") || "1");
      }
      /**
      * The index of the current row element in the table.
      */
      get rowIndex() {
        return this._rowIndex;
      }
      /**
      * Returns the {@link module:engine/model/position~Position} before the table slot.
      */
      getPositionBefore() {
        const model = this._table.root.document.model;
        return model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
      }
    }
    function downcastTable(tableUtils, options) {
      return (table2, { writer }) => {
        const headingRows = table2.getAttribute("headingRows") || 0;
        const tableElement = writer.createContainerElement("table", null, []);
        const figureElement = writer.createContainerElement("figure", {
          class: "table"
        }, tableElement);
        if (headingRows > 0) {
          writer.insert(writer.createPositionAt(tableElement, "end"), writer.createContainerElement("thead", null, writer.createSlot((element) => element.is("element", "tableRow") && element.index < headingRows)));
        }
        if (headingRows < tableUtils.getRows(table2)) {
          writer.insert(writer.createPositionAt(tableElement, "end"), writer.createContainerElement("tbody", null, writer.createSlot((element) => element.is("element", "tableRow") && element.index >= headingRows)));
        }
        for (const { positionOffset, filter } of options.additionalSlots) {
          writer.insert(writer.createPositionAt(tableElement, positionOffset), writer.createSlot(filter));
        }
        writer.insert(writer.createPositionAt(tableElement, "after"), writer.createSlot((element) => {
          if (element.is("element", "tableRow")) {
            return false;
          }
          return !options.additionalSlots.some(({ filter }) => filter(element));
        }));
        return options.asWidget ? toTableWidget(figureElement, writer) : figureElement;
      };
    }
    function downcastRow() {
      return (tableRow, { writer }) => {
        return tableRow.isEmpty ? writer.createEmptyElement("tr") : writer.createContainerElement("tr");
      };
    }
    function downcastCell(options = {}) {
      return (tableCell, { writer }) => {
        const tableRow = tableCell.parent;
        const table2 = tableRow.parent;
        const rowIndex = table2.getChildIndex(tableRow);
        const tableWalker = new TableWalker(table2, {
          row: rowIndex
        });
        const headingRows = table2.getAttribute("headingRows") || 0;
        const headingColumns = table2.getAttribute("headingColumns") || 0;
        let result = null;
        for (const tableSlot of tableWalker) {
          if (tableSlot.cell == tableCell) {
            const isHeading = tableSlot.row < headingRows || tableSlot.column < headingColumns;
            const cellElementName = isHeading ? "th" : "td";
            result = options.asWidget ? toWidgetEditable(writer.createEditableElement(cellElementName), writer) : writer.createContainerElement(cellElementName);
            break;
          }
        }
        return result;
      };
    }
    function convertParagraphInTableCell(options = {}) {
      return (modelElement, { writer }) => {
        if (!modelElement.parent.is("element", "tableCell")) {
          return null;
        }
        if (!isSingleParagraphWithoutAttributes(modelElement)) {
          return null;
        }
        if (options.asWidget) {
          return writer.createContainerElement("span", {
            class: "ck-table-bogus-paragraph"
          });
        } else {
          const viewElement = writer.createContainerElement("p");
          writer.setCustomProperty("dataPipeline:transparentRendering", true, viewElement);
          return viewElement;
        }
      };
    }
    function isSingleParagraphWithoutAttributes(modelElement) {
      const tableCell = modelElement.parent;
      const isSingleParagraph = tableCell.childCount == 1;
      return isSingleParagraph && !hasAnyAttribute(modelElement);
    }
    function toTableWidget(viewElement, writer) {
      writer.setCustomProperty("table", true, viewElement);
      return toWidget(viewElement, writer, {
        hasSelectionHandle: true
      });
    }
    function hasAnyAttribute(element) {
      const iteratorItem = element.getAttributeKeys().next();
      return !iteratorItem.done;
    }
    class InsertTableCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const selection = model.document.selection;
        const schema = model.schema;
        this.isEnabled = isAllowedInParent(selection, schema);
      }
      /**
      * Executes the command.
      *
      * Inserts a table with the given number of rows and columns into the editor.
      *
      * @param options.rows The number of rows to create in the inserted table. Default value is 2.
      * @param options.columns The number of columns to create in the inserted table. Default value is 2.
      * @param options.headingRows The number of heading rows. If not provided it will default to
      * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.rows`} table config.
      * @param options.headingColumns The number of heading columns. If not provided it will default to
      * {@link module:table/tableconfig~TableConfig#defaultHeadings `config.table.defaultHeadings.columns`} table config.
      * @fires execute
      */
      execute(options = {}) {
        const editor = this.editor;
        const model = editor.model;
        const tableUtils = editor.plugins.get("TableUtils");
        const defaultRows = editor.config.get("table.defaultHeadings.rows");
        const defaultColumns = editor.config.get("table.defaultHeadings.columns");
        if (options.headingRows === void 0 && defaultRows) {
          options.headingRows = defaultRows;
        }
        if (options.headingColumns === void 0 && defaultColumns) {
          options.headingColumns = defaultColumns;
        }
        model.change((writer) => {
          const table2 = tableUtils.createTable(writer, options);
          model.insertObject(table2, null, null, {
            findOptimalPosition: "auto"
          });
          writer.setSelection(writer.createPositionAt(table2.getNodeByPath([
            0,
            0,
            0
          ]), 0));
        });
      }
    }
    function isAllowedInParent(selection, schema) {
      const positionParent = selection.getFirstPosition().parent;
      const validParent = positionParent === positionParent.root ? positionParent : positionParent.parent;
      return schema.checkChild(validParent, "table");
    }
    class InsertRowCommand extends Command {
      /**
      * Creates a new `InsertRowCommand` instance.
      *
      * @param editor The editor on which this command will be used.
      * @param options.order The order of insertion relative to the row in which the caret is located.
      * Possible values: `"above"` and `"below"`. Default value is "below"
      */
      constructor(editor, options = {}) {
        super(editor);
        /**
        * The order of insertion relative to the row in which the caret is located.
        */
        __publicField(this, "order");
        this.order = options.order || "below";
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const selection = this.editor.model.document.selection;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const isAnyCellSelected = !!tableUtils.getSelectionAffectedTableCells(selection).length;
        this.isEnabled = isAnyCellSelected;
      }
      /**
      * Executes the command.
      *
      * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.
      *
      * @fires execute
      */
      execute() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        const tableUtils = editor.plugins.get("TableUtils");
        const insertAbove = this.order === "above";
        const affectedTableCells = tableUtils.getSelectionAffectedTableCells(selection);
        const rowIndexes = tableUtils.getRowIndexes(affectedTableCells);
        const row = insertAbove ? rowIndexes.first : rowIndexes.last;
        const table2 = affectedTableCells[0].findAncestor("table");
        tableUtils.insertRows(table2, {
          at: insertAbove ? row : row + 1,
          copyStructureFromAbove: !insertAbove
        });
      }
    }
    class InsertColumnCommand extends Command {
      /**
      * Creates a new `InsertColumnCommand` instance.
      *
      * @param editor An editor on which this command will be used.
      * @param options.order The order of insertion relative to the column in which the caret is located.
      * Possible values: `"left"` and `"right"`. Default value is "right".
      */
      constructor(editor, options = {}) {
        super(editor);
        /**
        * The order of insertion relative to the column in which the caret is located.
        */
        __publicField(this, "order");
        this.order = options.order || "right";
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const selection = this.editor.model.document.selection;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const isAnyCellSelected = !!tableUtils.getSelectionAffectedTableCells(selection).length;
        this.isEnabled = isAnyCellSelected;
      }
      /**
      * Executes the command.
      *
      * Depending on the command's {@link #order} value, it inserts a column to the `'left'` or `'right'` of the column
      * in which the selection is set.
      *
      * @fires execute
      */
      execute() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        const tableUtils = editor.plugins.get("TableUtils");
        const insertBefore = this.order === "left";
        const affectedTableCells = tableUtils.getSelectionAffectedTableCells(selection);
        const columnIndexes = tableUtils.getColumnIndexes(affectedTableCells);
        const column = insertBefore ? columnIndexes.first : columnIndexes.last;
        const table2 = affectedTableCells[0].findAncestor("table");
        tableUtils.insertColumns(table2, {
          columns: 1,
          at: insertBefore ? column : column + 1
        });
      }
    }
    class SplitCellCommand extends Command {
      /**
      * Creates a new `SplitCellCommand` instance.
      *
      * @param editor The editor on which this command will be used.
      * @param options.direction Indicates whether the command should split cells `'horizontally'` or `'vertically'`.
      */
      constructor(editor, options = {}) {
        super(editor);
        /**
        * The direction that indicates which cell will be split.
        */
        __publicField(this, "direction");
        this.direction = options.direction || "horizontally";
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
        this.isEnabled = selectedCells.length === 1;
      }
      /**
      * @inheritDoc
      */
      execute() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const tableCell = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
        const isHorizontal = this.direction === "horizontally";
        if (isHorizontal) {
          tableUtils.splitCellHorizontally(tableCell, 2);
        } else {
          tableUtils.splitCellVertically(tableCell, 2);
        }
      }
    }
    function cropTableToDimensions(sourceTable, cropDimensions, writer) {
      const { startRow, startColumn, endRow, endColumn } = cropDimensions;
      const croppedTable = writer.createElement("table");
      const cropHeight = endRow - startRow + 1;
      for (let i = 0; i < cropHeight; i++) {
        writer.insertElement("tableRow", croppedTable, "end");
      }
      const tableMap = [
        ...new TableWalker(sourceTable, {
          startRow,
          endRow,
          startColumn,
          endColumn,
          includeAllSlots: true
        })
      ];
      for (const { row: sourceRow, column: sourceColumn, cell: tableCell, isAnchor, cellAnchorRow, cellAnchorColumn } of tableMap) {
        const rowInCroppedTable = sourceRow - startRow;
        const row = croppedTable.getChild(rowInCroppedTable);
        if (!isAnchor) {
          if (cellAnchorRow < startRow || cellAnchorColumn < startColumn) {
            createEmptyTableCell(writer, writer.createPositionAt(row, "end"));
          }
        } else {
          const tableCellCopy = writer.cloneElement(tableCell);
          writer.append(tableCellCopy, row);
          trimTableCellIfNeeded(tableCellCopy, sourceRow, sourceColumn, endRow, endColumn, writer);
        }
      }
      addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer);
      return croppedTable;
    }
    function getVerticallyOverlappingCells(table2, overlapRow, startRow = 0) {
      const cells = [];
      const tableWalker = new TableWalker(table2, {
        startRow,
        endRow: overlapRow - 1
      });
      for (const slotInfo of tableWalker) {
        const { row, cellHeight } = slotInfo;
        const cellEndRow = row + cellHeight - 1;
        if (row < overlapRow && overlapRow <= cellEndRow) {
          cells.push(slotInfo);
        }
      }
      return cells;
    }
    function splitHorizontally(tableCell, splitRow, writer) {
      const tableRow = tableCell.parent;
      const table2 = tableRow.parent;
      const rowIndex = tableRow.index;
      const rowspan = parseInt(tableCell.getAttribute("rowspan"));
      const newRowspan = splitRow - rowIndex;
      const newCellAttributes = {};
      const newCellRowSpan = rowspan - newRowspan;
      if (newCellRowSpan > 1) {
        newCellAttributes.rowspan = newCellRowSpan;
      }
      const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
      if (colspan > 1) {
        newCellAttributes.colspan = colspan;
      }
      const startRow = rowIndex;
      const endRow = startRow + newRowspan;
      const tableMap = [
        ...new TableWalker(table2, {
          startRow,
          endRow,
          includeAllSlots: true
        })
      ];
      let newCell = null;
      let columnIndex;
      for (const tableSlot of tableMap) {
        const { row, column, cell } = tableSlot;
        if (cell === tableCell && columnIndex === void 0) {
          columnIndex = column;
        }
        if (columnIndex !== void 0 && columnIndex === column && row === endRow) {
          newCell = createEmptyTableCell(writer, tableSlot.getPositionBefore(), newCellAttributes);
        }
      }
      updateNumericAttribute("rowspan", newRowspan, tableCell, writer);
      return newCell;
    }
    function getHorizontallyOverlappingCells(table2, overlapColumn) {
      const cellsToSplit = [];
      const tableWalker = new TableWalker(table2);
      for (const slotInfo of tableWalker) {
        const { column, cellWidth } = slotInfo;
        const cellEndColumn = column + cellWidth - 1;
        if (column < overlapColumn && overlapColumn <= cellEndColumn) {
          cellsToSplit.push(slotInfo);
        }
      }
      return cellsToSplit;
    }
    function splitVertically(tableCell, columnIndex, splitColumn, writer) {
      const colspan = parseInt(tableCell.getAttribute("colspan"));
      const newColspan = splitColumn - columnIndex;
      const newCellAttributes = {};
      const newCellColSpan = colspan - newColspan;
      if (newCellColSpan > 1) {
        newCellAttributes.colspan = newCellColSpan;
      }
      const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
      if (rowspan > 1) {
        newCellAttributes.rowspan = rowspan;
      }
      const newCell = createEmptyTableCell(writer, writer.createPositionAfter(tableCell), newCellAttributes);
      updateNumericAttribute("colspan", newColspan, tableCell, writer);
      return newCell;
    }
    function trimTableCellIfNeeded(tableCell, cellRow, cellColumn, limitRow, limitColumn, writer) {
      const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
      const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
      const endColumn = cellColumn + colspan - 1;
      if (endColumn > limitColumn) {
        const trimmedSpan = limitColumn - cellColumn + 1;
        updateNumericAttribute("colspan", trimmedSpan, tableCell, writer, 1);
      }
      const endRow = cellRow + rowspan - 1;
      if (endRow > limitRow) {
        const trimmedSpan = limitRow - cellRow + 1;
        updateNumericAttribute("rowspan", trimmedSpan, tableCell, writer, 1);
      }
    }
    function addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer) {
      const headingRows = parseInt(sourceTable.getAttribute("headingRows") || "0");
      if (headingRows > 0) {
        const headingRowsInCrop = headingRows - startRow;
        updateNumericAttribute("headingRows", headingRowsInCrop, croppedTable, writer, 0);
      }
      const headingColumns = parseInt(sourceTable.getAttribute("headingColumns") || "0");
      if (headingColumns > 0) {
        const headingColumnsInCrop = headingColumns - startColumn;
        updateNumericAttribute("headingColumns", headingColumnsInCrop, croppedTable, writer, 0);
      }
    }
    function removeEmptyColumns(table2, tableUtils) {
      const width = tableUtils.getColumns(table2);
      const columnsMap = new Array(width).fill(0);
      for (const { column } of new TableWalker(table2)) {
        columnsMap[column]++;
      }
      const emptyColumns = columnsMap.reduce((result, cellsCount, column) => {
        return cellsCount ? result : [
          ...result,
          column
        ];
      }, []);
      if (emptyColumns.length > 0) {
        const emptyColumn = emptyColumns[emptyColumns.length - 1];
        tableUtils.removeColumns(table2, {
          at: emptyColumn
        });
        return true;
      }
      return false;
    }
    function removeEmptyRows(table2, tableUtils) {
      const emptyRows = [];
      const tableRowCount = tableUtils.getRows(table2);
      for (let rowIndex = 0; rowIndex < tableRowCount; rowIndex++) {
        const tableRow = table2.getChild(rowIndex);
        if (tableRow.isEmpty) {
          emptyRows.push(rowIndex);
        }
      }
      if (emptyRows.length > 0) {
        const emptyRow = emptyRows[emptyRows.length - 1];
        tableUtils.removeRows(table2, {
          at: emptyRow
        });
        return true;
      }
      return false;
    }
    function removeEmptyRowsColumns(table2, tableUtils) {
      const removedColumns = removeEmptyColumns(table2, tableUtils);
      if (!removedColumns) {
        removeEmptyRows(table2, tableUtils);
      }
    }
    function adjustLastRowIndex(table2, dimensions) {
      const lastRowMap = Array.from(new TableWalker(table2, {
        startColumn: dimensions.firstColumn,
        endColumn: dimensions.lastColumn,
        row: dimensions.lastRow
      }));
      const everyCellHasSingleRowspan = lastRowMap.every(({ cellHeight }) => cellHeight === 1);
      if (everyCellHasSingleRowspan) {
        return dimensions.lastRow;
      }
      const rowspanAdjustment = lastRowMap[0].cellHeight - 1;
      return dimensions.lastRow + rowspanAdjustment;
    }
    function adjustLastColumnIndex(table2, dimensions) {
      const lastColumnMap = Array.from(new TableWalker(table2, {
        startRow: dimensions.firstRow,
        endRow: dimensions.lastRow,
        column: dimensions.lastColumn
      }));
      const everyCellHasSingleColspan = lastColumnMap.every(({ cellWidth }) => cellWidth === 1);
      if (everyCellHasSingleColspan) {
        return dimensions.lastColumn;
      }
      const colspanAdjustment = lastColumnMap[0].cellWidth - 1;
      return dimensions.lastColumn + colspanAdjustment;
    }
    class MergeCellCommand extends Command {
      /**
      * Creates a new `MergeCellCommand` instance.
      *
      * @param editor The editor on which this command will be used.
      * @param options.direction Indicates which cell to merge with the currently selected one.
      * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.
      */
      constructor(editor, options) {
        super(editor);
        /**
        * The direction that indicates which cell will be merged with the currently selected one.
        */
        __publicField(this, "direction");
        /**
        * Whether the merge is horizontal (left/right) or vertical (up/down).
        */
        __publicField(this, "isHorizontal");
        this.direction = options.direction;
        this.isHorizontal = this.direction == "right" || this.direction == "left";
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const cellToMerge = this._getMergeableCell();
        this.value = cellToMerge;
        this.isEnabled = !!cellToMerge;
      }
      /**
      * Executes the command.
      *
      * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.
      *
      * @fires execute
      */
      execute() {
        const model = this.editor.model;
        const doc = model.document;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const tableCell = tableUtils.getTableCellsContainingSelection(doc.selection)[0];
        const cellToMerge = this.value;
        const direction = this.direction;
        model.change((writer) => {
          const isMergeNext = direction == "right" || direction == "down";
          const cellToExpand = isMergeNext ? tableCell : cellToMerge;
          const cellToRemove = isMergeNext ? cellToMerge : tableCell;
          const removedTableCellRow = cellToRemove.parent;
          mergeTableCells$1(cellToRemove, cellToExpand, writer);
          const spanAttribute = this.isHorizontal ? "colspan" : "rowspan";
          const cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || "1");
          const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || "1");
          writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);
          writer.setSelection(writer.createRangeIn(cellToExpand));
          const tableUtils2 = this.editor.plugins.get("TableUtils");
          const table2 = removedTableCellRow.findAncestor("table");
          removeEmptyRowsColumns(table2, tableUtils2);
        });
      }
      /**
      * Returns a cell that can be merged with the current cell depending on the command's direction.
      */
      _getMergeableCell() {
        const model = this.editor.model;
        const doc = model.document;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const tableCell = tableUtils.getTableCellsContainingSelection(doc.selection)[0];
        if (!tableCell) {
          return;
        }
        const cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction, tableUtils);
        if (!cellToMerge) {
          return;
        }
        const spanAttribute = this.isHorizontal ? "rowspan" : "colspan";
        const span = parseInt(tableCell.getAttribute(spanAttribute) || "1");
        const cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || "1");
        if (cellToMergeSpan === span) {
          return cellToMerge;
        }
      }
    }
    function getHorizontalCell(tableCell, direction, tableUtils) {
      const tableRow = tableCell.parent;
      const table2 = tableRow.parent;
      const horizontalCell = direction == "right" ? tableCell.nextSibling : tableCell.previousSibling;
      const hasHeadingColumns = (table2.getAttribute("headingColumns") || 0) > 0;
      if (!horizontalCell) {
        return;
      }
      const cellOnLeft = direction == "right" ? tableCell : horizontalCell;
      const cellOnRight = direction == "right" ? horizontalCell : tableCell;
      const { column: leftCellColumn } = tableUtils.getCellLocation(cellOnLeft);
      const { column: rightCellColumn } = tableUtils.getCellLocation(cellOnRight);
      const leftCellSpan = parseInt(cellOnLeft.getAttribute("colspan") || "1");
      const isCellOnLeftInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnLeft);
      const isCellOnRightInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnRight);
      if (hasHeadingColumns && isCellOnLeftInHeadingColumn != isCellOnRightInHeadingColumn) {
        return;
      }
      const cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn;
      return cellsAreTouching ? horizontalCell : void 0;
    }
    function getVerticalCell(tableCell, direction, tableUtils) {
      const tableRow = tableCell.parent;
      const table2 = tableRow.parent;
      const rowIndex = table2.getChildIndex(tableRow);
      if (direction == "down" && rowIndex === tableUtils.getRows(table2) - 1 || direction == "up" && rowIndex === 0) {
        return null;
      }
      const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
      const headingRows = table2.getAttribute("headingRows") || 0;
      const isMergeWithBodyCell = direction == "down" && rowIndex + rowspan === headingRows;
      const isMergeWithHeadCell = direction == "up" && rowIndex === headingRows;
      if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {
        return null;
      }
      const currentCellRowSpan = parseInt(tableCell.getAttribute("rowspan") || "1");
      const rowOfCellToMerge = direction == "down" ? rowIndex + currentCellRowSpan : rowIndex;
      const tableMap = [
        ...new TableWalker(table2, {
          endRow: rowOfCellToMerge
        })
      ];
      const currentCellData = tableMap.find((value) => value.cell === tableCell);
      const mergeColumn = currentCellData.column;
      const cellToMergeData = tableMap.find(({ row, cellHeight, column }) => {
        if (column !== mergeColumn) {
          return false;
        }
        if (direction == "down") {
          return row === rowOfCellToMerge;
        } else {
          return rowOfCellToMerge === row + cellHeight;
        }
      });
      return cellToMergeData && cellToMergeData.cell ? cellToMergeData.cell : null;
    }
    function mergeTableCells$1(cellToRemove, cellToExpand, writer) {
      if (!isEmpty$2(cellToRemove)) {
        if (isEmpty$2(cellToExpand)) {
          writer.remove(writer.createRangeIn(cellToExpand));
        }
        writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, "end"));
      }
      writer.remove(cellToRemove);
    }
    function isEmpty$2(tableCell) {
      const firstTableChild = tableCell.getChild(0);
      return tableCell.childCount == 1 && firstTableChild.is("element", "paragraph") && firstTableChild.isEmpty;
    }
    class RemoveRowCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
        const firstCell = selectedCells[0];
        if (firstCell) {
          const table2 = firstCell.findAncestor("table");
          const tableRowCount = tableUtils.getRows(table2);
          const lastRowIndex = tableRowCount - 1;
          const selectedRowIndexes = tableUtils.getRowIndexes(selectedCells);
          const areAllRowsSelected = selectedRowIndexes.first === 0 && selectedRowIndexes.last === lastRowIndex;
          this.isEnabled = !areAllRowsSelected;
        } else {
          this.isEnabled = false;
        }
      }
      /**
      * @inheritDoc
      */
      execute() {
        const model = this.editor.model;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const removedRowIndexes = tableUtils.getRowIndexes(referenceCells);
        const firstCell = referenceCells[0];
        const table2 = firstCell.findAncestor("table");
        const columnIndexToFocus = tableUtils.getCellLocation(firstCell).column;
        model.change((writer) => {
          const rowsToRemove = removedRowIndexes.last - removedRowIndexes.first + 1;
          tableUtils.removeRows(table2, {
            at: removedRowIndexes.first,
            rows: rowsToRemove
          });
          const cellToFocus = getCellToFocus$1(table2, removedRowIndexes.first, columnIndexToFocus, tableUtils.getRows(table2));
          writer.setSelection(writer.createPositionAt(cellToFocus, 0));
        });
      }
    }
    function getCellToFocus$1(table2, removedRowIndex, columnToFocus, tableRowCount) {
      const row = table2.getChild(Math.min(removedRowIndex, tableRowCount - 1));
      let cellToFocus = row.getChild(0);
      let column = 0;
      for (const tableCell of row.getChildren()) {
        if (column > columnToFocus) {
          return cellToFocus;
        }
        cellToFocus = tableCell;
        column += parseInt(tableCell.getAttribute("colspan") || "1");
      }
      return cellToFocus;
    }
    class RemoveColumnCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
        const firstCell = selectedCells[0];
        if (firstCell) {
          const table2 = firstCell.findAncestor("table");
          const tableColumnCount = tableUtils.getColumns(table2);
          const { first: first2, last: last2 } = tableUtils.getColumnIndexes(selectedCells);
          this.isEnabled = last2 - first2 < tableColumnCount - 1;
        } else {
          this.isEnabled = false;
        }
      }
      /**
      * @inheritDoc
      */
      execute() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const [firstCell, lastCell] = getBoundaryCells(this.editor.model.document.selection, tableUtils);
        const table2 = firstCell.parent.parent;
        const tableMap = [
          ...new TableWalker(table2)
        ];
        const removedColumnIndexes = {
          first: tableMap.find((value) => value.cell === firstCell).column,
          last: tableMap.find((value) => value.cell === lastCell).column
        };
        const cellToFocus = getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes);
        this.editor.model.change((writer) => {
          const columnsToRemove = removedColumnIndexes.last - removedColumnIndexes.first + 1;
          tableUtils.removeColumns(table2, {
            at: removedColumnIndexes.first,
            columns: columnsToRemove
          });
          writer.setSelection(writer.createPositionAt(cellToFocus, 0));
        });
      }
    }
    function getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes) {
      const colspan = parseInt(lastCell.getAttribute("colspan") || "1");
      if (colspan > 1) {
        return lastCell;
      } else if (firstCell.previousSibling || lastCell.nextSibling) {
        return lastCell.nextSibling || firstCell.previousSibling;
      } else {
        if (removedColumnIndexes.first) {
          return tableMap.reverse().find(({ column }) => {
            return column < removedColumnIndexes.first;
          }).cell;
        } else {
          return tableMap.reverse().find(({ column }) => {
            return column > removedColumnIndexes.last;
          }).cell;
        }
      }
    }
    function getBoundaryCells(selection, tableUtils) {
      const referenceCells = tableUtils.getSelectionAffectedTableCells(selection);
      const firstCell = referenceCells[0];
      const lastCell = referenceCells.pop();
      const returnValue = [
        firstCell,
        lastCell
      ];
      return firstCell.isBefore(lastCell) ? returnValue : returnValue.reverse();
    }
    class SetHeaderRowCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const model = this.editor.model;
        const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const isInTable = selectedCells.length > 0;
        this.isEnabled = isInTable;
        this.value = isInTable && selectedCells.every((cell) => this._isInHeading(cell, cell.parent.parent));
      }
      /**
      * Executes the command.
      *
      * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.
      *
      * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.
      *
      * @fires execute
      * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header rows according to
      * the `forceValue` parameter instead of the current model state.
      */
      execute(options = {}) {
        if (options.forceValue === this.value) {
          return;
        }
        const tableUtils = this.editor.plugins.get("TableUtils");
        const model = this.editor.model;
        const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const table2 = selectedCells[0].findAncestor("table");
        const { first: first2, last: last2 } = tableUtils.getRowIndexes(selectedCells);
        const headingRowsToSet = this.value ? first2 : last2 + 1;
        const currentHeadingRows = table2.getAttribute("headingRows") || 0;
        model.change((writer) => {
          if (headingRowsToSet) {
            const startRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0;
            const overlappingCells = getVerticallyOverlappingCells(table2, headingRowsToSet, startRow);
            for (const { cell } of overlappingCells) {
              splitHorizontally(cell, headingRowsToSet, writer);
            }
          }
          updateNumericAttribute("headingRows", headingRowsToSet, table2, writer, 0);
        });
      }
      /**
      * Checks if a table cell is in the heading section.
      */
      _isInHeading(tableCell, table2) {
        const headingRows = parseInt(table2.getAttribute("headingRows") || "0");
        return !!headingRows && tableCell.parent.index < headingRows;
      }
    }
    class SetHeaderColumnCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const model = this.editor.model;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const isInTable = selectedCells.length > 0;
        this.isEnabled = isInTable;
        this.value = isInTable && selectedCells.every((cell) => isHeadingColumnCell(tableUtils, cell));
      }
      /**
      * Executes the command.
      *
      * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.
      *
      * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.
      *
      * @fires execute
      * @param options.forceValue If set, the command will set (`true`) or unset (`false`) the header columns according to
      * the `forceValue` parameter instead of the current model state.
      */
      execute(options = {}) {
        if (options.forceValue === this.value) {
          return;
        }
        const tableUtils = this.editor.plugins.get("TableUtils");
        const model = this.editor.model;
        const selectedCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const table2 = selectedCells[0].findAncestor("table");
        const { first: first2, last: last2 } = tableUtils.getColumnIndexes(selectedCells);
        const headingColumnsToSet = this.value ? first2 : last2 + 1;
        model.change((writer) => {
          if (headingColumnsToSet) {
            const overlappingCells = getHorizontallyOverlappingCells(table2, headingColumnsToSet);
            for (const { cell, column } of overlappingCells) {
              splitVertically(cell, column, headingColumnsToSet, writer);
            }
          }
          updateNumericAttribute("headingColumns", headingColumnsToSet, table2, writer, 0);
        });
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const COLUMN_MIN_WIDTH_AS_PERCENTAGE = 5;
    const COLUMN_MIN_WIDTH_IN_PIXELS = 40;
    const COLUMN_WIDTH_PRECISION = 2;
    function getChangedResizedTables(model) {
      const affectedTables = /* @__PURE__ */ new Set();
      for (const change of model.document.differ.getChanges()) {
        let referencePosition = null;
        switch (change.type) {
          case "insert":
            referencePosition = [
              "table",
              "tableRow",
              "tableCell"
            ].includes(change.name) ? change.position : null;
            break;
          case "remove":
            referencePosition = [
              "tableRow",
              "tableCell"
            ].includes(change.name) ? change.position : null;
            break;
          case "attribute":
            if (change.range.start.nodeAfter) {
              referencePosition = [
                "table",
                "tableRow",
                "tableCell"
              ].includes(change.range.start.nodeAfter.name) ? change.range.start : null;
            }
            break;
        }
        if (!referencePosition) {
          continue;
        }
        const tableNode = referencePosition.nodeAfter && referencePosition.nodeAfter.is("element", "table") ? referencePosition.nodeAfter : referencePosition.findAncestor("table");
        for (const node of model.createRangeOn(tableNode).getItems()) {
          if (!node.is("element", "table")) {
            continue;
          }
          if (!getColumnGroupElement(node)) {
            continue;
          }
          affectedTables.add(node);
        }
      }
      return affectedTables;
    }
    function getColumnMinWidthAsPercentage(modelTable, editor) {
      return COLUMN_MIN_WIDTH_IN_PIXELS * 100 / getTableWidthInPixels(modelTable, editor);
    }
    function getTableWidthInPixels(modelTable, editor) {
      const referenceElement = getChildrenViewElement(modelTable, "tbody", editor) || getChildrenViewElement(modelTable, "thead", editor);
      const domReferenceElement = editor.editing.view.domConverter.mapViewToDom(referenceElement);
      return getElementWidthInPixels(domReferenceElement);
    }
    function getChildrenViewElement(modelTable, elementName, editor) {
      const viewFigure = editor.editing.mapper.toViewElement(modelTable);
      const viewTable = [
        ...viewFigure.getChildren()
      ].find((node) => node.is("element", "table"));
      return [
        ...viewTable.getChildren()
      ].find((node) => node.is("element", elementName));
    }
    function getElementWidthInPixels(domElement) {
      const styles = global$1.window.getComputedStyle(domElement);
      if (styles.boxSizing === "border-box") {
        return parseFloat(styles.width) - parseFloat(styles.paddingLeft) - parseFloat(styles.paddingRight) - parseFloat(styles.borderLeftWidth) - parseFloat(styles.borderRightWidth);
      } else {
        return parseFloat(styles.width);
      }
    }
    function getColumnEdgesIndexes(cell, tableUtils) {
      const cellColumnIndex = tableUtils.getCellLocation(cell).column;
      const cellWidth = cell.getAttribute("colspan") || 1;
      return {
        leftEdge: cellColumnIndex,
        rightEdge: cellColumnIndex + cellWidth - 1
      };
    }
    function toPrecision(value) {
      const multiplier = Math.pow(10, COLUMN_WIDTH_PRECISION);
      const number = typeof value === "number" ? value : parseFloat(value);
      return Math.round(number * multiplier) / multiplier;
    }
    function clamp(number, min, max) {
      if (number <= min) {
        return toPrecision(min);
      }
      if (number >= max) {
        return toPrecision(max);
      }
      return toPrecision(number);
    }
    function createFilledArray(length, value) {
      return Array(length).fill(value);
    }
    function sumArray(array) {
      return array.map((value) => typeof value === "number" ? value : parseFloat(value)).filter((value) => !Number.isNaN(value)).reduce((result, item) => result + item, 0);
    }
    function normalizeColumnWidths(columnWidths) {
      const widths = columnWidths.map((width) => {
        if (width === "auto") {
          return width;
        }
        return parseFloat(width.replace("%", ""));
      });
      let normalizedWidths = calculateMissingColumnWidths(widths);
      const totalWidth = sumArray(normalizedWidths);
      if (totalWidth !== 100) {
        normalizedWidths = normalizedWidths.map((width) => toPrecision(width * 100 / totalWidth)).map((columnWidth, columnIndex, width) => {
          const isLastColumn = columnIndex === width.length - 1;
          if (!isLastColumn) {
            return columnWidth;
          }
          const totalWidth2 = sumArray(width);
          return toPrecision(columnWidth + 100 - totalWidth2);
        });
      }
      return normalizedWidths.map((width) => width + "%");
    }
    function calculateMissingColumnWidths(columnWidths) {
      const numberOfUninitializedColumns = columnWidths.filter((columnWidth) => columnWidth === "auto").length;
      if (numberOfUninitializedColumns === 0) {
        return columnWidths.map((columnWidth) => toPrecision(columnWidth));
      }
      const totalWidthOfInitializedColumns = sumArray(columnWidths);
      const widthForUninitializedColumn = Math.max((100 - totalWidthOfInitializedColumns) / numberOfUninitializedColumns, COLUMN_MIN_WIDTH_AS_PERCENTAGE);
      return columnWidths.map((columnWidth) => columnWidth === "auto" ? widthForUninitializedColumn : columnWidth).map((columnWidth) => toPrecision(columnWidth));
    }
    function getDomCellOuterWidth(domCell) {
      const styles = global$1.window.getComputedStyle(domCell);
      if (styles.boxSizing === "border-box") {
        return parseInt(styles.width);
      } else {
        return parseFloat(styles.width) + parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight) + parseFloat(styles.borderWidth);
      }
    }
    function updateColumnElements(columns, tableColumnGroup, normalizedWidths, writer) {
      for (let i = 0; i < Math.max(normalizedWidths.length, columns.length); i++) {
        const column = columns[i];
        const columnWidth = normalizedWidths[i];
        if (!columnWidth) {
          writer.remove(column);
        } else if (!column) {
          writer.appendElement("tableColumn", {
            columnWidth
          }, tableColumnGroup);
        } else {
          writer.setAttribute("columnWidth", columnWidth, column);
        }
      }
    }
    function getColumnGroupElement(element) {
      if (element.is("element", "tableColumnGroup")) {
        return element;
      }
      const children = element.getChildren();
      return Array.from(children).find((element2) => element2.is("element", "tableColumnGroup"));
    }
    function getTableColumnElements(element) {
      const columnGroupElement = getColumnGroupElement(element);
      if (!columnGroupElement) {
        return [];
      }
      return Array.from(columnGroupElement.getChildren());
    }
    function getTableColumnsWidths(element) {
      return getTableColumnElements(element).map((column) => column.getAttribute("columnWidth"));
    }
    function translateColSpanAttribute(element, writer) {
      const tableColumnElements = getTableColumnElements(element);
      return tableColumnElements.reduce((acc, element2) => {
        const columnWidth = element2.getAttribute("columnWidth");
        const colSpan = element2.getAttribute("colSpan");
        if (!colSpan) {
          acc.push(columnWidth);
          return acc;
        }
        for (let i = 0; i < colSpan; i++) {
          acc.push(columnWidth);
        }
        writer.removeAttribute("colSpan", element2);
        return acc;
      }, []);
    }
    class TableUtils extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableUtils";
      }
      /**
      * @inheritDoc
      */
      init() {
        this.decorate("insertColumns");
        this.decorate("insertRows");
      }
      /**
      * Returns the table cell location as an object with table row and table column indexes.
      *
      * For instance, in the table below:
      *
      *      0   1   2   3
      *    +---+---+---+---+
      *  0 | a     | b | c |
      *    +       +   +---+
      *  1 |       |   | d |
      *    +---+---+   +---+
      *  2 | e     |   | f |
      *    +---+---+---+---+
      *
      * the method will return:
      *
      * ```ts
      * const cellA = table.getNodeByPath( [ 0, 0 ] );
      * editor.plugins.get( 'TableUtils' ).getCellLocation( cellA );
      * // will return { row: 0, column: 0 }
      *
      * const cellD = table.getNodeByPath( [ 1, 0 ] );
      * editor.plugins.get( 'TableUtils' ).getCellLocation( cellD );
      * // will return { row: 1, column: 3 }
      * ```
      *
      * @returns Returns a `{row, column}` object.
      */
      getCellLocation(tableCell) {
        const tableRow = tableCell.parent;
        const table2 = tableRow.parent;
        const rowIndex = table2.getChildIndex(tableRow);
        const tableWalker = new TableWalker(table2, {
          row: rowIndex
        });
        for (const { cell, row, column } of tableWalker) {
          if (cell === tableCell) {
            return {
              row,
              column
            };
          }
        }
        /* istanbul ignore next -- @preserve */
        return void 0;
      }
      /**
      * Creates an empty table with a proper structure. The table needs to be inserted into the model,
      * for example, by using the {@link module:engine/model/model~Model#insertContent} function.
      *
      * ```ts
      * model.change( ( writer ) => {
      *   // Create a table of 2 rows and 7 columns:
      *   const table = tableUtils.createTable( writer, { rows: 2, columns: 7 } );
      *
      *   // Insert a table to the model at the best position taking the current selection:
      *   model.insertContent( table );
      * }
      * ```
      *
      * @param writer The model writer.
      * @param options.rows The number of rows to create. Default value is 2.
      * @param options.columns The number of columns to create. Default value is 2.
      * @param options.headingRows The number of heading rows. Default value is 0.
      * @param options.headingColumns The number of heading columns. Default value is 0.
      * @returns The created table element.
      */
      createTable(writer, options) {
        const table2 = writer.createElement("table");
        const rows = options.rows || 2;
        const columns = options.columns || 2;
        createEmptyRows(writer, table2, 0, rows, columns);
        if (options.headingRows) {
          updateNumericAttribute("headingRows", Math.min(options.headingRows, rows), table2, writer, 0);
        }
        if (options.headingColumns) {
          updateNumericAttribute("headingColumns", Math.min(options.headingColumns, columns), table2, writer, 0);
        }
        return table2;
      }
      /**
      * Inserts rows into a table.
      *
      * ```ts
      * editor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );
      * ```
      *
      * Assuming the table on the left, the above code will transform it to the table on the right:
      *
      *  row index
      *    0 +---+---+---+       `at` = 1,      +---+---+---+ 0
      *      | a | b | c |       `rows` = 2,    | a | b | c |
      *    1 +   +---+---+   <-- insert here    +   +---+---+ 1
      *      |   | d | e |                      |   |   |   |
      *    2 +   +---+---+       will give:     +   +---+---+ 2
      *      |   | f | g |                      |   |   |   |
      *    3 +---+---+---+                      +   +---+---+ 3
      *                                         |   | d | e |
      *                                         +   +---+---+ 4
      *                                         +   + f | g |
      *                                         +---+---+---+ 5
      *
      * @param table The table model element where the rows will be inserted.
      * @param options.at The row index at which the rows will be inserted.  Default value is 0.
      * @param options.rows The number of rows to insert.  Default value is 1.
      * @param options.copyStructureFromAbove The flag for copying row structure. Note that
      * the row structure will not be copied if this option is not provided.
      */
      insertRows(table2, options = {}) {
        const model = this.editor.model;
        const insertAt2 = options.at || 0;
        const rowsToInsert = options.rows || 1;
        const isCopyStructure = options.copyStructureFromAbove !== void 0;
        const copyStructureFrom = options.copyStructureFromAbove ? insertAt2 - 1 : insertAt2;
        const rows = this.getRows(table2);
        const columns = this.getColumns(table2);
        if (insertAt2 > rows) {
          throw new CKEditorError("tableutils-insertrows-insert-out-of-range", this, {
            options
          });
        }
        model.change((writer) => {
          const headingRows = table2.getAttribute("headingRows") || 0;
          if (headingRows > insertAt2) {
            updateNumericAttribute("headingRows", headingRows + rowsToInsert, table2, writer, 0);
          }
          if (!isCopyStructure && (insertAt2 === 0 || insertAt2 === rows)) {
            createEmptyRows(writer, table2, insertAt2, rowsToInsert, columns);
            return;
          }
          const walkerEndRow = isCopyStructure ? Math.max(insertAt2, copyStructureFrom) : insertAt2;
          const tableIterator = new TableWalker(table2, {
            endRow: walkerEndRow
          });
          const rowColSpansMap = new Array(columns).fill(1);
          for (const { row, column, cellHeight, cellWidth, cell } of tableIterator) {
            const lastCellRow = row + cellHeight - 1;
            const isOverlappingInsertedRow = row < insertAt2 && insertAt2 <= lastCellRow;
            const isReferenceRow = row <= copyStructureFrom && copyStructureFrom <= lastCellRow;
            if (isOverlappingInsertedRow) {
              writer.setAttribute("rowspan", cellHeight + rowsToInsert, cell);
              rowColSpansMap[column] = -cellWidth;
            } else if (isCopyStructure && isReferenceRow) {
              rowColSpansMap[column] = cellWidth;
            }
          }
          for (let rowIndex = 0; rowIndex < rowsToInsert; rowIndex++) {
            const tableRow = writer.createElement("tableRow");
            writer.insert(tableRow, table2, insertAt2);
            for (let cellIndex = 0; cellIndex < rowColSpansMap.length; cellIndex++) {
              const colspan = rowColSpansMap[cellIndex];
              const insertPosition = writer.createPositionAt(tableRow, "end");
              if (colspan > 0) {
                createEmptyTableCell(writer, insertPosition, colspan > 1 ? {
                  colspan
                } : void 0);
              }
              cellIndex += Math.abs(colspan) - 1;
            }
          }
        });
      }
      /**
      * Inserts columns into a table.
      *
      * ```ts
      * editor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );
      * ```
      *
      * Assuming the table on the left, the above code will transform it to the table on the right:
      *
      *  0   1   2   3                   0   1   2   3   4   5
      *  +---+---+---+                   +---+---+---+---+---+
      *  | a     | b |                   | a             | b |
      *  +       +---+                   +               +---+
      *  |       | c |                   |               | c |
      *  +---+---+---+     will give:    +---+---+---+---+---+
      *  | d | e | f |                   | d |   |   | e | f |
      *  +---+   +---+                   +---+---+---+   +---+
      *  | g |   | h |                   | g |   |   |   | h |
      *  +---+---+---+                   +---+---+---+---+---+
      *  | i         |                   | i                 |
      *  +---+---+---+                   +---+---+---+---+---+
      *      ^---- insert here, `at` = 1, `columns` = 2
      *
      * @param table The table model element where the columns will be inserted.
      * @param options.at The column index at which the columns will be inserted. Default value is 0.
      * @param options.columns The number of columns to insert. Default value is 1.
      */
      insertColumns(table2, options = {}) {
        const model = this.editor.model;
        const insertAt2 = options.at || 0;
        const columnsToInsert = options.columns || 1;
        model.change((writer) => {
          const headingColumns = table2.getAttribute("headingColumns");
          if (insertAt2 < headingColumns) {
            writer.setAttribute("headingColumns", headingColumns + columnsToInsert, table2);
          }
          const tableColumns = this.getColumns(table2);
          if (insertAt2 === 0 || tableColumns === insertAt2) {
            for (const tableRow of table2.getChildren()) {
              if (!tableRow.is("element", "tableRow")) {
                continue;
              }
              createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt2 ? "end" : 0));
            }
            return;
          }
          const tableWalker = new TableWalker(table2, {
            column: insertAt2,
            includeAllSlots: true
          });
          for (const tableSlot of tableWalker) {
            const { row, cell, cellAnchorColumn, cellAnchorRow, cellWidth, cellHeight } = tableSlot;
            if (cellAnchorColumn < insertAt2) {
              writer.setAttribute("colspan", cellWidth + columnsToInsert, cell);
              const lastCellRow = cellAnchorRow + cellHeight - 1;
              for (let i = row; i <= lastCellRow; i++) {
                tableWalker.skipRow(i);
              }
            } else {
              createCells(columnsToInsert, writer, tableSlot.getPositionBefore());
            }
          }
        });
      }
      /**
      * Removes rows from the given `table`.
      *
      * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows
      * and table headings values.
      *
      * ```ts
      * editor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );
      * ```
      *
      * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
      *
      *  row index
      *      ┌───┬───┬───┐        `at` = 1        ┌───┬───┬───┐
      *    0 │ a │ b │ c │        `rows` = 2      │ a │ b │ c │ 0
      *      │   ├───┼───┤                        │   ├───┼───┤
      *    1 │   │ d │ e │  <-- remove from here  │   │ d │ g │ 1
      *      │   │   ├───┤        will give:      ├───┼───┼───┤
      *    2 │   │   │ f │                        │ h │ i │ j │ 2
      *      │   │   ├───┤                        └───┴───┴───┘
      *    3 │   │   │ g │
      *      ├───┼───┼───┤
      *    4 │ h │ i │ j │
      *      └───┴───┴───┘
      *
      * @param options.at The row index at which the removing rows will start.
      * @param options.rows The number of rows to remove. Default value is 1.
      */
      removeRows(table2, options) {
        const model = this.editor.model;
        const rowsToRemove = options.rows || 1;
        const rowCount = this.getRows(table2);
        const first2 = options.at;
        const last2 = first2 + rowsToRemove - 1;
        if (last2 > rowCount - 1) {
          throw new CKEditorError("tableutils-removerows-row-index-out-of-range", this, {
            table: table2,
            options
          });
        }
        model.change((writer) => {
          const indexesObject = {
            first: first2,
            last: last2
          };
          const { cellsToMove, cellsToTrim } = getCellsToMoveAndTrimOnRemoveRow(table2, indexesObject);
          if (cellsToMove.size) {
            const rowAfterRemovedSection = last2 + 1;
            moveCellsToRow(table2, rowAfterRemovedSection, cellsToMove, writer);
          }
          for (let i = last2; i >= first2; i--) {
            writer.remove(table2.getChild(i));
          }
          for (const { rowspan, cell } of cellsToTrim) {
            updateNumericAttribute("rowspan", rowspan, cell, writer);
          }
          updateHeadingRows(table2, indexesObject, writer);
          if (!removeEmptyColumns(table2, this)) {
            removeEmptyRows(table2, this);
          }
        });
      }
      /**
      * Removes columns from the given `table`.
      *
      * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns
      * and table headings values.
      *
      * ```ts
      * editor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );
      * ```
      *
      * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
      *
      *    0   1   2   3   4                       0   1   2
      *  ┌───────────────┬───┐                   ┌───────┬───┐
      *  │ a             │ b │                   │ a     │ b │
      *  │               ├───┤                   │       ├───┤
      *  │               │ c │                   │       │ c │
      *  ├───┬───┬───┬───┼───┤     will give:    ├───┬───┼───┤
      *  │ d │ e │ f │ g │ h │                   │ d │ g │ h │
      *  ├───┼───┼───┤   ├───┤                   ├───┤   ├───┤
      *  │ i │ j │ k │   │ l │                   │ i │   │ l │
      *  ├───┴───┴───┴───┴───┤                   ├───┴───┴───┤
      *  │ m                 │                   │ m         │
      *  └───────────────────┘                   └───────────┘
      *        ^---- remove from here, `at` = 1, `columns` = 2
      *
      * @param options.at The row index at which the removing columns will start.
      * @param options.columns The number of columns to remove.
      */
      removeColumns(table2, options) {
        const model = this.editor.model;
        const first2 = options.at;
        const columnsToRemove = options.columns || 1;
        const last2 = options.at + columnsToRemove - 1;
        model.change((writer) => {
          adjustHeadingColumns(table2, {
            first: first2,
            last: last2
          }, writer);
          const tableColumns = getTableColumnElements(table2);
          for (let removedColumnIndex = last2; removedColumnIndex >= first2; removedColumnIndex--) {
            for (const { cell, column, cellWidth } of [
              ...new TableWalker(table2)
            ]) {
              if (column <= removedColumnIndex && cellWidth > 1 && column + cellWidth > removedColumnIndex) {
                updateNumericAttribute("colspan", cellWidth - 1, cell, writer);
              } else if (column === removedColumnIndex) {
                writer.remove(cell);
              }
            }
            if (tableColumns[removedColumnIndex]) {
              const adjacentColumn = removedColumnIndex === 0 ? tableColumns[1] : tableColumns[removedColumnIndex - 1];
              const removedColumnWidth = parseFloat(tableColumns[removedColumnIndex].getAttribute("columnWidth"));
              const adjacentColumnWidth = parseFloat(adjacentColumn.getAttribute("columnWidth"));
              writer.remove(tableColumns[removedColumnIndex]);
              writer.setAttribute("columnWidth", removedColumnWidth + adjacentColumnWidth + "%", adjacentColumn);
            }
          }
          if (!removeEmptyRows(table2, this)) {
            removeEmptyColumns(table2, this);
          }
        });
      }
      /**
      * Divides a table cell vertically into several ones.
      *
      * The cell will be visually split into more cells by updating colspans of other cells in a column
      * and inserting cells (columns) after that cell.
      *
      * In the table below, if cell "a" is split into 3 cells:
      *
      *  +---+---+---+
      *  | a | b | c |
      *  +---+---+---+
      *  | d | e | f |
      *  +---+---+---+
      *
      * it will result in the table below:
      *
      *  +---+---+---+---+---+
      *  | a |   |   | b | c |
      *  +---+---+---+---+---+
      *  | d         | e | f |
      *  +---+---+---+---+---+
      *
      * So cell "d" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).
      *
      * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder
      * will be left to the original cell:
      *
      *  +---+---+---+
      *  | a         |
      *  +---+---+---+
      *  | b | c | d |
      *  +---+---+---+
      *
      * Splitting cell "a" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell "a" that will have `colspan=2`:
      *
      *  +---+---+---+
      *  | a     |   |
      *  +---+---+---+
      *  | b | c | d |
      *  +---+---+---+
      */
      splitCellVertically(tableCell, numberOfCells = 2) {
        const model = this.editor.model;
        const tableRow = tableCell.parent;
        const table2 = tableRow.parent;
        const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
        const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
        model.change((writer) => {
          if (colspan > 1) {
            const { newCellsSpan, updatedSpan } = breakSpanEvenly(colspan, numberOfCells);
            updateNumericAttribute("colspan", updatedSpan, tableCell, writer);
            const newCellsAttributes = {};
            if (newCellsSpan > 1) {
              newCellsAttributes.colspan = newCellsSpan;
            }
            if (rowspan > 1) {
              newCellsAttributes.rowspan = rowspan;
            }
            const cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;
            createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
          }
          if (colspan < numberOfCells) {
            const cellsToInsert = numberOfCells - colspan;
            const tableMap = [
              ...new TableWalker(table2)
            ];
            const { column: splitCellColumn } = tableMap.find(({ cell }) => cell === tableCell);
            const cellsToUpdate = tableMap.filter(({ cell, cellWidth, column }) => {
              const isOnSameColumn = cell !== tableCell && column === splitCellColumn;
              const spansOverColumn = column < splitCellColumn && column + cellWidth > splitCellColumn;
              return isOnSameColumn || spansOverColumn;
            });
            for (const { cell, cellWidth } of cellsToUpdate) {
              writer.setAttribute("colspan", cellWidth + cellsToInsert, cell);
            }
            const newCellsAttributes = {};
            if (rowspan > 1) {
              newCellsAttributes.rowspan = rowspan;
            }
            createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
            const headingColumns = table2.getAttribute("headingColumns") || 0;
            if (headingColumns > splitCellColumn) {
              updateNumericAttribute("headingColumns", headingColumns + cellsToInsert, table2, writer);
            }
          }
        });
      }
      /**
      * Divides a table cell horizontally into several ones.
      *
      * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell
      * below.
      *
      * If in the table below cell "b" is split into 3 cells:
      *
      *  +---+---+---+
      *  | a | b | c |
      *  +---+---+---+
      *  | d | e | f |
      *  +---+---+---+
      *
      * It will result in the table below:
      *
      *  +---+---+---+
      *  | a | b | c |
      *  +   +---+   +
      *  |   |   |   |
      *  +   +---+   +
      *  |   |   |   |
      *  +---+---+---+
      *  | d | e | f |
      *  +---+---+---+
      *
      * So cells "a" and "b" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.
      *
      * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder
      * will be left to the original cell:
      *
      *  +---+---+---+
      *  | a | b | c |
      *  +   +---+---+
      *  |   | d | e |
      *  +   +---+---+
      *  |   | f | g |
      *  +   +---+---+
      *  |   | h | i |
      *  +---+---+---+
      *
      * Splitting cell "a" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell "a" will have `rowspan=2`:
      *
      *  +---+---+---+
      *  | a | b | c |
      *  +   +---+---+
      *  |   | d | e |
      *  +---+---+---+
      *  |   | f | g |
      *  +---+---+---+
      *  |   | h | i |
      *  +---+---+---+
      */
      splitCellHorizontally(tableCell, numberOfCells = 2) {
        const model = this.editor.model;
        const tableRow = tableCell.parent;
        const table2 = tableRow.parent;
        const splitCellRow = table2.getChildIndex(tableRow);
        const rowspan = parseInt(tableCell.getAttribute("rowspan") || "1");
        const colspan = parseInt(tableCell.getAttribute("colspan") || "1");
        model.change((writer) => {
          if (rowspan > 1) {
            const tableMap = [
              ...new TableWalker(table2, {
                startRow: splitCellRow,
                endRow: splitCellRow + rowspan - 1,
                includeAllSlots: true
              })
            ];
            const { newCellsSpan, updatedSpan } = breakSpanEvenly(rowspan, numberOfCells);
            updateNumericAttribute("rowspan", updatedSpan, tableCell, writer);
            const { column: cellColumn } = tableMap.find(({ cell }) => cell === tableCell);
            const newCellsAttributes = {};
            if (newCellsSpan > 1) {
              newCellsAttributes.rowspan = newCellsSpan;
            }
            if (colspan > 1) {
              newCellsAttributes.colspan = colspan;
            }
            for (const tableSlot of tableMap) {
              const { column, row } = tableSlot;
              const isAfterSplitCell = row >= splitCellRow + updatedSpan;
              const isOnSameColumn = column === cellColumn;
              const isInEvenlySplitRow = (row + splitCellRow + updatedSpan) % newCellsSpan === 0;
              if (isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow) {
                createCells(1, writer, tableSlot.getPositionBefore(), newCellsAttributes);
              }
            }
          }
          if (rowspan < numberOfCells) {
            const cellsToInsert = numberOfCells - rowspan;
            const tableMap = [
              ...new TableWalker(table2, {
                startRow: 0,
                endRow: splitCellRow
              })
            ];
            for (const { cell, cellHeight, row } of tableMap) {
              if (cell !== tableCell && row + cellHeight > splitCellRow) {
                const rowspanToSet = cellHeight + cellsToInsert;
                writer.setAttribute("rowspan", rowspanToSet, cell);
              }
            }
            const newCellsAttributes = {};
            if (colspan > 1) {
              newCellsAttributes.colspan = colspan;
            }
            createEmptyRows(writer, table2, splitCellRow + 1, cellsToInsert, 1, newCellsAttributes);
            const headingRows = table2.getAttribute("headingRows") || 0;
            if (headingRows > splitCellRow) {
              updateNumericAttribute("headingRows", headingRows + cellsToInsert, table2, writer);
            }
          }
        });
      }
      /**
      * Returns the number of columns for a given table.
      *
      * ```ts
      * editor.plugins.get( 'TableUtils' ).getColumns( table );
      * ```
      *
      * @param table The table to analyze.
      */
      getColumns(table2) {
        const row = table2.getChild(0);
        return [
          ...row.getChildren()
        ].filter((node) => node.is("element", "tableCell")).reduce((columns, row2) => {
          const columnWidth = parseInt(row2.getAttribute("colspan") || "1");
          return columns + columnWidth;
        }, 0);
      }
      /**
      * Returns the number of rows for a given table. Any other element present in the table model is omitted.
      *
      * ```ts
      * editor.plugins.get( 'TableUtils' ).getRows( table );
      * ```
      *
      * @param table The table to analyze.
      */
      getRows(table2) {
        return Array.from(table2.getChildren()).reduce((rowCount, child) => child.is("element", "tableRow") ? rowCount + 1 : rowCount, 0);
      }
      /**
      * Creates an instance of the table walker.
      *
      * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
      * It walks row by row and column by column in order to output values defined in the options.
      * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
      * pass the `includeAllSlots` option.
      *
      * @internal
      * @param table A table over which the walker iterates.
      * @param options An object with configuration.
      */
      createTableWalker(table2, options = {}) {
        return new TableWalker(table2, options);
      }
      /**
      * Returns all model table cells that are fully selected (from the outside)
      * within the provided model selection's ranges.
      *
      * To obtain the cells selected from the inside, use
      * {@link #getTableCellsContainingSelection}.
      */
      getSelectedTableCells(selection) {
        const cells = [];
        for (const range of this.sortRanges(selection.getRanges())) {
          const element = range.getContainedElement();
          if (element && element.is("element", "tableCell")) {
            cells.push(element);
          }
        }
        return cells;
      }
      /**
      * Returns all model table cells that the provided model selection's ranges
      * {@link module:engine/model/range~Range#start} inside.
      *
      * To obtain the cells selected from the outside, use
      * {@link #getSelectedTableCells}.
      */
      getTableCellsContainingSelection(selection) {
        const cells = [];
        for (const range of selection.getRanges()) {
          const cellWithSelection = range.start.findAncestor("tableCell");
          if (cellWithSelection) {
            cells.push(cellWithSelection);
          }
        }
        return cells;
      }
      /**
      * Returns all model table cells that are either completely selected
      * by selection ranges or host selection range
      * {@link module:engine/model/range~Range#start start positions} inside them.
      *
      * Combines {@link #getTableCellsContainingSelection} and
      * {@link #getSelectedTableCells}.
      */
      getSelectionAffectedTableCells(selection) {
        const selectedCells = this.getSelectedTableCells(selection);
        if (selectedCells.length) {
          return selectedCells;
        }
        return this.getTableCellsContainingSelection(selection);
      }
      /**
      * Returns an object with the `first` and `last` row index contained in the given `tableCells`.
      *
      * ```ts
      * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
      *
      * const { first, last } = getRowIndexes( selectedTableCells );
      *
      * console.log( `Selected rows: ${ first } to ${ last }` );
      * ```
      *
      * @returns Returns an object with the `first` and `last` table row indexes.
      */
      getRowIndexes(tableCells) {
        const indexes = tableCells.map((cell) => cell.parent.index);
        return this._getFirstLastIndexesObject(indexes);
      }
      /**
      * Returns an object with the `first` and `last` column index contained in the given `tableCells`.
      *
      * ```ts
      * const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
      *
      * const { first, last } = getColumnIndexes( selectedTableCells );
      *
      * console.log( `Selected columns: ${ first } to ${ last }` );
      * ```
      *
      * @returns Returns an object with the `first` and `last` table column indexes.
      */
      getColumnIndexes(tableCells) {
        const table2 = tableCells[0].findAncestor("table");
        const tableMap = [
          ...new TableWalker(table2)
        ];
        const indexes = tableMap.filter((entry) => tableCells.includes(entry.cell)).map((entry) => entry.column);
        return this._getFirstLastIndexesObject(indexes);
      }
      /**
      * Checks if the selection contains cells that do not exceed rectangular selection.
      *
      * In a table below:
      *
      *  ┌───┬───┬───┬───┐
      *  │ a │ b │ c │ d │
      *  ├───┴───┼───┤   │
      *  │ e     │ f │   │
      *  │       ├───┼───┤
      *  │       │ g │ h │
      *  └───────┴───┴───┘
      *
      * Valid selections are these which create a solid rectangle (without gaps), such as:
      *   - a, b (two horizontal cells)
      *   - c, f (two vertical cells)
      *   - a, b, e (cell "e" spans over four cells)
      *   - c, d, f (cell d spans over a cell in the row below)
      *
      * While an invalid selection would be:
      *   - a, c (the unselected cell "b" creates a gap)
      *   - f, g, h (cell "d" spans over a cell from the row of "f" cell - thus creates a gap)
      */
      isSelectionRectangular(selectedTableCells) {
        if (selectedTableCells.length < 2 || !this._areCellInTheSameTableSection(selectedTableCells)) {
          return false;
        }
        const rows = /* @__PURE__ */ new Set();
        const columns = /* @__PURE__ */ new Set();
        let areaOfSelectedCells = 0;
        for (const tableCell of selectedTableCells) {
          const { row, column } = this.getCellLocation(tableCell);
          const rowspan = parseInt(tableCell.getAttribute("rowspan")) || 1;
          const colspan = parseInt(tableCell.getAttribute("colspan")) || 1;
          rows.add(row);
          columns.add(column);
          if (rowspan > 1) {
            rows.add(row + rowspan - 1);
          }
          if (colspan > 1) {
            columns.add(column + colspan - 1);
          }
          areaOfSelectedCells += rowspan * colspan;
        }
        const areaOfValidSelection = getBiggestRectangleArea(rows, columns);
        return areaOfValidSelection == areaOfSelectedCells;
      }
      /**
      * Returns array of sorted ranges.
      */
      sortRanges(ranges) {
        return Array.from(ranges).sort(compareRangeOrder);
      }
      /**
      * Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.
      */
      _getFirstLastIndexesObject(indexes) {
        const allIndexesSorted = indexes.sort((indexA, indexB) => indexA - indexB);
        const first2 = allIndexesSorted[0];
        const last2 = allIndexesSorted[allIndexesSorted.length - 1];
        return {
          first: first2,
          last: last2
        };
      }
      /**
      * Checks if the selection does not mix a header (column or row) with other cells.
      *
      * For instance, in the table below valid selections consist of cells with the same letter only.
      * So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.
      *
      * header columns
      *    ↓   ↓
      *  ┌───┬───┬───┬───┐
      *  │ a │ a │ b │ b │  ← header row
      *  ├───┼───┼───┼───┤
      *  │ c │ c │ d │ d │
      *  ├───┼───┼───┼───┤
      *  │ c │ c │ d │ d │
      *  └───┴───┴───┴───┘
      */
      _areCellInTheSameTableSection(tableCells) {
        const table2 = tableCells[0].findAncestor("table");
        const rowIndexes = this.getRowIndexes(tableCells);
        const headingRows = parseInt(table2.getAttribute("headingRows")) || 0;
        if (!this._areIndexesInSameSection(rowIndexes, headingRows)) {
          return false;
        }
        const columnIndexes = this.getColumnIndexes(tableCells);
        const headingColumns = parseInt(table2.getAttribute("headingColumns")) || 0;
        return this._areIndexesInSameSection(columnIndexes, headingColumns);
      }
      /**
      * Unified check if table rows/columns indexes are in the same heading/body section.
      */
      _areIndexesInSameSection({ first: first2, last: last2 }, headingSectionSize) {
        const firstCellIsInHeading = first2 < headingSectionSize;
        const lastCellIsInHeading = last2 < headingSectionSize;
        return firstCellIsInHeading === lastCellIsInHeading;
      }
    }
    function createEmptyRows(writer, table2, insertAt2, rows, tableCellToInsert, attributes = {}) {
      for (let i = 0; i < rows; i++) {
        const tableRow = writer.createElement("tableRow");
        writer.insert(tableRow, table2, insertAt2);
        createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, "end"), attributes);
      }
    }
    function createCells(cells, writer, insertPosition, attributes = {}) {
      for (let i = 0; i < cells; i++) {
        createEmptyTableCell(writer, insertPosition, attributes);
      }
    }
    function breakSpanEvenly(span, numberOfCells) {
      if (span < numberOfCells) {
        return {
          newCellsSpan: 1,
          updatedSpan: 1
        };
      }
      const newCellsSpan = Math.floor(span / numberOfCells);
      const updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;
      return {
        newCellsSpan,
        updatedSpan
      };
    }
    function adjustHeadingColumns(table2, removedColumnIndexes, writer) {
      const headingColumns = table2.getAttribute("headingColumns") || 0;
      if (headingColumns && removedColumnIndexes.first < headingColumns) {
        const headingsRemoved = Math.min(headingColumns - 1, removedColumnIndexes.last) - removedColumnIndexes.first + 1;
        writer.setAttribute("headingColumns", headingColumns - headingsRemoved, table2);
      }
    }
    function updateHeadingRows(table2, { first: first2, last: last2 }, writer) {
      const headingRows = table2.getAttribute("headingRows") || 0;
      if (first2 < headingRows) {
        const newRows = last2 < headingRows ? headingRows - (last2 - first2 + 1) : first2;
        updateNumericAttribute("headingRows", newRows, table2, writer, 0);
      }
    }
    function getCellsToMoveAndTrimOnRemoveRow(table2, { first: first2, last: last2 }) {
      const cellsToMove = /* @__PURE__ */ new Map();
      const cellsToTrim = [];
      for (const { row, column, cellHeight, cell } of new TableWalker(table2, {
        endRow: last2
      })) {
        const lastRowOfCell = row + cellHeight - 1;
        const isCellStickingOutFromRemovedRows = row >= first2 && row <= last2 && lastRowOfCell > last2;
        if (isCellStickingOutFromRemovedRows) {
          const rowspanInRemovedSection = last2 - row + 1;
          const rowSpanToSet = cellHeight - rowspanInRemovedSection;
          cellsToMove.set(column, {
            cell,
            rowspan: rowSpanToSet
          });
        }
        const isCellOverlappingRemovedRows = row < first2 && lastRowOfCell >= first2;
        if (isCellOverlappingRemovedRows) {
          let rowspanAdjustment;
          if (lastRowOfCell >= last2) {
            rowspanAdjustment = last2 - first2 + 1;
          } else {
            rowspanAdjustment = lastRowOfCell - first2 + 1;
          }
          cellsToTrim.push({
            cell,
            rowspan: cellHeight - rowspanAdjustment
          });
        }
      }
      return {
        cellsToMove,
        cellsToTrim
      };
    }
    function moveCellsToRow(table2, targetRowIndex, cellsToMove, writer) {
      const tableWalker = new TableWalker(table2, {
        includeAllSlots: true,
        row: targetRowIndex
      });
      const tableRowMap = [
        ...tableWalker
      ];
      const row = table2.getChild(targetRowIndex);
      let previousCell;
      for (const { column, cell, isAnchor } of tableRowMap) {
        if (cellsToMove.has(column)) {
          const { cell: cellToMove, rowspan } = cellsToMove.get(column);
          const targetPosition = previousCell ? writer.createPositionAfter(previousCell) : writer.createPositionAt(row, 0);
          writer.move(writer.createRangeOn(cellToMove), targetPosition);
          updateNumericAttribute("rowspan", rowspan, cellToMove, writer);
          previousCell = cellToMove;
        } else if (isAnchor) {
          previousCell = cell;
        }
      }
    }
    function compareRangeOrder(rangeA, rangeB) {
      const posA = rangeA.start;
      const posB = rangeB.start;
      return posA.isBefore(posB) ? -1 : 1;
    }
    function getBiggestRectangleArea(rows, columns) {
      const rowsIndexes = Array.from(rows.values());
      const columnIndexes = Array.from(columns.values());
      const lastRow = Math.max(...rowsIndexes);
      const firstRow = Math.min(...rowsIndexes);
      const lastColumn = Math.max(...columnIndexes);
      const firstColumn = Math.min(...columnIndexes);
      return (lastRow - firstRow + 1) * (lastColumn - firstColumn + 1);
    }
    class MergeCellsCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get(TableUtils);
        const selectedTableCells = tableUtils.getSelectedTableCells(this.editor.model.document.selection);
        this.isEnabled = tableUtils.isSelectionRectangular(selectedTableCells);
      }
      /**
      * Executes the command.
      *
      * @fires execute
      */
      execute() {
        const model = this.editor.model;
        const tableUtils = this.editor.plugins.get(TableUtils);
        model.change((writer) => {
          const selectedTableCells = tableUtils.getSelectedTableCells(model.document.selection);
          const firstTableCell = selectedTableCells.shift();
          const { mergeWidth, mergeHeight } = getMergeDimensions(firstTableCell, selectedTableCells, tableUtils);
          updateNumericAttribute("colspan", mergeWidth, firstTableCell, writer);
          updateNumericAttribute("rowspan", mergeHeight, firstTableCell, writer);
          for (const tableCell of selectedTableCells) {
            mergeTableCells(tableCell, firstTableCell, writer);
          }
          const table2 = firstTableCell.findAncestor("table");
          removeEmptyRowsColumns(table2, tableUtils);
          writer.setSelection(firstTableCell, "in");
        });
      }
    }
    function mergeTableCells(cellBeingMerged, targetCell, writer) {
      if (!isEmpty$1(cellBeingMerged)) {
        if (isEmpty$1(targetCell)) {
          writer.remove(writer.createRangeIn(targetCell));
        }
        writer.move(writer.createRangeIn(cellBeingMerged), writer.createPositionAt(targetCell, "end"));
      }
      writer.remove(cellBeingMerged);
    }
    function isEmpty$1(tableCell) {
      const firstTableChild = tableCell.getChild(0);
      return tableCell.childCount == 1 && firstTableChild.is("element", "paragraph") && firstTableChild.isEmpty;
    }
    function getMergeDimensions(firstTableCell, selectedTableCells, tableUtils) {
      let maxWidthOffset = 0;
      let maxHeightOffset = 0;
      for (const tableCell of selectedTableCells) {
        const { row, column } = tableUtils.getCellLocation(tableCell);
        maxWidthOffset = getMaxOffset(tableCell, column, maxWidthOffset, "colspan");
        maxHeightOffset = getMaxOffset(tableCell, row, maxHeightOffset, "rowspan");
      }
      const { row: firstCellRow, column: firstCellColumn } = tableUtils.getCellLocation(firstTableCell);
      const mergeWidth = maxWidthOffset - firstCellColumn;
      const mergeHeight = maxHeightOffset - firstCellRow;
      return {
        mergeWidth,
        mergeHeight
      };
    }
    function getMaxOffset(tableCell, start, currentMaxOffset, which) {
      const dimensionValue = parseInt(tableCell.getAttribute(which) || "1");
      return Math.max(currentMaxOffset, start + dimensionValue);
    }
    class SelectRowCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        this.affectsData = false;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
        this.isEnabled = selectedCells.length > 0;
      }
      /**
      * @inheritDoc
      */
      execute() {
        const model = this.editor.model;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const rowIndexes = tableUtils.getRowIndexes(referenceCells);
        const table2 = referenceCells[0].findAncestor("table");
        const rangesToSelect = [];
        for (let rowIndex = rowIndexes.first; rowIndex <= rowIndexes.last; rowIndex++) {
          for (const cell of table2.getChild(rowIndex).getChildren()) {
            rangesToSelect.push(model.createRangeOn(cell));
          }
        }
        model.change((writer) => {
          writer.setSelection(rangesToSelect);
        });
      }
    }
    class SelectColumnCommand extends Command {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        this.affectsData = false;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedCells = tableUtils.getSelectionAffectedTableCells(this.editor.model.document.selection);
        this.isEnabled = selectedCells.length > 0;
      }
      /**
      * @inheritDoc
      */
      execute() {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const model = this.editor.model;
        const referenceCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const firstCell = referenceCells[0];
        const lastCell = referenceCells.pop();
        const table2 = firstCell.findAncestor("table");
        const startLocation = tableUtils.getCellLocation(firstCell);
        const endLocation = tableUtils.getCellLocation(lastCell);
        const startColumn = Math.min(startLocation.column, endLocation.column);
        const endColumn = Math.max(startLocation.column, endLocation.column);
        const rangesToSelect = [];
        for (const cellInfo of new TableWalker(table2, {
          startColumn,
          endColumn
        })) {
          rangesToSelect.push(model.createRangeOn(cellInfo.cell));
        }
        model.change((writer) => {
          writer.setSelection(rangesToSelect);
        });
      }
    }
    function injectTableLayoutPostFixer(model) {
      model.document.registerPostFixer((writer) => tableLayoutPostFixer(writer, model));
    }
    function tableLayoutPostFixer(writer, model) {
      const changes = model.document.differ.getChanges();
      let wasFixed = false;
      const analyzedTables = /* @__PURE__ */ new Set();
      for (const entry of changes) {
        let table2 = null;
        if (entry.type == "insert" && entry.name == "table") {
          table2 = entry.position.nodeAfter;
        }
        if ((entry.type == "insert" || entry.type == "remove") && (entry.name == "tableRow" || entry.name == "tableCell")) {
          table2 = entry.position.findAncestor("table");
        }
        if (isTableAttributeEntry(entry)) {
          table2 = entry.range.start.findAncestor("table");
        }
        if (table2 && !analyzedTables.has(table2)) {
          wasFixed = fixTableCellsRowspan(table2, writer) || wasFixed;
          wasFixed = fixTableRowsSizes(table2, writer) || wasFixed;
          analyzedTables.add(table2);
        }
      }
      return wasFixed;
    }
    function fixTableCellsRowspan(table2, writer) {
      let wasFixed = false;
      const cellsToTrim = findCellsToTrim(table2);
      if (cellsToTrim.length) {
        wasFixed = true;
        for (const data of cellsToTrim) {
          updateNumericAttribute("rowspan", data.rowspan, data.cell, writer, 1);
        }
      }
      return wasFixed;
    }
    function fixTableRowsSizes(table2, writer) {
      let wasFixed = false;
      const childrenLengths = getChildrenLengths(table2);
      const rowsToRemove = [];
      for (const [rowIndex, size] of childrenLengths.entries()) {
        if (!size && table2.getChild(rowIndex).is("element", "tableRow")) {
          rowsToRemove.push(rowIndex);
        }
      }
      if (rowsToRemove.length) {
        wasFixed = true;
        for (const rowIndex of rowsToRemove.reverse()) {
          writer.remove(table2.getChild(rowIndex));
          childrenLengths.splice(rowIndex, 1);
        }
      }
      const rowsLengths = childrenLengths.filter((row, rowIndex) => table2.getChild(rowIndex).is("element", "tableRow"));
      const tableSize = rowsLengths[0];
      const isValid2 = rowsLengths.every((length) => length === tableSize);
      if (!isValid2) {
        const maxColumns = rowsLengths.reduce((prev, current) => current > prev ? current : prev, 0);
        for (const [rowIndex, size] of rowsLengths.entries()) {
          const columnsToInsert = maxColumns - size;
          if (columnsToInsert) {
            for (let i = 0; i < columnsToInsert; i++) {
              createEmptyTableCell(writer, writer.createPositionAt(table2.getChild(rowIndex), "end"));
            }
            wasFixed = true;
          }
        }
      }
      return wasFixed;
    }
    function findCellsToTrim(table2) {
      const headingRows = parseInt(table2.getAttribute("headingRows") || "0");
      const maxRows = Array.from(table2.getChildren()).reduce((count2, row) => row.is("element", "tableRow") ? count2 + 1 : count2, 0);
      const cellsToTrim = [];
      for (const { row, cell, cellHeight } of new TableWalker(table2)) {
        if (cellHeight < 2) {
          continue;
        }
        const isInHeader = row < headingRows;
        const rowLimit = isInHeader ? headingRows : maxRows;
        if (row + cellHeight > rowLimit) {
          const newRowspan = rowLimit - row;
          cellsToTrim.push({
            cell,
            rowspan: newRowspan
          });
        }
      }
      return cellsToTrim;
    }
    function getChildrenLengths(table2) {
      const lengths = new Array(table2.childCount).fill(0);
      for (const { rowIndex } of new TableWalker(table2, {
        includeAllSlots: true
      })) {
        lengths[rowIndex]++;
      }
      return lengths;
    }
    function isTableAttributeEntry(entry) {
      if (entry.type !== "attribute") {
        return false;
      }
      const key = entry.attributeKey;
      return key === "headingRows" || key === "colspan" || key === "rowspan";
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function injectTableCellParagraphPostFixer(model) {
      model.document.registerPostFixer((writer) => tableCellContentsPostFixer(writer, model));
    }
    function tableCellContentsPostFixer(writer, model) {
      const changes = model.document.differ.getChanges();
      let wasFixed = false;
      for (const entry of changes) {
        if (entry.type == "insert" && entry.name == "table") {
          wasFixed = fixTable(entry.position.nodeAfter, writer) || wasFixed;
        }
        if (entry.type == "insert" && entry.name == "tableRow") {
          wasFixed = fixTableRow(entry.position.nodeAfter, writer) || wasFixed;
        }
        if (entry.type == "insert" && entry.name == "tableCell") {
          wasFixed = fixTableCellContent(entry.position.nodeAfter, writer) || wasFixed;
        }
        if ((entry.type == "remove" || entry.type == "insert") && checkTableCellChange(entry)) {
          wasFixed = fixTableCellContent(entry.position.parent, writer) || wasFixed;
        }
      }
      return wasFixed;
    }
    function fixTable(table2, writer) {
      let wasFixed = false;
      for (const row of table2.getChildren()) {
        if (row.is("element", "tableRow")) {
          wasFixed = fixTableRow(row, writer) || wasFixed;
        }
      }
      return wasFixed;
    }
    function fixTableRow(tableRow, writer) {
      let wasFixed = false;
      for (const tableCell of tableRow.getChildren()) {
        wasFixed = fixTableCellContent(tableCell, writer) || wasFixed;
      }
      return wasFixed;
    }
    function fixTableCellContent(tableCell, writer) {
      if (tableCell.childCount == 0) {
        writer.insertElement("paragraph", tableCell);
        return true;
      }
      const textNodes = Array.from(tableCell.getChildren()).filter((child) => child.is("$text"));
      for (const child of textNodes) {
        writer.wrap(writer.createRangeOn(child), "paragraph");
      }
      return !!textNodes.length;
    }
    function checkTableCellChange(entry) {
      if (!entry.position.parent.is("element", "tableCell")) {
        return false;
      }
      return entry.type == "insert" && entry.name == "$text" || entry.type == "remove";
    }
    function tableHeadingsRefreshHandler(model, editing) {
      const differ = model.document.differ;
      for (const change of differ.getChanges()) {
        let table2;
        let isRowChange = false;
        if (change.type == "attribute") {
          const element = change.range.start.nodeAfter;
          if (!element || !element.is("element", "table")) {
            continue;
          }
          if (change.attributeKey != "headingRows" && change.attributeKey != "headingColumns") {
            continue;
          }
          table2 = element;
          isRowChange = change.attributeKey == "headingRows";
        } else if (change.name == "tableRow" || change.name == "tableCell") {
          table2 = change.position.findAncestor("table");
          isRowChange = change.name == "tableRow";
        }
        if (!table2) {
          continue;
        }
        const headingRows = table2.getAttribute("headingRows") || 0;
        const headingColumns = table2.getAttribute("headingColumns") || 0;
        const tableWalker = new TableWalker(table2);
        for (const tableSlot of tableWalker) {
          const isHeading = tableSlot.row < headingRows || tableSlot.column < headingColumns;
          const expectedElementName = isHeading ? "th" : "td";
          const viewElement = editing.mapper.toViewElement(tableSlot.cell);
          if (viewElement && viewElement.is("element") && viewElement.name != expectedElementName) {
            editing.reconvertItem(isRowChange ? tableSlot.cell.parent : tableSlot.cell);
          }
        }
      }
    }
    function tableCellRefreshHandler(model, editing) {
      const differ = model.document.differ;
      const cellsToCheck = /* @__PURE__ */ new Set();
      for (const change of differ.getChanges()) {
        const parent2 = change.type == "attribute" ? change.range.start.parent : change.position.parent;
        if (parent2.is("element", "tableCell")) {
          cellsToCheck.add(parent2);
        }
      }
      for (const tableCell of cellsToCheck.values()) {
        const paragraphsToRefresh = Array.from(tableCell.getChildren()).filter((child) => shouldRefresh(child, editing.mapper));
        for (const paragraph2 of paragraphsToRefresh) {
          editing.reconvertItem(paragraph2);
        }
      }
    }
    function shouldRefresh(child, mapper) {
      if (!child.is("element", "paragraph")) {
        return false;
      }
      const viewElement = mapper.toViewElement(child);
      if (!viewElement) {
        return false;
      }
      return isSingleParagraphWithoutAttributes(child) !== viewElement.is("element", "span");
    }
    class TableEditing extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * Handlers for creating additional slots in the table.
        */
        __publicField(this, "_additionalSlots");
        this._additionalSlots = [];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        const schema = model.schema;
        const conversion = editor.conversion;
        const tableUtils = editor.plugins.get(TableUtils);
        schema.register("table", {
          inheritAllFrom: "$blockObject",
          allowAttributes: [
            "headingRows",
            "headingColumns"
          ]
        });
        schema.register("tableRow", {
          allowIn: "table",
          isLimit: true
        });
        schema.register("tableCell", {
          allowContentOf: "$container",
          allowIn: "tableRow",
          allowAttributes: [
            "colspan",
            "rowspan"
          ],
          isLimit: true,
          isSelectable: true
        });
        conversion.for("upcast").add(upcastTableFigure());
        conversion.for("upcast").add(upcastTable());
        conversion.for("editingDowncast").elementToStructure({
          model: {
            name: "table",
            attributes: [
              "headingRows"
            ]
          },
          view: downcastTable(tableUtils, {
            asWidget: true,
            additionalSlots: this._additionalSlots
          })
        });
        conversion.for("dataDowncast").elementToStructure({
          model: {
            name: "table",
            attributes: [
              "headingRows"
            ]
          },
          view: downcastTable(tableUtils, {
            additionalSlots: this._additionalSlots
          })
        });
        conversion.for("upcast").elementToElement({
          model: "tableRow",
          view: "tr"
        });
        conversion.for("upcast").add(skipEmptyTableRow());
        conversion.for("downcast").elementToElement({
          model: "tableRow",
          view: downcastRow()
        });
        conversion.for("upcast").elementToElement({
          model: "tableCell",
          view: "td"
        });
        conversion.for("upcast").elementToElement({
          model: "tableCell",
          view: "th"
        });
        conversion.for("upcast").add(ensureParagraphInTableCell("td"));
        conversion.for("upcast").add(ensureParagraphInTableCell("th"));
        conversion.for("editingDowncast").elementToElement({
          model: "tableCell",
          view: downcastCell({
            asWidget: true
          })
        });
        conversion.for("dataDowncast").elementToElement({
          model: "tableCell",
          view: downcastCell()
        });
        conversion.for("editingDowncast").elementToElement({
          model: "paragraph",
          view: convertParagraphInTableCell({
            asWidget: true
          }),
          converterPriority: "high"
        });
        conversion.for("dataDowncast").elementToElement({
          model: "paragraph",
          view: convertParagraphInTableCell(),
          converterPriority: "high"
        });
        conversion.for("downcast").attributeToAttribute({
          model: "colspan",
          view: "colspan"
        });
        conversion.for("upcast").attributeToAttribute({
          model: {
            key: "colspan",
            value: upcastCellSpan("colspan")
          },
          view: "colspan"
        });
        conversion.for("downcast").attributeToAttribute({
          model: "rowspan",
          view: "rowspan"
        });
        conversion.for("upcast").attributeToAttribute({
          model: {
            key: "rowspan",
            value: upcastCellSpan("rowspan")
          },
          view: "rowspan"
        });
        editor.config.define("table.defaultHeadings.rows", 0);
        editor.config.define("table.defaultHeadings.columns", 0);
        editor.commands.add("insertTable", new InsertTableCommand(editor));
        editor.commands.add("insertTableRowAbove", new InsertRowCommand(editor, {
          order: "above"
        }));
        editor.commands.add("insertTableRowBelow", new InsertRowCommand(editor, {
          order: "below"
        }));
        editor.commands.add("insertTableColumnLeft", new InsertColumnCommand(editor, {
          order: "left"
        }));
        editor.commands.add("insertTableColumnRight", new InsertColumnCommand(editor, {
          order: "right"
        }));
        editor.commands.add("removeTableRow", new RemoveRowCommand(editor));
        editor.commands.add("removeTableColumn", new RemoveColumnCommand(editor));
        editor.commands.add("splitTableCellVertically", new SplitCellCommand(editor, {
          direction: "vertically"
        }));
        editor.commands.add("splitTableCellHorizontally", new SplitCellCommand(editor, {
          direction: "horizontally"
        }));
        editor.commands.add("mergeTableCells", new MergeCellsCommand(editor));
        editor.commands.add("mergeTableCellRight", new MergeCellCommand(editor, {
          direction: "right"
        }));
        editor.commands.add("mergeTableCellLeft", new MergeCellCommand(editor, {
          direction: "left"
        }));
        editor.commands.add("mergeTableCellDown", new MergeCellCommand(editor, {
          direction: "down"
        }));
        editor.commands.add("mergeTableCellUp", new MergeCellCommand(editor, {
          direction: "up"
        }));
        editor.commands.add("setTableColumnHeader", new SetHeaderColumnCommand(editor));
        editor.commands.add("setTableRowHeader", new SetHeaderRowCommand(editor));
        editor.commands.add("selectTableRow", new SelectRowCommand(editor));
        editor.commands.add("selectTableColumn", new SelectColumnCommand(editor));
        injectTableLayoutPostFixer(model);
        injectTableCellParagraphPostFixer(model);
        this.listenTo(model.document, "change:data", () => {
          tableHeadingsRefreshHandler(model, editor.editing);
          tableCellRefreshHandler(model, editor.editing);
        });
      }
      /**
      * Registers downcast handler for the additional table slot.
      */
      registerAdditionalSlot(slotHandler) {
        this._additionalSlots.push(slotHandler);
      }
    }
    function upcastCellSpan(type) {
      return (cell) => {
        const span = parseInt(cell.getAttribute(type));
        if (Number.isNaN(span) || span <= 0) {
          return null;
        }
        return span;
      };
    }
    class InsertTableView extends View {
      /**
      * @inheritDoc
      */
      constructor(locale) {
        super(locale);
        /**
        * A collection of table size box items.
        */
        __publicField(this, "items");
        /**
        * Listen to `keydown` events fired in this view's main element.
        */
        __publicField(this, "keystrokes");
        /**
        * Tracks information about the DOM focus in the grid.
        */
        __publicField(this, "focusTracker");
        const bind = this.bindTemplate;
        this.items = this._createGridCollection();
        this.keystrokes = new KeystrokeHandler();
        this.focusTracker = new FocusTracker();
        this.set("rows", 0);
        this.set("columns", 0);
        this.bind("label").to(this, "columns", this, "rows", (columns, rows) => `${rows} × ${columns}`);
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck"
            ]
          },
          children: [
            {
              tag: "div",
              attributes: {
                class: [
                  "ck-insert-table-dropdown__grid"
                ]
              },
              on: {
                "mouseover@.ck-insert-table-dropdown-grid-box": bind.to("boxover")
              },
              children: this.items
            },
            {
              tag: "div",
              attributes: {
                class: [
                  "ck",
                  "ck-insert-table-dropdown__label"
                ],
                "aria-hidden": true
              },
              children: [
                {
                  text: bind.to("label")
                }
              ]
            }
          ],
          on: {
            mousedown: bind.to((evt) => {
              evt.preventDefault();
            }),
            click: bind.to(() => {
              this.fire("execute");
            })
          }
        });
        this.on("boxover", (evt, domEvt) => {
          const { row, column } = domEvt.target.dataset;
          this.items.get((parseInt(row, 10) - 1) * 10 + (parseInt(column, 10) - 1)).focus();
        });
        this.focusTracker.on("change:focusedElement", (evt, name, focusedElement) => {
          if (!focusedElement) {
            return;
          }
          const { row, column } = focusedElement.dataset;
          this.set({
            rows: parseInt(row),
            columns: parseInt(column)
          });
        });
        this.on("change:columns", () => this._highlightGridBoxes());
        this.on("change:rows", () => this._highlightGridBoxes());
      }
      render() {
        super.render();
        addKeyboardHandlingForGrid({
          keystrokeHandler: this.keystrokes,
          focusTracker: this.focusTracker,
          gridItems: this.items,
          numberOfColumns: 10,
          uiLanguageDirection: this.locale && this.locale.uiLanguageDirection
        });
        for (const item of this.items) {
          this.focusTracker.add(item.element);
        }
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Resets the rows and columns selection.
      */
      reset() {
        this.set({
          rows: 1,
          columns: 1
        });
      }
      /**
      * @inheritDoc
      */
      focus() {
        this.items.get(0).focus();
      }
      /**
      * @inheritDoc
      */
      focusLast() {
        this.items.get(0).focus();
      }
      /**
      * Highlights grid boxes depending on rows and columns selected.
      */
      _highlightGridBoxes() {
        const rows = this.rows;
        const columns = this.columns;
        this.items.map((boxView, index2) => {
          const itemRow = Math.floor(index2 / 10);
          const itemColumn = index2 % 10;
          const isOn = itemRow < rows && itemColumn < columns;
          boxView.set("isOn", isOn);
        });
      }
      /**
      * Creates a new Button for the grid.
      *
      * @param locale The locale instance.
      * @param row Row number.
      * @param column Column number.
      * @param label The grid button label.
      */
      _createGridButton(locale, row, column, label) {
        const button = new ButtonView(locale);
        button.set({
          label,
          class: "ck-insert-table-dropdown-grid-box"
        });
        button.extendTemplate({
          attributes: {
            "data-row": row,
            "data-column": column
          }
        });
        return button;
      }
      /**
      * @returns A view collection containing boxes to be placed in a table grid.
      */
      _createGridCollection() {
        const boxes = [];
        for (let index2 = 0; index2 < 100; index2++) {
          const row = Math.floor(index2 / 10);
          const column = index2 % 10;
          const label = `${row + 1} × ${column + 1}`;
          boxes.push(this._createGridButton(this.locale, row + 1, column + 1, label));
        }
        return this.createCollection(boxes);
      }
    }
    var tableColumnIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>';
    var tableRowIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>';
    var tableMergeCellIcon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>';
    class TableUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = this.editor.t;
        const contentLanguageDirection = editor.locale.contentLanguageDirection;
        const isContentLtr = contentLanguageDirection === "ltr";
        editor.ui.componentFactory.add("insertTable", (locale) => {
          const command = editor.commands.get("insertTable");
          const dropdownView = createDropdown(locale);
          dropdownView.bind("isEnabled").to(command);
          dropdownView.buttonView.set({
            icon: icons.table,
            label: t("Insert table"),
            tooltip: true
          });
          let insertTableView;
          dropdownView.on("change:isOpen", () => {
            if (insertTableView) {
              return;
            }
            insertTableView = new InsertTableView(locale);
            dropdownView.panelView.children.add(insertTableView);
            insertTableView.delegate("execute").to(dropdownView);
            dropdownView.on("execute", () => {
              editor.execute("insertTable", {
                rows: insertTableView.rows,
                columns: insertTableView.columns
              });
              editor.editing.view.focus();
            });
          });
          return dropdownView;
        });
        editor.ui.componentFactory.add("menuBar:insertTable", (locale) => {
          const command = editor.commands.get("insertTable");
          const menuView = new MenuBarMenuView(locale);
          const insertTableView = new InsertTableView(locale);
          insertTableView.delegate("execute").to(menuView);
          menuView.on("change:isOpen", (event, name, isOpen) => {
            if (!isOpen) {
              insertTableView.reset();
            }
          });
          insertTableView.on("execute", () => {
            editor.execute("insertTable", {
              rows: insertTableView.rows,
              columns: insertTableView.columns
            });
            editor.editing.view.focus();
          });
          menuView.buttonView.set({
            label: t("Table"),
            icon: icons.table
          });
          menuView.panelView.children.add(insertTableView);
          menuView.bind("isEnabled").to(command);
          return menuView;
        });
        editor.ui.componentFactory.add("tableColumn", (locale) => {
          const options = [
            {
              type: "switchbutton",
              model: {
                commandName: "setTableColumnHeader",
                label: t("Header column"),
                bindIsOn: true
              }
            },
            {
              type: "separator"
            },
            {
              type: "button",
              model: {
                commandName: isContentLtr ? "insertTableColumnLeft" : "insertTableColumnRight",
                label: t("Insert column left")
              }
            },
            {
              type: "button",
              model: {
                commandName: isContentLtr ? "insertTableColumnRight" : "insertTableColumnLeft",
                label: t("Insert column right")
              }
            },
            {
              type: "button",
              model: {
                commandName: "removeTableColumn",
                label: t("Delete column")
              }
            },
            {
              type: "button",
              model: {
                commandName: "selectTableColumn",
                label: t("Select column")
              }
            }
          ];
          return this._prepareDropdown(t("Column"), tableColumnIcon, options, locale);
        });
        editor.ui.componentFactory.add("tableRow", (locale) => {
          const options = [
            {
              type: "switchbutton",
              model: {
                commandName: "setTableRowHeader",
                label: t("Header row"),
                bindIsOn: true
              }
            },
            {
              type: "separator"
            },
            {
              type: "button",
              model: {
                commandName: "insertTableRowAbove",
                label: t("Insert row above")
              }
            },
            {
              type: "button",
              model: {
                commandName: "insertTableRowBelow",
                label: t("Insert row below")
              }
            },
            {
              type: "button",
              model: {
                commandName: "removeTableRow",
                label: t("Delete row")
              }
            },
            {
              type: "button",
              model: {
                commandName: "selectTableRow",
                label: t("Select row")
              }
            }
          ];
          return this._prepareDropdown(t("Row"), tableRowIcon, options, locale);
        });
        editor.ui.componentFactory.add("mergeTableCells", (locale) => {
          const options = [
            {
              type: "button",
              model: {
                commandName: "mergeTableCellUp",
                label: t("Merge cell up")
              }
            },
            {
              type: "button",
              model: {
                commandName: isContentLtr ? "mergeTableCellRight" : "mergeTableCellLeft",
                label: t("Merge cell right")
              }
            },
            {
              type: "button",
              model: {
                commandName: "mergeTableCellDown",
                label: t("Merge cell down")
              }
            },
            {
              type: "button",
              model: {
                commandName: isContentLtr ? "mergeTableCellLeft" : "mergeTableCellRight",
                label: t("Merge cell left")
              }
            },
            {
              type: "separator"
            },
            {
              type: "button",
              model: {
                commandName: "splitTableCellVertically",
                label: t("Split cell vertically")
              }
            },
            {
              type: "button",
              model: {
                commandName: "splitTableCellHorizontally",
                label: t("Split cell horizontally")
              }
            }
          ];
          return this._prepareMergeSplitButtonDropdown(t("Merge cells"), tableMergeCellIcon, options, locale);
        });
      }
      /**
      * Creates a dropdown view from a set of options.
      *
      * @param label The dropdown button label.
      * @param icon An icon for the dropdown button.
      * @param options The list of options for the dropdown.
      */
      _prepareDropdown(label, icon, options, locale) {
        const editor = this.editor;
        const dropdownView = createDropdown(locale);
        const commands = this._fillDropdownWithListOptions(dropdownView, options);
        dropdownView.buttonView.set({
          label,
          icon,
          tooltip: true
        });
        dropdownView.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => {
          return areEnabled.some((isEnabled2) => isEnabled2);
        });
        this.listenTo(dropdownView, "execute", (evt) => {
          editor.execute(evt.source.commandName);
          if (!(evt.source instanceof SwitchButtonView)) {
            editor.editing.view.focus();
          }
        });
        return dropdownView;
      }
      /**
      * Creates a dropdown view with a {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} for
      * merge (and split)–related commands.
      *
      * @param label The dropdown button label.
      * @param icon An icon for the dropdown button.
      * @param options The list of options for the dropdown.
      */
      _prepareMergeSplitButtonDropdown(label, icon, options, locale) {
        const editor = this.editor;
        const dropdownView = createDropdown(locale, SplitButtonView);
        const mergeCommandName = "mergeTableCells";
        const mergeCommand = editor.commands.get(mergeCommandName);
        const commands = this._fillDropdownWithListOptions(dropdownView, options);
        dropdownView.buttonView.set({
          label,
          icon,
          tooltip: true,
          isEnabled: true
        });
        dropdownView.bind("isEnabled").toMany([
          mergeCommand,
          ...commands
        ], "isEnabled", (...areEnabled) => {
          return areEnabled.some((isEnabled2) => isEnabled2);
        });
        this.listenTo(dropdownView.buttonView, "execute", () => {
          editor.execute(mergeCommandName);
          editor.editing.view.focus();
        });
        this.listenTo(dropdownView, "execute", (evt) => {
          editor.execute(evt.source.commandName);
          editor.editing.view.focus();
        });
        return dropdownView;
      }
      /**
      * Injects a {@link module:ui/list/listview~ListView} into the passed dropdown with buttons
      * which execute editor commands as configured in passed options.
      *
      * @param options The list of options for the dropdown.
      * @returns Commands the list options are interacting with.
      */
      _fillDropdownWithListOptions(dropdownView, options) {
        const editor = this.editor;
        const commands = [];
        const itemDefinitions = new Collection();
        for (const option of options) {
          addListOption(option, editor, commands, itemDefinitions);
        }
        addListToDropdown(dropdownView, itemDefinitions);
        return commands;
      }
    }
    function addListOption(option, editor, commands, itemDefinitions) {
      if (option.type === "button" || option.type === "switchbutton") {
        const model = option.model = new Model(option.model);
        const { commandName, bindIsOn } = option.model;
        const command = editor.commands.get(commandName);
        commands.push(command);
        model.set({
          commandName
        });
        model.bind("isEnabled").to(command);
        if (bindIsOn) {
          model.bind("isOn").to(command, "value");
        }
        model.set({
          withText: true
        });
      }
      itemDefinitions.add(option);
    }
    class TableSelection extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableSelection";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableUtils,
          TableUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const model = editor.model;
        const view = editor.editing.view;
        this.listenTo(model, "deleteContent", (evt, args) => this._handleDeleteContent(evt, args), {
          priority: "high"
        });
        this.listenTo(view.document, "insertText", (evt, data) => this._handleInsertTextEvent(evt, data), {
          priority: "high"
        });
        this._defineSelectionConverter();
        this._enablePluginDisabling();
      }
      /**
      * Returns the currently selected table cells or `null` if it is not a table cells selection.
      */
      getSelectedTableCells() {
        const tableUtils = this.editor.plugins.get(TableUtils);
        const selection = this.editor.model.document.selection;
        const selectedCells = tableUtils.getSelectedTableCells(selection);
        if (selectedCells.length == 0) {
          return null;
        }
        return selectedCells;
      }
      /**
      * Returns the selected table fragment as a document fragment.
      */
      getSelectionAsFragment() {
        const tableUtils = this.editor.plugins.get(TableUtils);
        const selectedCells = this.getSelectedTableCells();
        if (!selectedCells) {
          return null;
        }
        return this.editor.model.change((writer) => {
          const documentFragment = writer.createDocumentFragment();
          const { first: firstColumn, last: lastColumn } = tableUtils.getColumnIndexes(selectedCells);
          const { first: firstRow, last: lastRow } = tableUtils.getRowIndexes(selectedCells);
          const sourceTable = selectedCells[0].findAncestor("table");
          let adjustedLastRow = lastRow;
          let adjustedLastColumn = lastColumn;
          if (tableUtils.isSelectionRectangular(selectedCells)) {
            const dimensions = {
              firstColumn,
              lastColumn,
              firstRow,
              lastRow
            };
            adjustedLastRow = adjustLastRowIndex(sourceTable, dimensions);
            adjustedLastColumn = adjustLastColumnIndex(sourceTable, dimensions);
          }
          const cropDimensions = {
            startRow: firstRow,
            startColumn: firstColumn,
            endRow: adjustedLastRow,
            endColumn: adjustedLastColumn
          };
          const table2 = cropTableToDimensions(sourceTable, cropDimensions, writer);
          writer.insert(table2, documentFragment, 0);
          return documentFragment;
        });
      }
      /**
      * Sets the model selection based on given anchor and target cells (can be the same cell).
      * Takes care of setting the backward flag.
      *
      * ```ts
      * const modelRoot = editor.model.document.getRoot();
      * const firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );
      * const lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );
      *
      * const tableSelection = editor.plugins.get( 'TableSelection' );
      * tableSelection.setCellSelection( firstCell, lastCell );
      * ```
      */
      setCellSelection(anchorCell, targetCell) {
        const cellsToSelect = this._getCellsToSelect(anchorCell, targetCell);
        this.editor.model.change((writer) => {
          writer.setSelection(cellsToSelect.cells.map((cell) => writer.createRangeOn(cell)), {
            backward: cellsToSelect.backward
          });
        });
      }
      /**
      * Returns the focus cell from the current selection.
      */
      getFocusCell() {
        const selection = this.editor.model.document.selection;
        const focusCellRange = [
          ...selection.getRanges()
        ].pop();
        const element = focusCellRange.getContainedElement();
        if (element && element.is("element", "tableCell")) {
          return element;
        }
        return null;
      }
      /**
      * Returns the anchor cell from the current selection.
      */
      getAnchorCell() {
        const selection = this.editor.model.document.selection;
        const anchorCellRange = first(selection.getRanges());
        const element = anchorCellRange.getContainedElement();
        if (element && element.is("element", "tableCell")) {
          return element;
        }
        return null;
      }
      /**
      * Defines a selection converter which marks the selected cells with a specific class.
      *
      * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the
      * selection is backward or not, the last cell will usually be close to the "focus" end of the selection
      * (a selection has anchor and focus).
      *
      * The real DOM selection is then hidden with CSS.
      */
      _defineSelectionConverter() {
        const editor = this.editor;
        const highlighted = /* @__PURE__ */ new Set();
        editor.conversion.for("editingDowncast").add((dispatcher) => dispatcher.on("selection", (evt, data, conversionApi) => {
          const viewWriter = conversionApi.writer;
          clearHighlightedTableCells(viewWriter);
          const selectedCells = this.getSelectedTableCells();
          if (!selectedCells) {
            return;
          }
          for (const tableCell of selectedCells) {
            const viewElement = conversionApi.mapper.toViewElement(tableCell);
            viewWriter.addClass("ck-editor__editable_selected", viewElement);
            highlighted.add(viewElement);
          }
          const lastViewCell = conversionApi.mapper.toViewElement(selectedCells[selectedCells.length - 1]);
          viewWriter.setSelection(lastViewCell, 0);
        }, {
          priority: "lowest"
        }));
        function clearHighlightedTableCells(viewWriter) {
          for (const previouslyHighlighted of highlighted) {
            viewWriter.removeClass("ck-editor__editable_selected", previouslyHighlighted);
          }
          highlighted.clear();
        }
      }
      /**
      * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,
      * it collapses the multi-cell selection to a regular selection placed inside a table cell.
      *
      * This listener helps features that disable the table selection plugin bring the selection
      * to a clear state they can work with (for instance, because they don't support multiple cell selection).
      */
      _enablePluginDisabling() {
        const editor = this.editor;
        this.on("change:isEnabled", () => {
          if (!this.isEnabled) {
            const selectedCells = this.getSelectedTableCells();
            if (!selectedCells) {
              return;
            }
            editor.model.change((writer) => {
              const position = writer.createPositionAt(selectedCells[0], 0);
              const range = editor.model.schema.getNearestSelectionRange(position);
              writer.setSelection(range);
            });
          }
        });
      }
      /**
      * Overrides the default `model.deleteContent()` behavior over a selected table fragment.
      *
      * @param args Delete content method arguments.
      */
      _handleDeleteContent(event, args) {
        const tableUtils = this.editor.plugins.get(TableUtils);
        const selection = args[0];
        const options = args[1];
        const model = this.editor.model;
        const isBackward = !options || options.direction == "backward";
        const selectedTableCells = tableUtils.getSelectedTableCells(selection);
        if (!selectedTableCells.length) {
          return;
        }
        event.stop();
        model.change((writer) => {
          const tableCellToSelect = selectedTableCells[isBackward ? selectedTableCells.length - 1 : 0];
          model.change((writer2) => {
            for (const tableCell of selectedTableCells) {
              model.deleteContent(writer2.createSelection(tableCell, "in"));
            }
          });
          const rangeToSelect = model.schema.getNearestSelectionRange(writer.createPositionAt(tableCellToSelect, 0));
          if (selection.is("documentSelection")) {
            writer.setSelection(rangeToSelect);
          } else {
            selection.setTo(rangeToSelect);
          }
        });
      }
      /**
      * This handler makes it possible to remove the content of all selected cells by starting to type.
      * If you take a look at {@link #_defineSelectionConverter} you will find out that despite the multi-cell selection being set
      * in the model, the view selection is collapsed in the last cell (because most browsers are unable to render multi-cell selections;
      * yes, it's a hack).
      *
      * When multiple cells are selected in the model and the user starts to type, the
      * {@link module:engine/view/document~Document#event:insertText} event carries information provided by the
      * beforeinput DOM  event, that in turn only knows about this collapsed DOM selection in the last cell.
      *
      * As a result, the selected cells have no chance to be cleaned up. To fix this, this listener intercepts
      * the event and injects the custom view selection in the data that translates correctly to the actual state
      * of the multi-cell selection in the model.
      *
      * @param data Insert text event data.
      */
      _handleInsertTextEvent(evt, data) {
        const editor = this.editor;
        const selectedCells = this.getSelectedTableCells();
        if (!selectedCells) {
          return;
        }
        const view = editor.editing.view;
        const mapper = editor.editing.mapper;
        const viewRanges = selectedCells.map((tableCell) => view.createRangeOn(mapper.toViewElement(tableCell)));
        data.selection = view.createSelection(viewRanges);
      }
      /**
      * Returns an array of table cells that should be selected based on the
      * given anchor cell and target (focus) cell.
      *
      * The cells are returned in a reverse direction if the selection is backward.
      */
      _getCellsToSelect(anchorCell, targetCell) {
        const tableUtils = this.editor.plugins.get("TableUtils");
        const startLocation = tableUtils.getCellLocation(anchorCell);
        const endLocation = tableUtils.getCellLocation(targetCell);
        const startRow = Math.min(startLocation.row, endLocation.row);
        const endRow = Math.max(startLocation.row, endLocation.row);
        const startColumn = Math.min(startLocation.column, endLocation.column);
        const endColumn = Math.max(startLocation.column, endLocation.column);
        const selectionMap = new Array(endRow - startRow + 1).fill(null).map(() => []);
        const walkerOptions = {
          startRow,
          endRow,
          startColumn,
          endColumn
        };
        for (const { row, cell } of new TableWalker(anchorCell.findAncestor("table"), walkerOptions)) {
          selectionMap[row - startRow].push(cell);
        }
        const flipVertically = endLocation.row < startLocation.row;
        const flipHorizontally = endLocation.column < startLocation.column;
        if (flipVertically) {
          selectionMap.reverse();
        }
        if (flipHorizontally) {
          selectionMap.forEach((row) => row.reverse());
        }
        return {
          cells: selectionMap.flat(),
          backward: flipVertically || flipHorizontally
        };
      }
    }
    class TableClipboard extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableClipboard";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ClipboardMarkersUtils,
          ClipboardPipeline,
          TableSelection,
          TableUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        this.listenTo(viewDocument, "copy", (evt, data) => this._onCopyCut(evt, data));
        this.listenTo(viewDocument, "cut", (evt, data) => this._onCopyCut(evt, data));
        this.listenTo(editor.model, "insertContent", (evt, [content, selectable]) => this._onInsertContent(evt, content, selectable), {
          priority: "high"
        });
        this.decorate("_replaceTableSlotCell");
      }
      /**
      * Copies table content to a clipboard on "copy" & "cut" events.
      *
      * @param evt An object containing information about the handled event.
      * @param data Clipboard event data.
      */
      _onCopyCut(evt, data) {
        const view = this.editor.editing.view;
        const tableSelection = this.editor.plugins.get(TableSelection);
        const clipboardMarkersUtils = this.editor.plugins.get(ClipboardMarkersUtils);
        if (!tableSelection.getSelectedTableCells()) {
          return;
        }
        if (evt.name == "cut" && !this.editor.model.canEditAt(this.editor.model.document.selection)) {
          return;
        }
        data.preventDefault();
        evt.stop();
        this.editor.model.enqueueChange({
          isUndoable: evt.name === "cut"
        }, () => {
          const documentFragment = clipboardMarkersUtils._copySelectedFragmentWithMarkers(evt.name, this.editor.model.document.selection, () => tableSelection.getSelectionAsFragment());
          view.document.fire("clipboardOutput", {
            dataTransfer: data.dataTransfer,
            content: this.editor.data.toView(documentFragment),
            method: evt.name
          });
        });
      }
      /**
      * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside
      * selected table fragment.
      *
      * Depending on selected table fragment:
      * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.
      * - If dimensions are equal it will replace selected table fragment with a pasted table contents.
      *
      * @param content The content to insert.
      * @param selectable The selection into which the content should be inserted.
      * If not provided the current model document selection will be used.
      */
      _onInsertContent(evt, content, selectable) {
        if (selectable && !selectable.is("documentSelection")) {
          return;
        }
        const model = this.editor.model;
        const tableUtils = this.editor.plugins.get(TableUtils);
        const clipboardMarkersUtils = this.editor.plugins.get(ClipboardMarkersUtils);
        const pastedTable = this.getTableIfOnlyTableInContent(content, model);
        if (!pastedTable) {
          return;
        }
        const selectedTableCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        if (!selectedTableCells.length) {
          removeEmptyRowsColumns(pastedTable, tableUtils);
          return;
        }
        evt.stop();
        if (content.is("documentFragment")) {
          clipboardMarkersUtils._pasteMarkersIntoTransformedElement(content.markers, (writer) => this._replaceSelectedCells(pastedTable, selectedTableCells, writer));
        } else {
          this.editor.model.change((writer) => {
            this._replaceSelectedCells(pastedTable, selectedTableCells, writer);
          });
        }
      }
      /**
      * Inserts provided `selectedTableCells` into `pastedTable`.
      */
      _replaceSelectedCells(pastedTable, selectedTableCells, writer) {
        const tableUtils = this.editor.plugins.get(TableUtils);
        const pastedDimensions = {
          width: tableUtils.getColumns(pastedTable),
          height: tableUtils.getRows(pastedTable)
        };
        const selection = prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils);
        const selectionHeight = selection.lastRow - selection.firstRow + 1;
        const selectionWidth = selection.lastColumn - selection.firstColumn + 1;
        const cropDimensions = {
          startRow: 0,
          startColumn: 0,
          endRow: Math.min(selectionHeight, pastedDimensions.height) - 1,
          endColumn: Math.min(selectionWidth, pastedDimensions.width) - 1
        };
        pastedTable = cropTableToDimensions(pastedTable, cropDimensions, writer);
        const selectedTable = selectedTableCells[0].findAncestor("table");
        const cellsToSelect = this._replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer);
        if (this.editor.plugins.get("TableSelection").isEnabled) {
          const selectionRanges = tableUtils.sortRanges(cellsToSelect.map((cell) => writer.createRangeOn(cell)));
          writer.setSelection(selectionRanges);
        } else {
          writer.setSelection(cellsToSelect[0], 0);
        }
        return selectedTable;
      }
      /**
      * Replaces the part of selectedTable with pastedTable.
      */
      _replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer) {
        const { width: pastedWidth, height: pastedHeight } = pastedDimensions;
        const pastedTableLocationMap = createLocationMap(pastedTable, pastedWidth, pastedHeight);
        const selectedTableMap = [
          ...new TableWalker(selectedTable, {
            startRow: selection.firstRow,
            endRow: selection.lastRow,
            startColumn: selection.firstColumn,
            endColumn: selection.lastColumn,
            includeAllSlots: true
          })
        ];
        const cellsToSelect = [];
        let insertPosition;
        for (const tableSlot of selectedTableMap) {
          const { row, column } = tableSlot;
          if (column === selection.firstColumn) {
            insertPosition = tableSlot.getPositionBefore();
          }
          const pastedRow = row - selection.firstRow;
          const pastedColumn = column - selection.firstColumn;
          const pastedCell = pastedTableLocationMap[pastedRow % pastedHeight][pastedColumn % pastedWidth];
          const cellToInsert = pastedCell ? writer.cloneElement(pastedCell) : null;
          const newTableCell = this._replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer);
          if (!newTableCell) {
            continue;
          }
          trimTableCellIfNeeded(newTableCell, row, column, selection.lastRow, selection.lastColumn, writer);
          cellsToSelect.push(newTableCell);
          insertPosition = writer.createPositionAfter(newTableCell);
        }
        const headingRows = parseInt(selectedTable.getAttribute("headingRows") || "0");
        const headingColumns = parseInt(selectedTable.getAttribute("headingColumns") || "0");
        const areHeadingRowsIntersectingSelection = selection.firstRow < headingRows && headingRows <= selection.lastRow;
        const areHeadingColumnsIntersectingSelection = selection.firstColumn < headingColumns && headingColumns <= selection.lastColumn;
        if (areHeadingRowsIntersectingSelection) {
          const columnsLimit = {
            first: selection.firstColumn,
            last: selection.lastColumn
          };
          const newCells = doHorizontalSplit(selectedTable, headingRows, columnsLimit, writer, selection.firstRow);
          cellsToSelect.push(...newCells);
        }
        if (areHeadingColumnsIntersectingSelection) {
          const rowsLimit = {
            first: selection.firstRow,
            last: selection.lastRow
          };
          const newCells = doVerticalSplit(selectedTable, headingColumns, rowsLimit, writer);
          cellsToSelect.push(...newCells);
        }
        return cellsToSelect;
      }
      /**
      * Replaces a single table slot.
      *
      * @returns Inserted table cell or null if slot should remain empty.
      * @private
      */
      _replaceTableSlotCell(tableSlot, cellToInsert, insertPosition, writer) {
        const { cell, isAnchor } = tableSlot;
        if (isAnchor) {
          writer.remove(cell);
        }
        if (!cellToInsert) {
          return null;
        }
        writer.insert(cellToInsert, insertPosition);
        return cellToInsert;
      }
      /**
      * Extracts the table for pasting into a table.
      *
      * @param content The content to insert.
      * @param model The editor model.
      */
      getTableIfOnlyTableInContent(content, model) {
        if (!content.is("documentFragment") && !content.is("element")) {
          return null;
        }
        if (content.is("element", "table")) {
          return content;
        }
        if (content.childCount == 1 && content.getChild(0).is("element", "table")) {
          return content.getChild(0);
        }
        const contentRange = model.createRangeIn(content);
        for (const element of contentRange.getItems()) {
          if (element.is("element", "table")) {
            const rangeBefore = model.createRange(contentRange.start, model.createPositionBefore(element));
            if (model.hasContent(rangeBefore, {
              ignoreWhitespaces: true
            })) {
              return null;
            }
            const rangeAfter = model.createRange(model.createPositionAfter(element), contentRange.end);
            if (model.hasContent(rangeAfter, {
              ignoreWhitespaces: true
            })) {
              return null;
            }
            return element;
          }
        }
        return null;
      }
    }
    function prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils) {
      const selectedTable = selectedTableCells[0].findAncestor("table");
      const columnIndexes = tableUtils.getColumnIndexes(selectedTableCells);
      const rowIndexes = tableUtils.getRowIndexes(selectedTableCells);
      const selection = {
        firstColumn: columnIndexes.first,
        lastColumn: columnIndexes.last,
        firstRow: rowIndexes.first,
        lastRow: rowIndexes.last
      };
      const shouldExpandSelection = selectedTableCells.length === 1;
      if (shouldExpandSelection) {
        selection.lastRow += pastedDimensions.height - 1;
        selection.lastColumn += pastedDimensions.width - 1;
        expandTableSize(selectedTable, selection.lastRow + 1, selection.lastColumn + 1, tableUtils);
      }
      if (shouldExpandSelection || !tableUtils.isSelectionRectangular(selectedTableCells)) {
        splitCellsToRectangularSelection(selectedTable, selection, writer);
      } else {
        selection.lastRow = adjustLastRowIndex(selectedTable, selection);
        selection.lastColumn = adjustLastColumnIndex(selectedTable, selection);
      }
      return selection;
    }
    function expandTableSize(table2, expectedHeight, expectedWidth, tableUtils) {
      const tableWidth = tableUtils.getColumns(table2);
      const tableHeight = tableUtils.getRows(table2);
      if (expectedWidth > tableWidth) {
        tableUtils.insertColumns(table2, {
          at: tableWidth,
          columns: expectedWidth - tableWidth
        });
      }
      if (expectedHeight > tableHeight) {
        tableUtils.insertRows(table2, {
          at: tableHeight,
          rows: expectedHeight - tableHeight
        });
      }
    }
    function createLocationMap(table2, width, height) {
      const map = new Array(height).fill(null).map(() => new Array(width).fill(null));
      for (const { column, row, cell } of new TableWalker(table2)) {
        map[row][column] = cell;
      }
      return map;
    }
    function splitCellsToRectangularSelection(table2, dimensions, writer) {
      const { firstRow, lastRow, firstColumn, lastColumn } = dimensions;
      const rowIndexes = {
        first: firstRow,
        last: lastRow
      };
      const columnIndexes = {
        first: firstColumn,
        last: lastColumn
      };
      doVerticalSplit(table2, firstColumn, rowIndexes, writer);
      doVerticalSplit(table2, lastColumn + 1, rowIndexes, writer);
      doHorizontalSplit(table2, firstRow, columnIndexes, writer);
      doHorizontalSplit(table2, lastRow + 1, columnIndexes, writer, firstRow);
    }
    function doHorizontalSplit(table2, splitRow, limitColumns, writer, startRow = 0) {
      if (splitRow < 1) {
        return;
      }
      const overlappingCells = getVerticallyOverlappingCells(table2, splitRow, startRow);
      const cellsToSplit = overlappingCells.filter(({ column, cellWidth }) => isAffectedBySelection(column, cellWidth, limitColumns));
      return cellsToSplit.map(({ cell }) => splitHorizontally(cell, splitRow, writer));
    }
    function doVerticalSplit(table2, splitColumn, limitRows, writer) {
      if (splitColumn < 1) {
        return;
      }
      const overlappingCells = getHorizontallyOverlappingCells(table2, splitColumn);
      const cellsToSplit = overlappingCells.filter(({ row, cellHeight }) => isAffectedBySelection(row, cellHeight, limitRows));
      return cellsToSplit.map(({ cell, column }) => splitVertically(cell, column, splitColumn, writer));
    }
    function isAffectedBySelection(index2, span, limit) {
      const endIndex = index2 + span - 1;
      const { first: first2, last: last2 } = limit;
      const isInsideSelection = index2 >= first2 && index2 <= last2;
      const overlapsSelectionFromOutside = index2 < first2 && endIndex >= first2;
      return isInsideSelection || overlapsSelectionFromOutside;
    }
    class TableKeyboard extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableKeyboard";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableSelection,
          TableUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const view = editor.editing.view;
        const viewDocument = view.document;
        const t = editor.t;
        this.listenTo(viewDocument, "arrowKey", (...args) => this._onArrowKey(...args), {
          context: "table"
        });
        this.listenTo(viewDocument, "tab", (...args) => this._handleTabOnSelectedTable(...args), {
          context: "figure"
        });
        this.listenTo(viewDocument, "tab", (...args) => this._handleTab(...args), {
          context: [
            "th",
            "td"
          ]
        });
        editor.accessibility.addKeystrokeInfoGroup({
          id: "table",
          label: t("Keystrokes that can be used in a table cell"),
          keystrokes: [
            {
              label: t("Move the selection to the next cell"),
              keystroke: "Tab"
            },
            {
              label: t("Move the selection to the previous cell"),
              keystroke: "Shift+Tab"
            },
            {
              label: t("Insert a new table row (when in the last cell of a table)"),
              keystroke: "Tab"
            },
            {
              label: t("Navigate through the table"),
              keystroke: [
                [
                  "arrowup"
                ],
                [
                  "arrowright"
                ],
                [
                  "arrowdown"
                ],
                [
                  "arrowleft"
                ]
              ]
            }
          ]
        });
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
      * when the table widget is selected.
      */
      _handleTabOnSelectedTable(bubblingEventInfo, domEventData) {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        const selectedElement = selection.getSelectedElement();
        if (!selectedElement || !selectedElement.is("element", "table")) {
          return;
        }
        domEventData.preventDefault();
        domEventData.stopPropagation();
        bubblingEventInfo.stop();
        editor.model.change((writer) => {
          writer.setSelection(writer.createRangeIn(selectedElement.getChild(0).getChild(0)));
        });
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:tab tab} events for the <kbd>Tab</kbd> key executed
      * inside table cells.
      */
      _handleTab(bubblingEventInfo, domEventData) {
        const editor = this.editor;
        const tableUtils = this.editor.plugins.get(TableUtils);
        const tableSelection = this.editor.plugins.get("TableSelection");
        const selection = editor.model.document.selection;
        const isForward = !domEventData.shiftKey;
        let tableCell = tableUtils.getTableCellsContainingSelection(selection)[0];
        if (!tableCell) {
          tableCell = tableSelection.getFocusCell();
        }
        if (!tableCell) {
          return;
        }
        domEventData.preventDefault();
        domEventData.stopPropagation();
        bubblingEventInfo.stop();
        const tableRow = tableCell.parent;
        const table2 = tableRow.parent;
        const currentRowIndex = table2.getChildIndex(tableRow);
        const currentCellIndex = tableRow.getChildIndex(tableCell);
        const isFirstCellInRow = currentCellIndex === 0;
        if (!isForward && isFirstCellInRow && currentRowIndex === 0) {
          editor.model.change((writer) => {
            writer.setSelection(writer.createRangeOn(table2));
          });
          return;
        }
        const isLastCellInRow = currentCellIndex === tableRow.childCount - 1;
        const isLastRow = currentRowIndex === tableUtils.getRows(table2) - 1;
        if (isForward && isLastRow && isLastCellInRow) {
          editor.execute("insertTableRowBelow");
          if (currentRowIndex === tableUtils.getRows(table2) - 1) {
            editor.model.change((writer) => {
              writer.setSelection(writer.createRangeOn(table2));
            });
            return;
          }
        }
        let cellToFocus;
        if (isForward && isLastCellInRow) {
          const nextRow = table2.getChild(currentRowIndex + 1);
          cellToFocus = nextRow.getChild(0);
        } else if (!isForward && isFirstCellInRow) {
          const previousRow = table2.getChild(currentRowIndex - 1);
          cellToFocus = previousRow.getChild(previousRow.childCount - 1);
        } else {
          cellToFocus = tableRow.getChild(currentCellIndex + (isForward ? 1 : -1));
        }
        editor.model.change((writer) => {
          writer.setSelection(writer.createRangeIn(cellToFocus));
        });
      }
      /**
      * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
      */
      _onArrowKey(eventInfo, domEventData) {
        const editor = this.editor;
        const keyCode = domEventData.keyCode;
        const direction = getLocalizedArrowKeyCodeDirection(keyCode, editor.locale.contentLanguageDirection);
        const wasHandled = this._handleArrowKeys(direction, domEventData.shiftKey);
        if (wasHandled) {
          domEventData.preventDefault();
          domEventData.stopPropagation();
          eventInfo.stop();
        }
      }
      /**
      * Handles arrow keys to move the selection around the table.
      *
      * @param direction The direction of the arrow key.
      * @param expandSelection If the current selection should be expanded.
      * @returns Returns `true` if key was handled.
      */
      _handleArrowKeys(direction, expandSelection) {
        const tableUtils = this.editor.plugins.get(TableUtils);
        const tableSelection = this.editor.plugins.get("TableSelection");
        const model = this.editor.model;
        const selection = model.document.selection;
        const isForward = [
          "right",
          "down"
        ].includes(direction);
        const selectedCells = tableUtils.getSelectedTableCells(selection);
        if (selectedCells.length) {
          let focusCell;
          if (expandSelection) {
            focusCell = tableSelection.getFocusCell();
          } else {
            focusCell = isForward ? selectedCells[selectedCells.length - 1] : selectedCells[0];
          }
          this._navigateFromCellInDirection(focusCell, direction, expandSelection);
          return true;
        }
        const tableCell = selection.focus.findAncestor("tableCell");
        /* istanbul ignore if: paranoid check -- @preserve */
        if (!tableCell) {
          return false;
        }
        if (!selection.isCollapsed) {
          if (expandSelection) {
            if (selection.isBackward == isForward && !selection.containsEntireContent(tableCell)) {
              return false;
            }
          } else {
            const selectedElement = selection.getSelectedElement();
            if (!selectedElement || !model.schema.isObject(selectedElement)) {
              return false;
            }
          }
        }
        if (this._isSelectionAtCellEdge(selection, tableCell, isForward)) {
          this._navigateFromCellInDirection(tableCell, direction, expandSelection);
          return true;
        }
        return false;
      }
      /**
      * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.
      *
      * @param selection The current selection.
      * @param tableCell The current table cell element.
      * @param isForward The expected navigation direction.
      */
      _isSelectionAtCellEdge(selection, tableCell, isForward) {
        const model = this.editor.model;
        const schema = this.editor.model.schema;
        const focus = isForward ? selection.getLastPosition() : selection.getFirstPosition();
        if (!schema.getLimitElement(focus).is("element", "tableCell")) {
          const boundaryPosition = model.createPositionAt(tableCell, isForward ? "end" : 0);
          return boundaryPosition.isTouching(focus);
        }
        const probe = model.createSelection(focus);
        model.modifySelection(probe, {
          direction: isForward ? "forward" : "backward"
        });
        return focus.isEqual(probe.focus);
      }
      /**
      * Moves the selection from the given table cell in the specified direction.
      *
      * @param focusCell The table cell that is current multi-cell selection focus.
      * @param direction Direction in which selection should move.
      * @param expandSelection If the current selection should be expanded. Default value is false.
      */
      _navigateFromCellInDirection(focusCell, direction, expandSelection = false) {
        const model = this.editor.model;
        const table2 = focusCell.findAncestor("table");
        const tableMap = [
          ...new TableWalker(table2, {
            includeAllSlots: true
          })
        ];
        const { row: lastRow, column: lastColumn } = tableMap[tableMap.length - 1];
        const currentCellInfo = tableMap.find(({ cell }) => cell == focusCell);
        let { row, column } = currentCellInfo;
        switch (direction) {
          case "left":
            column--;
            break;
          case "up":
            row--;
            break;
          case "right":
            column += currentCellInfo.cellWidth;
            break;
          case "down":
            row += currentCellInfo.cellHeight;
            break;
        }
        const isOutsideVertically = row < 0 || row > lastRow;
        const isBeforeFirstCell = column < 0 && row <= 0;
        const isAfterLastCell = column > lastColumn && row >= lastRow;
        if (isOutsideVertically || isBeforeFirstCell || isAfterLastCell) {
          model.change((writer) => {
            writer.setSelection(writer.createRangeOn(table2));
          });
          return;
        }
        if (column < 0) {
          column = expandSelection ? 0 : lastColumn;
          row--;
        } else if (column > lastColumn) {
          column = expandSelection ? lastColumn : 0;
          row++;
        }
        const cellToSelect = tableMap.find((cellInfo) => cellInfo.row == row && cellInfo.column == column).cell;
        const isForward = [
          "right",
          "down"
        ].includes(direction);
        const tableSelection = this.editor.plugins.get("TableSelection");
        if (expandSelection && tableSelection.isEnabled) {
          const anchorCell = tableSelection.getAnchorCell() || focusCell;
          tableSelection.setCellSelection(anchorCell, cellToSelect);
        } else {
          const positionToSelect = model.createPositionAt(cellToSelect, isForward ? 0 : "end");
          model.change((writer) => {
            writer.setSelection(positionToSelect);
          });
        }
      }
    }
    class MouseEventsObserver extends DomEventObserver {
      constructor() {
        super(...arguments);
        __publicField(this, "domEventType", [
          "mousemove",
          "mouseleave"
        ]);
      }
      /**
      * @inheritDoc
      */
      onDomEvent(domEvent) {
        this.fire(domEvent.type, domEvent);
      }
    }
    class TableMouse extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableMouse";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableSelection,
          TableUtils
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        editor.editing.view.addObserver(MouseEventsObserver);
        this._enableShiftClickSelection();
        this._enableMouseDragSelection();
      }
      /**
      * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held
      * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.
      */
      _enableShiftClickSelection() {
        const editor = this.editor;
        const tableUtils = editor.plugins.get(TableUtils);
        let blockSelectionChange = false;
        const tableSelection = editor.plugins.get(TableSelection);
        this.listenTo(editor.editing.view.document, "mousedown", (evt, domEventData) => {
          const selection = editor.model.document.selection;
          if (!this.isEnabled || !tableSelection.isEnabled) {
            return;
          }
          if (!domEventData.domEvent.shiftKey) {
            return;
          }
          const anchorCell = tableSelection.getAnchorCell() || tableUtils.getTableCellsContainingSelection(selection)[0];
          if (!anchorCell) {
            return;
          }
          const targetCell = this._getModelTableCellFromDomEvent(domEventData);
          if (targetCell && haveSameTableParent(anchorCell, targetCell)) {
            blockSelectionChange = true;
            tableSelection.setCellSelection(anchorCell, targetCell);
            domEventData.preventDefault();
          }
        });
        this.listenTo(editor.editing.view.document, "mouseup", () => {
          blockSelectionChange = false;
        });
        this.listenTo(editor.editing.view.document, "selectionChange", (evt) => {
          if (blockSelectionChange) {
            evt.stop();
          }
        }, {
          priority: "highest"
        });
      }
      /**
      * Enables making cells selection by dragging.
      *
      * The selection is made only on mousemove. Mouse tracking is started on mousedown.
      * However, the cells selection is enabled only after the mouse cursor left the anchor cell.
      * Thanks to that normal text selection within one cell works just fine. However, you can still select
      * just one cell by leaving the anchor cell and moving back to it.
      */
      _enableMouseDragSelection() {
        const editor = this.editor;
        let anchorCell, targetCell;
        let beganCellSelection = false;
        let blockSelectionChange = false;
        const tableSelection = editor.plugins.get(TableSelection);
        this.listenTo(editor.editing.view.document, "mousedown", (evt, domEventData) => {
          if (!this.isEnabled || !tableSelection.isEnabled) {
            return;
          }
          if (domEventData.domEvent.shiftKey || domEventData.domEvent.ctrlKey || domEventData.domEvent.altKey) {
            return;
          }
          anchorCell = this._getModelTableCellFromDomEvent(domEventData);
        });
        this.listenTo(editor.editing.view.document, "mousemove", (evt, domEventData) => {
          if (!domEventData.domEvent.buttons) {
            return;
          }
          if (!anchorCell) {
            return;
          }
          const newTargetCell = this._getModelTableCellFromDomEvent(domEventData);
          if (newTargetCell && haveSameTableParent(anchorCell, newTargetCell)) {
            targetCell = newTargetCell;
            if (!beganCellSelection && targetCell != anchorCell) {
              beganCellSelection = true;
            }
          }
          if (!beganCellSelection) {
            return;
          }
          blockSelectionChange = true;
          tableSelection.setCellSelection(anchorCell, targetCell);
          domEventData.preventDefault();
        });
        this.listenTo(editor.editing.view.document, "mouseup", () => {
          beganCellSelection = false;
          blockSelectionChange = false;
          anchorCell = null;
          targetCell = null;
        });
        this.listenTo(editor.editing.view.document, "selectionChange", (evt) => {
          if (blockSelectionChange) {
            evt.stop();
          }
        }, {
          priority: "highest"
        });
      }
      /**
      * Returns the model table cell element based on the target element of the passed DOM event.
      *
      * @returns Returns the table cell or `undefined`.
      */
      _getModelTableCellFromDomEvent(domEventData) {
        const viewTargetElement = domEventData.target;
        const viewPosition = this.editor.editing.view.createPositionAt(viewTargetElement, 0);
        const modelPosition = this.editor.editing.mapper.toModelPosition(viewPosition);
        const modelElement = modelPosition.parent;
        return modelElement.findAncestor("tableCell", {
          includeSelf: true
        });
      }
    }
    function haveSameTableParent(cellA, cellB) {
      return cellA.parent.parent == cellB.parent.parent;
    }
    class Table extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableEditing,
          TableUI,
          TableSelection,
          TableMouse,
          TableKeyboard,
          TableClipboard,
          Widget
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "Table";
      }
    }
    function getSelectionAffectedTableWidget(selection) {
      const selectedTable = getSelectedTableWidget(selection);
      if (selectedTable) {
        return selectedTable;
      }
      return getTableWidgetAncestor(selection);
    }
    function getSelectedTableWidget(selection) {
      const viewElement = selection.getSelectedElement();
      if (viewElement && isTableWidget(viewElement)) {
        return viewElement;
      }
      return null;
    }
    function getTableWidgetAncestor(selection) {
      const selectionPosition = selection.getFirstPosition();
      if (!selectionPosition) {
        return null;
      }
      let parent2 = selectionPosition.parent;
      while (parent2) {
        if (parent2.is("element") && isTableWidget(parent2)) {
          return parent2;
        }
        parent2 = parent2.parent;
      }
      return null;
    }
    function isTableWidget(viewElement) {
      return !!viewElement.getCustomProperty("table") && isWidget(viewElement);
    }
    class TableToolbar extends Plugin {
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          WidgetToolbarRepository
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableToolbar";
      }
      /**
      * @inheritDoc
      */
      afterInit() {
        const editor = this.editor;
        const t = editor.t;
        const widgetToolbarRepository = editor.plugins.get(WidgetToolbarRepository);
        const tableContentToolbarItems = editor.config.get("table.contentToolbar");
        const tableToolbarItems = editor.config.get("table.tableToolbar");
        if (tableContentToolbarItems) {
          widgetToolbarRepository.register("tableContent", {
            ariaLabel: t("Table toolbar"),
            items: tableContentToolbarItems,
            getRelatedElement: getTableWidgetAncestor
          });
        }
        if (tableToolbarItems) {
          widgetToolbarRepository.register("table", {
            ariaLabel: t("Table toolbar"),
            items: tableToolbarItems,
            getRelatedElement: getSelectedTableWidget
          });
        }
      }
    }
    class ColorInputView extends View {
      /**
      * Creates an instance of the color input view.
      *
      * @param locale The locale instance.
      * @param options The input options.
      * @param options.colorDefinitions The colors to be displayed in the palette inside the input's dropdown.
      * @param options.columns The number of columns in which the colors will be displayed.
      * @param options.defaultColorValue If specified, the color input view will replace the "Remove color" button with
      * the "Restore default" button. Instead of clearing the input field, the default color value will be set.
      */
      constructor(locale, options) {
        super(locale);
        /**
        * A cached reference to the options passed to the constructor.
        */
        __publicField(this, "options");
        /**
        * Tracks information about the DOM focus in the view.
        */
        __publicField(this, "focusTracker");
        /**
        * Helps cycling over focusable children in the input view.
        */
        __publicField(this, "focusCycler");
        /**
        * A collection of views that can be focused in the view.
        */
        __publicField(this, "_focusables");
        /**
        * An instance of the dropdown allowing to select a color from a grid.
        */
        __publicField(this, "dropdownView");
        /**
        * An instance of the input allowing the user to type a color value.
        */
        __publicField(this, "inputView");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * The flag that indicates whether the user is still typing.
        * If set to true, it means that the text input field ({@link #inputView}) still has the focus.
        * So, we should interrupt the user by replacing the input's value.
        */
        __publicField(this, "_stillTyping");
        this.set("value", "");
        this.set("isReadOnly", false);
        this.set("isFocused", false);
        this.set("isEmpty", true);
        this.options = options;
        this.focusTracker = new FocusTracker();
        this._focusables = new ViewCollection();
        this.dropdownView = this._createDropdownView();
        this.inputView = this._createInputTextView();
        this.keystrokes = new KeystrokeHandler();
        this._stillTyping = false;
        this.focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate items backwards using the <kbd>Shift</kbd> + <kbd>Tab</kbd> keystroke.
            focusPrevious: "shift + tab",
            // Navigate items forwards using the <kbd>Tab</kbd> key.
            focusNext: "tab"
          }
        });
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-input-color"
            ]
          },
          children: [
            this.dropdownView,
            this.inputView
          ]
        });
        this.on("change:value", (evt, name, inputValue) => this._setInputValue(inputValue));
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        [
          this.inputView,
          this.dropdownView.buttonView
        ].forEach((view) => {
          this.focusTracker.add(view.element);
          this._focusables.add(view);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * Focuses the view.
      */
      focus(direction) {
        if (direction === -1) {
          this.focusCycler.focusLast();
        } else {
          this.focusCycler.focusFirst();
        }
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Creates and configures the {@link #dropdownView}.
      */
      _createDropdownView() {
        const locale = this.locale;
        const t = locale.t;
        const bind = this.bindTemplate;
        const colorSelector = this._createColorSelector(locale);
        const dropdown = createDropdown(locale);
        const colorPreview = new View();
        colorPreview.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck",
              "ck-input-color__button__preview"
            ],
            style: {
              backgroundColor: bind.to("value")
            }
          },
          children: [
            {
              tag: "span",
              attributes: {
                class: [
                  "ck",
                  "ck-input-color__button__preview__no-color-indicator",
                  bind.if("value", "ck-hidden", (value) => value != "")
                ]
              }
            }
          ]
        });
        dropdown.buttonView.extendTemplate({
          attributes: {
            class: "ck-input-color__button"
          }
        });
        dropdown.buttonView.children.add(colorPreview);
        dropdown.buttonView.label = t("Color picker");
        dropdown.buttonView.tooltip = true;
        dropdown.panelPosition = locale.uiLanguageDirection === "rtl" ? "se" : "sw";
        dropdown.panelView.children.add(colorSelector);
        dropdown.bind("isEnabled").to(this, "isReadOnly", (value) => !value);
        dropdown.on("change:isOpen", (evt, name, isVisible2) => {
          if (isVisible2) {
            colorSelector.updateSelectedColors();
            colorSelector.showColorGridsFragment();
          }
        });
        return dropdown;
      }
      /**
      * Creates and configures an instance of {@link module:ui/inputtext/inputtextview~InputTextView}.
      *
      * @returns A configured instance to be set as {@link #inputView}.
      */
      _createInputTextView() {
        const locale = this.locale;
        const inputView = new InputTextView(locale);
        inputView.extendTemplate({
          on: {
            blur: inputView.bindTemplate.to("blur")
          }
        });
        inputView.value = this.value;
        inputView.bind("isReadOnly", "hasError").to(this);
        this.bind("isFocused", "isEmpty").to(inputView);
        inputView.on("input", () => {
          const inputValue = inputView.element.value;
          const mappedColor = this.options.colorDefinitions.find((def) => inputValue === def.label);
          this._stillTyping = true;
          this.value = mappedColor && mappedColor.color || inputValue;
        });
        inputView.on("blur", () => {
          this._stillTyping = false;
          this._setInputValue(inputView.element.value);
        });
        inputView.delegate("input").to(this);
        return inputView;
      }
      /**
      * Creates and configures the panel with "color grid" and "color picker" inside the {@link #dropdownView}.
      */
      _createColorSelector(locale) {
        const t = locale.t;
        const defaultColor = this.options.defaultColorValue || "";
        const removeColorButtonLabel = defaultColor ? t("Restore default") : t("Remove color");
        const colorSelector = new ColorSelectorView(locale, {
          colors: this.options.colorDefinitions,
          columns: this.options.columns,
          removeButtonLabel: removeColorButtonLabel,
          colorPickerLabel: t("Color picker"),
          colorPickerViewConfig: this.options.colorPickerConfig === false ? false : {
            ...this.options.colorPickerConfig,
            hideInput: true
          }
        });
        colorSelector.appendUI();
        colorSelector.on("execute", (evt, data) => {
          if (data.source === "colorPickerSaveButton") {
            this.dropdownView.isOpen = false;
            return;
          }
          this.value = data.value || defaultColor;
          this.fire("input");
          if (data.source !== "colorPicker") {
            this.dropdownView.isOpen = false;
          }
        });
        let backupColor = this.value;
        colorSelector.on("colorPicker:cancel", () => {
          this.value = backupColor;
          this.fire("input");
          this.dropdownView.isOpen = false;
        });
        colorSelector.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
          backupColor = this.value;
        });
        colorSelector.bind("selectedColor").to(this, "value");
        return colorSelector;
      }
      /**
      * Sets {@link #inputView}'s value property to the color value or color label,
      * if there is one and the user is not typing.
      *
      * Handles cases like:
      *
      * * Someone picks the color in the grid.
      * * The color is set from the plugin level.
      *
      * @param inputValue Color value to be set.
      */
      _setInputValue(inputValue) {
        if (!this._stillTyping) {
          const normalizedInputValue = normalizeColor(inputValue);
          const mappedColor = this.options.colorDefinitions.find((def) => normalizedInputValue === normalizeColor(def.color));
          if (mappedColor) {
            this.inputView.value = mappedColor.label;
          } else {
            this.inputView.value = inputValue || "";
          }
        }
      }
    }
    function normalizeColor(colorString) {
      return colorString.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ");
    }
    const isEmpty = (val) => val === "";
    function getBorderStyleLabels(t) {
      return {
        none: t("None"),
        solid: t("Solid"),
        dotted: t("Dotted"),
        dashed: t("Dashed"),
        double: t("Double"),
        groove: t("Groove"),
        ridge: t("Ridge"),
        inset: t("Inset"),
        outset: t("Outset")
      };
    }
    function getLocalizedColorErrorText(t) {
      return t('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
    }
    function getLocalizedLengthErrorText(t) {
      return t('The value is invalid. Try "10px" or "2em" or simply "2".');
    }
    function colorFieldValidator(value) {
      value = value.trim().toLowerCase();
      return isEmpty(value) || isColor(value);
    }
    function lengthFieldValidator(value) {
      value = value.trim();
      return isEmpty(value) || isNumberString(value) || isLength(value) || isPercentage(value);
    }
    function lineWidthFieldValidator(value) {
      value = value.trim();
      return isEmpty(value) || isNumberString(value) || isLength(value);
    }
    function getBorderStyleDefinitions(view, defaultStyle) {
      const itemDefinitions = new Collection();
      const styleLabels = getBorderStyleLabels(view.t);
      for (const style in styleLabels) {
        const definition = {
          type: "button",
          model: new Model({
            _borderStyleValue: style,
            label: styleLabels[style],
            role: "menuitemradio",
            withText: true
          })
        };
        if (style === "none") {
          definition.model.bind("isOn").to(view, "borderStyle", (value) => {
            if (defaultStyle === "none") {
              return !value;
            }
            return value === style;
          });
        } else {
          definition.model.bind("isOn").to(view, "borderStyle", (value) => {
            return value === style;
          });
        }
        itemDefinitions.add(definition);
      }
      return itemDefinitions;
    }
    function fillToolbar(options) {
      const { view, icons: icons2, toolbar, labels, propertyName, nameToValue, defaultValue } = options;
      for (const name in labels) {
        const button = new ButtonView(view.locale);
        button.set({
          label: labels[name],
          icon: icons2[name],
          tooltip: labels[name]
        });
        const buttonValue = nameToValue ? nameToValue(name) : name;
        button.bind("isOn").to(view, propertyName, (value) => {
          let valueToCompare = value;
          if (value === "" && defaultValue) {
            valueToCompare = defaultValue;
          }
          return buttonValue === valueToCompare;
        });
        button.on("execute", () => {
          view[propertyName] = buttonValue;
        });
        toolbar.items.add(button);
      }
    }
    const defaultColors = [
      {
        color: "hsl(0, 0%, 0%)",
        label: "Black"
      },
      {
        color: "hsl(0, 0%, 30%)",
        label: "Dim grey"
      },
      {
        color: "hsl(0, 0%, 60%)",
        label: "Grey"
      },
      {
        color: "hsl(0, 0%, 90%)",
        label: "Light grey"
      },
      {
        color: "hsl(0, 0%, 100%)",
        label: "White",
        hasBorder: true
      },
      {
        color: "hsl(0, 75%, 60%)",
        label: "Red"
      },
      {
        color: "hsl(30, 75%, 60%)",
        label: "Orange"
      },
      {
        color: "hsl(60, 75%, 60%)",
        label: "Yellow"
      },
      {
        color: "hsl(90, 75%, 60%)",
        label: "Light green"
      },
      {
        color: "hsl(120, 75%, 60%)",
        label: "Green"
      },
      {
        color: "hsl(150, 75%, 60%)",
        label: "Aquamarine"
      },
      {
        color: "hsl(180, 75%, 60%)",
        label: "Turquoise"
      },
      {
        color: "hsl(210, 75%, 60%)",
        label: "Light blue"
      },
      {
        color: "hsl(240, 75%, 60%)",
        label: "Blue"
      },
      {
        color: "hsl(270, 75%, 60%)",
        label: "Purple"
      }
    ];
    function getLabeledColorInputCreator(options) {
      return (labeledFieldView, viewUid, statusUid) => {
        const colorInputView = new ColorInputView(labeledFieldView.locale, {
          colorDefinitions: colorConfigToColorGridDefinitions(options.colorConfig),
          columns: options.columns,
          defaultColorValue: options.defaultColorValue,
          colorPickerConfig: options.colorPickerConfig
        });
        colorInputView.inputView.set({
          id: viewUid,
          ariaDescribedById: statusUid
        });
        colorInputView.bind("isReadOnly").to(labeledFieldView, "isEnabled", (value) => !value);
        colorInputView.bind("hasError").to(labeledFieldView, "errorText", (value) => !!value);
        colorInputView.on("input", () => {
          labeledFieldView.errorText = null;
        });
        labeledFieldView.bind("isEmpty", "isFocused").to(colorInputView);
        return colorInputView;
      };
    }
    function isNumberString(value) {
      const parsedValue = parseFloat(value);
      return !Number.isNaN(parsedValue) && value === String(parsedValue);
    }
    function colorConfigToColorGridDefinitions(colorConfig) {
      return colorConfig.map((item) => ({
        color: item.model,
        label: item.label,
        options: {
          hasBorder: item.hasBorder
        }
      }));
    }
    class FormRowView extends View {
      /**
      * Creates an instance of the form row class.
      *
      * @param locale The locale instance.
      * @param options.labelView When passed, the row gets the `group` and `aria-labelledby`
      * DOM attributes and gets described by the label.
      */
      constructor(locale, options = {}) {
        super(locale);
        /**
        * A collection of row items (buttons, dropdowns, etc.).
        */
        __publicField(this, "children");
        const bind = this.bindTemplate;
        this.set("class", options.class || null);
        this.children = this.createCollection();
        if (options.children) {
          options.children.forEach((child) => this.children.add(child));
        }
        this.set("_role", null);
        this.set("_ariaLabelledBy", null);
        if (options.labelView) {
          this.set({
            _role: "group",
            _ariaLabelledBy: options.labelView.id
          });
        }
        this.setTemplate({
          tag: "div",
          attributes: {
            class: [
              "ck",
              "ck-form__row",
              bind.to("class")
            ],
            role: bind.to("_role"),
            "aria-labelledby": bind.to("_ariaLabelledBy")
          },
          children: this.children
        });
      }
    }
    class TableCellPropertiesView extends View {
      /**
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param options Additional configuration of the view.
      * @param options.borderColors A configuration of the border color palette used by the
      * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#borderColorInput}.
      * @param options.backgroundColors A configuration of the background color palette used by the
      * {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView#backgroundInput}.
      * @param options.defaultTableCellProperties The default table cell properties.
      */
      constructor(locale, options) {
        super(locale);
        /**
        * Options passed to the view. See {@link #constructor} to learn more.
        */
        __publicField(this, "options");
        /**
        * Tracks information about the DOM focus in the form.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of child views in the form.
        */
        __publicField(this, "children");
        /**
        * A dropdown that allows selecting the style of the table cell border.
        */
        __publicField(this, "borderStyleDropdown");
        /**
        * An input that allows specifying the width of the table cell border.
        */
        __publicField(this, "borderWidthInput");
        /**
        * An input that allows specifying the color of the table cell border.
        */
        __publicField(this, "borderColorInput");
        /**
        * An input that allows specifying the table cell background color.
        */
        __publicField(this, "backgroundInput");
        /**
        * An input that allows specifying the table cell padding.
        */
        __publicField(this, "paddingInput");
        /**
        * An input that allows specifying the table cell width.
        */
        __publicField(this, "widthInput");
        /**
        * An input that allows specifying the table cell height.
        */
        __publicField(this, "heightInput");
        /**
        * A toolbar with buttons that allow changing the horizontal text alignment in a table cell.
        */
        __publicField(this, "horizontalAlignmentToolbar");
        /**
        * A toolbar with buttons that allow changing the vertical text alignment in a table cell.
        */
        __publicField(this, "verticalAlignmentToolbar");
        /**
        * The "Save" button view.
        */
        __publicField(this, "saveButtonView");
        /**
        * The "Cancel" button view.
        */
        __publicField(this, "cancelButtonView");
        /**
        * A collection of views that can be focused in the form.
        */
        __publicField(this, "_focusables");
        /**
        * Helps cycling over {@link #_focusables} in the form.
        */
        __publicField(this, "_focusCycler");
        this.set({
          borderStyle: "",
          borderWidth: "",
          borderColor: "",
          padding: "",
          backgroundColor: "",
          width: "",
          height: "",
          horizontalAlignment: "",
          verticalAlignment: ""
        });
        this.options = options;
        const { borderStyleDropdown, borderWidthInput, borderColorInput, borderRowLabel } = this._createBorderFields();
        const { backgroundRowLabel, backgroundInput } = this._createBackgroundFields();
        const { widthInput, operatorLabel, heightInput, dimensionsLabel } = this._createDimensionFields();
        const { horizontalAlignmentToolbar, verticalAlignmentToolbar, alignmentLabel } = this._createAlignmentFields();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.children = this.createCollection();
        this.borderStyleDropdown = borderStyleDropdown;
        this.borderWidthInput = borderWidthInput;
        this.borderColorInput = borderColorInput;
        this.backgroundInput = backgroundInput;
        this.paddingInput = this._createPaddingField();
        this.widthInput = widthInput;
        this.heightInput = heightInput;
        this.horizontalAlignmentToolbar = horizontalAlignmentToolbar;
        this.verticalAlignmentToolbar = verticalAlignmentToolbar;
        const { saveButtonView, cancelButtonView } = this._createActionButtons();
        this.saveButtonView = saveButtonView;
        this.cancelButtonView = cancelButtonView;
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.children.add(new FormHeaderView(locale, {
          label: this.t("Cell properties")
        }));
        this.children.add(new FormRowView(locale, {
          labelView: borderRowLabel,
          children: [
            borderRowLabel,
            borderStyleDropdown,
            borderColorInput,
            borderWidthInput
          ],
          class: "ck-table-form__border-row"
        }));
        this.children.add(new FormRowView(locale, {
          labelView: backgroundRowLabel,
          children: [
            backgroundRowLabel,
            backgroundInput
          ],
          class: "ck-table-form__background-row"
        }));
        this.children.add(new FormRowView(locale, {
          children: [
            // Dimensions row.
            new FormRowView(locale, {
              labelView: dimensionsLabel,
              children: [
                dimensionsLabel,
                widthInput,
                operatorLabel,
                heightInput
              ],
              class: "ck-table-form__dimensions-row"
            }),
            // Padding row.
            new FormRowView(locale, {
              children: [
                this.paddingInput
              ],
              class: "ck-table-cell-properties-form__padding-row"
            })
          ]
        }));
        this.children.add(new FormRowView(locale, {
          labelView: alignmentLabel,
          children: [
            alignmentLabel,
            horizontalAlignmentToolbar,
            verticalAlignmentToolbar
          ],
          class: "ck-table-cell-properties-form__alignment-row"
        }));
        this.children.add(new FormRowView(locale, {
          children: [
            this.saveButtonView,
            this.cancelButtonView
          ],
          class: "ck-table-form__action-row"
        }));
        this.setTemplate({
          tag: "form",
          attributes: {
            class: [
              "ck",
              "ck-form",
              "ck-table-form",
              "ck-table-cell-properties-form"
            ],
            // https://github.com/ckeditor/ckeditor5-link/issues/90
            tabindex: "-1"
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        submitHandler({
          view: this
        });
        [
          this.borderColorInput,
          this.backgroundInput
        ].forEach((view) => {
          view.fieldView.focusCycler.on("forwardCycle", (evt) => {
            this._focusCycler.focusNext();
            evt.stop();
          });
          view.fieldView.focusCycler.on("backwardCycle", (evt) => {
            this._focusCycler.focusPrevious();
            evt.stop();
          });
        });
        [
          this.borderStyleDropdown,
          this.borderColorInput,
          this.borderWidthInput,
          this.backgroundInput,
          this.widthInput,
          this.heightInput,
          this.paddingInput,
          this.horizontalAlignmentToolbar,
          this.verticalAlignmentToolbar,
          this.saveButtonView,
          this.cancelButtonView
        ].forEach((view) => {
          this._focusables.add(view);
          this.focusTracker.add(view.element);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the fist focusable field in the form.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #borderStyleDropdown},
      * * {@link #borderWidthInput},
      * * {@link #borderColorInput}.
      */
      _createBorderFields() {
        const defaultTableCellProperties = this.options.defaultTableCellProperties;
        const defaultBorder = {
          style: defaultTableCellProperties.borderStyle,
          width: defaultTableCellProperties.borderWidth,
          color: defaultTableCellProperties.borderColor
        };
        const colorInputCreator = getLabeledColorInputCreator({
          colorConfig: this.options.borderColors,
          columns: 5,
          defaultColorValue: defaultBorder.color,
          colorPickerConfig: this.options.colorPickerConfig
        });
        const locale = this.locale;
        const t = this.t;
        const accessibleLabel = t("Style");
        const borderRowLabel = new LabelView(locale);
        borderRowLabel.text = t("Border");
        const styleLabels = getBorderStyleLabels(t);
        const borderStyleDropdown = new LabeledFieldView(locale, createLabeledDropdown);
        borderStyleDropdown.set({
          label: accessibleLabel,
          class: "ck-table-form__border-style"
        });
        borderStyleDropdown.fieldView.buttonView.set({
          ariaLabel: accessibleLabel,
          ariaLabelledBy: void 0,
          isOn: false,
          withText: true,
          tooltip: accessibleLabel
        });
        borderStyleDropdown.fieldView.buttonView.bind("label").to(this, "borderStyle", (value) => {
          return styleLabels[value ? value : "none"];
        });
        borderStyleDropdown.fieldView.on("execute", (evt) => {
          this.borderStyle = evt.source._borderStyleValue;
        });
        borderStyleDropdown.bind("isEmpty").to(this, "borderStyle", (value) => !value);
        addListToDropdown(borderStyleDropdown.fieldView, getBorderStyleDefinitions(this, defaultBorder.style), {
          role: "menu",
          ariaLabel: accessibleLabel
        });
        const borderWidthInput = new LabeledFieldView(locale, createLabeledInputText);
        borderWidthInput.set({
          label: t("Width"),
          class: "ck-table-form__border-width"
        });
        borderWidthInput.fieldView.bind("value").to(this, "borderWidth");
        borderWidthInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet$1);
        borderWidthInput.fieldView.on("input", () => {
          this.borderWidth = borderWidthInput.fieldView.element.value;
        });
        const borderColorInput = new LabeledFieldView(locale, colorInputCreator);
        borderColorInput.set({
          label: t("Color"),
          class: "ck-table-form__border-color"
        });
        borderColorInput.fieldView.bind("value").to(this, "borderColor");
        borderColorInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet$1);
        borderColorInput.fieldView.on("input", () => {
          this.borderColor = borderColorInput.fieldView.value;
        });
        this.on("change:borderStyle", (evt, name, newValue, oldValue) => {
          if (!isBorderStyleSet$1(newValue)) {
            this.borderColor = "";
            this.borderWidth = "";
          }
          if (!isBorderStyleSet$1(oldValue)) {
            this.borderColor = defaultBorder.color;
            this.borderWidth = defaultBorder.width;
          }
        });
        return {
          borderRowLabel,
          borderStyleDropdown,
          borderColorInput,
          borderWidthInput
        };
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #backgroundInput}.
      */
      _createBackgroundFields() {
        const locale = this.locale;
        const t = this.t;
        const backgroundRowLabel = new LabelView(locale);
        backgroundRowLabel.text = t("Background");
        const colorInputCreator = getLabeledColorInputCreator({
          colorConfig: this.options.backgroundColors,
          columns: 5,
          defaultColorValue: this.options.defaultTableCellProperties.backgroundColor,
          colorPickerConfig: this.options.colorPickerConfig
        });
        const backgroundInput = new LabeledFieldView(locale, colorInputCreator);
        backgroundInput.set({
          label: t("Color"),
          class: "ck-table-cell-properties-form__background"
        });
        backgroundInput.fieldView.bind("value").to(this, "backgroundColor");
        backgroundInput.fieldView.on("input", () => {
          this.backgroundColor = backgroundInput.fieldView.value;
        });
        return {
          backgroundRowLabel,
          backgroundInput
        };
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #widthInput}.
      * * {@link #heightInput}.
      */
      _createDimensionFields() {
        const locale = this.locale;
        const t = this.t;
        const dimensionsLabel = new LabelView(locale);
        dimensionsLabel.text = t("Dimensions");
        const widthInput = new LabeledFieldView(locale, createLabeledInputText);
        widthInput.set({
          label: t("Width"),
          class: "ck-table-form__dimensions-row__width"
        });
        widthInput.fieldView.bind("value").to(this, "width");
        widthInput.fieldView.on("input", () => {
          this.width = widthInput.fieldView.element.value;
        });
        const operatorLabel = new View(locale);
        operatorLabel.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck-table-form__dimension-operator"
            ]
          },
          children: [
            {
              text: "×"
            }
          ]
        });
        const heightInput = new LabeledFieldView(locale, createLabeledInputText);
        heightInput.set({
          label: t("Height"),
          class: "ck-table-form__dimensions-row__height"
        });
        heightInput.fieldView.bind("value").to(this, "height");
        heightInput.fieldView.on("input", () => {
          this.height = heightInput.fieldView.element.value;
        });
        return {
          dimensionsLabel,
          widthInput,
          operatorLabel,
          heightInput
        };
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #paddingInput}.
      */
      _createPaddingField() {
        const locale = this.locale;
        const t = this.t;
        const paddingInput = new LabeledFieldView(locale, createLabeledInputText);
        paddingInput.set({
          label: t("Padding"),
          class: "ck-table-cell-properties-form__padding"
        });
        paddingInput.fieldView.bind("value").to(this, "padding");
        paddingInput.fieldView.on("input", () => {
          this.padding = paddingInput.fieldView.element.value;
        });
        return paddingInput;
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #horizontalAlignmentToolbar},
      * * {@link #verticalAlignmentToolbar}.
      */
      _createAlignmentFields() {
        const locale = this.locale;
        const t = this.t;
        const alignmentLabel = new LabelView(locale);
        const ALIGNMENT_ICONS = {
          left: icons.alignLeft,
          center: icons.alignCenter,
          right: icons.alignRight,
          justify: icons.alignJustify,
          top: icons.alignTop,
          middle: icons.alignMiddle,
          bottom: icons.alignBottom
        };
        alignmentLabel.text = t("Table cell text alignment");
        const horizontalAlignmentToolbar = new ToolbarView(locale);
        const isContentRTL = locale.contentLanguageDirection === "rtl";
        horizontalAlignmentToolbar.set({
          isCompact: true,
          ariaLabel: t("Horizontal text alignment toolbar")
        });
        fillToolbar({
          view: this,
          icons: ALIGNMENT_ICONS,
          toolbar: horizontalAlignmentToolbar,
          labels: this._horizontalAlignmentLabels,
          propertyName: "horizontalAlignment",
          nameToValue: (name) => {
            if (isContentRTL) {
              if (name === "left") {
                return "right";
              } else if (name === "right") {
                return "left";
              }
            }
            return name;
          },
          defaultValue: this.options.defaultTableCellProperties.horizontalAlignment
        });
        const verticalAlignmentToolbar = new ToolbarView(locale);
        verticalAlignmentToolbar.set({
          isCompact: true,
          ariaLabel: t("Vertical text alignment toolbar")
        });
        fillToolbar({
          view: this,
          icons: ALIGNMENT_ICONS,
          toolbar: verticalAlignmentToolbar,
          labels: this._verticalAlignmentLabels,
          propertyName: "verticalAlignment",
          defaultValue: this.options.defaultTableCellProperties.verticalAlignment
        });
        return {
          horizontalAlignmentToolbar,
          verticalAlignmentToolbar,
          alignmentLabel
        };
      }
      /**
      * Creates the following form controls:
      *
      * * {@link #saveButtonView},
      * * {@link #cancelButtonView}.
      */
      _createActionButtons() {
        const locale = this.locale;
        const t = this.t;
        const saveButtonView = new ButtonView(locale);
        const cancelButtonView = new ButtonView(locale);
        const fieldsThatShouldValidateToSave = [
          this.borderWidthInput,
          this.borderColorInput,
          this.backgroundInput,
          this.paddingInput
        ];
        saveButtonView.set({
          label: t("Save"),
          icon: icons.check,
          class: "ck-button-save",
          type: "submit",
          withText: true
        });
        saveButtonView.bind("isEnabled").toMany(fieldsThatShouldValidateToSave, "errorText", (...errorTexts) => {
          return errorTexts.every((errorText) => !errorText);
        });
        cancelButtonView.set({
          label: t("Cancel"),
          icon: icons.cancel,
          class: "ck-button-cancel",
          withText: true
        });
        cancelButtonView.delegate("execute").to(this, "cancel");
        return {
          saveButtonView,
          cancelButtonView
        };
      }
      /**
      * Provides localized labels for {@link #horizontalAlignmentToolbar} buttons.
      */
      get _horizontalAlignmentLabels() {
        const locale = this.locale;
        const t = this.t;
        const left = t("Align cell text to the left");
        const center = t("Align cell text to the center");
        const right = t("Align cell text to the right");
        const justify = t("Justify cell text");
        if (locale.uiLanguageDirection === "rtl") {
          return {
            right,
            center,
            left,
            justify
          };
        } else {
          return {
            left,
            center,
            right,
            justify
          };
        }
      }
      /**
      * Provides localized labels for {@link #verticalAlignmentToolbar} buttons.
      */
      get _verticalAlignmentLabels() {
        const t = this.t;
        return {
          top: t("Align cell text to the top"),
          middle: t("Align cell text to the middle"),
          bottom: t("Align cell text to the bottom")
        };
      }
    }
    function isBorderStyleSet$1(value) {
      return value !== "none";
    }
    const BALLOON_POSITIONS = /* @__PURE__ */ (() => [
      BalloonPanelView.defaultPositions.northArrowSouth,
      BalloonPanelView.defaultPositions.northArrowSouthWest,
      BalloonPanelView.defaultPositions.northArrowSouthEast,
      BalloonPanelView.defaultPositions.southArrowNorth,
      BalloonPanelView.defaultPositions.southArrowNorthWest,
      BalloonPanelView.defaultPositions.southArrowNorthEast,
      BalloonPanelView.defaultPositions.viewportStickyNorth
    ])();
    function repositionContextualBalloon(editor, target) {
      const balloon = editor.plugins.get("ContextualBalloon");
      const selection = editor.editing.view.document.selection;
      let position;
      if (target === "cell") {
        if (getTableWidgetAncestor(selection)) {
          position = getBalloonCellPositionData(editor);
        }
      } else if (getSelectionAffectedTableWidget(selection)) {
        position = getBalloonTablePositionData(editor);
      }
      if (position) {
        balloon.updatePosition(position);
      }
    }
    function getBalloonTablePositionData(editor) {
      const selection = editor.model.document.selection;
      const modelTable = getSelectionAffectedTable(selection);
      const viewTable = editor.editing.mapper.toViewElement(modelTable);
      return {
        target: editor.editing.view.domConverter.mapViewToDom(viewTable),
        positions: BALLOON_POSITIONS
      };
    }
    function getBalloonCellPositionData(editor) {
      const mapper = editor.editing.mapper;
      const domConverter = editor.editing.view.domConverter;
      const selection = editor.model.document.selection;
      if (selection.rangeCount > 1) {
        return {
          target: () => createBoundingRect(selection.getRanges(), editor),
          positions: BALLOON_POSITIONS
        };
      }
      const modelTableCell = getTableCellAtPosition(selection.getFirstPosition());
      const viewTableCell = mapper.toViewElement(modelTableCell);
      return {
        target: domConverter.mapViewToDom(viewTableCell),
        positions: BALLOON_POSITIONS
      };
    }
    function getTableCellAtPosition(position) {
      const isTableCellSelected = position.nodeAfter && position.nodeAfter.is("element", "tableCell");
      return isTableCellSelected ? position.nodeAfter : position.findAncestor("tableCell");
    }
    function createBoundingRect(ranges, editor) {
      const mapper = editor.editing.mapper;
      const domConverter = editor.editing.view.domConverter;
      const rects = Array.from(ranges).map((range) => {
        const modelTableCell = getTableCellAtPosition(range.start);
        const viewTableCell = mapper.toViewElement(modelTableCell);
        return new Rect(domConverter.mapViewToDom(viewTableCell));
      });
      return Rect.getBoundingRect(rects);
    }
    var tableCellProperties = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>';
    function getSingleValue(objectOrString) {
      if (!objectOrString || !isObject$1(objectOrString)) {
        return objectOrString;
      }
      const { top, right, bottom, left } = objectOrString;
      if (top == right && right == bottom && bottom == left) {
        return top;
      }
    }
    function addDefaultUnitToNumericValue(value, defaultUnit) {
      const numericValue = parseFloat(value);
      if (Number.isNaN(numericValue)) {
        return value;
      }
      if (String(numericValue) !== String(value)) {
        return value;
      }
      return `${numericValue}${defaultUnit}`;
    }
    function getNormalizedDefaultProperties(config, options = {}) {
      const normalizedConfig = {
        borderStyle: "none",
        borderWidth: "",
        borderColor: "",
        backgroundColor: "",
        width: "",
        height: "",
        ...config
      };
      if (options.includeAlignmentProperty && !normalizedConfig.alignment) {
        normalizedConfig.alignment = "center";
      }
      if (options.includePaddingProperty && !normalizedConfig.padding) {
        normalizedConfig.padding = "";
      }
      if (options.includeVerticalAlignmentProperty && !normalizedConfig.verticalAlignment) {
        normalizedConfig.verticalAlignment = "middle";
      }
      if (options.includeHorizontalAlignmentProperty && !normalizedConfig.horizontalAlignment) {
        normalizedConfig.horizontalAlignment = options.isRightToLeftContent ? "right" : "left";
      }
      return normalizedConfig;
    }
    const ERROR_TEXT_TIMEOUT$1 = 500;
    const propertyToCommandMap$1 = {
      borderStyle: "tableCellBorderStyle",
      borderColor: "tableCellBorderColor",
      borderWidth: "tableCellBorderWidth",
      height: "tableCellHeight",
      width: "tableCellWidth",
      padding: "tableCellPadding",
      backgroundColor: "tableCellBackgroundColor",
      horizontalAlignment: "tableCellHorizontalAlignment",
      verticalAlignment: "tableCellVerticalAlignment"
    };
    class TableCellPropertiesUI extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The default table cell properties.
        */
        __publicField(this, "_defaultTableCellProperties");
        /**
        * The contextual balloon plugin instance.
        */
        __publicField(this, "_balloon");
        /**
        * The cell properties form view displayed inside the balloon.
        */
        __publicField(this, "view");
        /**
        * The batch used to undo all changes made by the form (which are live, as the user types)
        * when "Cancel" was pressed. Each time the view is shown, a new batch is created.
        */
        __publicField(this, "_undoStepBatch");
        /**
        * Flag used to indicate whether view is ready to execute update commands
        * (it finished loading initial data).
        */
        __publicField(this, "_isReady");
        editor.config.define("table.tableCellProperties", {
          borderColors: defaultColors,
          backgroundColors: defaultColors
        });
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ContextualBalloon
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCellPropertiesUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        this._defaultTableCellProperties = getNormalizedDefaultProperties(editor.config.get("table.tableCellProperties.defaultProperties"), {
          includeVerticalAlignmentProperty: true,
          includeHorizontalAlignmentProperty: true,
          includePaddingProperty: true,
          isRightToLeftContent: editor.locale.contentLanguageDirection === "rtl"
        });
        this._balloon = editor.plugins.get(ContextualBalloon);
        this.view = null;
        this._isReady = false;
        editor.ui.componentFactory.add("tableCellProperties", (locale) => {
          const view = new ButtonView(locale);
          view.set({
            label: t("Cell properties"),
            icon: tableCellProperties,
            tooltip: true
          });
          this.listenTo(view, "execute", () => this._showView());
          const commands = Object.values(propertyToCommandMap$1).map((commandName) => editor.commands.get(commandName));
          view.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => areEnabled.some((isCommandEnabled) => isCommandEnabled));
          return view;
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this.view) {
          this.view.destroy();
        }
      }
      /**
      * Creates the {@link module:table/tablecellproperties/ui/tablecellpropertiesview~TableCellPropertiesView} instance.
      *
      * @returns The cell properties form view instance.
      */
      _createPropertiesView() {
        const editor = this.editor;
        const config = editor.config.get("table.tableCellProperties");
        const borderColorsConfig = normalizeColorOptions(config.borderColors);
        const localizedBorderColors = getLocalizedColorOptions(editor.locale, borderColorsConfig);
        const backgroundColorsConfig = normalizeColorOptions(config.backgroundColors);
        const localizedBackgroundColors = getLocalizedColorOptions(editor.locale, backgroundColorsConfig);
        const hasColorPicker = config.colorPicker !== false;
        const view = new TableCellPropertiesView(editor.locale, {
          borderColors: localizedBorderColors,
          backgroundColors: localizedBackgroundColors,
          defaultTableCellProperties: this._defaultTableCellProperties,
          colorPickerConfig: hasColorPicker ? config.colorPicker || {} : false
        });
        const t = editor.t;
        view.render();
        this.listenTo(view, "submit", () => {
          this._hideView();
        });
        this.listenTo(view, "cancel", () => {
          if (this._undoStepBatch.operations.length) {
            editor.execute("undo", this._undoStepBatch);
          }
          this._hideView();
        });
        view.keystrokes.set("Esc", (data, cancel2) => {
          this._hideView();
          cancel2();
        });
        clickOutsideHandler({
          emitter: view,
          activator: () => this._isViewInBalloon,
          contextElements: [
            this._balloon.view.element
          ],
          callback: () => this._hideView()
        });
        const colorErrorText = getLocalizedColorErrorText(t);
        const lengthErrorText = getLocalizedLengthErrorText(t);
        view.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle"));
        view.on("change:borderColor", this._getValidatedPropertyChangeCallback({
          viewField: view.borderColorInput,
          commandName: "tableCellBorderColor",
          errorText: colorErrorText,
          validator: colorFieldValidator
        }));
        view.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
          viewField: view.borderWidthInput,
          commandName: "tableCellBorderWidth",
          errorText: lengthErrorText,
          validator: lineWidthFieldValidator
        }));
        view.on("change:padding", this._getValidatedPropertyChangeCallback({
          viewField: view.paddingInput,
          commandName: "tableCellPadding",
          errorText: lengthErrorText,
          validator: lengthFieldValidator
        }));
        view.on("change:width", this._getValidatedPropertyChangeCallback({
          viewField: view.widthInput,
          commandName: "tableCellWidth",
          errorText: lengthErrorText,
          validator: lengthFieldValidator
        }));
        view.on("change:height", this._getValidatedPropertyChangeCallback({
          viewField: view.heightInput,
          commandName: "tableCellHeight",
          errorText: lengthErrorText,
          validator: lengthFieldValidator
        }));
        view.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
          viewField: view.backgroundInput,
          commandName: "tableCellBackgroundColor",
          errorText: colorErrorText,
          validator: colorFieldValidator
        }));
        view.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment"));
        view.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment"));
        return view;
      }
      /**
      * In this method the "editor data -> UI" binding is happening.
      *
      * When executed, this method obtains selected cell property values from various table commands
      * and passes them to the {@link #view}.
      *
      * This way, the UI stays up–to–date with the editor data.
      */
      _fillViewFormFromCommandValues() {
        const commands = this.editor.commands;
        const borderStyleCommand = commands.get("tableCellBorderStyle");
        Object.entries(propertyToCommandMap$1).map(([property2, commandName]) => {
          const defaultValue = this._defaultTableCellProperties[property2] || "";
          return [
            property2,
            commands.get(commandName).value || defaultValue
          ];
        }).forEach(([property2, value]) => {
          if ((property2 === "borderColor" || property2 === "borderWidth") && borderStyleCommand.value === "none") {
            return;
          }
          this.view.set(property2, value);
        });
        this._isReady = true;
      }
      /**
      * Shows the {@link #view} in the {@link #_balloon}.
      *
      * **Note**: Each time a view is shown, a new {@link #_undoStepBatch} is created. It contains
      * all changes made to the document when the view is visible, allowing a single undo step
      * for all of them.
      */
      _showView() {
        const editor = this.editor;
        if (!this.view) {
          this.view = this._createPropertiesView();
        }
        this.listenTo(editor.ui, "update", () => {
          this._updateView();
        });
        this._fillViewFormFromCommandValues();
        this._balloon.add({
          view: this.view,
          position: getBalloonCellPositionData(editor)
        });
        this._undoStepBatch = editor.model.createBatch();
        this.view.focus();
      }
      /**
      * Removes the {@link #view} from the {@link #_balloon}.
      */
      _hideView() {
        const editor = this.editor;
        this.stopListening(editor.ui, "update");
        this._isReady = false;
        this.view.saveButtonView.focus();
        this._balloon.remove(this.view);
        this.editor.editing.view.focus();
      }
      /**
      * Repositions the {@link #_balloon} or hides the {@link #view} if a table cell is no longer selected.
      */
      _updateView() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        if (!getTableWidgetAncestor(viewDocument.selection)) {
          this._hideView();
        } else if (this._isViewVisible) {
          repositionContextualBalloon(editor, "cell");
        }
      }
      /**
      * Returns `true` when the {@link #view} is visible in the {@link #_balloon}.
      */
      get _isViewVisible() {
        return !!this.view && this._balloon.visibleView === this.view;
      }
      /**
      * Returns `true` when the {@link #view} is in the {@link #_balloon}.
      */
      get _isViewInBalloon() {
        return !!this.view && this._balloon.hasView(this.view);
      }
      /**
      * Creates a callback that when executed upon the {@link #view view's} property change
      * executes a related editor command with the new property value.
      *
      * @param defaultValue The default value of the command.
      */
      _getPropertyChangeCallback(commandName) {
        return (evt, propertyName, newValue) => {
          if (!this._isReady) {
            return;
          }
          this.editor.execute(commandName, {
            value: newValue,
            batch: this._undoStepBatch
          });
        };
      }
      /**
      * Creates a callback that when executed upon the {@link #view view's} property change:
      * * Executes a related editor command with the new property value if the value is valid,
      * * Or sets the error text next to the invalid field, if the value did not pass the validation.
      */
      _getValidatedPropertyChangeCallback(options) {
        const { commandName, viewField, validator, errorText } = options;
        const setErrorTextDebounced = debounce(() => {
          viewField.errorText = errorText;
        }, ERROR_TEXT_TIMEOUT$1);
        return (evt, propertyName, newValue) => {
          setErrorTextDebounced.cancel();
          if (!this._isReady) {
            return;
          }
          if (validator(newValue)) {
            this.editor.execute(commandName, {
              value: newValue,
              batch: this._undoStepBatch
            });
            viewField.errorText = null;
          } else {
            setErrorTextDebounced();
          }
        };
      }
    }
    class TableCellPropertyCommand extends Command {
      /**
      * Creates a new `TableCellPropertyCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param attributeName Table cell attribute name.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, attributeName, defaultValue) {
        super(editor);
        /**
        * The attribute that will be set by the command.
        */
        __publicField(this, "attributeName");
        /**
        * The default value for the attribute.
        */
        __publicField(this, "_defaultValue");
        this.attributeName = attributeName;
        this._defaultValue = defaultValue;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const selectedTableCells = tableUtils.getSelectionAffectedTableCells(editor.model.document.selection);
        this.isEnabled = !!selectedTableCells.length;
        this.value = this._getSingleValue(selectedTableCells);
      }
      /**
      * Executes the command.
      *
      * @fires execute
      * @param options.value If set, the command will set the attribute on selected table cells.
      * If it is not set, the command will remove the attribute from the selected table cells.
      * @param options.batch Pass the model batch instance to the command to aggregate changes,
      * for example to allow a single undo step for multiple executions.
      */
      execute(options = {}) {
        const { value, batch } = options;
        const model = this.editor.model;
        const tableUtils = this.editor.plugins.get("TableUtils");
        const tableCells = tableUtils.getSelectionAffectedTableCells(model.document.selection);
        const valueToSet = this._getValueToSet(value);
        model.enqueueChange(batch, (writer) => {
          if (valueToSet) {
            tableCells.forEach((tableCell) => writer.setAttribute(this.attributeName, valueToSet, tableCell));
          } else {
            tableCells.forEach((tableCell) => writer.removeAttribute(this.attributeName, tableCell));
          }
        });
      }
      /**
      * Returns the attribute value for a table cell.
      */
      _getAttribute(tableCell) {
        if (!tableCell) {
          return;
        }
        const value = tableCell.getAttribute(this.attributeName);
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
      /**
      * Returns the proper model value. It can be used to add a default unit to numeric values.
      */
      _getValueToSet(value) {
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
      /**
      * Returns a single value for all selected table cells. If the value is the same for all cells,
      * it will be returned (`undefined` otherwise).
      */
      _getSingleValue(tableCells) {
        const firstCellValue = this._getAttribute(tableCells[0]);
        const everyCellHasAttribute = tableCells.every((tableCells2) => this._getAttribute(tableCells2) === firstCellValue);
        return everyCellHasAttribute ? firstCellValue : void 0;
      }
    }
    class TableCellWidthCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellWidthCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellWidth", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        value = addDefaultUnitToNumericValue(value, "px");
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableCellWidthEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCellWidthEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableEditing
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const defaultTableCellProperties = getNormalizedDefaultProperties(editor.config.get("table.tableCellProperties.defaultProperties"));
        enableProperty$1(editor.model.schema, editor.conversion, {
          modelAttribute: "tableCellWidth",
          styleName: "width",
          defaultValue: defaultTableCellProperties.width
        });
        editor.commands.add("tableCellWidth", new TableCellWidthCommand(editor, defaultTableCellProperties.width));
      }
    }
    class TableCellPaddingCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellPaddingCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellPadding", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getAttribute(tableCell) {
        if (!tableCell) {
          return;
        }
        const value = getSingleValue(tableCell.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        const newValue = addDefaultUnitToNumericValue(value, "px");
        if (newValue === this._defaultValue) {
          return;
        }
        return newValue;
      }
    }
    class TableCellHeightCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellHeightCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellHeight", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        const newValue = addDefaultUnitToNumericValue(value, "px");
        if (newValue === this._defaultValue) {
          return;
        }
        return newValue;
      }
    }
    class TableCellBackgroundColorCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellBackgroundColorCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellBackgroundColor", defaultValue);
      }
    }
    class TableCellVerticalAlignmentCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellVerticalAlignmentCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value for the "alignment" attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellVerticalAlignment", defaultValue);
      }
    }
    class TableCellHorizontalAlignmentCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellHorizontalAlignmentCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value for the "alignment" attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellHorizontalAlignment", defaultValue);
      }
    }
    class TableCellBorderStyleCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellBorderStyleCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellBorderStyle", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getAttribute(tableCell) {
        if (!tableCell) {
          return;
        }
        const value = getSingleValue(tableCell.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableCellBorderColorCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellBorderColorCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellBorderColor", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getAttribute(tableCell) {
        if (!tableCell) {
          return;
        }
        const value = getSingleValue(tableCell.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableCellBorderWidthCommand extends TableCellPropertyCommand {
      /**
      * Creates a new `TableCellBorderWidthCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableCellBorderWidth", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getAttribute(tableCell) {
        if (!tableCell) {
          return;
        }
        const value = getSingleValue(tableCell.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        const newValue = addDefaultUnitToNumericValue(value, "px");
        if (newValue === this._defaultValue) {
          return;
        }
        return newValue;
      }
    }
    const VALIGN_VALUES_REG_EXP = /^(top|middle|bottom)$/;
    const ALIGN_VALUES_REG_EXP$1 = /^(left|center|right|justify)$/;
    class TableCellPropertiesEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCellPropertiesEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableEditing,
          TableCellWidthEditing
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        editor.config.define("table.tableCellProperties.defaultProperties", {});
        const defaultTableCellProperties = getNormalizedDefaultProperties(editor.config.get("table.tableCellProperties.defaultProperties"), {
          includeVerticalAlignmentProperty: true,
          includeHorizontalAlignmentProperty: true,
          includePaddingProperty: true,
          isRightToLeftContent: editor.locale.contentLanguageDirection === "rtl"
        });
        editor.data.addStyleProcessorRules(addBorderRules);
        enableBorderProperties$1(schema, conversion, {
          color: defaultTableCellProperties.borderColor,
          style: defaultTableCellProperties.borderStyle,
          width: defaultTableCellProperties.borderWidth
        });
        editor.commands.add("tableCellBorderStyle", new TableCellBorderStyleCommand(editor, defaultTableCellProperties.borderStyle));
        editor.commands.add("tableCellBorderColor", new TableCellBorderColorCommand(editor, defaultTableCellProperties.borderColor));
        editor.commands.add("tableCellBorderWidth", new TableCellBorderWidthCommand(editor, defaultTableCellProperties.borderWidth));
        enableProperty$1(schema, conversion, {
          modelAttribute: "tableCellHeight",
          styleName: "height",
          defaultValue: defaultTableCellProperties.height
        });
        editor.commands.add("tableCellHeight", new TableCellHeightCommand(editor, defaultTableCellProperties.height));
        editor.data.addStyleProcessorRules(addPaddingRules);
        enableProperty$1(schema, conversion, {
          modelAttribute: "tableCellPadding",
          styleName: "padding",
          reduceBoxSides: true,
          defaultValue: defaultTableCellProperties.padding
        });
        editor.commands.add("tableCellPadding", new TableCellPaddingCommand(editor, defaultTableCellProperties.padding));
        editor.data.addStyleProcessorRules(addBackgroundRules);
        enableProperty$1(schema, conversion, {
          modelAttribute: "tableCellBackgroundColor",
          styleName: "background-color",
          defaultValue: defaultTableCellProperties.backgroundColor
        });
        editor.commands.add("tableCellBackgroundColor", new TableCellBackgroundColorCommand(editor, defaultTableCellProperties.backgroundColor));
        enableHorizontalAlignmentProperty(schema, conversion, defaultTableCellProperties.horizontalAlignment);
        editor.commands.add("tableCellHorizontalAlignment", new TableCellHorizontalAlignmentCommand(editor, defaultTableCellProperties.horizontalAlignment));
        enableVerticalAlignmentProperty(schema, conversion, defaultTableCellProperties.verticalAlignment);
        editor.commands.add("tableCellVerticalAlignment", new TableCellVerticalAlignmentCommand(editor, defaultTableCellProperties.verticalAlignment));
      }
    }
    function enableBorderProperties$1(schema, conversion, defaultBorder) {
      const modelAttributes = {
        width: "tableCellBorderWidth",
        color: "tableCellBorderColor",
        style: "tableCellBorderStyle"
      };
      schema.extend("tableCell", {
        allowAttributes: Object.values(modelAttributes)
      });
      upcastBorderStyles(conversion, "td", modelAttributes, defaultBorder);
      upcastBorderStyles(conversion, "th", modelAttributes, defaultBorder);
      downcastAttributeToStyle(conversion, {
        modelElement: "tableCell",
        modelAttribute: modelAttributes.style,
        styleName: "border-style"
      });
      downcastAttributeToStyle(conversion, {
        modelElement: "tableCell",
        modelAttribute: modelAttributes.color,
        styleName: "border-color"
      });
      downcastAttributeToStyle(conversion, {
        modelElement: "tableCell",
        modelAttribute: modelAttributes.width,
        styleName: "border-width"
      });
    }
    function enableHorizontalAlignmentProperty(schema, conversion, defaultValue) {
      schema.extend("tableCell", {
        allowAttributes: [
          "tableCellHorizontalAlignment"
        ]
      });
      conversion.for("downcast").attributeToAttribute({
        model: {
          name: "tableCell",
          key: "tableCellHorizontalAlignment"
        },
        view: (alignment) => ({
          key: "style",
          value: {
            "text-align": alignment
          }
        })
      });
      conversion.for("upcast").attributeToAttribute({
        view: {
          name: /^(td|th)$/,
          styles: {
            "text-align": ALIGN_VALUES_REG_EXP$1
          }
        },
        model: {
          key: "tableCellHorizontalAlignment",
          value: (viewElement) => {
            const align = viewElement.getStyle("text-align");
            return align === defaultValue ? null : align;
          }
        }
      }).attributeToAttribute({
        view: {
          name: /^(td|th)$/,
          attributes: {
            align: ALIGN_VALUES_REG_EXP$1
          }
        },
        model: {
          key: "tableCellHorizontalAlignment",
          value: (viewElement) => {
            const align = viewElement.getAttribute("align");
            return align === defaultValue ? null : align;
          }
        }
      });
    }
    function enableVerticalAlignmentProperty(schema, conversion, defaultValue) {
      schema.extend("tableCell", {
        allowAttributes: [
          "tableCellVerticalAlignment"
        ]
      });
      conversion.for("downcast").attributeToAttribute({
        model: {
          name: "tableCell",
          key: "tableCellVerticalAlignment"
        },
        view: (alignment) => ({
          key: "style",
          value: {
            "vertical-align": alignment
          }
        })
      });
      conversion.for("upcast").attributeToAttribute({
        view: {
          name: /^(td|th)$/,
          styles: {
            "vertical-align": VALIGN_VALUES_REG_EXP
          }
        },
        model: {
          key: "tableCellVerticalAlignment",
          value: (viewElement) => {
            const align = viewElement.getStyle("vertical-align");
            return align === defaultValue ? null : align;
          }
        }
      }).attributeToAttribute({
        view: {
          name: /^(td|th)$/,
          attributes: {
            valign: VALIGN_VALUES_REG_EXP
          }
        },
        model: {
          key: "tableCellVerticalAlignment",
          value: (viewElement) => {
            const valign = viewElement.getAttribute("valign");
            return valign === defaultValue ? null : valign;
          }
        }
      });
    }
    class TableCellProperties extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCellProperties";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableCellPropertiesEditing,
          TableCellPropertiesUI
        ];
      }
    }
    class TablePropertyCommand extends Command {
      /**
      * Creates a new `TablePropertyCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param attributeName Table cell attribute name.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, attributeName, defaultValue) {
        super(editor);
        /**
        * The attribute that will be set by the command.
        */
        __publicField(this, "attributeName");
        /**
        * The default value for the attribute.
        */
        __publicField(this, "_defaultValue");
        this.attributeName = attributeName;
        this._defaultValue = defaultValue;
      }
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const selection = editor.model.document.selection;
        const table2 = getSelectionAffectedTable(selection);
        this.isEnabled = !!table2;
        this.value = this._getValue(table2);
      }
      /**
      * Executes the command.
      *
      * @fires execute
      * @param options.value If set, the command will set the attribute on the selected table.
      * If not set, the command will remove the attribute from the selected table.
      * @param options.batch Pass the model batch instance to the command to aggregate changes,
      * for example, to allow a single undo step for multiple executions.
      */
      execute(options = {}) {
        const model = this.editor.model;
        const selection = model.document.selection;
        const { value, batch } = options;
        const table2 = getSelectionAffectedTable(selection);
        const valueToSet = this._getValueToSet(value);
        model.enqueueChange(batch, (writer) => {
          if (valueToSet) {
            writer.setAttribute(this.attributeName, valueToSet, table2);
          } else {
            writer.removeAttribute(this.attributeName, table2);
          }
        });
      }
      /**
      * Returns the attribute value for a table.
      */
      _getValue(table2) {
        if (!table2) {
          return;
        }
        const value = table2.getAttribute(this.attributeName);
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
      /**
      * Returns the proper model value. It can be used to add a default unit to numeric values.
      */
      _getValueToSet(value) {
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableBackgroundColorCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableBackgroundColorCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableBackgroundColor", defaultValue);
      }
    }
    class TableBorderColorCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableBorderColorCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableBorderColor", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValue(table2) {
        if (!table2) {
          return;
        }
        const value = getSingleValue(table2.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableBorderStyleCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableBorderStyleCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableBorderStyle", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValue(table2) {
        if (!table2) {
          return;
        }
        const value = getSingleValue(table2.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableBorderWidthCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableBorderWidthCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableBorderWidth", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValue(table2) {
        if (!table2) {
          return;
        }
        const value = getSingleValue(table2.getAttribute(this.attributeName));
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        const newValue = addDefaultUnitToNumericValue(value, "px");
        if (newValue === this._defaultValue) {
          return;
        }
        return newValue;
      }
    }
    class TableWidthCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableWidthCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableWidth", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        value = addDefaultUnitToNumericValue(value, "px");
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableHeightCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableHeightCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value of the attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableHeight", defaultValue);
      }
      /**
      * @inheritDoc
      */
      _getValueToSet(value) {
        value = addDefaultUnitToNumericValue(value, "px");
        if (value === this._defaultValue) {
          return;
        }
        return value;
      }
    }
    class TableAlignmentCommand extends TablePropertyCommand {
      /**
      * Creates a new `TableAlignmentCommand` instance.
      *
      * @param editor An editor in which this command will be used.
      * @param defaultValue The default value for the "alignment" attribute.
      */
      constructor(editor, defaultValue) {
        super(editor, "tableAlignment", defaultValue);
      }
    }
    const ALIGN_VALUES_REG_EXP = /^(left|center|right)$/;
    const FLOAT_VALUES_REG_EXP = /^(left|none|right)$/;
    class TablePropertiesEditing extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TablePropertiesEditing";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableEditing
        ];
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const conversion = editor.conversion;
        editor.config.define("table.tableProperties.defaultProperties", {});
        const defaultTableProperties = getNormalizedDefaultProperties(editor.config.get("table.tableProperties.defaultProperties"), {
          includeAlignmentProperty: true
        });
        editor.data.addStyleProcessorRules(addBorderRules);
        enableBorderProperties(schema, conversion, {
          color: defaultTableProperties.borderColor,
          style: defaultTableProperties.borderStyle,
          width: defaultTableProperties.borderWidth
        });
        editor.commands.add("tableBorderColor", new TableBorderColorCommand(editor, defaultTableProperties.borderColor));
        editor.commands.add("tableBorderStyle", new TableBorderStyleCommand(editor, defaultTableProperties.borderStyle));
        editor.commands.add("tableBorderWidth", new TableBorderWidthCommand(editor, defaultTableProperties.borderWidth));
        enableAlignmentProperty(schema, conversion, defaultTableProperties.alignment);
        editor.commands.add("tableAlignment", new TableAlignmentCommand(editor, defaultTableProperties.alignment));
        enableTableToFigureProperty(schema, conversion, {
          modelAttribute: "tableWidth",
          styleName: "width",
          defaultValue: defaultTableProperties.width
        });
        editor.commands.add("tableWidth", new TableWidthCommand(editor, defaultTableProperties.width));
        enableTableToFigureProperty(schema, conversion, {
          modelAttribute: "tableHeight",
          styleName: "height",
          defaultValue: defaultTableProperties.height
        });
        editor.commands.add("tableHeight", new TableHeightCommand(editor, defaultTableProperties.height));
        editor.data.addStyleProcessorRules(addBackgroundRules);
        enableProperty(schema, conversion, {
          modelAttribute: "tableBackgroundColor",
          styleName: "background-color",
          defaultValue: defaultTableProperties.backgroundColor
        });
        editor.commands.add("tableBackgroundColor", new TableBackgroundColorCommand(editor, defaultTableProperties.backgroundColor));
      }
    }
    function enableBorderProperties(schema, conversion, defaultBorder) {
      const modelAttributes = {
        width: "tableBorderWidth",
        color: "tableBorderColor",
        style: "tableBorderStyle"
      };
      schema.extend("table", {
        allowAttributes: Object.values(modelAttributes)
      });
      upcastBorderStyles(conversion, "table", modelAttributes, defaultBorder);
      downcastTableAttribute(conversion, {
        modelAttribute: modelAttributes.color,
        styleName: "border-color"
      });
      downcastTableAttribute(conversion, {
        modelAttribute: modelAttributes.style,
        styleName: "border-style"
      });
      downcastTableAttribute(conversion, {
        modelAttribute: modelAttributes.width,
        styleName: "border-width"
      });
    }
    function enableAlignmentProperty(schema, conversion, defaultValue) {
      schema.extend("table", {
        allowAttributes: [
          "tableAlignment"
        ]
      });
      conversion.for("downcast").attributeToAttribute({
        model: {
          name: "table",
          key: "tableAlignment"
        },
        view: (alignment) => ({
          key: "style",
          value: {
            // Model: `alignment:center` => CSS: `float:none`.
            float: alignment === "center" ? "none" : alignment
          }
        }),
        converterPriority: "high"
      });
      conversion.for("upcast").attributeToAttribute({
        view: {
          name: /^(table|figure)$/,
          styles: {
            float: FLOAT_VALUES_REG_EXP
          }
        },
        model: {
          key: "tableAlignment",
          value: (viewElement) => {
            let align = viewElement.getStyle("float");
            if (align === "none") {
              align = "center";
            }
            return align === defaultValue ? null : align;
          }
        }
      }).attributeToAttribute({
        view: {
          attributes: {
            align: ALIGN_VALUES_REG_EXP
          }
        },
        model: {
          name: "table",
          key: "tableAlignment",
          value: (viewElement) => {
            const align = viewElement.getAttribute("align");
            return align === defaultValue ? null : align;
          }
        }
      });
    }
    function enableProperty(schema, conversion, options) {
      const { modelAttribute } = options;
      schema.extend("table", {
        allowAttributes: [
          modelAttribute
        ]
      });
      upcastStyleToAttribute(conversion, {
        viewElement: "table",
        ...options
      });
      downcastTableAttribute(conversion, options);
    }
    function enableTableToFigureProperty(schema, conversion, options) {
      const { modelAttribute } = options;
      schema.extend("table", {
        allowAttributes: [
          modelAttribute
        ]
      });
      upcastStyleToAttribute(conversion, {
        viewElement: /^(table|figure)$/,
        shouldUpcast: (element) => !(element.name == "table" && element.parent.name == "figure"),
        ...options
      });
      downcastAttributeToStyle(conversion, {
        modelElement: "table",
        ...options
      });
    }
    class TablePropertiesView extends View {
      /**
      * @param locale The {@link module:core/editor/editor~Editor#locale} instance.
      * @param options Additional configuration of the view.
      */
      constructor(locale, options) {
        super(locale);
        /**
        * Options passed to the view. See {@link #constructor} to learn more.
        */
        __publicField(this, "options");
        /**
        * Tracks information about the DOM focus in the form.
        */
        __publicField(this, "focusTracker");
        /**
        * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
        */
        __publicField(this, "keystrokes");
        /**
        * A collection of child views in the form.
        */
        __publicField(this, "children");
        /**
        * A dropdown that allows selecting the style of the table border.
        */
        __publicField(this, "borderStyleDropdown");
        /**
        * An input that allows specifying the width of the table border.
        */
        __publicField(this, "borderWidthInput");
        /**
        * An input that allows specifying the color of the table border.
        */
        __publicField(this, "borderColorInput");
        /**
        * An input that allows specifying the table background color.
        */
        __publicField(this, "backgroundInput");
        /**
        * An input that allows specifying the table width.
        */
        __publicField(this, "widthInput");
        /**
        * An input that allows specifying the table height.
        */
        __publicField(this, "heightInput");
        /**
        * A toolbar with buttons that allow changing the alignment of an entire table.
        */
        __publicField(this, "alignmentToolbar");
        /**
        * The "Save" button view.
        */
        __publicField(this, "saveButtonView");
        /**
        * The "Cancel" button view.
        */
        __publicField(this, "cancelButtonView");
        /**
        * A collection of views that can be focused in the form.
        */
        __publicField(this, "_focusables");
        /**
        * Helps cycling over {@link #_focusables} in the form.
        */
        __publicField(this, "_focusCycler");
        this.set({
          borderStyle: "",
          borderWidth: "",
          borderColor: "",
          backgroundColor: "",
          width: "",
          height: "",
          alignment: ""
        });
        this.options = options;
        const { borderStyleDropdown, borderWidthInput, borderColorInput, borderRowLabel } = this._createBorderFields();
        const { backgroundRowLabel, backgroundInput } = this._createBackgroundFields();
        const { widthInput, operatorLabel, heightInput, dimensionsLabel } = this._createDimensionFields();
        const { alignmentToolbar, alignmentLabel } = this._createAlignmentFields();
        this.focusTracker = new FocusTracker();
        this.keystrokes = new KeystrokeHandler();
        this.children = this.createCollection();
        this.borderStyleDropdown = borderStyleDropdown;
        this.borderWidthInput = borderWidthInput;
        this.borderColorInput = borderColorInput;
        this.backgroundInput = backgroundInput;
        this.widthInput = widthInput;
        this.heightInput = heightInput;
        this.alignmentToolbar = alignmentToolbar;
        const { saveButtonView, cancelButtonView } = this._createActionButtons();
        this.saveButtonView = saveButtonView;
        this.cancelButtonView = cancelButtonView;
        this._focusables = new ViewCollection();
        this._focusCycler = new FocusCycler({
          focusables: this._focusables,
          focusTracker: this.focusTracker,
          keystrokeHandler: this.keystrokes,
          actions: {
            // Navigate form fields backwards using the Shift + Tab keystroke.
            focusPrevious: "shift + tab",
            // Navigate form fields forwards using the Tab key.
            focusNext: "tab"
          }
        });
        this.children.add(new FormHeaderView(locale, {
          label: this.t("Table properties")
        }));
        this.children.add(new FormRowView(locale, {
          labelView: borderRowLabel,
          children: [
            borderRowLabel,
            borderStyleDropdown,
            borderColorInput,
            borderWidthInput
          ],
          class: "ck-table-form__border-row"
        }));
        this.children.add(new FormRowView(locale, {
          labelView: backgroundRowLabel,
          children: [
            backgroundRowLabel,
            backgroundInput
          ],
          class: "ck-table-form__background-row"
        }));
        this.children.add(new FormRowView(locale, {
          children: [
            // Dimensions row.
            new FormRowView(locale, {
              labelView: dimensionsLabel,
              children: [
                dimensionsLabel,
                widthInput,
                operatorLabel,
                heightInput
              ],
              class: "ck-table-form__dimensions-row"
            }),
            // Alignment row.
            new FormRowView(locale, {
              labelView: alignmentLabel,
              children: [
                alignmentLabel,
                alignmentToolbar
              ],
              class: "ck-table-properties-form__alignment-row"
            })
          ]
        }));
        this.children.add(new FormRowView(locale, {
          children: [
            this.saveButtonView,
            this.cancelButtonView
          ],
          class: "ck-table-form__action-row"
        }));
        this.setTemplate({
          tag: "form",
          attributes: {
            class: [
              "ck",
              "ck-form",
              "ck-table-form",
              "ck-table-properties-form"
            ],
            // https://github.com/ckeditor/ckeditor5-link/issues/90
            tabindex: "-1"
          },
          children: this.children
        });
      }
      /**
      * @inheritDoc
      */
      render() {
        super.render();
        submitHandler({
          view: this
        });
        [
          this.borderColorInput,
          this.backgroundInput
        ].forEach((view) => {
          view.fieldView.focusCycler.on("forwardCycle", (evt) => {
            this._focusCycler.focusNext();
            evt.stop();
          });
          view.fieldView.focusCycler.on("backwardCycle", (evt) => {
            this._focusCycler.focusPrevious();
            evt.stop();
          });
        });
        [
          this.borderStyleDropdown,
          this.borderColorInput,
          this.borderWidthInput,
          this.backgroundInput,
          this.widthInput,
          this.heightInput,
          this.alignmentToolbar,
          this.saveButtonView,
          this.cancelButtonView
        ].forEach((view) => {
          this._focusables.add(view);
          this.focusTracker.add(view.element);
        });
        this.keystrokes.listenTo(this.element);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        this.focusTracker.destroy();
        this.keystrokes.destroy();
      }
      /**
      * Focuses the fist focusable field in the form.
      */
      focus() {
        this._focusCycler.focusFirst();
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #borderStyleDropdown},
      * * {@link #borderWidthInput},
      * * {@link #borderColorInput}.
      */
      _createBorderFields() {
        const defaultTableProperties = this.options.defaultTableProperties;
        const defaultBorder = {
          style: defaultTableProperties.borderStyle,
          width: defaultTableProperties.borderWidth,
          color: defaultTableProperties.borderColor
        };
        const colorInputCreator = getLabeledColorInputCreator({
          colorConfig: this.options.borderColors,
          columns: 5,
          defaultColorValue: defaultBorder.color,
          colorPickerConfig: this.options.colorPickerConfig
        });
        const locale = this.locale;
        const t = this.t;
        const accessibleLabel = t("Style");
        const borderRowLabel = new LabelView(locale);
        borderRowLabel.text = t("Border");
        const styleLabels = getBorderStyleLabels(t);
        const borderStyleDropdown = new LabeledFieldView(locale, createLabeledDropdown);
        borderStyleDropdown.set({
          label: accessibleLabel,
          class: "ck-table-form__border-style"
        });
        borderStyleDropdown.fieldView.buttonView.set({
          ariaLabel: accessibleLabel,
          ariaLabelledBy: void 0,
          isOn: false,
          withText: true,
          tooltip: accessibleLabel
        });
        borderStyleDropdown.fieldView.buttonView.bind("label").to(this, "borderStyle", (value) => {
          return styleLabels[value ? value : "none"];
        });
        borderStyleDropdown.fieldView.on("execute", (evt) => {
          this.borderStyle = evt.source._borderStyleValue;
        });
        borderStyleDropdown.bind("isEmpty").to(this, "borderStyle", (value) => !value);
        addListToDropdown(borderStyleDropdown.fieldView, getBorderStyleDefinitions(this, defaultBorder.style), {
          role: "menu",
          ariaLabel: accessibleLabel
        });
        const borderWidthInput = new LabeledFieldView(locale, createLabeledInputText);
        borderWidthInput.set({
          label: t("Width"),
          class: "ck-table-form__border-width"
        });
        borderWidthInput.fieldView.bind("value").to(this, "borderWidth");
        borderWidthInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet);
        borderWidthInput.fieldView.on("input", () => {
          this.borderWidth = borderWidthInput.fieldView.element.value;
        });
        const borderColorInput = new LabeledFieldView(locale, colorInputCreator);
        borderColorInput.set({
          label: t("Color"),
          class: "ck-table-form__border-color"
        });
        borderColorInput.fieldView.bind("value").to(this, "borderColor");
        borderColorInput.bind("isEnabled").to(this, "borderStyle", isBorderStyleSet);
        borderColorInput.fieldView.on("input", () => {
          this.borderColor = borderColorInput.fieldView.value;
        });
        this.on("change:borderStyle", (evt, name, newValue, oldValue) => {
          if (!isBorderStyleSet(newValue)) {
            this.borderColor = "";
            this.borderWidth = "";
          }
          if (!isBorderStyleSet(oldValue)) {
            this.borderColor = defaultBorder.color;
            this.borderWidth = defaultBorder.width;
          }
        });
        return {
          borderRowLabel,
          borderStyleDropdown,
          borderColorInput,
          borderWidthInput
        };
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #backgroundInput}.
      */
      _createBackgroundFields() {
        const locale = this.locale;
        const t = this.t;
        const backgroundRowLabel = new LabelView(locale);
        backgroundRowLabel.text = t("Background");
        const backgroundInputCreator = getLabeledColorInputCreator({
          colorConfig: this.options.backgroundColors,
          columns: 5,
          defaultColorValue: this.options.defaultTableProperties.backgroundColor,
          colorPickerConfig: this.options.colorPickerConfig
        });
        const backgroundInput = new LabeledFieldView(locale, backgroundInputCreator);
        backgroundInput.set({
          label: t("Color"),
          class: "ck-table-properties-form__background"
        });
        backgroundInput.fieldView.bind("value").to(this, "backgroundColor");
        backgroundInput.fieldView.on("input", () => {
          this.backgroundColor = backgroundInput.fieldView.value;
        });
        return {
          backgroundRowLabel,
          backgroundInput
        };
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #widthInput},
      * * {@link #heightInput}.
      */
      _createDimensionFields() {
        const locale = this.locale;
        const t = this.t;
        const dimensionsLabel = new LabelView(locale);
        dimensionsLabel.text = t("Dimensions");
        const widthInput = new LabeledFieldView(locale, createLabeledInputText);
        widthInput.set({
          label: t("Width"),
          class: "ck-table-form__dimensions-row__width"
        });
        widthInput.fieldView.bind("value").to(this, "width");
        widthInput.fieldView.on("input", () => {
          this.width = widthInput.fieldView.element.value;
        });
        const operatorLabel = new View(locale);
        operatorLabel.setTemplate({
          tag: "span",
          attributes: {
            class: [
              "ck-table-form__dimension-operator"
            ]
          },
          children: [
            {
              text: "×"
            }
          ]
        });
        const heightInput = new LabeledFieldView(locale, createLabeledInputText);
        heightInput.set({
          label: t("Height"),
          class: "ck-table-form__dimensions-row__height"
        });
        heightInput.fieldView.bind("value").to(this, "height");
        heightInput.fieldView.on("input", () => {
          this.height = heightInput.fieldView.element.value;
        });
        return {
          dimensionsLabel,
          widthInput,
          operatorLabel,
          heightInput
        };
      }
      /**
      * Creates the following form fields:
      *
      * * {@link #alignmentToolbar}.
      */
      _createAlignmentFields() {
        const locale = this.locale;
        const t = this.t;
        const alignmentLabel = new LabelView(locale);
        alignmentLabel.text = t("Alignment");
        const alignmentToolbar = new ToolbarView(locale);
        alignmentToolbar.set({
          isCompact: true,
          ariaLabel: t("Table alignment toolbar")
        });
        fillToolbar({
          view: this,
          icons: {
            left: icons.objectLeft,
            center: icons.objectCenter,
            right: icons.objectRight
          },
          toolbar: alignmentToolbar,
          labels: this._alignmentLabels,
          propertyName: "alignment",
          defaultValue: this.options.defaultTableProperties.alignment
        });
        return {
          alignmentLabel,
          alignmentToolbar
        };
      }
      /**
      * Creates the following form controls:
      *
      * * {@link #saveButtonView},
      * * {@link #cancelButtonView}.
      */
      _createActionButtons() {
        const locale = this.locale;
        const t = this.t;
        const saveButtonView = new ButtonView(locale);
        const cancelButtonView = new ButtonView(locale);
        const fieldsThatShouldValidateToSave = [
          this.borderWidthInput,
          this.borderColorInput,
          this.backgroundInput,
          this.widthInput,
          this.heightInput
        ];
        saveButtonView.set({
          label: t("Save"),
          icon: icons.check,
          class: "ck-button-save",
          type: "submit",
          withText: true
        });
        saveButtonView.bind("isEnabled").toMany(fieldsThatShouldValidateToSave, "errorText", (...errorTexts) => {
          return errorTexts.every((errorText) => !errorText);
        });
        cancelButtonView.set({
          label: t("Cancel"),
          icon: icons.cancel,
          class: "ck-button-cancel",
          withText: true
        });
        cancelButtonView.delegate("execute").to(this, "cancel");
        return {
          saveButtonView,
          cancelButtonView
        };
      }
      /**
      * Provides localized labels for {@link #alignmentToolbar} buttons.
      */
      get _alignmentLabels() {
        const locale = this.locale;
        const t = this.t;
        const left = t("Align table to the left");
        const center = t("Center table");
        const right = t("Align table to the right");
        if (locale.uiLanguageDirection === "rtl") {
          return {
            right,
            center,
            left
          };
        } else {
          return {
            left,
            center,
            right
          };
        }
      }
    }
    function isBorderStyleSet(value) {
      return value !== "none";
    }
    var tableProperties = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>';
    const ERROR_TEXT_TIMEOUT = 500;
    const propertyToCommandMap = {
      borderStyle: "tableBorderStyle",
      borderColor: "tableBorderColor",
      borderWidth: "tableBorderWidth",
      backgroundColor: "tableBackgroundColor",
      width: "tableWidth",
      height: "tableHeight",
      alignment: "tableAlignment"
    };
    class TablePropertiesUI extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * The default table properties.
        */
        __publicField(this, "_defaultTableProperties");
        /**
        * The contextual balloon plugin instance.
        */
        __publicField(this, "_balloon");
        /**
        * The properties form view displayed inside the balloon.
        */
        __publicField(this, "view", null);
        /**
        * The batch used to undo all changes made by the form (which are live, as the user types)
        * when "Cancel" was pressed. Each time the view is shown, a new batch is created.
        */
        __publicField(this, "_undoStepBatch");
        /**
        * Flag used to indicate whether view is ready to execute update commands
        * (it finished loading initial data).
        */
        __publicField(this, "_isReady");
        editor.config.define("table.tableProperties", {
          borderColors: defaultColors,
          backgroundColors: defaultColors
        });
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          ContextualBalloon
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TablePropertiesUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const t = editor.t;
        this._defaultTableProperties = getNormalizedDefaultProperties(editor.config.get("table.tableProperties.defaultProperties"), {
          includeAlignmentProperty: true
        });
        this._balloon = editor.plugins.get(ContextualBalloon);
        editor.ui.componentFactory.add("tableProperties", (locale) => {
          const view = new ButtonView(locale);
          view.set({
            label: t("Table properties"),
            icon: tableProperties,
            tooltip: true
          });
          this.listenTo(view, "execute", () => this._showView());
          const commands = Object.values(propertyToCommandMap).map((commandName) => editor.commands.get(commandName));
          view.bind("isEnabled").toMany(commands, "isEnabled", (...areEnabled) => areEnabled.some((isCommandEnabled) => isCommandEnabled));
          return view;
        });
      }
      /**
      * @inheritDoc
      */
      destroy() {
        super.destroy();
        if (this.view) {
          this.view.destroy();
        }
      }
      /**
      * Creates the {@link module:table/tableproperties/ui/tablepropertiesview~TablePropertiesView} instance.
      *
      * @returns The table properties form view instance.
      */
      _createPropertiesView() {
        const editor = this.editor;
        const config = editor.config.get("table.tableProperties");
        const borderColorsConfig = normalizeColorOptions(config.borderColors);
        const localizedBorderColors = getLocalizedColorOptions(editor.locale, borderColorsConfig);
        const backgroundColorsConfig = normalizeColorOptions(config.backgroundColors);
        const localizedBackgroundColors = getLocalizedColorOptions(editor.locale, backgroundColorsConfig);
        const hasColorPicker = config.colorPicker !== false;
        const view = new TablePropertiesView(editor.locale, {
          borderColors: localizedBorderColors,
          backgroundColors: localizedBackgroundColors,
          defaultTableProperties: this._defaultTableProperties,
          colorPickerConfig: hasColorPicker ? config.colorPicker || {} : false
        });
        const t = editor.t;
        view.render();
        this.listenTo(view, "submit", () => {
          this._hideView();
        });
        this.listenTo(view, "cancel", () => {
          if (this._undoStepBatch.operations.length) {
            editor.execute("undo", this._undoStepBatch);
          }
          this._hideView();
        });
        view.keystrokes.set("Esc", (data, cancel2) => {
          this._hideView();
          cancel2();
        });
        clickOutsideHandler({
          emitter: view,
          activator: () => this._isViewInBalloon,
          contextElements: [
            this._balloon.view.element
          ],
          callback: () => this._hideView()
        });
        const colorErrorText = getLocalizedColorErrorText(t);
        const lengthErrorText = getLocalizedLengthErrorText(t);
        view.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle"));
        view.on("change:borderColor", this._getValidatedPropertyChangeCallback({
          viewField: view.borderColorInput,
          commandName: "tableBorderColor",
          errorText: colorErrorText,
          validator: colorFieldValidator
        }));
        view.on("change:borderWidth", this._getValidatedPropertyChangeCallback({
          viewField: view.borderWidthInput,
          commandName: "tableBorderWidth",
          errorText: lengthErrorText,
          validator: lineWidthFieldValidator
        }));
        view.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({
          viewField: view.backgroundInput,
          commandName: "tableBackgroundColor",
          errorText: colorErrorText,
          validator: colorFieldValidator
        }));
        view.on("change:width", this._getValidatedPropertyChangeCallback({
          viewField: view.widthInput,
          commandName: "tableWidth",
          errorText: lengthErrorText,
          validator: lengthFieldValidator
        }));
        view.on("change:height", this._getValidatedPropertyChangeCallback({
          viewField: view.heightInput,
          commandName: "tableHeight",
          errorText: lengthErrorText,
          validator: lengthFieldValidator
        }));
        view.on("change:alignment", this._getPropertyChangeCallback("tableAlignment"));
        return view;
      }
      /**
      * In this method the "editor data -> UI" binding is happening.
      *
      * When executed, this method obtains selected table property values from various table commands
      * and passes them to the {@link #view}.
      *
      * This way, the UI stays up–to–date with the editor data.
      */
      _fillViewFormFromCommandValues() {
        const commands = this.editor.commands;
        const borderStyleCommand = commands.get("tableBorderStyle");
        Object.entries(propertyToCommandMap).map(([property2, commandName]) => {
          const propertyKey = property2;
          const defaultValue = this._defaultTableProperties[propertyKey] || "";
          return [
            propertyKey,
            commands.get(commandName).value || defaultValue
          ];
        }).forEach(([property2, value]) => {
          if ((property2 === "borderColor" || property2 === "borderWidth") && borderStyleCommand.value === "none") {
            return;
          }
          this.view.set(property2, value);
        });
        this._isReady = true;
      }
      /**
      * Shows the {@link #view} in the {@link #_balloon}.
      *
      * **Note**: Each time a view is shown, the new {@link #_undoStepBatch} is created that contains
      * all changes made to the document when the view is visible, allowing a single undo step
      * for all of them.
      */
      _showView() {
        const editor = this.editor;
        if (!this.view) {
          this.view = this._createPropertiesView();
        }
        this.listenTo(editor.ui, "update", () => {
          this._updateView();
        });
        this._fillViewFormFromCommandValues();
        this._balloon.add({
          view: this.view,
          position: getBalloonTablePositionData(editor)
        });
        this._undoStepBatch = editor.model.createBatch();
        this.view.focus();
      }
      /**
      * Removes the {@link #view} from the {@link #_balloon}.
      */
      _hideView() {
        const editor = this.editor;
        this.stopListening(editor.ui, "update");
        this._isReady = false;
        this.view.saveButtonView.focus();
        this._balloon.remove(this.view);
        this.editor.editing.view.focus();
      }
      /**
      * Repositions the {@link #_balloon} or hides the {@link #view} if a table is no longer selected.
      */
      _updateView() {
        const editor = this.editor;
        const viewDocument = editor.editing.view.document;
        if (!getSelectionAffectedTableWidget(viewDocument.selection)) {
          this._hideView();
        } else if (this._isViewVisible) {
          repositionContextualBalloon(editor, "table");
        }
      }
      /**
      * Returns `true` when the {@link #view} is the visible in the {@link #_balloon}.
      */
      get _isViewVisible() {
        return !!this.view && this._balloon.visibleView === this.view;
      }
      /**
      * Returns `true` when the {@link #view} is in the {@link #_balloon}.
      */
      get _isViewInBalloon() {
        return !!this.view && this._balloon.hasView(this.view);
      }
      /**
      * Creates a callback that when executed upon {@link #view view's} property change
      * executes a related editor command with the new property value.
      *
      * If new value will be set to the default value, the command will not be executed.
      *
      * @param commandName The command that will be executed.
      */
      _getPropertyChangeCallback(commandName) {
        return (evt, propertyName, newValue) => {
          if (!this._isReady) {
            return;
          }
          this.editor.execute(commandName, {
            value: newValue,
            batch: this._undoStepBatch
          });
        };
      }
      /**
      * Creates a callback that when executed upon {@link #view view's} property change:
      * * executes a related editor command with the new property value if the value is valid,
      * * or sets the error text next to the invalid field, if the value did not pass the validation.
      */
      _getValidatedPropertyChangeCallback(options) {
        const { commandName, viewField, validator, errorText } = options;
        const setErrorTextDebounced = debounce(() => {
          viewField.errorText = errorText;
        }, ERROR_TEXT_TIMEOUT);
        return (evt, propertyName, newValue) => {
          setErrorTextDebounced.cancel();
          if (!this._isReady) {
            return;
          }
          if (validator(newValue)) {
            this.editor.execute(commandName, {
              value: newValue,
              batch: this._undoStepBatch
            });
            viewField.errorText = null;
          } else {
            setErrorTextDebounced();
          }
        };
      }
    }
    class TableProperties extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableProperties";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TablePropertiesEditing,
          TablePropertiesUI
        ];
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    function injectTableCaptionPostFixer(model) {
      model.document.registerPostFixer((writer) => tableCaptionPostFixer(writer, model));
    }
    function tableCaptionPostFixer(writer, model) {
      const changes = model.document.differ.getChanges();
      let wasFixed = false;
      for (const entry of changes) {
        if (entry.type != "insert") {
          continue;
        }
        const positionParent = entry.position.parent;
        if (positionParent.is("element", "table") || entry.name == "table") {
          const table2 = entry.name == "table" ? entry.position.nodeAfter : positionParent;
          const captionsToMerge = Array.from(table2.getChildren()).filter((child) => child.is("element", "caption"));
          const firstCaption = captionsToMerge.shift();
          if (!firstCaption) {
            continue;
          }
          for (const caption2 of captionsToMerge) {
            writer.move(writer.createRangeIn(caption2), firstCaption, "end");
            writer.remove(caption2);
          }
          if (firstCaption.nextSibling) {
            writer.move(writer.createRangeOn(firstCaption), table2, "end");
            wasFixed = true;
          }
          wasFixed = !!captionsToMerge.length || wasFixed;
        }
      }
      return wasFixed;
    }
    function isTable(modelElement) {
      return !!modelElement && modelElement.is("element", "table");
    }
    function getCaptionFromTableModelElement(tableModelElement) {
      for (const node of tableModelElement.getChildren()) {
        if (node.is("element", "caption")) {
          return node;
        }
      }
      return null;
    }
    function getCaptionFromModelSelection(selection) {
      const tableElement = getSelectionAffectedTable(selection);
      if (!tableElement) {
        return null;
      }
      return getCaptionFromTableModelElement(tableElement);
    }
    function matchTableCaptionViewElement(element) {
      const parent2 = element.parent;
      if (element.name == "figcaption" && parent2 && parent2.is("element", "figure") && parent2.hasClass("table")) {
        return {
          name: true
        };
      }
      if (element.name == "caption" && parent2 && parent2.is("element", "table")) {
        return {
          name: true
        };
      }
      return null;
    }
    class ToggleTableCaptionCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        const editor = this.editor;
        const tableElement = getSelectionAffectedTable(editor.model.document.selection);
        this.isEnabled = !!tableElement;
        if (!this.isEnabled) {
          this.value = false;
        } else {
          this.value = !!getCaptionFromTableModelElement(tableElement);
        }
      }
      /**
      * Executes the command.
      *
      * ```ts
      * editor.execute( 'toggleTableCaption' );
      * ```
      *
      * @param options Options for the executed command.
      * @param options.focusCaptionOnShow When true and the caption shows up, the selection will be moved into it straight away.
      * @fires execute
      */
      execute({ focusCaptionOnShow = false } = {}) {
        this.editor.model.change((writer) => {
          if (this.value) {
            this._hideTableCaption(writer);
          } else {
            this._showTableCaption(writer, focusCaptionOnShow);
          }
        });
      }
      /**
      * Shows the table caption. Also:
      *
      * * it attempts to restore the caption content from the `TableCaptionEditing` caption registry,
      * * it moves the selection to the caption right away, it the `focusCaptionOnShow` option was set.
      *
      * @param focusCaptionOnShow Default focus behavior when showing the caption.
      */
      _showTableCaption(writer, focusCaptionOnShow) {
        const model = this.editor.model;
        const tableElement = getSelectionAffectedTable(model.document.selection);
        const tableCaptionEditing = this.editor.plugins.get("TableCaptionEditing");
        const savedCaptionElement = tableCaptionEditing._getSavedCaption(tableElement);
        const newCaptionElement = savedCaptionElement || writer.createElement("caption");
        model.insertContent(newCaptionElement, tableElement, "end");
        if (focusCaptionOnShow) {
          writer.setSelection(newCaptionElement, "in");
        }
      }
      /**
      * Hides the caption of a selected table (or an table caption the selection is anchored to).
      *
      * The content of the caption is stored in the `TableCaptionEditing` caption registry to make this
      * a reversible action.
      */
      _hideTableCaption(writer) {
        const model = this.editor.model;
        const tableElement = getSelectionAffectedTable(model.document.selection);
        const tableCaptionEditing = this.editor.plugins.get("TableCaptionEditing");
        const captionElement = getCaptionFromTableModelElement(tableElement);
        tableCaptionEditing._saveCaption(tableElement, captionElement);
        model.deleteContent(writer.createSelection(captionElement, "on"));
      }
    }
    class TableCaptionEditing extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * A map that keeps saved JSONified table captions and table model elements they are
        * associated with.
        *
        * To learn more about this system, see {@link #_saveCaption}.
        */
        __publicField(this, "_savedCaptionsMap");
        this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCaptionEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const schema = editor.model.schema;
        const view = editor.editing.view;
        const t = editor.t;
        if (!schema.isRegistered("caption")) {
          schema.register("caption", {
            allowIn: "table",
            allowContentOf: "$block",
            isLimit: true
          });
        } else {
          schema.extend("caption", {
            allowIn: "table"
          });
        }
        editor.commands.add("toggleTableCaption", new ToggleTableCaptionCommand(this.editor));
        editor.conversion.for("upcast").elementToElement({
          view: matchTableCaptionViewElement,
          model: "caption"
        });
        editor.conversion.for("dataDowncast").elementToElement({
          model: "caption",
          view: (modelElement, { writer }) => {
            if (!isTable(modelElement.parent)) {
              return null;
            }
            return writer.createContainerElement("figcaption");
          }
        });
        editor.conversion.for("editingDowncast").elementToElement({
          model: "caption",
          view: (modelElement, { writer }) => {
            if (!isTable(modelElement.parent)) {
              return null;
            }
            const figcaptionElement = writer.createEditableElement("figcaption");
            writer.setCustomProperty("tableCaption", true, figcaptionElement);
            figcaptionElement.placeholder = t("Enter table caption");
            enablePlaceholder({
              view,
              element: figcaptionElement,
              keepOnFocus: true
            });
            return toWidgetEditable(figcaptionElement, writer);
          }
        });
        injectTableCaptionPostFixer(editor.model);
      }
      /**
      * Returns the saved {@link module:engine/model/element~Element#toJSON JSONified} caption
      * of a table model element.
      *
      * See {@link #_saveCaption}.
      *
      * @internal
      * @param tableModelElement The model element the caption should be returned for.
      * @returns The model caption element or `null` if there is none.
      */
      _getSavedCaption(tableModelElement) {
        const jsonObject = this._savedCaptionsMap.get(tableModelElement);
        return jsonObject ? Element.fromJSON(jsonObject) : null;
      }
      /**
      * Saves a {@link module:engine/model/element~Element#toJSON JSONified} caption for
      * a table element to allow restoring it in the future.
      *
      * A caption is saved every time it gets hidden. The
      * user should be able to restore it on demand.
      *
      * **Note**: The caption cannot be stored in the table model element attribute because,
      * for instance, when the model state propagates to collaborators, the attribute would get
      * lost (mainly because it does not convert to anything when the caption is hidden) and
      * the states of collaborators' models would de-synchronize causing numerous issues.
      *
      * See {@link #_getSavedCaption}.
      *
      * @internal
      * @param tableModelElement The model element the caption is saved for.
      * @param caption The caption model element to be saved.
      */
      _saveCaption(tableModelElement, caption2) {
        this._savedCaptionsMap.set(tableModelElement, caption2.toJSON());
      }
    }
    class TableCaptionUI extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCaptionUI";
      }
      /**
      * @inheritDoc
      */
      init() {
        const editor = this.editor;
        const editingView = editor.editing.view;
        const t = editor.t;
        editor.ui.componentFactory.add("toggleTableCaption", (locale) => {
          const command = editor.commands.get("toggleTableCaption");
          const view = new ButtonView(locale);
          view.set({
            icon: icons.caption,
            tooltip: true,
            isToggleable: true
          });
          view.bind("isOn", "isEnabled").to(command, "value", "isEnabled");
          view.bind("label").to(command, "value", (value) => value ? t("Toggle caption off") : t("Toggle caption on"));
          this.listenTo(view, "execute", () => {
            editor.execute("toggleTableCaption", {
              focusCaptionOnShow: true
            });
            if (command.value) {
              const modelCaptionElement = getCaptionFromModelSelection(editor.model.document.selection);
              const figcaptionElement = editor.editing.mapper.toViewElement(modelCaptionElement);
              if (!figcaptionElement) {
                return;
              }
              editingView.scrollToTheSelection();
              editingView.change((writer) => {
                writer.addClass("table__caption_highlighted", figcaptionElement);
              });
            }
            editor.editing.view.focus();
          });
          return view;
        });
      }
    }
    class TableCaption extends Plugin {
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableCaption";
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableCaptionEditing,
          TableCaptionUI
        ];
      }
    }
    class TableWidthsCommand extends Command {
      /**
      * @inheritDoc
      */
      refresh() {
        this.isEnabled = true;
      }
      /**
      * Updated the `tableWidth` attribute of the table and the `columnWidth` attribute of the columns of that table.
      */
      execute(options = {}) {
        const { model, plugins } = this.editor;
        let { table: table2 = model.document.selection.getSelectedElement(), columnWidths, tableWidth } = options;
        if (columnWidths) {
          columnWidths = Array.isArray(columnWidths) ? columnWidths : columnWidths.split(",");
        }
        model.change((writer) => {
          if (tableWidth) {
            writer.setAttribute("tableWidth", tableWidth, table2);
          } else {
            writer.removeAttribute("tableWidth", table2);
          }
          const tableColumnGroup = plugins.get("TableColumnResizeEditing").getColumnGroupElement(table2);
          if (!columnWidths && !tableColumnGroup) {
            return;
          }
          if (!columnWidths) {
            return writer.remove(tableColumnGroup);
          }
          const widths = normalizeColumnWidths(columnWidths);
          if (!tableColumnGroup) {
            const colGroupElement = writer.createElement("tableColumnGroup");
            widths.forEach((columnWidth) => writer.appendElement("tableColumn", {
              columnWidth
            }, colGroupElement));
            writer.append(colGroupElement, table2);
          } else {
            Array.from(tableColumnGroup.getChildren()).forEach((column, index2) => writer.setAttribute("columnWidth", widths[index2], column));
          }
        });
      }
    }
    function upcastColgroupElement(tableUtilsPlugin) {
      return (dispatcher) => dispatcher.on("element:colgroup", (evt, data, conversionApi) => {
        const modelTable = data.modelCursor.findAncestor("table");
        const tableColumnGroup = getColumnGroupElement(modelTable);
        if (!tableColumnGroup) {
          return;
        }
        const columnElements = getTableColumnElements(tableColumnGroup);
        const columnsCount = tableUtilsPlugin.getColumns(modelTable);
        let columnWidths = translateColSpanAttribute(tableColumnGroup, conversionApi.writer);
        columnWidths = Array.from({
          length: columnsCount
        }, (_, index2) => columnWidths[index2] || "auto");
        if (columnWidths.length != columnElements.length || columnWidths.includes("auto")) {
          updateColumnElements(columnElements, tableColumnGroup, normalizeColumnWidths(columnWidths), conversionApi.writer);
        }
      }, {
        priority: "low"
      });
    }
    function downcastTableResizedClass() {
      return (dispatcher) => dispatcher.on("insert:table", (evt, data, conversionApi) => {
        const viewWriter = conversionApi.writer;
        const modelTable = data.item;
        const viewElement = conversionApi.mapper.toViewElement(modelTable);
        const viewTable = viewElement.is("element", "table") ? viewElement : Array.from(viewElement.getChildren()).find((viewChild) => viewChild.is("element", "table"));
        const tableColumnGroup = getColumnGroupElement(modelTable);
        if (tableColumnGroup) {
          viewWriter.addClass("ck-table-resized", viewTable);
        } else {
          viewWriter.removeClass("ck-table-resized", viewTable);
        }
      }, {
        priority: "low"
      });
    }
    class TableColumnResizeEditing extends Plugin {
      /**
      * @inheritDoc
      */
      constructor(editor) {
        super(editor);
        /**
        * A flag indicating if the column resizing is in progress.
        */
        __publicField(this, "_isResizingActive");
        /**
        * A temporary storage for the required data needed to correctly calculate the widths of the resized columns. This storage is
        * initialized when column resizing begins, and is purged upon completion.
        */
        __publicField(this, "_resizingData");
        /**
        * DOM emitter.
        */
        __publicField(this, "_domEmitter");
        /**
        * A local reference to the {@link module:table/tableutils~TableUtils} plugin.
        */
        __publicField(this, "_tableUtilsPlugin");
        this._isResizingActive = false;
        this.set("_isResizingAllowed", true);
        this._resizingData = null;
        this._domEmitter = new (DomEmitterMixin())();
        this._tableUtilsPlugin = editor.plugins.get("TableUtils");
        this.on("change:_isResizingAllowed", (evt, name, value) => {
          const classAction = value ? "removeClass" : "addClass";
          editor.editing.view.change((writer) => {
            for (const root2 of editor.editing.view.document.roots) {
              writer[classAction]("ck-column-resize_disabled", editor.editing.view.document.getRoot(root2.rootName));
            }
          });
        });
      }
      /**
      * @inheritDoc
      */
      static get requires() {
        return [
          TableEditing,
          TableUtils
        ];
      }
      /**
      * @inheritDoc
      */
      static get pluginName() {
        return "TableColumnResizeEditing";
      }
      /**
      * @inheritDoc
      */
      init() {
        this._extendSchema();
        this._registerPostFixer();
        this._registerConverters();
        this._registerResizingListeners();
        this._registerResizerInserter();
        const editor = this.editor;
        const columnResizePlugin = editor.plugins.get("TableColumnResize");
        const tableEditing = editor.plugins.get("TableEditing");
        tableEditing.registerAdditionalSlot({
          filter: (element) => element.is("element", "tableColumnGroup"),
          positionOffset: 0
        });
        const tableWidthsCommand = new TableWidthsCommand(editor);
        editor.commands.add("resizeTableWidth", tableWidthsCommand);
        editor.commands.add("resizeColumnWidths", tableWidthsCommand);
        this.bind("_isResizingAllowed").to(editor, "isReadOnly", columnResizePlugin, "isEnabled", tableWidthsCommand, "isEnabled", (isEditorReadOnly, isPluginEnabled, isTableWidthsCommandCommandEnabled) => !isEditorReadOnly && isPluginEnabled && isTableWidthsCommandCommandEnabled);
      }
      /**
      * @inheritDoc
      */
      destroy() {
        this._domEmitter.stopListening();
        super.destroy();
      }
      /**
      * Returns a 'tableColumnGroup' element from the 'table'.
      *
      * @param element A 'table' or 'tableColumnGroup' element.
      * @returns A 'tableColumnGroup' element.
      */
      getColumnGroupElement(element) {
        return getColumnGroupElement(element);
      }
      /**
      * Returns an array of 'tableColumn' elements.
      *
      * @param element A 'table' or 'tableColumnGroup' element.
      * @returns An array of 'tableColumn' elements.
      */
      getTableColumnElements(element) {
        return getTableColumnElements(element);
      }
      /**
      * Returns an array of table column widths.
      *
      * @param element A 'table' or 'tableColumnGroup' element.
      * @returns An array of table column widths.
      */
      getTableColumnsWidths(element) {
        return getTableColumnsWidths(element);
      }
      /**
      * Registers new attributes for a table model element.
      */
      _extendSchema() {
        this.editor.model.schema.extend("table", {
          allowAttributes: [
            "tableWidth"
          ]
        });
        this.editor.model.schema.register("tableColumnGroup", {
          allowIn: "table",
          isLimit: true
        });
        this.editor.model.schema.register("tableColumn", {
          allowIn: "tableColumnGroup",
          allowAttributes: [
            "columnWidth",
            "colSpan"
          ],
          isLimit: true
        });
      }
      /**
      * Registers table column resize post-fixer.
      *
      * It checks if the change from the differ concerns a table-related element or attribute. For detected changes it:
      *  * Adjusts the `columnWidths` attribute to guarantee that the sum of the widths from all columns is 100%.
      *  * Checks if the `columnWidths` attribute gets updated accordingly after columns have been added or removed.
      */
      _registerPostFixer() {
        const editor = this.editor;
        const model = editor.model;
        model.document.registerPostFixer((writer) => {
          let changed = false;
          for (const table2 of getChangedResizedTables(model)) {
            const tableColumnGroup = this.getColumnGroupElement(table2);
            const columns = this.getTableColumnElements(tableColumnGroup);
            const columnWidths = this.getTableColumnsWidths(tableColumnGroup);
            let normalizedWidths = normalizeColumnWidths(columnWidths);
            normalizedWidths = adjustColumnWidths(normalizedWidths, table2, this);
            if (isEqual(columnWidths, normalizedWidths)) {
              continue;
            }
            updateColumnElements(columns, tableColumnGroup, normalizedWidths, writer);
            changed = true;
          }
          return changed;
        });
        function adjustColumnWidths(columnWidths, table2, plugin) {
          const newTableColumnsCount = plugin._tableUtilsPlugin.getColumns(table2);
          const columnsCountDelta = newTableColumnsCount - columnWidths.length;
          if (columnsCountDelta === 0) {
            return columnWidths;
          }
          const widths = columnWidths.map((width) => Number(width.replace("%", "")));
          const cellSet = getAffectedCells(plugin.editor.model.document.differ, table2);
          for (const cell of cellSet) {
            const currentColumnsDelta = newTableColumnsCount - widths.length;
            if (currentColumnsDelta === 0) {
              continue;
            }
            const hasMoreColumns = currentColumnsDelta > 0;
            const currentColumnIndex = plugin._tableUtilsPlugin.getCellLocation(cell).column;
            if (hasMoreColumns) {
              const columnMinWidthAsPercentage = getColumnMinWidthAsPercentage(table2, plugin.editor);
              const columnWidthsToInsert = createFilledArray(currentColumnsDelta, columnMinWidthAsPercentage);
              widths.splice(currentColumnIndex, 0, ...columnWidthsToInsert);
            } else {
              const removedColumnWidths = widths.splice(currentColumnIndex, Math.abs(currentColumnsDelta));
              widths[currentColumnIndex] += sumArray(removedColumnWidths);
            }
          }
          return widths.map((width) => width + "%");
        }
        function getAffectedCells(differ, table2) {
          const cellSet = /* @__PURE__ */ new Set();
          for (const change of differ.getChanges()) {
            if (change.type == "insert" && change.position.nodeAfter && change.position.nodeAfter.name == "tableCell" && change.position.nodeAfter.getAncestors().includes(table2)) {
              cellSet.add(change.position.nodeAfter);
            } else if (change.type == "remove") {
              const referenceNode = change.position.nodeBefore || change.position.nodeAfter;
              if (referenceNode.name == "tableCell" && referenceNode.getAncestors().includes(table2)) {
                cellSet.add(referenceNode);
              }
            }
          }
          return cellSet;
        }
      }
      /**
      * Registers table column resize converters.
      */
      _registerConverters() {
        const editor = this.editor;
        const conversion = editor.conversion;
        conversion.for("upcast").attributeToAttribute({
          view: {
            name: "figure",
            key: "style",
            value: {
              width: /[\s\S]+/
            }
          },
          model: {
            name: "table",
            key: "tableWidth",
            value: (viewElement) => viewElement.getStyle("width")
          }
        });
        conversion.for("downcast").attributeToAttribute({
          model: {
            name: "table",
            key: "tableWidth"
          },
          view: (width) => ({
            name: "figure",
            key: "style",
            value: {
              width
            }
          })
        });
        conversion.elementToElement({
          model: "tableColumnGroup",
          view: "colgroup"
        });
        conversion.elementToElement({
          model: "tableColumn",
          view: "col"
        });
        conversion.for("downcast").add(downcastTableResizedClass());
        conversion.for("upcast").add(upcastColgroupElement(this._tableUtilsPlugin));
        conversion.for("upcast").attributeToAttribute({
          view: {
            name: "col",
            styles: {
              width: /.*/
            }
          },
          model: {
            key: "columnWidth",
            value: (viewElement) => {
              const viewColWidth = viewElement.getStyle("width");
              if (!viewColWidth || !viewColWidth.endsWith("%") && !viewColWidth.endsWith("pt")) {
                return "auto";
              }
              return viewColWidth;
            }
          }
        });
        conversion.for("upcast").attributeToAttribute({
          view: {
            name: "col",
            key: "span"
          },
          model: "colSpan"
        });
        conversion.for("downcast").attributeToAttribute({
          model: {
            name: "tableColumn",
            key: "columnWidth"
          },
          view: (width) => ({
            key: "style",
            value: {
              width
            }
          })
        });
      }
      /**
      * Registers listeners to handle resizing process.
      */
      _registerResizingListeners() {
        const editingView = this.editor.editing.view;
        editingView.addObserver(MouseEventsObserver);
        editingView.document.on("mousedown", this._onMouseDownHandler.bind(this), {
          priority: "high"
        });
        this._domEmitter.listenTo(global$1.window.document, "mousemove", throttle(this._onMouseMoveHandler.bind(this), 50));
        this._domEmitter.listenTo(global$1.window.document, "mouseup", this._onMouseUpHandler.bind(this));
      }
      /**
      * Handles the `mousedown` event on column resizer element:
      *  * calculates the initial column pixel widths,
      *  * inserts the `<colgroup>` element if it is not present in the `<table>`,
      *  * puts the necessary data in the temporary storage,
      *  * applies the attributes to the `<table>` view element.
      *
      * @param eventInfo An object containing information about the fired event.
      * @param domEventData The data related to the DOM event.
      */
      _onMouseDownHandler(eventInfo, domEventData) {
        const target = domEventData.target;
        if (!target.hasClass("ck-table-column-resizer")) {
          return;
        }
        if (!this._isResizingAllowed) {
          return;
        }
        const editor = this.editor;
        const modelTable = editor.editing.mapper.toModelElement(target.findAncestor("figure"));
        if (!editor.model.canEditAt(modelTable)) {
          return;
        }
        domEventData.preventDefault();
        eventInfo.stop();
        const columnWidthsInPx = _calculateDomColumnWidths(modelTable, this._tableUtilsPlugin, editor);
        const viewTable = target.findAncestor("table");
        const editingView = editor.editing.view;
        if (!Array.from(viewTable.getChildren()).find((viewCol) => viewCol.is("element", "colgroup"))) {
          editingView.change((viewWriter) => {
            _insertColgroupElement(viewWriter, columnWidthsInPx, viewTable);
          });
        }
        this._isResizingActive = true;
        this._resizingData = this._getResizingData(domEventData, columnWidthsInPx);
        editingView.change((writer) => _applyResizingAttributesToTable(writer, viewTable, this._resizingData));
        function _calculateDomColumnWidths(modelTable2, tableUtilsPlugin, editor2) {
          const columnWidthsInPx2 = Array(tableUtilsPlugin.getColumns(modelTable2));
          const tableWalker = new TableWalker(modelTable2);
          for (const cellSlot of tableWalker) {
            const viewCell = editor2.editing.mapper.toViewElement(cellSlot.cell);
            const domCell = editor2.editing.view.domConverter.mapViewToDom(viewCell);
            const domCellWidth = getDomCellOuterWidth(domCell);
            if (!columnWidthsInPx2[cellSlot.column] || domCellWidth < columnWidthsInPx2[cellSlot.column]) {
              columnWidthsInPx2[cellSlot.column] = toPrecision(domCellWidth);
            }
          }
          return columnWidthsInPx2;
        }
        function _insertColgroupElement(viewWriter, columnWidthsInPx2, viewTable2) {
          const colgroup = viewWriter.createContainerElement("colgroup");
          for (let i = 0; i < columnWidthsInPx2.length; i++) {
            const viewColElement = viewWriter.createEmptyElement("col");
            const columnWidthInPc = `${toPrecision(columnWidthsInPx2[i] / sumArray(columnWidthsInPx2) * 100)}%`;
            viewWriter.setStyle("width", columnWidthInPc, viewColElement);
            viewWriter.insert(viewWriter.createPositionAt(colgroup, "end"), viewColElement);
          }
          viewWriter.insert(viewWriter.createPositionAt(viewTable2, 0), colgroup);
        }
        function _applyResizingAttributesToTable(viewWriter, viewTable2, resizingData) {
          const figureInitialPcWidth = resizingData.widths.viewFigureWidth / resizingData.widths.viewFigureParentWidth;
          viewWriter.addClass("ck-table-resized", viewTable2);
          viewWriter.addClass("ck-table-column-resizer__active", resizingData.elements.viewResizer);
          viewWriter.setStyle("width", `${toPrecision(figureInitialPcWidth * 100)}%`, viewTable2.findAncestor("figure"));
        }
      }
      /**
      * Handles the `mousemove` event.
      *  * If resizing process is not in progress, it does nothing.
      *  * If resizing is active but not allowed, it stops the resizing process instantly calling the `mousedown` event handler.
      *  * Otherwise it dynamically updates the widths of the resized columns.
      *
      * @param eventInfo An object containing information about the fired event.
      * @param mouseEventData The native DOM event.
      */
      _onMouseMoveHandler(eventInfo, mouseEventData) {
        if (!this._isResizingActive) {
          return;
        }
        if (!this._isResizingAllowed) {
          this._onMouseUpHandler();
          return;
        }
        const { columnPosition, flags: { isRightEdge, isTableCentered, isLtrContent }, elements: { viewFigure, viewLeftColumn, viewRightColumn }, widths: { viewFigureParentWidth, tableWidth, leftColumnWidth, rightColumnWidth } } = this._resizingData;
        const dxLowerBound = -leftColumnWidth + COLUMN_MIN_WIDTH_IN_PIXELS;
        const dxUpperBound = isRightEdge ? viewFigureParentWidth - tableWidth : rightColumnWidth - COLUMN_MIN_WIDTH_IN_PIXELS;
        const multiplier = (isLtrContent ? 1 : -1) * (isRightEdge && isTableCentered ? 2 : 1);
        const dx = clamp((mouseEventData.clientX - columnPosition) * multiplier, Math.min(dxLowerBound, 0), Math.max(dxUpperBound, 0));
        if (dx === 0) {
          return;
        }
        this.editor.editing.view.change((writer) => {
          const leftColumnWidthAsPercentage = toPrecision((leftColumnWidth + dx) * 100 / tableWidth);
          writer.setStyle("width", `${leftColumnWidthAsPercentage}%`, viewLeftColumn);
          if (isRightEdge) {
            const tableWidthAsPercentage = toPrecision((tableWidth + dx) * 100 / viewFigureParentWidth);
            writer.setStyle("width", `${tableWidthAsPercentage}%`, viewFigure);
          } else {
            const rightColumnWidthAsPercentage = toPrecision((rightColumnWidth - dx) * 100 / tableWidth);
            writer.setStyle("width", `${rightColumnWidthAsPercentage}%`, viewRightColumn);
          }
        });
      }
      /**
      * Handles the `mouseup` event.
      *  * If resizing process is not in progress, it does nothing.
      *  * If resizing is active but not allowed, it cancels the resizing process restoring the original widths.
      *  * Otherwise it propagates the changes from view to the model by executing the adequate commands.
      */
      _onMouseUpHandler() {
        if (!this._isResizingActive) {
          return;
        }
        const { viewResizer, modelTable, viewFigure, viewColgroup } = this._resizingData.elements;
        const editor = this.editor;
        const editingView = editor.editing.view;
        const tableColumnGroup = this.getColumnGroupElement(modelTable);
        const viewColumns = Array.from(viewColgroup.getChildren()).filter((column) => column.is("view:element"));
        const columnWidthsAttributeOld = tableColumnGroup ? this.getTableColumnsWidths(tableColumnGroup) : null;
        const columnWidthsAttributeNew = viewColumns.map((column) => column.getStyle("width"));
        const isColumnWidthsAttributeChanged = !isEqual(columnWidthsAttributeOld, columnWidthsAttributeNew);
        const tableWidthAttributeOld = modelTable.getAttribute("tableWidth");
        const tableWidthAttributeNew = viewFigure.getStyle("width");
        const isTableWidthAttributeChanged = tableWidthAttributeOld !== tableWidthAttributeNew;
        if (isColumnWidthsAttributeChanged || isTableWidthAttributeChanged) {
          if (this._isResizingAllowed) {
            editor.execute("resizeTableWidth", {
              table: modelTable,
              tableWidth: `${toPrecision(tableWidthAttributeNew)}%`,
              columnWidths: columnWidthsAttributeNew
            });
          } else {
            editingView.change((writer) => {
              if (columnWidthsAttributeOld) {
                for (const viewCol of viewColumns) {
                  writer.setStyle("width", columnWidthsAttributeOld.shift(), viewCol);
                }
              } else {
                writer.remove(viewColgroup);
              }
              if (isTableWidthAttributeChanged) {
                if (tableWidthAttributeOld) {
                  writer.setStyle("width", tableWidthAttributeOld, viewFigure);
                } else {
                  writer.removeStyle("width", viewFigure);
                }
              }
              if (!columnWidthsAttributeOld && !tableWidthAttributeOld) {
                writer.removeClass("ck-table-resized", [
                  ...viewFigure.getChildren()
                ].find((element) => element.name === "table"));
              }
            });
          }
        }
        editingView.change((writer) => {
          writer.removeClass("ck-table-column-resizer__active", viewResizer);
        });
        this._isResizingActive = false;
        this._resizingData = null;
      }
      /**
      * Retrieves and returns required data needed for the resizing process.
      *
      * @param domEventData The data of the `mousedown` event.
      * @param columnWidths The current widths of the columns.
      * @returns The data needed for the resizing process.
      */
      _getResizingData(domEventData, columnWidths) {
        const editor = this.editor;
        const columnPosition = domEventData.domEvent.clientX;
        const viewResizer = domEventData.target;
        const viewLeftCell = viewResizer.findAncestor("td") || viewResizer.findAncestor("th");
        const modelLeftCell = editor.editing.mapper.toModelElement(viewLeftCell);
        const modelTable = modelLeftCell.findAncestor("table");
        const leftColumnIndex = getColumnEdgesIndexes(modelLeftCell, this._tableUtilsPlugin).rightEdge;
        const lastColumnIndex = this._tableUtilsPlugin.getColumns(modelTable) - 1;
        const isRightEdge = leftColumnIndex === lastColumnIndex;
        const isTableCentered = !modelTable.hasAttribute("tableAlignment");
        const isLtrContent = editor.locale.contentLanguageDirection !== "rtl";
        const viewTable = viewLeftCell.findAncestor("table");
        const viewFigure = viewTable.findAncestor("figure");
        const viewColgroup = [
          ...viewTable.getChildren()
        ].find((viewCol) => viewCol.is("element", "colgroup"));
        const viewLeftColumn = viewColgroup.getChild(leftColumnIndex);
        const viewRightColumn = isRightEdge ? void 0 : viewColgroup.getChild(leftColumnIndex + 1);
        const viewFigureParentWidth = getElementWidthInPixels(editor.editing.view.domConverter.mapViewToDom(viewFigure.parent));
        const viewFigureWidth = getElementWidthInPixels(editor.editing.view.domConverter.mapViewToDom(viewFigure));
        const tableWidth = getTableWidthInPixels(modelTable, editor);
        const leftColumnWidth = columnWidths[leftColumnIndex];
        const rightColumnWidth = isRightEdge ? void 0 : columnWidths[leftColumnIndex + 1];
        return {
          columnPosition,
          flags: {
            isRightEdge,
            isTableCentered,
            isLtrContent
          },
          elements: {
            viewResizer,
            modelTable,
            viewFigure,
            viewColgroup,
            viewLeftColumn,
            viewRightColumn
          },
          widths: {
            viewFigureParentWidth,
            viewFigureWidth,
            tableWidth,
            leftColumnWidth,
            rightColumnWidth
          }
        };
      }
      /**
      * Registers a listener ensuring that each resizable cell have a resizer handle.
      */
      _registerResizerInserter() {
        this.editor.conversion.for("editingDowncast").add((dispatcher) => {
          dispatcher.on("insert:tableCell", (evt, data, conversionApi) => {
            const modelElement = data.item;
            const viewElement = conversionApi.mapper.toViewElement(modelElement);
            const viewWriter = conversionApi.writer;
            viewWriter.insert(viewWriter.createPositionAt(viewElement, "end"), viewWriter.createUIElement("div", {
              class: "ck-table-column-resizer"
            }));
          }, {
            priority: "lowest"
          });
        });
      }
    }
    class TableColumnResize extends Plugin {
      /**
      * @inheritDoc
       */
      static get requires() {
        return [
          TableColumnResizeEditing,
          TableCellWidthEditing
        ];
      }
      /**
      * @inheritDoc
       */
      static get pluginName() {
        return "TableColumnResize";
      }
    }
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const translationsDE = { "de": { "dictionary": { "Words: %0": "Wörter: %0 ", "Characters: %0": "Zeichen: %0 ", "Widget toolbar": "Widget Werkzeugleiste", "Insert paragraph before block": "Absatz vor Block einfügen", "Insert paragraph after block": "Absatz nach Block einfügen", "Press Enter to type after or press Shift + Enter to type before the widget": "Drücken Sie die Eingabetaste, um nach dem Widget zu tippen oder Shift + Eingabetaste, um vor dem Widget zu tippen.", "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)": "Tastatureingaben, die verwendet werden können, wenn ein Widget ausgewählt wurde (zum Beispiel: Bilder, Tabellen etc.)", "Insert a new paragraph directly after a widget": "Einen neuen Abschnitt direkt nach einem Widget einfügen", "Insert a new paragraph directly before a widget": "Einen neuen Abschnitt direkt vor einem Widget einfügen", "Move the caret to allow typing directly before a widget": "Verschieben Sie den Textcursor, um die Eingabe direkt nach dem Widget zu erlauben", "Move the caret to allow typing directly after a widget": "Verschieben Sie den Textcursor, um die direkte Eingabe nach dem Widget zu erlauben", "Move focus from an editable area back to the parent widget": "Bewegen Sie den Fokus von einem bearbeitbaren Bereich zurück zum übergeordneten Widget", "Upload in progress": "Upload läuft", "Undo": "Rückgängig", "Redo": "Wiederherstellen", "Rich Text Editor": "Rich Text Editor", "Editor editing area: %0": "Bearbeitungsbereich des Editors: %0", "Edit block": "Absatz bearbeiten", "Click to edit block": "Zum Bearbeiten des Blocks klicken", "Drag to move": "Zum Verschieben ziehen", "Next": "Nächste", "Previous": "vorherige", "Editor toolbar": "Editor Werkzeugleiste", "Dropdown toolbar": "Dropdown-Liste Werkzeugleiste", "Black": "Schwarz", "Dim grey": "Dunkelgrau", "Grey": "Grau", "Light grey": "Hellgrau", "White": "Weiß", "Red": "Rot", "Orange": "Orange", "Yellow": "Gelb", "Light green": "Hellgrün", "Green": "Grün", "Aquamarine": "Aquamarinblau", "Turquoise": "Türkis", "Light blue": "Hellblau", "Blue": "Blau", "Purple": "Violett", "Editor block content toolbar": "Editor Blockinhalt-Toolbar", "Editor contextual toolbar": "Editor kontextuelle Toolbar", "HEX": "HEX", "No results found": "Keine Ergebnisse gefunden", "No searchable items": "Keine durchsuchbaren Elemente", "Editor dialog": "Editor-Dialog", "Close": "Schließen", "Help Contents. To close this dialog press ESC.": "Hilfe zum Inhalt. Drücken Sie die Esc-Taste, um dieses Dialogfenster zu schließen.", "Below, you can find a list of keyboard shortcuts that can be used in the editor.": "Unten finden Sie eine Liste mit Tastenkombinationen, die im Editor benutzt werden können.", "(may require <kbd>Fn</kbd>)": "(erfordert gegebenenfalls <kbd>Fn</kbd>)", "Accessibility": "Bedienungshilfen", "Accessibility help": "Hilfe zur Eingabe", "Press %0 for help.": "Drücken Sie %0 für Hilfe.", "Move focus in and out of an active dialog window": "Fokus auf ein aktives Dialogfenster richten oder aufheben", "MENU_BAR_MENU_FILE": "Datei", "MENU_BAR_MENU_EDIT": "Bearbeiten", "MENU_BAR_MENU_VIEW": "Anzeigen", "MENU_BAR_MENU_INSERT": "Einfügen", "MENU_BAR_MENU_FORMAT": "Format", "MENU_BAR_MENU_TOOLS": "Werkzeuge", "MENU_BAR_MENU_HELP": "Hilfe", "MENU_BAR_MENU_TEXT": "Text", "MENU_BAR_MENU_FONT": "Schriftart", "Editor menu bar": "Menüleiste des Editors", 'Please enter a valid color (e.g. "ff0000").': "Bitte geben Sie eine gültige Farbe ein (z. B. „ff0000“).", "Insert table": "Tabelle einfügen", "Header column": "Kopfspalte", "Insert column left": "Spalte links einfügen", "Insert column right": "Spalte rechts einfügen", "Delete column": "Spalte löschen", "Select column": "Spalte auswählen", "Column": "Spalte", "Header row": "Kopfzeile", "Insert row below": "Zeile unten einfügen", "Insert row above": "Zeile oben einfügen", "Delete row": "Zeile löschen", "Select row": "Zeile auswählen", "Row": "Zeile", "Merge cell up": "Zelle verbinden", "Merge cell right": "Zelle rechts verbinden", "Merge cell down": "Zelle unten verbinden", "Merge cell left": "Zelle links verbinden", "Split cell vertically": "Zelle vertikal teilen", "Split cell horizontally": "Zelle horizontal teilen", "Merge cells": "Zellen verbinden", "Table toolbar": "Tabelle Werkzeugleiste", "Table properties": "Tabelleneigenschaften", "Cell properties": "Zelleneigenschaften", "Border": "Rahmen", "Style": "Rahmenart", "Width": "Breite", "Height": "Höhe", "Color": "Farbe", "Background": "Hintergrund", "Padding": "Innenabstand", "Dimensions": "Größe", "Table cell text alignment": "Ausrichtung des Zellentextes", "Alignment": "Ausrichtung", "Horizontal text alignment toolbar": "Werkzeugleiste für die horizontale Zellentext-Ausrichtung", "Vertical text alignment toolbar": "Werkzeugleiste für die vertikale Zellentext-Ausrichtung", "Table alignment toolbar": "Werkzeugleiste für die Tabellen-Ausrichtung", "None": "Kein Rahmen", "Solid": "Durchgezogen", "Dotted": "Gepunktet", "Dashed": "Gestrichelt", "Double": "Doppelt", "Groove": "Eingeritzt", "Ridge": "Hervorgehoben", "Inset": "Eingelassen", "Outset": "Geprägt", "Align cell text to the left": "Zellentext linksbündig ausrichten", "Align cell text to the center": "Zellentext zentriert ausrichten", "Align cell text to the right": "Zellentext rechtsbündig ausrichten", "Justify cell text": "Zellentext als Blocksatz ausrichten", "Align cell text to the top": "Zellentext oben ausrichten", "Align cell text to the middle": "Zellentext mittig ausrichten", "Align cell text to the bottom": "Zellentext unten ausrichten", "Align table to the left": "Tabelle links ausrichten", "Center table": "Tabelle zentrieren", "Align table to the right": "Tabelle rechts ausrichten", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': "Die Farbe ist ungültig. Probieren Sie „#FF0000“ oder „rgb(255,0,0)“ oder „red“.", 'The value is invalid. Try "10px" or "2em" or simply "2".': "Der Wert ist ungültig. Probieren Sie „10px“ oder „2em“ oder „2“.", "Color picker": "Farbwähler", "Enter table caption": "Tabellenüberschrift eingeben", "Keystrokes that can be used in a table cell": "Tastatureingaben, die in einer Tabelle benutz werden können.", "Move the selection to the next cell": "Auswahl in die nächste Zelle verschieben", "Move the selection to the previous cell": "Auswahl in die vorherige Zelle verschieben", "Insert a new table row (when in the last cell of a table)": "Eine neue Tabellenspalte einfügen (wenn in der letzten Tabellenzelle)", "Navigate through the table": "Tabellennavigation", "Table": "Tabelle", "Styles": "Stile", "Multiple styles": "Mehrere Stile", "Block styles": "Block-Stile", "Text styles": "Text-Stile", "Special characters": "Sonderzeichen", "All": "Alle", "Arrows": "Pfeile", "Currency": "Währung", "Latin": "Lateinisch", "Mathematical": "Mathematisch", "Text": "Text", "leftwards simple arrow": "einfacher Linkspfeil", "rightwards simple arrow": "einfacher Rechtspfeil", "upwards simple arrow": "einfacher Aufwärtspfeil", "downwards simple arrow": "einfacher Abwärtspfeil", "leftwards double arrow": "Doppelpfeil nach links", "rightwards double arrow": "Doppelpfeil nach rechts", "upwards double arrow": "Doppelpfeil nach oben", "downwards double arrow": "Doppelpfeil nach unten", "leftwards dashed arrow": "Gestrichelter Pfeil nach links", "rightwards dashed arrow": "Gestrichelter Pfeil nach rechts", "upwards dashed arrow": "Gestrichelter Pfeil nach oben", "downwards dashed arrow": "Gestrichelter Pfeil nach unten", "leftwards arrow to bar": "Pfeil nach links zum Querstrich", "rightwards arrow to bar": "Pfeil nach rechts zum Querstrich", "upwards arrow to bar": "Pfeil nach oben zum Querstrich", "downwards arrow to bar": "Pfeil nach unten zum Querstrich", "up down arrow with base": "Unterstrichener Pfeil nach oben und unten", "back with leftwards arrow above": "„Back“ darüber Pfeil nach links", "end with leftwards arrow above": "„End“ darüber Pfeil nach links", "on with exclamation mark with left right arrow above": "„On“ mit Ausrufezeichen darüber Pfeil nach links und rechts", "soon with rightwards arrow above": "„Soon“ darüber Pfeil nach rechts", "top with upwards arrow above": "„Top“ darüber Pfeil nach oben", "Dollar sign": "Dollar-Zeichen", "Euro sign": "Euro-Zeichen", "Yen sign": "Yen-Zeichen", "Pound sign": "Pfund-Zeichen", "Cent sign": "Cent-Zeichen", "Euro-currency sign": "Euro-Währungszeichen", "Colon sign": "Colón-Zeichen", "Cruzeiro sign": "Cruzeiro-Zeichen", "French franc sign": "Französischer Franc-Zeichen", "Lira sign": "Lira-Zeichen", "Currency sign": "Währungssymbol", "Bitcoin sign": "Bitcoin-Zeichen", "Mill sign": "Mill-Zeichen", "Naira sign": "Naira-Zeichen", "Peseta sign": "Peseta-Zeichen", "Rupee sign": "Rupie-Zeichen", "Won sign": "Won-Zeichen", "New sheqel sign": "Schekel-Zeichen", "Dong sign": "Đồng-Zeichen", "Kip sign": "Kip-Zeichen", "Tugrik sign": "Tugrik-Zeichen", "Drachma sign": "Drachme-Zeichen", "German penny sign": "Pfennig-Zeichen", "Peso sign": "Philippinischer Peso-Zeichen", "Guarani sign": "Guaraní-Zeichen", "Austral sign": "Austral-Zeichen", "Hryvnia sign": "Hrywnja-Zeichen", "Cedi sign": "Cedi-Zeichen", "Livre tournois sign": "Livre tournois-Zeichen", "Spesmilo sign": "Spesmilo-Zeichen", "Tenge sign": "Tenge-Zeichen", "Indian rupee sign": "Indische Rupie-Zeichen", "Turkish lira sign": "Türkische Lira-Zeichen", "Nordic mark sign": "Nordische Mark-Zeichen", "Manat sign": "Manat-Zeichen", "Ruble sign": "Rubel-Zeichen", "Latin capital letter a with macron": "Lateinischer Großbuchstabe a mit Makron", "Latin small letter a with macron": "Lateinischer Kleinbuchstabe a mit Makron", "Latin capital letter a with breve": "Lateinischer Großbuchstabe a mit Breve", "Latin small letter a with breve": "Lateinischer Kleinbuchstabe a mit Breve", "Latin capital letter a with ogonek": "Lateinischer Großbuchstabe a mit Ogonek", "Latin small letter a with ogonek": "Lateinischer Kleinbuchstabe a mit Ogonek", "Latin capital letter c with acute": "Lateinischer Großbuchstabe c mit Akut", "Latin small letter c with acute": "Lateinischer Kleinbuchstabe c mit Akut", "Latin capital letter c with circumflex": "Lateinischer Großbuchstabe c mit Zirkumflex", "Latin small letter c with circumflex": "Lateinischer Kleinbuchstabe c mit Zirkumflex", "Latin capital letter c with dot above": "Lateinischer Großbuchstabe c mit Punkt darüber", "Latin small letter c with dot above": "Lateinischer Kleinbuchstabe c mit Punkt darüber", "Latin capital letter c with caron": "Lateinischer Großbuchstabe c mit Hatschek", "Latin small letter c with caron": "Lateinischer Kleinbuchstabe c mit Hatschek", "Latin capital letter d with caron": "Lateinischer Großbuchstabe d mit Hatschek", "Latin small letter d with caron": "Lateinischer Kleinbuchstabe d mit Hatschek", "Latin capital letter d with stroke": "Lateinischer Großbuchstabe d mit Querstrich", "Latin small letter d with stroke": "Lateinischer Kleinbuchstabe d mit Querstrich", "Latin capital letter e with macron": "Lateinischer Großbuchstabe e mit Makron", "Latin small letter e with macron": "Lateinischer Kleinbuchstabe e mit Makron", "Latin capital letter e with breve": "Lateinischer Großbuchstabe e mit Breve", "Latin small letter e with breve": "Lateinischer Kleinbuchstabe e mit Breve", "Latin capital letter e with dot above": "Lateinischer Großbuchstabe e mit Punkt darüber", "Latin small letter e with dot above": "Lateinischer Kleinbuchstabe e mit Punkt darüber", "Latin capital letter e with ogonek": "Lateinischer Großbuchstabe e mit Ogonek", "Latin small letter e with ogonek": "Lateinischer Kleinbuchstabe e mit Ogonek", "Latin capital letter e with caron": "Lateinischer Großbuchstabe e mit Hatschek", "Latin small letter e with caron": "Lateinischer Kleinbuchstabe e mit Hatschek", "Latin capital letter g with circumflex": "Lateinischer Großbuchstabe g mit Zirkumflex", "Latin small letter g with circumflex": "Lateinischer Kleinbuchstabe g mit Zirkumflex", "Latin capital letter g with breve": "Lateinischer Großbuchstabe g mit Breve", "Latin small letter g with breve": "Lateinischer Kleinbuchstabe g mit Breve", "Latin capital letter g with dot above": "Lateinischer Großbuchstabe g mit Punkt darüber", "Latin small letter g with dot above": "Lateinischer Kleinbuchstabe g mit Punkt darüber", "Latin capital letter g with cedilla": "Lateinischer Großbuchstabe g mit Cedille", "Latin small letter g with cedilla": "Lateinischer Kleinbuchstabe g mit Cedille", "Latin capital letter h with circumflex": "Lateinischer Großbuchstabe h mit Zirkumflex", "Latin small letter h with circumflex": "Lateinischer Kleinbuchstabe h mit Zirkumflex", "Latin capital letter h with stroke": "Lateinischer Großbuchstabe h mit Querstrich", "Latin small letter h with stroke": "Lateinischer Kleinbuchstabe h mit Querstrich", "Latin capital letter i with tilde": "Lateinischer Großbuchstabe i mit Tilde", "Latin small letter i with tilde": "Lateinischer Kleinbuchstabe i mit Tilde", "Latin capital letter i with macron": "Lateinischer Großbuchstabe i mit Makron", "Latin small letter i with macron": "Lateinischer Kleinbuchstabe i mit Makron", "Latin capital letter i with breve": "Lateinischer Großbuchstabe i mit Breve", "Latin small letter i with breve": "Lateinischer Kleinbuchstabe i mit Breve", "Latin capital letter i with ogonek": "Lateinischer Großbuchstabe i mit Ogonek", "Latin small letter i with ogonek": "Lateinischer Kleinbuchstabe i mit Ogonek", "Latin capital letter i with dot above": "Lateinischer Großbuchstabe i mit Punkt darüber", "Latin small letter dotless i": "Lateinischer Kleinbuchstabe i ohne Punkt", "Latin capital ligature ij": "Große lateinische Ligatur ij", "Latin small ligature ij": "Kleine lateinische Ligatur ij", "Latin capital letter j with circumflex": "Lateinischer Großbuchstabe j mit Zirkumflex", "Latin small letter j with circumflex": "Lateinischer Kleinbuchstabe j mit Zirkumflex", "Latin capital letter k with cedilla": "Lateinischer Großbuchstabe k mit Cedille", "Latin small letter k with cedilla": "Lateinischer Kleinbuchstabe k mit Cedille", "Latin small letter kra": "Lateinischer Kleinbuchstabe Kra", "Latin capital letter l with acute": "Lateinischer Großbuchstabe l mit Akut", "Latin small letter l with acute": "Lateinischer Kleinbuchstabe l mit Akut", "Latin capital letter l with cedilla": "Lateinischer Großbuchstabe l mit Cedille", "Latin small letter l with cedilla": "Lateinischer Kleinbuchstabe l mit Cedille", "Latin capital letter l with caron": "Lateinischer Großbuchstabe l mit Hatschek", "Latin small letter l with caron": "Lateinischer Kleinbuchstabe l mit Hatschek", "Latin capital letter l with middle dot": "Lateinischer Großbuchstabe l mit Mittelpunkt", "Latin small letter l with middle dot": "Lateinischer Kleinbuchstabe l mit Mittelpunkt", "Latin capital letter l with stroke": "Lateinischer Großbuchstabe l mit Querstrich", "Latin small letter l with stroke": "Lateinischer Kleinbuchstabe l mit Querstrich", "Latin capital letter n with acute": "Lateinischer Großbuchstabe n mit Akut", "Latin small letter n with acute": "Lateinischer Kleinbuchstabe n mit Akut", "Latin capital letter n with cedilla": "Lateinischer Großbuchstabe n mit Cedille", "Latin small letter n with cedilla": "Lateinischer Kleinbuchstabe n mit Cedille", "Latin capital letter n with caron": "Lateinischer Großbuchstabe n mit Hatschek", "Latin small letter n with caron": "Lateinischer Kleinbuchstabe n mit Hatschek", "Latin small letter n preceded by apostrophe": "Lateinischer Kleinbuchstabe n mit vorangestelltem Apostroph", "Latin capital letter eng": "Lateinischer Großbuchstabe Eng", "Latin small letter eng": "Lateinischer Kleinbuchstabe Eng", "Latin capital letter o with macron": "Lateinischer Großbuchstabe o mit Makron", "Latin small letter o with macron": "Lateinischer Kleinbuchstabe o mit Makron", "Latin capital letter o with breve": "Lateinischer Großbuchstabe o mit Breve", "Latin small letter o with breve": "Lateinischer Kleinbuchstabe o mit Breve", "Latin capital letter o with double acute": "Lateinischer Großbuchstabe o mit doppeltem Akut", "Latin small letter o with double acute": "Lateinischer Kleinbuchstabe o mit doppeltem Akut", "Latin capital ligature oe": "Große lateinische Ligatur oe", "Latin small ligature oe": "Kleine lateinische Ligatur oe", "Latin capital letter r with acute": "Lateinischer Großbuchstabe r mit Akut", "Latin small letter r with acute": "Lateinischer Kleinbuchstabe r mit Akut", "Latin capital letter r with cedilla": "Lateinischer Großbuchstabe r mit Cedille", "Latin small letter r with cedilla": "Lateinischer Kleinbuchstabe r mit Cedille", "Latin capital letter r with caron": "Lateinischer Großbuchstabe r mit Hatschek", "Latin small letter r with caron": "Lateinischer Kleinbuchstabe r mit Hatschek", "Latin capital letter s with acute": "Lateinischer Großbuchstabe s mit Akut", "Latin small letter s with acute": "Lateinischer Kleinbuchstabe s mit Akut", "Latin capital letter s with circumflex": "Lateinischer Großbuchstabe s mit Zirkumflex", "Latin small letter s with circumflex": "Lateinischer Kleinbuchstabe s mit Zirkumflex", "Latin capital letter s with cedilla": "Lateinischer Großbuchstabe s mit Cedille", "Latin small letter s with cedilla": "Lateinischer Kleinbuchstabe s mit Cedille", "Latin capital letter s with caron": "Lateinischer Großbuchstabe s mit Hatschek", "Latin small letter s with caron": "Lateinischer Kleinbuchstabe s mit Hatschek", "Latin capital letter t with cedilla": "Lateinischer Großbuchstabe t mit Cedille", "Latin small letter t with cedilla": "Lateinischer Kleinbuchstabe t mit Cedille", "Latin capital letter t with caron": "Lateinischer Großbuchstabe t mit Hatschek", "Latin small letter t with caron": "Lateinischer Kleinbuchstabe t mit Hatschek", "Latin capital letter t with stroke": "Lateinischer Großbuchstabe t mit Querstrich", "Latin small letter t with stroke": "Lateinischer Kleinbuchstabe t mit Querstrich", "Latin capital letter u with tilde": "Lateinischer Großbuchstabe u mit Tilde", "Latin small letter u with tilde": "Lateinischer Kleinbuchstabe u mit Tilde", "Latin capital letter u with macron": "Lateinischer Großbuchstabe u mit Makron", "Latin small letter u with macron": "Lateinischer Kleinbuchstabe u mit Makron", "Latin capital letter u with breve": "Lateinischer Großbuchstabe u mit Breve", "Latin small letter u with breve": "Lateinischer Kleinbuchstabe u mit Breve", "Latin capital letter u with ring above": "Lateinischer Großbuchstabe u mit Kroužek darüber", "Latin small letter u with ring above": "Lateinischer Kleinbuchstabe u mit Kroužek darüber", "Latin capital letter u with double acute": "Lateinischer Großbuchstabe u mit doppeltem Akut", "Latin small letter u with double acute": "Lateinischer Kleinbuchstabe u mit doppeltem Akut", "Latin capital letter u with ogonek": "Lateinischer Großbuchstabe u mit Ogonek", "Latin small letter u with ogonek": "Lateinischer Kleinbuchstabe u mit Ogonek", "Latin capital letter w with circumflex": "Lateinischer Großbuchstabe w mit Zirkumflex", "Latin small letter w with circumflex": "Lateinischer Kleinbuchstabe w mit Zirkumflex", "Latin capital letter y with circumflex": "Lateinischer Großbuchstabe y mit Zirkumflex", "Latin small letter y with circumflex": "Lateinischer Kleinbuchstabe y mit Zirkumflex", "Latin capital letter y with diaeresis": "Lateinischer Großbuchstabe y mit Trema", "Latin capital letter z with acute": "Lateinischer Großbuchstabe z mit Akut", "Latin small letter z with acute": "Lateinischer Kleinbuchstabe z mit Akut", "Latin capital letter z with dot above": "Lateinischer Großbuchstabe z mit Punkt darüber", "Latin small letter z with dot above": "Lateinischer Kleinbuchstabe z mit Punkt darüber", "Latin capital letter z with caron": "Lateinischer Großbuchstabe z mit Hatschek", "Latin small letter z with caron": "Lateinischer Kleinbuchstabe z mit Hatschek", "Latin small letter long s": "Lateinischer Kleinbuchstabe langes s", "Less-than sign": "Kleiner-als-Zeichen", "Greater-than sign": "Größer-als-Zeichen", "Less-than or equal to": "Kleiner als oder gleich", "Greater-than or equal to": "Größer als oder gleich", "En dash": "Halbgeviertstrich", "Em dash": "Geviertstrich", "Macron": "Makron", "Overline": "Überstrich", "Degree sign": "Grad-Zeichen", "Minus sign": "Minus-Zeichen", "Plus-minus sign": "Plus-Minus-Zeichen", "Division sign": "Geteilt-Zeichen", "Fraction slash": "Schrägstrich", "Multiplication sign": "Mal-Zeichen", "Latin small letter f with hook": "Lateinischer Kleinbuchstabe f mit Haken", "Integral": "Integral-Zeichen", "N-ary summation": "Summen-Zeichen", "Infinity": "Unendlich-Zeichen", "Square root": "Wurzel-Zeichen", "Tilde operator": "Tilde-Operator", "Approximately equal to": "Ungefähr gleich", "Almost equal to": "Gerundet", "Not equal to": "Ungleich", "Identical to": "Identisch mit", "Element of": "Element von", "Not an element of": "Kein Element von", "Contains as member": "Enthält als Element", "N-ary product": "Produkt-Zeichen", "Logical and": "Logisches und", "Logical or": "Logisches oder", "Not sign": "Negations-Zeichen", "Intersection": "Schnitt", "Union": "Vereinigung", "Partial differential": "Partielle Ableitung", "For all": "Allquantor", "There exists": "Existenzquantor", "Empty set": "Leere Menge", "Nabla": "Nabla", "Asterisk operator": "Hodge-Stern-Operator", "Proportional to": "Proportional zu", "Angle": "Winkel-Zeichen", "Vulgar fraction one quarter": "Gemeiner Bruch ein Viertel", "Vulgar fraction one half": "Gemeiner Bruch ein Halb", "Vulgar fraction three quarters": "Gemeiner Bruch drei Viertel", "Single left-pointing angle quotation mark": "Einfache Guillemets nach links", "Single right-pointing angle quotation mark": "Einfache Guillemets nach rechts", "Left-pointing double angle quotation mark": "Doppelte Guillemets nach links", "Right-pointing double angle quotation mark": "Doppelte Guillemets nach rechts", "Left single quotation mark": "Einfache Anführungszeichen links", "Right single quotation mark": "Einfache Anführungszeichen rechts", "Left double quotation mark": "Doppelte Anführungszeichen links", "Right double quotation mark": "Doppelte Anführungszeichen rechts", "Single low-9 quotation mark": "Einfache Anführungszeichen links unten", "Double low-9 quotation mark": "Doppelte Anführungszeichen links unten", "Inverted exclamation mark": "Umgekehrtes Ausrufezeichen", "Inverted question mark": "Umgekehrtes Fragezeichen", "Two dot leader": "Doppel-Punktlinie", "Horizontal ellipsis": "Auslassungspunkte", "Double dagger": "Zweibalkenkreuz", "Per mille sign": "Promille-Zeichen", "Per ten thousand sign": "Pro-Zehntausend-Zeichen", "Double exclamation mark": "Doppeltes Ausrufezeichen", "Question exclamation mark": "Frage-Ruf-Zeichen", "Exclamation question mark": "Ruf-Frage-Zeichen", "Double question mark": "Doppeltes Fragezeichen", "Copyright sign": "Copyright-Zeichen", "Registered sign": "Registered-Trade-Mark-Zeichen", "Trade mark sign": "Unregistered-Trade-Mark-Zeichen", "Section sign": "Paragraphen-Zeichen", "Paragraph sign": "Absatz-Zeichen", "Reversed paragraph sign": "Umgedrehtes Absatz-Zeichen", "Character categories": "Zeichenkategorien", "Source": "Quellcode", "Show source": "Quelle anzeigen", "Show blocks": "Blöcke anzeigen", "Select all": "Alles auswählen", "Disable editing": "Bearbeitung deaktivieren", "Enable editing": "Bearbeitung zulassen", "Previous editable region": "Vorheriger bearbeitbarer Bereich", "Next editable region": "Nächster bearbeitbarer Bereich", "Navigate editable regions": "Durch bearbeitbare Bereiche navigieren", "Remove Format": "Formatierung entfernen", "Page break": "Seitenumbruch", "media widget": "Medien-Widget", "Media URL": "Medien-URL", "Paste the media URL in the input.": "Medien-URL in das Eingabefeld einfügen.", "Tip: Paste the URL into the content to embed faster.": "Tipp: Zum schnelleren Einbetten können Sie die Medien-URL in den Inhalt einfügen.", "The URL must not be empty.": "Die URL darf nicht leer sein.", "This media URL is not supported.": "Diese Medien-URL wird nicht unterstützt.", "Insert media": "Medium einfügen", "Media": "Medien", "Media toolbar": "Medien Werkzeugleiste", "Open media in new tab": "Medien in neuem Tab öffnen", "Numbered List": "Nummerierte Liste", "Bulleted List": "Aufzählungsliste", "To-do List": "Aufgabenliste", "Bulleted list styles toolbar": "Darstellung der ungeordneten Liste", "Numbered list styles toolbar": "Darstellung der geordneten Liste", "Toggle the disc list style": "Gefüllten Kreis einstellen", "Toggle the circle list style": "Leeren Kreis einstellen", "Toggle the square list style": "Quadrat einstellen", "Toggle the decimal list style": "Dezimalzahlen einstellen", "Toggle the decimal with leading zero list style": "Dezimalzahlen mit vorangestellten Nullen einstellen", "Toggle the lower–roman list style": "Kleingeschriebene römische Zahlen einstellen", "Toggle the upper–roman list style": "Großgeschriebene römische Zahlen einstellen", "Toggle the lower–latin list style": "Kleingeschriebene lateinische Buchstaben einstellen", "Toggle the upper–latin list style": "Großgeschriebene lateinische Buchstaben einstellen", "Disc": "Gefüllter Kreis", "Circle": "Leerer Kreis", "Square": "Quadrat", "Decimal": "Dezimalzahlen", "Decimal with leading zero": "Dezimalzahlen mit vorangestellten Nullen", "Lower–roman": "Kleingeschriebene römische Zahlen", "Upper-roman": "Großgeschriebene römische Zahlen", "Lower-latin": "Kleingeschriebene lateinische Buchstaben", "Upper-latin": "Großgeschriebene lateinische Buchstaben", "List properties": "Listeneigenschaften", "Start at": "Beginnen mit", "Invalid start index value.": "Ungültiger Anfangsindexwert.", "Start index must be greater than 0.": "Der Startwert muss größer als 0 sein.", "Reversed order": "Umgekehrte Reihenfolge", "Keystrokes that can be used in a list": "Tastatureingaben, die in einer Liste verwendet werden können.", "Increase list item indent": "Listeneinzug vergrößern", "Decrease list item indent": "Listeneinzug verkleinern", "Entering a to-do list": "Eingabe einer Aufgabenliste", "Leaving a to-do list": "Verlassen einer Aufgabenliste", "Unlink": "Link entfernen", "Link": "Link", "Link URL": "Linkadresse", "Link URL must not be empty.": "Die Link-URL darf nicht leer sein.", "Link image": "Bild verlinken", "Edit link": "Link bearbeiten", "Open link in new tab": "Link im neuen Tab öffnen", "This link has no URL": "Dieser Link hat keine Adresse", "Open in a new tab": "In neuem Tab öffnen", "Downloadable": "Herunterladbar", "Create link": "Link erstellen", "Move out of a link": "Linkauswahl aufheben", "Language": "Sprache", "Choose language": "Sprache auswählen", "Remove language": "Sprache entfernen", "Increase indent": "Einzug vergrößern", "Decrease indent": "Einzug verkleinern", "image widget": "Bild-Steuerelement", "Wrap text": "Text umfließt Bild", "Break text": "Bild teilt Text", "In line": "Text in Zeile", "Side image": "Seitenbild", "Full size image": "Bild in voller Größe", "Left aligned image": "Linksbündiges Bild", "Centered image": "Zentriertes Bild", "Right aligned image": "Rechtsbündiges Bild", "Change image text alternative": "Alternativtext ändern", "Text alternative": "Alternativtext", "Enter image caption": "Bildunterschrift eingeben", "Insert image": "Bild einfügen", "Replace image": "Bild ersetzen", "Upload from computer": "Vom Computer hochladen", "Replace from computer": "Vom Computer ersetzen", "Upload image from computer": "Bild vom Computer hochladen", "Image from computer": "Bild vom Computer", "From computer": "Vom Computer", "Replace image from computer": "Bild vom Computer ersetzen", "Upload failed": "Hochladen fehlgeschlagen", "Image toolbar": "Bild Werkzeugleiste", "Resize image": "Bildgröße ändern", "Resize image to %0": "Bildgröße ändern in %0", "Resize image to the original size": "Bild in Originalgröße ändern", "Resize image (in %0)": "Bildgröße ändern (in %0)", "Original": "Original", "Custom image size": "Benutzerdefinierte Bildgröße", "Custom": "Benutzerdefiniert", "Image resize list": "Bildgrößen-Liste", "Insert image via URL": "Bild von URL einfügen", "Insert via URL": "Per URL einfügen", "Image via URL": "Bild per URL", "Via URL": "Per URL", "Update image URL": "Bild-URL aktualisieren", "Caption for the image": "Bildunterschrift", "Caption for image: %0": "Bildunterschrift: %0", "The value must not be empty.": "Der Wert darf nicht leer sein.", "The value should be a plain number.": "Der Wert sollte eine einfache Zahl sein.", "Uploading image": "Bild hochladen", "Image upload complete": "Bild erfolgreich hochgeladen", "Error during image upload": "Fehler beim Hochladen des Bildes", "Image": "Bild", "HTML object": "HTML-Objekt", "Insert HTML": "HTML einfügen", "HTML snippet": "HTML-Snippet", "Paste raw HTML here...": "Rohes HTML hier einfügen …", "Edit source": "Quelle bearbeiten", "Save changes": "Änderungen speichern", "No preview available": "Keine Vorschau verfügbar", "Empty snippet content": "Leerer Snippet-Inhalt", "Horizontal line": "Horizontale Linie", "Yellow marker": "Gelber Marker", "Green marker": "Grüner Marker", "Pink marker": "Pinker Marker", "Blue marker": "Blauer Marker", "Red pen": "Rote Schriftfarbe", "Green pen": "Grüne Schriftfarbe", "Remove highlight": "Texthervorhebung entfernen", "Highlight": "Texthervorhebung", "Text highlight toolbar": "Text hervorheben Werkzeugleiste", "Paragraph": "Absatz", "Heading": "Überschrift", "Choose heading": "Überschrift auswählen", "Heading 1": "Überschrift 1", "Heading 2": "Überschrift 2", "Heading 3": "Überschrift 3", "Heading 4": "Überschrift 4", "Heading 5": "Überschrift 5", "Heading 6": "Überschrift 6", "Type your title": "Titel eingeben", "Type or paste your content here.": "Hier Inhalt einfügen.", "Font Size": "Schriftgröße", "Tiny": "Sehr klein", "Small": "Klein", "Big": "Groß", "Huge": "Sehr groß", "Font Family": "Schriftart", "Default": "Standard", "Font Color": "Schriftfarbe", "Font Background Color": "Hintergrundfarbe", "Document colors": "Dokumentfarben", "Find and replace": "Suchen und ersetzen", "Find in text…": "In Text suchen…", "Find": "Suchen", "Previous result": "Vorheriges Ergebnis", "Next result": "Nächstes Ergebnis", "Replace": "Ersetzen", "Replace all": "Alle ersetzen", "Match case": "Groß-/Kleinschreibung beachten", "Whole words only": "Nur ganze Wörter", "Replace with…": "Ersetzen durch…", "Text to find must not be empty.": "Der Suchtext darf nicht leer sein.", "Tip: Find some text first in order to replace it.": "Tipp: Zuerst nach Text suchen um diesen zu ersetzen.", "Advanced options": "Erweiterte Optionen", "Find in the document": "Dokument durchsuchen", "Insert a soft break (a <code>&lt;br&gt;</code> element)": "Einen weichen Zeilenumbruch einfügen (ein <code>&lt;br&gt;</code>-Element)", "Insert a hard break (a new paragraph)": "Zeilenumbruch einfügen (einen neuen Abschnitt)", "Cancel": "Abbrechen", "Clear": "Löschen", "Remove color": "Farbe entfernen", "Restore default": "Standard wiederherstellen", "Save": "Speichern", "Show more items": "Mehr anzeigen", "%0 of %1": "%0 von %1", "Cannot upload file:": "Die Datei kann nicht hochgeladen werden:", "Rich Text Editor. Editing area: %0": "Rich Text Editor. Bearbeitungsbereich: %0", "Insert with file manager": "Mit Dateimanager einfügen", "Replace with file manager": "Mittels Dateimanager ersetzen", "Insert image with file manager": "Bild mit dem Dateimanager einfügen", "Replace image with file manager": "Bild mittels Dateimanager ersetzen", "File": "Datei", "With file manager": "Mit dem Dateimanager", "Toggle caption off": "Tabellenüberschrift deaktivieren", "Toggle caption on": "Tabellenüberschrift aktivieren", "Content editing keystrokes": "Tastatureingaben zur Inhaltsverarbeitung", "These keyboard shortcuts allow for quick access to content editing features.": "Diese Tastenkombinationen ermöglichen einen schnellen Zugang zu den Inhaltsverarbeitungsfunktionen.", "User interface and content navigation keystrokes": "Benutzeroberfläche und Inhaltsnavigationstasten", "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.": "Verwenden Sie die folgenden Tastatureingaben für eine effizientere Navigation auf der CKEditor-5-Benutzeroberfläche.", "Close contextual balloons, dropdowns, and dialogs": "Kontextsprechblasen, Dropdown-Menü und Dialoge schließen", "Open the accessibility help dialog": "Den Dialog zur Eingabehilfe öffnen", "Move focus between form fields (inputs, buttons, etc.)": "Fokus zwischen Formularfeldern verschieben (Eingaben, Tastenfelder etc.)", "Move focus to the menu bar, navigate between menu bars": "Fokus auf die Menüleiste richten, zwischen Menüleisten navigieren", "Move focus to the toolbar, navigate between toolbars": "Fokus auf die Symbolleiste verschieben, zwischen den Symbolleisten navigieren", "Navigate through the toolbar or menu bar": "Durch die Werkzeugleiste oder Menüleiste navigieren", "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.": "Ausführen der aktuell fokussierten Schaltfläche. Das Ausführen von Schaltflächen, die mit dem Inhalt des Editors interagieren, richtet den Fokus zurück auf den Inhalt.", "Accept": "Akzeptieren", "Insert code block": "Code-Block einfügen", "Plain text": "Nur Text", "Leaving %0 code snippet": "%0 Code-Ausschnitt verlassen", "Entering %0 code snippet": "%0 Code-Ausschnitt eingeben", "Entering code snippet": "Code-Ausschnit eingeben", "Leaving code snippet": "Code-Ausschnit verlassen", "Code block": "Codeblock", "Copy selected content": "Markierten Inhalt kopieren", "Paste content": "Inhalt einfügen", "Paste content as plain text": "Inhalt als Klartext einfügen", "Insert image or file": "Bild oder Datei einfügen", "Could not obtain resized image URL.": "Die URL des angepassten Bildes konnte nicht abgerufen werden.", "Selecting resized image failed": "Das angepasste Bild konnte nicht ausgewählt werden.", "Could not insert image at the current position.": "Das Bild konnte an der aktuellen Position nicht eingefügt werden.", "Inserting image failed": "Einfügen des Bildes fehlgeschlagen", "Open file manager": "Dateimanager öffnen", "Cannot determine a category for the uploaded file.": "Die Kategorie für die hochgeladene Datei konnte nicht bestimmt werden.", "Cannot access default workspace.": "Zugriff auf Standardarbeitsbereich nicht möglich.", "Edit image": "Bild bearbeiten", "Processing the edited image.": "Das bearbeitete Bild wird verarbeitet.", "Server failed to process the image.": "Der Server konnte das Bild nicht verarbeiten.", "Failed to determine category of edited image.": "Es konnte für das bearbeitete Bild keine Kategorie ermittelt werden.", "Block quote": "Blockzitat", "Bold": "Fett", "Italic": "Kursiv", "Underline": "Unterstrichen", "Code": "Code", "Strikethrough": "Durchgestrichen", "Subscript": "Tiefgestellt", "Superscript": "Hochgestellt", "Italic text": "Kursivschrift", "Move out of an inline code style": "Inline Code Style verlassen", "Bold text": "Fettschrift", "Underline text": "Text hervorheben", "Strikethrough text": "Durchgestrichener Text", "Saving changes": "Änderungen werden gespeichert", "Revert autoformatting action": "Automatischen Formatierungsvorgang rückgängig machen", "Align left": "Linksbündig", "Align right": "Rechtsbündig", "Align center": "Zentriert", "Justify": "Blocksatz", "Text alignment": "Textausrichtung", "Text alignment toolbar": "Text-Ausrichtung Toolbar" }, getPluralForm(n) {
      return n != 1;
    } } };
    /**
     * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
     */
    const translationsEN = { "en": { "dictionary": { "Words: %0": "Words: %0", "Characters: %0": "Characters: %0", "Widget toolbar": "Widget toolbar", "Insert paragraph before block": "Insert paragraph before block", "Insert paragraph after block": "Insert paragraph after block", "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget", "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)": "Keystrokes that can be used when a widget is selected (for example: image, table, etc.)", "Insert a new paragraph directly after a widget": "Insert a new paragraph directly after a widget", "Insert a new paragraph directly before a widget": "Insert a new paragraph directly before a widget", "Move the caret to allow typing directly before a widget": "Move the caret to allow typing directly before a widget", "Move the caret to allow typing directly after a widget": "Move the caret to allow typing directly after a widget", "Move focus from an editable area back to the parent widget": "Move focus from an editable area back to the parent widget", "Upload in progress": "Upload in progress", "Undo": "Undo", "Redo": "Redo", "Rich Text Editor": "Rich Text Editor", "Editor editing area: %0": "Editor editing area: %0", "Edit block": "Edit block", "Click to edit block": "Click to edit block", "Drag to move": "Drag to move", "Next": "Next", "Previous": "Previous", "Editor toolbar": "Editor toolbar", "Dropdown toolbar": "Dropdown toolbar", "Black": "Black", "Dim grey": "Dim grey", "Grey": "Grey", "Light grey": "Light grey", "White": "White", "Red": "Red", "Orange": "Orange", "Yellow": "Yellow", "Light green": "Light green", "Green": "Green", "Aquamarine": "Aquamarine", "Turquoise": "Turquoise", "Light blue": "Light blue", "Blue": "Blue", "Purple": "Purple", "Editor block content toolbar": "Editor block content toolbar", "Editor contextual toolbar": "Editor contextual toolbar", "HEX": "HEX", "No results found": "No results found", "No searchable items": "No searchable items", "Editor dialog": "Editor dialog", "Close": "Close", "Help Contents. To close this dialog press ESC.": "Help Contents. To close this dialog press ESC.", "Below, you can find a list of keyboard shortcuts that can be used in the editor.": "Below, you can find a list of keyboard shortcuts that can be used in the editor.", "(may require <kbd>Fn</kbd>)": "(may require <kbd>Fn</kbd>)", "Accessibility": "Accessibility", "Accessibility help": "Accessibility help", "Press %0 for help.": "Press %0 for help.", "Move focus in and out of an active dialog window": "Move focus in and out of an active dialog window", "MENU_BAR_MENU_FILE": "File", "MENU_BAR_MENU_EDIT": "Edit", "MENU_BAR_MENU_VIEW": "View", "MENU_BAR_MENU_INSERT": "Insert", "MENU_BAR_MENU_FORMAT": "Format", "MENU_BAR_MENU_TOOLS": "Tools", "MENU_BAR_MENU_HELP": "Help", "MENU_BAR_MENU_TEXT": "Text", "MENU_BAR_MENU_FONT": "Font", "Editor menu bar": "Editor menu bar", 'Please enter a valid color (e.g. "ff0000").': 'Please enter a valid color (e.g. "ff0000").', "Insert table": "Insert table", "Header column": "Header column", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Delete column": "Delete column", "Select column": "Select column", "Column": "Column", "Header row": "Header row", "Insert row below": "Insert row below", "Insert row above": "Insert row above", "Delete row": "Delete row", "Select row": "Select row", "Row": "Row", "Merge cell up": "Merge cell up", "Merge cell right": "Merge cell right", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Split cell vertically": "Split cell vertically", "Split cell horizontally": "Split cell horizontally", "Merge cells": "Merge cells", "Table toolbar": "Table toolbar", "Table properties": "Table properties", "Cell properties": "Cell properties", "Border": "Border", "Style": "Style", "Width": "Width", "Height": "Height", "Color": "Color", "Background": "Background", "Padding": "Padding", "Dimensions": "Dimensions", "Table cell text alignment": "Table cell text alignment", "Alignment": "Alignment", "Horizontal text alignment toolbar": "Horizontal text alignment toolbar", "Vertical text alignment toolbar": "Vertical text alignment toolbar", "Table alignment toolbar": "Table alignment toolbar", "None": "None", "Solid": "Solid", "Dotted": "Dotted", "Dashed": "Dashed", "Double": "Double", "Groove": "Groove", "Ridge": "Ridge", "Inset": "Inset", "Outset": "Outset", "Align cell text to the left": "Align cell text to the left", "Align cell text to the center": "Align cell text to the center", "Align cell text to the right": "Align cell text to the right", "Justify cell text": "Justify cell text", "Align cell text to the top": "Align cell text to the top", "Align cell text to the middle": "Align cell text to the middle", "Align cell text to the bottom": "Align cell text to the bottom", "Align table to the left": "Align table to the left", "Center table": "Center table", "Align table to the right": "Align table to the right", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".', 'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".', "Color picker": "Color picker", "Enter table caption": "Enter table caption", "Keystrokes that can be used in a table cell": "Keystrokes that can be used in a table cell", "Move the selection to the next cell": "Move the selection to the next cell", "Move the selection to the previous cell": "Move the selection to the previous cell", "Insert a new table row (when in the last cell of a table)": "Insert a new table row (when in the last cell of a table)", "Navigate through the table": "Navigate through the table", "Table": "Table", "Styles": "Styles", "Multiple styles": "Multiple styles", "Block styles": "Block styles", "Text styles": "Text styles", "Special characters": "Special characters", "All": "All", "Arrows": "Arrows", "Currency": "Currency", "Latin": "Latin", "Mathematical": "Mathematical", "Text": "Text", "leftwards simple arrow": "leftwards simple arrow", "rightwards simple arrow": "rightwards simple arrow", "upwards simple arrow": "upwards simple arrow", "downwards simple arrow": "downwards simple arrow", "leftwards double arrow": "leftwards double arrow", "rightwards double arrow": "rightwards double arrow", "upwards double arrow": "upwards double arrow", "downwards double arrow": "downwards double arrow", "leftwards dashed arrow": "leftwards dashed arrow", "rightwards dashed arrow": "rightwards dashed arrow", "upwards dashed arrow": "upwards dashed arrow", "downwards dashed arrow": "downwards dashed arrow", "leftwards arrow to bar": "leftwards arrow to bar", "rightwards arrow to bar": "rightwards arrow to bar", "upwards arrow to bar": "upwards arrow to bar", "downwards arrow to bar": "downwards arrow to bar", "up down arrow with base": "up down arrow with base", "back with leftwards arrow above": "back with leftwards arrow above", "end with leftwards arrow above": "end with leftwards arrow above", "on with exclamation mark with left right arrow above": "on with exclamation mark with left right arrow above", "soon with rightwards arrow above": "soon with rightwards arrow above", "top with upwards arrow above": "top with upwards arrow above", "Dollar sign": "Dollar sign", "Euro sign": "Euro sign", "Yen sign": "Yen sign", "Pound sign": "Pound sign", "Cent sign": "Cent sign", "Euro-currency sign": "Euro-currency sign", "Colon sign": "Colon sign", "Cruzeiro sign": "Cruzeiro sign", "French franc sign": "French franc sign", "Lira sign": "Lira sign", "Currency sign": "Currency sign", "Bitcoin sign": "Bitcoin sign", "Mill sign": "Mill sign", "Naira sign": "Naira sign", "Peseta sign": "Peseta sign", "Rupee sign": "Rupee sign", "Won sign": "Won sign", "New sheqel sign": "New sheqel sign", "Dong sign": "Dong sign", "Kip sign": "Kip sign", "Tugrik sign": "Tugrik sign", "Drachma sign": "Drachma sign", "German penny sign": "German penny sign", "Peso sign": "Peso sign", "Guarani sign": "Guarani sign", "Austral sign": "Austral sign", "Hryvnia sign": "Hryvnia sign", "Cedi sign": "Cedi sign", "Livre tournois sign": "Livre tournois sign", "Spesmilo sign": "Spesmilo sign", "Tenge sign": "Tenge sign", "Indian rupee sign": "Indian rupee sign", "Turkish lira sign": "Turkish lira sign", "Nordic mark sign": "Nordic mark sign", "Manat sign": "Manat sign", "Ruble sign": "Ruble sign", "Latin capital letter a with macron": "Latin capital letter a with macron", "Latin small letter a with macron": "Latin small letter a with macron", "Latin capital letter a with breve": "Latin capital letter a with breve", "Latin small letter a with breve": "Latin small letter a with breve", "Latin capital letter a with ogonek": "Latin capital letter a with ogonek", "Latin small letter a with ogonek": "Latin small letter a with ogonek", "Latin capital letter c with acute": "Latin capital letter c with acute", "Latin small letter c with acute": "Latin small letter c with acute", "Latin capital letter c with circumflex": "Latin capital letter c with circumflex", "Latin small letter c with circumflex": "Latin small letter c with circumflex", "Latin capital letter c with dot above": "Latin capital letter c with dot above", "Latin small letter c with dot above": "Latin small letter c with dot above", "Latin capital letter c with caron": "Latin capital letter c with caron", "Latin small letter c with caron": "Latin small letter c with caron", "Latin capital letter d with caron": "Latin capital letter d with caron", "Latin small letter d with caron": "Latin small letter d with caron", "Latin capital letter d with stroke": "Latin capital letter d with stroke", "Latin small letter d with stroke": "Latin small letter d with stroke", "Latin capital letter e with macron": "Latin capital letter e with macron", "Latin small letter e with macron": "Latin small letter e with macron", "Latin capital letter e with breve": "Latin capital letter e with breve", "Latin small letter e with breve": "Latin small letter e with breve", "Latin capital letter e with dot above": "Latin capital letter e with dot above", "Latin small letter e with dot above": "Latin small letter e with dot above", "Latin capital letter e with ogonek": "Latin capital letter e with ogonek", "Latin small letter e with ogonek": "Latin small letter e with ogonek", "Latin capital letter e with caron": "Latin capital letter e with caron", "Latin small letter e with caron": "Latin small letter e with caron", "Latin capital letter g with circumflex": "Latin capital letter g with circumflex", "Latin small letter g with circumflex": "Latin small letter g with circumflex", "Latin capital letter g with breve": "Latin capital letter g with breve", "Latin small letter g with breve": "Latin small letter g with breve", "Latin capital letter g with dot above": "Latin capital letter g with dot above", "Latin small letter g with dot above": "Latin small letter g with dot above", "Latin capital letter g with cedilla": "Latin capital letter g with cedilla", "Latin small letter g with cedilla": "Latin small letter g with cedilla", "Latin capital letter h with circumflex": "Latin capital letter h with circumflex", "Latin small letter h with circumflex": "Latin small letter h with circumflex", "Latin capital letter h with stroke": "Latin capital letter h with stroke", "Latin small letter h with stroke": "Latin small letter h with stroke", "Latin capital letter i with tilde": "Latin capital letter i with tilde", "Latin small letter i with tilde": "Latin small letter i with tilde", "Latin capital letter i with macron": "Latin capital letter i with macron", "Latin small letter i with macron": "Latin small letter i with macron", "Latin capital letter i with breve": "Latin capital letter i with breve", "Latin small letter i with breve": "Latin small letter i with breve", "Latin capital letter i with ogonek": "Latin capital letter i with ogonek", "Latin small letter i with ogonek": "Latin small letter i with ogonek", "Latin capital letter i with dot above": "Latin capital letter i with dot above", "Latin small letter dotless i": "Latin small letter dotless i", "Latin capital ligature ij": "Latin capital ligature ij", "Latin small ligature ij": "Latin small ligature ij", "Latin capital letter j with circumflex": "Latin capital letter j with circumflex", "Latin small letter j with circumflex": "Latin small letter j with circumflex", "Latin capital letter k with cedilla": "Latin capital letter k with cedilla", "Latin small letter k with cedilla": "Latin small letter k with cedilla", "Latin small letter kra": "Latin small letter kra", "Latin capital letter l with acute": "Latin capital letter l with acute", "Latin small letter l with acute": "Latin small letter l with acute", "Latin capital letter l with cedilla": "Latin capital letter l with cedilla", "Latin small letter l with cedilla": "Latin small letter l with cedilla", "Latin capital letter l with caron": "Latin capital letter l with caron", "Latin small letter l with caron": "Latin small letter l with caron", "Latin capital letter l with middle dot": "Latin capital letter l with middle dot", "Latin small letter l with middle dot": "Latin small letter l with middle dot", "Latin capital letter l with stroke": "Latin capital letter l with stroke", "Latin small letter l with stroke": "Latin small letter l with stroke", "Latin capital letter n with acute": "Latin capital letter n with acute", "Latin small letter n with acute": "Latin small letter n with acute", "Latin capital letter n with cedilla": "Latin capital letter n with cedilla", "Latin small letter n with cedilla": "Latin small letter n with cedilla", "Latin capital letter n with caron": "Latin capital letter n with caron", "Latin small letter n with caron": "Latin small letter n with caron", "Latin small letter n preceded by apostrophe": "Latin small letter n preceded by apostrophe", "Latin capital letter eng": "Latin capital letter eng", "Latin small letter eng": "Latin small letter eng", "Latin capital letter o with macron": "Latin capital letter o with macron", "Latin small letter o with macron": "Latin small letter o with macron", "Latin capital letter o with breve": "Latin capital letter o with breve", "Latin small letter o with breve": "Latin small letter o with breve", "Latin capital letter o with double acute": "Latin capital letter o with double acute", "Latin small letter o with double acute": "Latin small letter o with double acute", "Latin capital ligature oe": "Latin capital ligature oe", "Latin small ligature oe": "Latin small ligature oe", "Latin capital letter r with acute": "Latin capital letter r with acute", "Latin small letter r with acute": "Latin small letter r with acute", "Latin capital letter r with cedilla": "Latin capital letter r with cedilla", "Latin small letter r with cedilla": "Latin small letter r with cedilla", "Latin capital letter r with caron": "Latin capital letter r with caron", "Latin small letter r with caron": "Latin small letter r with caron", "Latin capital letter s with acute": "Latin capital letter s with acute", "Latin small letter s with acute": "Latin small letter s with acute", "Latin capital letter s with circumflex": "Latin capital letter s with circumflex", "Latin small letter s with circumflex": "Latin small letter s with circumflex", "Latin capital letter s with cedilla": "Latin capital letter s with cedilla", "Latin small letter s with cedilla": "Latin small letter s with cedilla", "Latin capital letter s with caron": "Latin capital letter s with caron", "Latin small letter s with caron": "Latin small letter s with caron", "Latin capital letter t with cedilla": "Latin capital letter t with cedilla", "Latin small letter t with cedilla": "Latin small letter t with cedilla", "Latin capital letter t with caron": "Latin capital letter t with caron", "Latin small letter t with caron": "Latin small letter t with caron", "Latin capital letter t with stroke": "Latin capital letter t with stroke", "Latin small letter t with stroke": "Latin small letter t with stroke", "Latin capital letter u with tilde": "Latin capital letter u with tilde", "Latin small letter u with tilde": "Latin small letter u with tilde", "Latin capital letter u with macron": "Latin capital letter u with macron", "Latin small letter u with macron": "Latin small letter u with macron", "Latin capital letter u with breve": "Latin capital letter u with breve", "Latin small letter u with breve": "Latin small letter u with breve", "Latin capital letter u with ring above": "Latin capital letter u with ring above", "Latin small letter u with ring above": "Latin small letter u with ring above", "Latin capital letter u with double acute": "Latin capital letter u with double acute", "Latin small letter u with double acute": "Latin small letter u with double acute", "Latin capital letter u with ogonek": "Latin capital letter u with ogonek", "Latin small letter u with ogonek": "Latin small letter u with ogonek", "Latin capital letter w with circumflex": "Latin capital letter w with circumflex", "Latin small letter w with circumflex": "Latin small letter w with circumflex", "Latin capital letter y with circumflex": "Latin capital letter y with circumflex", "Latin small letter y with circumflex": "Latin small letter y with circumflex", "Latin capital letter y with diaeresis": "Latin capital letter y with diaeresis", "Latin capital letter z with acute": "Latin capital letter z with acute", "Latin small letter z with acute": "Latin small letter z with acute", "Latin capital letter z with dot above": "Latin capital letter z with dot above", "Latin small letter z with dot above": "Latin small letter z with dot above", "Latin capital letter z with caron": "Latin capital letter z with caron", "Latin small letter z with caron": "Latin small letter z with caron", "Latin small letter long s": "Latin small letter long s", "Less-than sign": "Less-than sign", "Greater-than sign": "Greater-than sign", "Less-than or equal to": "Less-than or equal to", "Greater-than or equal to": "Greater-than or equal to", "En dash": "En dash", "Em dash": "Em dash", "Macron": "Macron", "Overline": "Overline", "Degree sign": "Degree sign", "Minus sign": "Minus sign", "Plus-minus sign": "Plus-minus sign", "Division sign": "Division sign", "Fraction slash": "Fraction slash", "Multiplication sign": "Multiplication sign", "Latin small letter f with hook": "Latin small letter f with hook", "Integral": "Integral", "N-ary summation": "N-ary summation", "Infinity": "Infinity", "Square root": "Square root", "Tilde operator": "Tilde operator", "Approximately equal to": "Approximately equal to", "Almost equal to": "Almost equal to", "Not equal to": "Not equal to", "Identical to": "Identical to", "Element of": "Element of", "Not an element of": "Not an element of", "Contains as member": "Contains as member", "N-ary product": "N-ary product", "Logical and": "Logical and", "Logical or": "Logical or", "Not sign": "Not sign", "Intersection": "Intersection", "Union": "Union", "Partial differential": "Partial differential", "For all": "For all", "There exists": "There exists", "Empty set": "Empty set", "Nabla": "Nabla", "Asterisk operator": "Asterisk operator", "Proportional to": "Proportional to", "Angle": "Angle", "Vulgar fraction one quarter": "Vulgar fraction one quarter", "Vulgar fraction one half": "Vulgar fraction one half", "Vulgar fraction three quarters": "Vulgar fraction three quarters", "Single left-pointing angle quotation mark": "Single left-pointing angle quotation mark", "Single right-pointing angle quotation mark": "Single right-pointing angle quotation mark", "Left-pointing double angle quotation mark": "Left-pointing double angle quotation mark", "Right-pointing double angle quotation mark": "Right-pointing double angle quotation mark", "Left single quotation mark": "Left single quotation mark", "Right single quotation mark": "Right single quotation mark", "Left double quotation mark": "Left double quotation mark", "Right double quotation mark": "Right double quotation mark", "Single low-9 quotation mark": "Single low-9 quotation mark", "Double low-9 quotation mark": "Double low-9 quotation mark", "Inverted exclamation mark": "Inverted exclamation mark", "Inverted question mark": "Inverted question mark", "Two dot leader": "Two dot leader", "Horizontal ellipsis": "Horizontal ellipsis", "Double dagger": "Double dagger", "Per mille sign": "Per mille sign", "Per ten thousand sign": "Per ten thousand sign", "Double exclamation mark": "Double exclamation mark", "Question exclamation mark": "Question exclamation mark", "Exclamation question mark": "Exclamation question mark", "Double question mark": "Double question mark", "Copyright sign": "Copyright sign", "Registered sign": "Registered sign", "Trade mark sign": "Trade mark sign", "Section sign": "Section sign", "Paragraph sign": "Paragraph sign", "Reversed paragraph sign": "Reversed paragraph sign", "Character categories": "Character categories", "Source": "Source", "Show source": "Show source", "Show blocks": "Show blocks", "Select all": "Select all", "Disable editing": "Disable editing", "Enable editing": "Enable editing", "Previous editable region": "Previous editable region", "Next editable region": "Next editable region", "Navigate editable regions": "Navigate editable regions", "Remove Format": "Remove Format", "Page break": "Page break", "media widget": "media widget", "Media URL": "Media URL", "Paste the media URL in the input.": "Paste the media URL in the input.", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", "The URL must not be empty.": "The URL must not be empty.", "This media URL is not supported.": "This media URL is not supported.", "Insert media": "Insert media", "Media": "Media", "Media toolbar": "Media toolbar", "Open media in new tab": "Open media in new tab", "Numbered List": "Numbered List", "Bulleted List": "Bulleted List", "To-do List": "To-do List", "Bulleted list styles toolbar": "Bulleted list styles toolbar", "Numbered list styles toolbar": "Numbered list styles toolbar", "Toggle the disc list style": "Toggle the disc list style", "Toggle the circle list style": "Toggle the circle list style", "Toggle the square list style": "Toggle the square list style", "Toggle the decimal list style": "Toggle the decimal list style", "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style", "Toggle the lower–roman list style": "Toggle the lower–roman list style", "Toggle the upper–roman list style": "Toggle the upper–roman list style", "Toggle the lower–latin list style": "Toggle the lower–latin list style", "Toggle the upper–latin list style": "Toggle the upper–latin list style", "Disc": "Disc", "Circle": "Circle", "Square": "Square", "Decimal": "Decimal", "Decimal with leading zero": "Decimal with leading zero", "Lower–roman": "Lower–roman", "Upper-roman": "Upper-roman", "Lower-latin": "Lower-latin", "Upper-latin": "Upper-latin", "List properties": "List properties", "Start at": "Start at", "Invalid start index value.": "Invalid start index value.", "Start index must be greater than 0.": "Start index must be greater than 0.", "Reversed order": "Reversed order", "Keystrokes that can be used in a list": "Keystrokes that can be used in a list", "Increase list item indent": "Increase list item indent", "Decrease list item indent": "Decrease list item indent", "Entering a to-do list": "Entering a to-do list", "Leaving a to-do list": "Leaving a to-do list", "Unlink": "Unlink", "Link": "Link", "Link URL": "Link URL", "Link URL must not be empty.": "Link URL must not be empty.", "Link image": "Link image", "Edit link": "Edit link", "Open link in new tab": "Open link in new tab", "This link has no URL": "This link has no URL", "Open in a new tab": "Open in a new tab", "Downloadable": "Downloadable", "Create link": "Create link", "Move out of a link": "Move out of a link", "Language": "Language", "Choose language": "Choose language", "Remove language": "Remove language", "Increase indent": "Increase indent", "Decrease indent": "Decrease indent", "image widget": "image widget", "Wrap text": "Wrap text", "Break text": "Break text", "In line": "In line", "Side image": "Side image", "Full size image": "Full size image", "Left aligned image": "Left aligned image", "Centered image": "Centered image", "Right aligned image": "Right aligned image", "Change image text alternative": "Change image text alternative", "Text alternative": "Text alternative", "Enter image caption": "Enter image caption", "Insert image": "Insert image", "Replace image": "Replace image", "Upload from computer": "Upload from computer", "Replace from computer": "Replace from computer", "Upload image from computer": "Upload image from computer", "Image from computer": "Image from computer", "From computer": "From computer", "Replace image from computer": "Replace image from computer", "Upload failed": "Upload failed", "Image toolbar": "Image toolbar", "Resize image": "Resize image", "Resize image to %0": "Resize image to %0", "Resize image to the original size": "Resize image to the original size", "Resize image (in %0)": "Resize image (in %0)", "Original": "Original", "Custom image size": "Custom image size", "Custom": "Custom", "Image resize list": "Image resize list", "Insert image via URL": "Insert image via URL", "Insert via URL": "Insert via URL", "Image via URL": "Image via URL", "Via URL": "Via URL", "Update image URL": "Update image URL", "Caption for the image": "Caption for the image", "Caption for image: %0": "Caption for image: %0", "The value must not be empty.": "The value must not be empty.", "The value should be a plain number.": "The value should be a plain number.", "Uploading image": "Uploading image", "Image upload complete": "Image upload complete", "Error during image upload": "Error during image upload", "Image": "Image", "HTML object": "HTML object", "Insert HTML": "Insert HTML", "HTML snippet": "HTML snippet", "Paste raw HTML here...": "Paste raw HTML here...", "Edit source": "Edit source", "Save changes": "Save changes", "No preview available": "No preview available", "Empty snippet content": "Empty snippet content", "Horizontal line": "Horizontal line", "Yellow marker": "Yellow marker", "Green marker": "Green marker", "Pink marker": "Pink marker", "Blue marker": "Blue marker", "Red pen": "Red pen", "Green pen": "Green pen", "Remove highlight": "Remove highlight", "Highlight": "Highlight", "Text highlight toolbar": "Text highlight toolbar", "Paragraph": "Paragraph", "Heading": "Heading", "Choose heading": "Choose heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", "Type your title": "Type your title", "Type or paste your content here.": "Type or paste your content here.", "Font Size": "Font Size", "Tiny": "Tiny", "Small": "Small", "Big": "Big", "Huge": "Huge", "Font Family": "Font Family", "Default": "Default", "Font Color": "Font Color", "Font Background Color": "Font Background Color", "Document colors": "Document colors", "Find and replace": "Find and replace", "Find in text…": "Find in text…", "Find": "Find", "Previous result": "Previous result", "Next result": "Next result", "Replace": "Replace", "Replace all": "Replace all", "Match case": "Match case", "Whole words only": "Whole words only", "Replace with…": "Replace with…", "Text to find must not be empty.": "Text to find must not be empty.", "Tip: Find some text first in order to replace it.": "Tip: Find some text first in order to replace it.", "Advanced options": "Advanced options", "Find in the document": "Find in the document", "Insert a soft break (a <code>&lt;br&gt;</code> element)": "Insert a soft break (a <code>&lt;br&gt;</code> element)", "Insert a hard break (a new paragraph)": "Insert a hard break (a new paragraph)", "Cancel": "Cancel", "Clear": "Clear", "Remove color": "Remove color", "Restore default": "Restore default", "Save": "Save", "Show more items": "Show more items", "%0 of %1": "%0 of %1", "Cannot upload file:": "Cannot upload file:", "Rich Text Editor. Editing area: %0": "Rich Text Editor. Editing area: %0", "Insert with file manager": "Insert with file manager", "Replace with file manager": "Replace with file manager", "Insert image with file manager": "Insert image with file manager", "Replace image with file manager": "Replace image with file manager", "File": "File", "With file manager": "With file manager", "Toggle caption off": "Toggle caption off", "Toggle caption on": "Toggle caption on", "Content editing keystrokes": "Content editing keystrokes", "These keyboard shortcuts allow for quick access to content editing features.": "These keyboard shortcuts allow for quick access to content editing features.", "User interface and content navigation keystrokes": "User interface and content navigation keystrokes", "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.": "Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface.", "Close contextual balloons, dropdowns, and dialogs": "Close contextual balloons, dropdowns, and dialogs", "Open the accessibility help dialog": "Open the accessibility help dialog", "Move focus between form fields (inputs, buttons, etc.)": "Move focus between form fields (inputs, buttons, etc.)", "Move focus to the menu bar, navigate between menu bars": "Move focus to the menu bar, navigate between menu bars", "Move focus to the toolbar, navigate between toolbars": "Move focus to the toolbar, navigate between toolbars", "Navigate through the toolbar or menu bar": "Navigate through the toolbar or menu bar", "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.": "Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content.", "Accept": "Accept", "Insert code block": "Insert code block", "Plain text": "Plain text", "Leaving %0 code snippet": "Leaving %0 code snippet", "Entering %0 code snippet": "Entering %0 code snippet", "Entering code snippet": "Entering code snippet", "Leaving code snippet": "Leaving code snippet", "Code block": "Code block", "Copy selected content": "Copy selected content", "Paste content": "Paste content", "Paste content as plain text": "Paste content as plain text", "Insert image or file": "Insert image or file", "Could not obtain resized image URL.": "Could not obtain resized image URL.", "Selecting resized image failed": "Selecting resized image failed", "Could not insert image at the current position.": "Could not insert image at the current position.", "Inserting image failed": "Inserting image failed", "Open file manager": "Open file manager", "Cannot determine a category for the uploaded file.": "Cannot determine a category for the uploaded file.", "Cannot access default workspace.": "Cannot access default workspace.", "Edit image": "Edit image", "Processing the edited image.": "Processing the edited image.", "Server failed to process the image.": "Server failed to process the image.", "Failed to determine category of edited image.": "Failed to determine category of edited image.", "Block quote": "Block quote", "Bold": "Bold", "Italic": "Italic", "Underline": "Underline", "Code": "Code", "Strikethrough": "Strikethrough", "Subscript": "Subscript", "Superscript": "Superscript", "Italic text": "Italic text", "Move out of an inline code style": "Move out of an inline code style", "Bold text": "Bold text", "Underline text": "Underline text", "Strikethrough text": "Strikethrough text", "Saving changes": "Saving changes", "Revert autoformatting action": "Revert autoformatting action", "Align left": "Align left", "Align right": "Align right", "Align center": "Align center", "Justify": "Justify", "Text alignment": "Text alignment", "Text alignment toolbar": "Text alignment toolbar" }, "getPluralForm": null } };
    window.minerva = window.minerva || {};
    window.minerva.createEditor = function(lang, id, heading, extraPlugins, setter) {
      const editorConfig = {
        toolbar: {
          items: [
            "undo",
            "redo",
            "|",
            "heading",
            "style",
            "|",
            "fontSize",
            "fontColor",
            "fontBackgroundColor",
            "|",
            "bold",
            "italic",
            "underline",
            "strikethrough",
            "code",
            "|",
            "link",
            "uploadImage",
            "insertTable",
            "blockQuote",
            "|",
            "bulletedList",
            "numberedList"
          ],
          shouldNotGroupWhenFull: false
        },
        plugins: [
          BlockQuote,
          Bold,
          Code,
          CodeBlock,
          Essentials,
          FontBackgroundColor,
          FontColor,
          FontSize,
          GeneralHtmlSupport,
          Heading,
          ImageBlock,
          ImageInline,
          ImageUpload,
          Italic,
          Link,
          List,
          Paragraph,
          PasteFromOffice,
          Strikethrough,
          Style,
          Table,
          TableCaption,
          TableCellProperties,
          TableColumnResize,
          TableProperties,
          TableToolbar,
          Underline,
          Undo
        ],
        fontSize: {
          options: [10, 12, 14, "default", 18, 20, 22],
          supportAllValues: true
        },
        heading,
        htmlSupport: {
          allow: [
            {
              name: /^.*$/,
              styles: true,
              attributes: true,
              classes: true
            }
          ]
        },
        language: lang,
        link: {
          addTargetToExternalLinks: true,
          defaultProtocol: "https://"
        },
        style: {
          definitions: [
            {
              name: "Info box",
              element: "p",
              classes: ["info-box"]
            },
            {
              name: "Marker",
              element: "span",
              classes: ["marker"]
            },
            {
              name: "Spoiler",
              element: "span",
              classes: ["spoiler"]
            }
          ]
        },
        table: {
          contentToolbar: ["tableColumn", "tableRow", "mergeTableCells", "tableProperties", "tableCellProperties"]
        },
        translations: [lang == "de" ? translationsDE : translationsEN],
        extraPlugins
      };
      DecoupledEditor.create(document.querySelector("#" + id), editorConfig).then((it) => {
        const toolbarContainer = setter(it);
        toolbarContainer.appendChild(it.ui.view.toolbar.element);
        return it;
      }).catch((error) => {
        console.error(error);
      });
    };
  }
});
export default require_ckeditor_vite();
